
===== main.dart =====

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'core/config/firebase_options.dart';
import 'features/auth/widgets/auth_gate.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

// Add these imports for Crashlytics
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/foundation.dart' show PlatformDispatcher; // Needed for PlatformDispatcher

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  try {
    await dotenv.load(fileName: "assets/.env");
    debugPrint(".env file loaded");
  } catch (e) {
    debugPrint("Error loading .env file: $e");
  }

  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );

    // --- START Crashlytics Setup ---
    // Pass all uncaught "fatal" errors from the framework to Crashlytics
    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

    // Pass all uncaught asynchronous errors that aren't handled by the Flutter framework
    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      // Return true to indicate that the error has been handled.
      // This prevents it from being processed further by default error handlers
      // which might print to console or cause the app to exit depending on the error.
      return true;
    };
    // --- END Crashlytics Setup ---

    debugPrint("Firebase initialized successfully."); // Good to confirm initialization

  } catch (e) {
    // If Firebase initialization itself fails, Crashlytics might not be ready,
    // so we print the error and show a FirebaseErrorApp.
    // Crashlytics might still catch this if the native setup part was successful
    // and the error happens after the very initial native Firebase core setup.
    print('Failed to initialize Firebase: $e');
    FirebaseCrashlytics.instance.recordError(
        e, StackTrace.current,
        reason: 'Failed to initialize Firebase in main.dart',
        fatal: true
    );
    runApp(const FirebaseErrorApp());
    return;
  }

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MM Associates',
      theme: ThemeData(
        primarySwatch: Colors.indigo,
        visualDensity: VisualDensity.adaptivePlatformDensity,
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Theme.of(context).primaryColor, width: 2.0),
            borderRadius: BorderRadius.circular(8.0),
          ),
          contentPadding: const EdgeInsets.symmetric(horizontal: 15.0, vertical: 12.0),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8.0),
            ),
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
          ),
        ),
        textButtonTheme: TextButtonThemeData(
          style: TextButton.styleFrom(
            foregroundColor: Colors.indigo,
          ),
        ),
      ),
      debugShowCheckedModeBanner: false,
      home: const AuthGate(),
    );
  }
}

class FirebaseErrorApp extends StatelessWidget {
  const FirebaseErrorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: Center(
          child: Padding(
            padding: EdgeInsets.all(16.0),
            child: Text(
              'Failed to initialize Firebase.\nPlease ensure you have followed the setup instructions and placed the configuration files correctly.',
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.red, fontSize: 16),
            ),
          ),
        ),
      ),
    );
  }
}


===== core\config\firebase_options.dart =====

// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyDgGtrW7zCMa36n83_e-6fjSP9QhkCni3k',
    appId: '1:399976911903:web:8ca40c5ba45b3993a9712a',
    messagingSenderId: '399976911903',
    projectId: 'fir-flutter-auth-6fb90',
    authDomain: 'fir-flutter-auth-6fb90.firebaseapp.com',
    storageBucket: 'fir-flutter-auth-6fb90.firebasestorage.app',
    measurementId: 'G-3XY7H7N3Q6',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBgXY7qSdLrN9ZqJnzhURR_EbzL2JrwZ9g',
    appId: '1:399976911903:android:552a547c2d036d35a9712a',
    messagingSenderId: '399976911903',
    projectId: 'fir-flutter-auth-6fb90',
    storageBucket: 'fir-flutter-auth-6fb90.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCpeFWt1NIonQJNK7h1pltDALy5WTpp7fI',
    appId: '1:399976911903:ios:92b4b2aa2964491aa9712a',
    messagingSenderId: '399976911903',
    projectId: 'fir-flutter-auth-6fb90',
    storageBucket: 'fir-flutter-auth-6fb90.firebasestorage.app',
    iosClientId: '399976911903-r0kp22jh05gdnus7jlj5hoac9q0vb9s9.apps.googleusercontent.com',
    iosBundleId: 'com.example.singupLogin',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCpeFWt1NIonQJNK7h1pltDALy5WTpp7fI',
    appId: '1:399976911903:ios:92b4b2aa2964491aa9712a',
    messagingSenderId: '399976911903',
    projectId: 'fir-flutter-auth-6fb90',
    storageBucket: 'fir-flutter-auth-6fb90.firebasestorage.app',
    iosClientId: '399976911903-r0kp22jh05gdnus7jlj5hoac9q0vb9s9.apps.googleusercontent.com',
    iosBundleId: 'com.example.singupLogin',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyDgGtrW7zCMa36n83_e-6fjSP9QhkCni3k',
    appId: '1:399976911903:web:08bee114744b02b4a9712a',
    messagingSenderId: '399976911903',
    projectId: 'fir-flutter-auth-6fb90',
    authDomain: 'fir-flutter-auth-6fb90.firebaseapp.com',
    storageBucket: 'fir-flutter-auth-6fb90.firebasestorage.app',
    measurementId: 'G-PPRDEPQMDH',
  );
}


===== core\services\geocoding_service.dart =====

import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'dart:convert';
import 'dart:async';


class LocationIQService {

  Future<GeoPoint?> getCoordsFromAddress(String fullAddress) async {
    final String apiKey = dotenv.env['LOCATIONIQ_API_KEY'] ?? '';

    if (apiKey.isEmpty) {
        debugPrint("ERROR: LOCATIONIQ_API_KEY not found in .env or not loaded.");
        throw Exception("API Key Not Configured");
    }

    if (fullAddress.isEmpty) {
       throw Exception("Address cannot be empty");
    }

    final Uri apiUrl = Uri.parse(
      'https://us1.locationiq.com/v1/search.php?key=$apiKey&q=$fullAddress&format=json'
    );

    try {
      final response = await http.get(apiUrl).timeout(const Duration(seconds: 15));

      debugPrint("LocationIQ Response [${apiUrl.path}?q=...]: ${response.statusCode}");

      if (response.statusCode == 200) {
        final List<dynamic> responseBody = jsonDecode(response.body);
        if (responseBody.isNotEmpty) {
          final Map<String, dynamic> firstResult = responseBody[0];
          final String? latString = firstResult['lat'];
          final String? lonString = firstResult['lon'];

          if (latString != null && lonString != null) {
            final double? lat = double.tryParse(latString);
            final double? lon = double.tryParse(lonString);
            if (lat != null && lon != null) {
              return GeoPoint(lat, lon);
            } else {
               debugPrint("LocationIQ couldn't parse lat/lon strings: '$latString', '$lonString'");
               throw Exception("Invalid Coordinate Format");
            }
          } else {
            debugPrint("LocationIQ response missing lat/lon keys.");
            throw Exception("Invalid Response Format");
          }
        } else {
          debugPrint("LocationIQ returned empty results array.");
          throw Exception("Address Not Found");
        }
      } else if (response.statusCode == 401 || response.statusCode == 403) {
          debugPrint("LocationIQ API Key invalid or unauthorized.");
          throw Exception("Invalid API Key");
      } else if (response.statusCode == 404 || response.statusCode == 400) {
         debugPrint("LocationIQ returned 400/404.");
         throw Exception("Address Not Found/Invalid");
      }
       else {
         debugPrint("LocationIQ returned error status: ${response.statusCode}");
         throw Exception("Service Error (${response.statusCode})");
      }

    } on TimeoutException catch (_) {
      debugPrint("LocationIQ request timed out for '$fullAddress'");
      throw Exception("Request Timeout");
    } catch (e) {
      debugPrint("Error during LocationIQ service call for '$fullAddress': $e");
      if (e is Exception) {
         rethrow;
      } else {
         throw Exception("Geocoding Failed");
      }
    }
  }
}


===== core\services\image_upload_service.dart =====

// import 'dart:async';
// import 'dart:typed_data';
// import 'package:flutter/foundation.dart' show debugPrint;
// import 'package:http/http.dart' as http;
// import 'package:image_picker/image_picker.dart';
// import 'dart:convert'; // For jsonDecode

// class ImageUploadService {
//   final String _cloudName = 'dvcyhagv0'; // Get this from your Cloudinary Dashboard
//   final String _uploadPreset = 'mm_associates_profile_pics'; // The unsigned preset you created

//   static final ImageUploadService _instance = ImageUploadService._internal();
//   factory ImageUploadService() => _instance;
//   ImageUploadService._internal();

//   Future<String?> uploadImageToCloudinary(XFile imageXFile, {String? folder}) async {
//     final uri = Uri.parse('https://api.cloudinary.com/v1_1/$_cloudName/image/upload');
//     var request = http.MultipartRequest('POST', uri);

//     request.fields['upload_preset'] = _uploadPreset;
//     if (folder != null && folder.isNotEmpty) {
//       request.fields['folder'] = folder; // e.g., 'profile_pictures'
//     }
//     // You can add tags if needed:
//     // request.fields['tags'] = 'profile,user_generated';

//     try {
//       debugPrint("ImageUploadService: Reading bytes from XFile: ${imageXFile.name}");
//       final Uint8List imageBytes = await imageXFile.readAsBytes();
//       debugPrint("ImageUploadService: Image bytes read: ${imageBytes.length}");

//       request.files.add(http.MultipartFile.fromBytes(
//         'file', // This 'file' field name is standard for Cloudinary API
//         imageBytes,
//         filename: imageXFile.name,
//         // contentType: MediaType.parse(imageXFile.mimeType ?? 'image/jpeg'), // Optional
//       ));

//       debugPrint("ImageUploadService: Uploading to Cloudinary...");
//       var response = await request.send().timeout(const Duration(seconds: 60)); // Added timeout
//       var responseBody = await response.stream.bytesToString();

//       if (response.statusCode == 200 || response.statusCode == 201) {
//         var decoded = jsonDecode(responseBody);
//         String? secureUrl = decoded['secure_url'] as String?;
//         if (secureUrl != null) {
//           debugPrint("ImageUploadService: Cloudinary Upload Success. URL: $secureUrl");
//           return secureUrl;
//         } else {
//           debugPrint("ImageUploadService: Cloudinary response missing 'secure_url'. Response: $decoded");
//           throw Exception('Cloudinary response missing secure_url.');
//         }
//       } else {
//         debugPrint("ImageUploadService: Cloudinary Upload Error - Status: ${response.statusCode}, Body: $responseBody");
//         throw Exception('Failed to upload image: ${response.reasonPhrase} (Status ${response.statusCode})');
//       }
//     } on TimeoutException catch (e) {
//         debugPrint("ImageUploadService: Upload to Cloudinary timed out: $e");
//         throw Exception("Image upload timed out. Please check your connection.");
//     } catch (e) {
//       debugPrint("ImageUploadService: Error during Cloudinary upload process: $e");
//       // Rethrow a generic error or the specific one
//       throw Exception("Image upload failed. Please try again. ($e)");
//     }
//   }
// }

import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:http/http.dart' as http;
import 'package:image_picker/image_picker.dart';
import 'dart:convert'; // For jsonDecode
// import 'package:http_parser/http_parser.dart'; // Only needed if contentType is uncommented and used

class ImageUploadService {
  final String _cloudName = 'dvcyhagv0'; // Get this from your Cloudinary Dashboard
  // --- REMOVED: Hardcoded upload preset ---
  // final String _uploadPreset = 'mm_associates_profile_pics';

  static final ImageUploadService _instance = ImageUploadService._internal();
  factory ImageUploadService() => _instance;
  ImageUploadService._internal();

  Future<String?> uploadImageToCloudinary(
    XFile imageXFile, {
    // --- MODIFIED: Make uploadPreset a required named parameter ---
    required String uploadPreset,
    String? folder,
  }) async {
    final uri = Uri.parse('https://api.cloudinary.com/v1_1/$_cloudName/image/upload');
    var request = http.MultipartRequest('POST', uri);

    // --- MODIFIED: Use the passed uploadPreset ---
    request.fields['upload_preset'] = uploadPreset;

    if (folder != null && folder.isNotEmpty) {
      request.fields['folder'] = folder; // e.g., 'profile_pictures', 'venue_images'
    }
    // You can add tags if needed:
    // request.fields['tags'] = 'profile,user_generated';

    try {
      debugPrint("ImageUploadService: Reading bytes from XFile: ${imageXFile.name}");
      final Uint8List imageBytes = await imageXFile.readAsBytes();
      debugPrint("ImageUploadService: Image bytes read: ${imageBytes.length}");

      request.files.add(http.MultipartFile.fromBytes(
        'file', // This 'file' field name is standard for Cloudinary API
        imageBytes,
        filename: imageXFile.name,
        // contentType: MediaType.parse(imageXFile.mimeType ?? 'image/jpeg'), // Optional
      ));

      debugPrint("ImageUploadService: Uploading to Cloudinary with preset: $uploadPreset, folder: $folder...");
      var response = await request.send().timeout(const Duration(seconds: 60));
      var responseBody = await response.stream.bytesToString();

      if (response.statusCode == 200 || response.statusCode == 201) {
        var decoded = jsonDecode(responseBody);
        String? secureUrl = decoded['secure_url'] as String?;
        if (secureUrl != null) {
          debugPrint("ImageUploadService: Cloudinary Upload Success. URL: $secureUrl");
          return secureUrl;
        } else {
          debugPrint("ImageUploadService: Cloudinary response missing 'secure_url'. Response: $decoded");
          throw Exception('Cloudinary response missing secure_url.');
        }
      } else {
        debugPrint("ImageUploadService: Cloudinary Upload Error - Status: ${response.statusCode}, Body: $responseBody");
        throw Exception('Failed to upload image: ${response.reasonPhrase} (Status ${response.statusCode})');
      }
    } on TimeoutException catch (e) {
        debugPrint("ImageUploadService: Upload to Cloudinary timed out: $e");
        throw Exception("Image upload timed out. Please check your connection.");
    } catch (e) {
      debugPrint("ImageUploadService: Error during Cloudinary upload process: $e");
      throw Exception("Image upload failed. Please try again. ($e)");
    }
  }
}


===== core\services\location_service.dart =====

import 'package:geolocator/geolocator.dart';
import 'package:flutter/foundation.dart';

class LocationService {
  Future<bool> requestPermission() async {
    bool serviceEnabled;
    LocationPermission permission;

    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      debugPrint('Location services are disabled.');
      return false;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        debugPrint('Location permissions are denied');
        return false;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      debugPrint('Location permissions are permanently denied, we cannot request permissions.');
      return false;
    }

    return true;
  }

  Future<Position?> getCurrentLocation() async {
    try {
      final hasPermission = await requestPermission();
      if (!hasPermission) {
        return null;
      }
      return await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );
    } catch (e) {
      debugPrint("Error getting current location: $e");
      return null;
    }
  }

  double calculateDistance(double startLatitude, double startLongitude, double endLatitude, double endLongitude) {
     return Geolocator.distanceBetween(startLatitude, startLongitude, endLatitude, endLongitude) / 1000; // in KM
  }
}


===== features\admin\screens\admin_bookings_screen.dart =====

// lib/features/admin/screens/admin_bookings_screen.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'admin_service.dart';

class AdminBookingsScreen extends StatefulWidget {
  const AdminBookingsScreen({super.key});

  @override
  State<AdminBookingsScreen> createState() => _AdminBookingsScreenState();
}

class _AdminBookingsScreenState extends State<AdminBookingsScreen> {
  late Future<List<Map<String, dynamic>>> _bookingsFuture;
  final AdminService _adminService = AdminService();

  @override
  void initState() {
    super.initState();
    _bookingsFuture = _adminService.fetchBookingsForAdminVenues();
  }

  Future<void> _showUserDetailsDialog(BuildContext context, String userId) async {
    return showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return FutureBuilder<DocumentSnapshot<Map<String, dynamic>>>(
          future: _adminService.getUserDetails(userId),
          builder: (context, snapshot) {
            Widget content;
            if (snapshot.connectionState == ConnectionState.waiting) {
              content = const Center(child: CircularProgressIndicator());
            } else if (snapshot.hasError) {
              content = const Text("Error loading user details.");
            } else if (!snapshot.hasData || !snapshot.data!.exists) {
              content = const Text("User not found.");
            } else {
              final userData = snapshot.data!.data();
              content = Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Name: ${userData?['name'] ?? 'N/A'}'),
                  const SizedBox(height: 8),
                  Text('Email: ${userData?['email'] ?? 'N/A'}'),
                  const SizedBox(height: 8),
                  Text('Phone: ${userData?['phoneNumber'] ?? 'N/A'}'),
                ],
              );
            }

            return AlertDialog(
              title: const Text('Booked By'),
              content: content,
              actions: [
                TextButton(
                  child: const Text('Close'),
                  onPressed: () {
                    Navigator.of(dialogContext).pop();
                  },
                ),
              ],
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Venue Bookings'),
        centerTitle: true,
      ),
      body: FutureBuilder<List<Map<String, dynamic>>>(
        future: _bookingsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text("Error: ${snapshot.error}", textAlign: TextAlign.center),
            );
          }

          if (!snapshot.hasData || snapshot.data!.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.event_busy, size: 60, color: Colors.grey),
                  SizedBox(height: 16),
                  Text(
                    'No bookings found for your venues.',
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            );
          }

          final bookings = snapshot.data!;

          return ListView.builder(
            padding: const EdgeInsets.all(8.0),
            itemCount: bookings.length,
            itemBuilder: (context, index) {
              final booking = bookings[index];
              return _BookingInfoCard(
                bookingData: booking,
                onViewUserPressed: () {
                  _showUserDetailsDialog(context, booking['userId']);
                },
              );
            },
          );
        },
      ),
    );
  }
}

class _BookingInfoCard extends StatelessWidget {
  final Map<String, dynamic> bookingData;
  final VoidCallback onViewUserPressed;

  const _BookingInfoCard({
    required this.bookingData,
    required this.onViewUserPressed,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final startTime = (bookingData['bookingStartTime'] as Timestamp).toDate();
    final endTime = (bookingData['bookingEndTime'] as Timestamp).toDate();

    return Card(
      elevation: 3,
      margin: const EdgeInsets.symmetric(vertical: 8),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    bookingData['venueName'] ?? 'Venue Name N/A',
                    style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                _BookingStatusChip(status: bookingData['status'] ?? 'unknown'),
              ],
            ),
            const Divider(height: 24),
            _buildInfoRow(
              icon: Icons.person_outline,
              label: 'User Name',
              value: bookingData['userName'] ?? 'N/A',
            ),
            const SizedBox(height: 12),
            _buildInfoRow(
              icon: Icons.calendar_today_outlined,
              label: 'Date',
              value: DateFormat.yMMMMd().format(startTime),
            ),
            const SizedBox(height: 12),
            _buildInfoRow(
              icon: Icons.access_time_outlined,
              label: 'Slot',
              value: '${DateFormat.jm().format(startTime)} - ${DateFormat.jm().format(endTime)}',
            ),
            const SizedBox(height: 16),
            Align(
              alignment: Alignment.centerRight,
              child: OutlinedButton.icon(
                icon: const Icon(Icons.info_outline, size: 18),
                label: const Text('View User Details'),
                onPressed: onViewUserPressed,
                style: OutlinedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  side: BorderSide(color: theme.primaryColor),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildInfoRow({required IconData icon, required String label, required String value}) {
    return Row(
      children: [
        Icon(icon, size: 20, color: Colors.grey.shade600),
        const SizedBox(width: 16),
        Text('$label: ', style: const TextStyle(fontWeight: FontWeight.w600)),
        Expanded(child: Text(value, style: const TextStyle(fontSize: 15), overflow: TextOverflow.ellipsis)),
      ],
    );
  }
}

class _BookingStatusChip extends StatelessWidget {
  final String status;
  const _BookingStatusChip({required this.status});

  @override
  Widget build(BuildContext context) {
    Color chipColor;
    String label;
    IconData icon;

    switch (status.toLowerCase()) {
      case 'confirmed':
        chipColor = Colors.green.shade100;
        label = 'Confirmed';
        icon = Icons.check_circle_outline;
        break;
      case 'pending':
        chipColor = Colors.orange.shade100;
        label = 'Pending';
        icon = Icons.hourglass_empty_outlined;
        break;
      case 'cancelled_user':
      case 'cancelled_admin':
        chipColor = Colors.red.shade100;
        label = 'Cancelled';
        icon = Icons.cancel_outlined;
        break;
      default:
        chipColor = Colors.grey.shade300;
        label = 'Unknown';
        icon = Icons.help_outline;
    }
    return Chip(
      label: Text(label),
      avatar: Icon(icon, size: 16, color: chipColor.computeLuminance() > 0.5 ? Colors.black87 : Colors.white70,),
      backgroundColor: chipColor,
      labelStyle: TextStyle(
        fontWeight: FontWeight.w600,
        color: chipColor.computeLuminance() > 0.5 ? Colors.black87 : Colors.white70,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 8),
    );
  }
}


===== features\admin\screens\admin_service.dart =====

// lib/features/admin/services/admin_service.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

class AdminService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  /// Fetches all bookings for venues created by the currently logged-in admin.
  Future<List<Map<String, dynamic>>> fetchBookingsForAdminVenues() async {
    final User? currentUser = _auth.currentUser;
    if (currentUser == null) {
      throw Exception("User not logged in.");
    }

    try {
      // Step 1: Find all venues created by the current admin.
      final venuesSnapshot = await _firestore
          .collection('mm_venues')
          .where('creatorUid', isEqualTo: currentUser.uid)
          .get();

      if (venuesSnapshot.docs.isEmpty) {
        // The admin has no venues, so there can be no bookings.
        return [];
      }

      // Step 2: Extract the IDs of these venues.
      final List<String> adminVenueIds =
          venuesSnapshot.docs.map((doc) => doc.id).toList();

      if (adminVenueIds.isEmpty) {
        return [];
      }

      // Step 3: Query the bookings collection for any booking whose venueId
      // is in the list of the admin's venue IDs.
      // Firestore 'whereIn' queries are limited to 30 items per query. 
      // If you expect more venues, this needs pagination. For now, this is sufficient.
      final bookingsSnapshot = await _firestore
          .collection('bookings')
          .where('venueId', whereIn: adminVenueIds)
          .orderBy('bookingStartTime', descending: true) // Show newest bookings first
          .get();

      // Combine booking data with its document ID
      return bookingsSnapshot.docs.map((doc) {
        final data = doc.data();
        data['bookingId'] = doc.id;
        return data;
      }).toList();

    } catch (e) {
      print("Error fetching admin bookings: $e");
      throw Exception("Failed to load bookings. Please try again.");
    }
  }
  
  /// Fetches a single user's profile data.
  Future<DocumentSnapshot<Map<String, dynamic>>> getUserDetails(String userId) {
    return _firestore.collection('mm_users').doc(userId).get();
  }
}


===== features\auth\screens\forgot_password_screen.dart =====


// // import 'package:flutter/material.dart';
// // import '../services/auth_service.dart'; // Ensure this path is correct to your AuthService
// // import 'dart:async';

// // class ForgotPasswordScreen extends StatefulWidget {
// //   const ForgotPasswordScreen({super.key}); // This is the constructor SignInScreen is looking for

// //   @override
// //   State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
// // }

// // class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
// //   final _formKey = GlobalKey<FormState>();
// //   final _emailController = TextEditingController();
// //   final AuthService _authService = AuthService();
// //   bool _isLoading = false;
// //   String? _errorMessage;
// //   String? _successMessage;

// //   bool _isButtonDisabled = false;
// //   int _countdownSeconds = 60;
// //   Timer? _timer;

// //   final FocusNode _emailFocusNode = FocusNode();

// //   @override
// //   void dispose() {
// //     _emailController.dispose();
// //     _timer?.cancel();
// //     _emailFocusNode.dispose();
// //     super.dispose();
// //   }

// //   void _startTimer() {
// //     if (!mounted) return;
// //     setState(() {
// //       _isButtonDisabled = true;
// //       _countdownSeconds = 60;
// //     });
// //     _timer?.cancel();
// //     _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
// //       if (!mounted) {
// //         timer.cancel();
// //         return;
// //       }
// //       setState(() {
// //         if (_countdownSeconds > 0) {
// //           _countdownSeconds--;
// //         } else {
// //           _timer?.cancel();
// //           _isButtonDisabled = false;
// //         }
// //       });
// //     });
// //   }

// //   Future<void> _sendResetLink() async {
// //     if (_isButtonDisabled || !mounted || _isLoading) return;

// //     if (!_formKey.currentState!.validate()) {
// //       return;
// //     }

// //     if (!mounted) return;
// //     setState(() {
// //       _isLoading = true;
// //       _errorMessage = null;
// //       _successMessage = null;
// //     });

// //     final String email = _emailController.text.trim();

// //     try {
// //       await _authService.sendPasswordResetEmail(email);

// //       if (mounted) {
// //         _startTimer();
// //         _formKey.currentState?.reset();
// //         _emailController.clear();

// //         setState(() {
// //           _successMessage = 'Password reset link sent! Please check your email (including spam folder).';
// //           _isLoading = false;
// //         });

// //         WidgetsBinding.instance.addPostFrameCallback((_) {
// //           if (mounted) {
// //             ScaffoldMessenger.of(context).showSnackBar(
// //               const SnackBar(
// //                 content: Text('Password reset link sent!'),
// //                 backgroundColor: Colors.green,
// //                 behavior: SnackBarBehavior.floating,
// //                 margin: EdgeInsets.all(10),
// //                 shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10))),
// //               ),
// //             );
// //           }
// //         });
// //       }
// //     } catch (e) {
// //       if (mounted) {
// //         debugPrint("Error sending password reset link: $e");
// //         setState(() {
// //           _errorMessage = e.toString().replaceFirst('Exception: ', '');
// //           _isLoading = false;
// //         });
// //       }
// //     }
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final ThemeData theme = Theme.of(context);

// //     Widget forgotPasswordFormContent = Form(
// //       key: _formKey,
// //       child: Column(
// //         mainAxisAlignment: MainAxisAlignment.center,
// //         mainAxisSize: MainAxisSize.min,
// //         crossAxisAlignment: CrossAxisAlignment.stretch,
// //         children: [
// //           const Icon(Icons.lock_reset_outlined, size: 60, color: Colors.orangeAccent),
// //           const SizedBox(height: 20),
// //           const Text(
// //             'Forgot Your Password?',
// //             style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
// //             textAlign: TextAlign.center,
// //           ),
// //           const SizedBox(height: 15),
// //           Text(
// //             'Enter your account email address below and we\'ll send you a link to reset your password.',
// //             style: TextStyle(fontSize: 15, color: Colors.grey[600]),
// //             textAlign: TextAlign.center,
// //           ),
// //           const SizedBox(height: 30),

// //           TextFormField(
// //             controller: _emailController,
// //             focusNode: _emailFocusNode,
// //             decoration: const InputDecoration(labelText: 'Email', prefixIcon: Icon(Icons.email_outlined)),
// //             keyboardType: TextInputType.emailAddress,
// //             autovalidateMode: AutovalidateMode.onUserInteraction,
// //             textInputAction: TextInputAction.done,
// //             onFieldSubmitted: (_) => _sendResetLink(),
// //             validator: (value) {
// //               if (value == null || value.trim().isEmpty) return 'Please enter your email';
// //               if (!RegExp(r"^[a-zA-Z0-9.a-zA-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[a-zA-Z0-9]+\.[a-zA-Z]+").hasMatch(value.trim())) {
// //                 return 'Please enter a valid email address';
// //               }
// //               return null;
// //             },
// //           ),
// //           const SizedBox(height: 25),

// //           if (_errorMessage != null && _errorMessage!.isNotEmpty)
// //             Padding(
// //               padding: const EdgeInsets.only(bottom: 15.0),
// //               child: Text(
// //                 _errorMessage!,
// //                 style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
// //                 textAlign: TextAlign.center,
// //               ),
// //             ),

// //           if (_successMessage != null && _successMessage!.isNotEmpty)
// //             Padding(
// //               padding: const EdgeInsets.only(bottom: 15.0),
// //               child: Text(
// //                 _successMessage!,
// //                 style: const TextStyle(color: Colors.green, fontSize: 14, fontWeight: FontWeight.w500),
// //                 textAlign: TextAlign.center,
// //               ),
// //             ),

// //           if (_isLoading)
// //             const Center(child: Padding(padding: EdgeInsets.symmetric(vertical: 8.0), child: CircularProgressIndicator()))
// //           else
// //             ElevatedButton(
// //               onPressed: _isButtonDisabled ? null : _sendResetLink,
// //               style: ElevatedButton.styleFrom(
// //                 backgroundColor: Colors.orange,
// //                 disabledBackgroundColor: Colors.orange.withOpacity(0.5),
// //                 padding: const EdgeInsets.symmetric(vertical: 14),
// //               ),
// //               child: Text(
// //                 _isButtonDisabled ? 'Resend in $_countdownSeconds s' : 'Send Reset Link',
// //                 style: const TextStyle(fontSize: 16, color: Colors.white),
// //               ),
// //             ),
// //           const SizedBox(height: 20),
// //         ],
// //       ),
// //     );

// //     return Scaffold(
// //       appBar: AppBar(
// //         title: const Text('Reset Password'),
// //       ),
// //       body: SafeArea(
// //         child: Center(
// //           child: Padding(
// //             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
// //             child: Container(
// //               constraints: BoxConstraints(
// //                 maxWidth: 400,
// //               ),
// //               decoration: BoxDecoration(
// //                 color: theme.cardColor,
// //                 borderRadius: BorderRadius.circular(16.0),
// //                 border: Border.all(
// //                   color: theme.dividerColor.withOpacity(0.5),
// //                   width: 1.0,
// //                 ),
// //                 boxShadow: [
// //                   BoxShadow(
// //                     color: Colors.black.withOpacity(0.08),
// //                     blurRadius: 12.0,
// //                     offset: const Offset(0, 4),
// //                   ),
// //                 ],
// //               ),
// //               child: ClipRRect(
// //                 borderRadius: BorderRadius.circular(15.0),
// //                 child: SingleChildScrollView(
// //                   padding: const EdgeInsets.all(24.0),
// //                   child: forgotPasswordFormContent,
// //                 ),
// //               ),
// //             ),
// //           ),
// //         ),
// //       ),
// //     );
// //   }
// // }

// import 'package:flutter/material.dart';
// import '../services/auth_service.dart'; // Ensure this path is correct to your AuthService
// import 'dart:async';

// // If your AuthService throws FirebaseAuthException, you'd uncomment this and use it in error handling.
// // import 'package:firebase_auth/firebase_auth.dart';

// class ForgotPasswordScreen extends StatefulWidget {
//   const ForgotPasswordScreen({super.key});

//   @override
//   State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
// }

// class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
//   final _formKey = GlobalKey<FormState>();
//   final _emailController = TextEditingController();
//   final AuthService _authService = AuthService();
//   bool _isLoading = false;
//   String? _errorMessage;
//   String? _successMessage;

//   bool _isButtonDisabled = false;
//   int _countdownSeconds = 60;
//   Timer? _timer;

//   final FocusNode _emailFocusNode = FocusNode();

//   @override
//   void dispose() {
//     _emailController.dispose();
//     _timer?.cancel();
//     _emailFocusNode.dispose();
//     super.dispose();
//   }

//   void _startTimer() {
//     if (!mounted) return;
//     setState(() {
//       _isButtonDisabled = true;
//       _countdownSeconds = 60;
//     });
//     _timer?.cancel();
//     _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
//       if (!mounted) {
//         timer.cancel();
//         return;
//       }
//       setState(() {
//         if (_countdownSeconds > 0) {
//           _countdownSeconds--;
//         } else {
//           _timer?.cancel();
//           _isButtonDisabled = false;
//         }
//       });
//     });
//   }

//   Future<void> _sendResetLink() async {
//     if (_isButtonDisabled || !mounted || _isLoading) return;

//     if (!_formKey.currentState!.validate()) {
//       return;
//     }
//     _emailFocusNode.unfocus(); // Unfocus keyboard before processing

//     if (!mounted) return;
//     setState(() {
//       _isLoading = true;
//       _errorMessage = null;
//       _successMessage = null;
//     });

//     final String email = _emailController.text.trim();

//     try {
//       await _authService.sendPasswordResetEmail(email);

//       if (mounted) {
//         _startTimer();
//         _formKey.currentState?.reset(); // Clears the form fields
//         // _emailController.clear(); // Redundant if form.reset() is used effectively

//         setState(() {
//           _successMessage = 'Password reset link sent! Please check your email (including spam folder).';
//           _isLoading = false;
//         });

//         WidgetsBinding.instance.addPostFrameCallback((_) {
//           if (mounted) {
//             ScaffoldMessenger.of(context).showSnackBar(
//               const SnackBar(
//                 content: Text('Password reset link sent!'),
//                 backgroundColor: Colors.green,
//                 behavior: SnackBarBehavior.floating,
//                 margin: EdgeInsets.all(10),
//                 shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10))),
//               ),
//             );
//           }
//         });
//       }
//     } catch (e, s) { // Added stack trace 's' for better debugging
//       if (mounted) {
//         debugPrint("Error sending password reset link: $e\nStack trace: $s");
//         String displayMessage;

//         // --- Start: More Granular Error Handling ---
//         // OPTION 1: Generic keyword matching (if AuthService doesn't throw specific typed exceptions)
//         final errorString = e.toString().toLowerCase();
//         if (errorString.contains('user-not-found') || errorString.contains('no user record')) {
//             displayMessage = 'No account found with this email. Please check the email or sign up.';
//         } else if (errorString.contains('invalid-email') || errorString.contains('malformed')) {
//             displayMessage = 'The email address provided is not valid. Please enter a valid email.';
//         } else if (errorString.contains('network') || errorString.contains('socket') || errorString.contains('host lookup') || errorString.contains('timeout')) {
//             displayMessage = 'Could not connect. Please check your internet connection and try again.';
//         } else if (errorString.contains('too-many-requests')) {
//             displayMessage = 'Too many requests. Please wait a moment and try again.';
//         }
//         else {
//             // Fallback for other errors.
//             // In a production app, you might want to log 'e.toString()' to a service.
//             displayMessage = 'An unexpected error occurred. Please try again later.';
//             debugPrint("Original error for unhandled case: $e");
//         }

//         // OPTION 2: If your AuthService throws specific exceptions (e.g., FirebaseAuthException)
//         // You would uncomment the firebase_auth import and use this block instead of OPTION 1.
//         /*
//         if (e is FirebaseAuthException) {
//           switch (e.code) {
//             case 'user-not-found':
//               displayMessage = 'No account found with this email address. Please check the email or sign up.';
//               break;
//             case 'invalid-email':
//               displayMessage = 'The email address is badly formatted. Please enter a valid email.';
//               break;
//             case 'too-many-requests':
//               displayMessage = 'Too many attempts. Please try again later.';
//               break;
//             // Add other Firebase specific codes here
//             default:
//               displayMessage = e.message ?? 'An error occurred sending the reset email. Please try again.';
//           }
//         } else {
//           // Handle other types of exceptions not specifically caught above
//           displayMessage = 'An unexpected error occurred. Please try again.';
//           debugPrint("Original error: $e");
//         }
//         */
//         // --- End: More Granular Error Handling ---

//         setState(() {
//           _errorMessage = displayMessage;
//           _isLoading = false;
//         });
//       }
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     final ThemeData theme = Theme.of(context);

//     Widget forgotPasswordFormContent = Form(
//       key: _formKey,
//       child: Column(
//         mainAxisAlignment: MainAxisAlignment.center,
//         mainAxisSize: MainAxisSize.min,
//         crossAxisAlignment: CrossAxisAlignment.stretch,
//         children: [
//           const Icon(Icons.lock_reset_outlined, size: 60, color: Colors.orangeAccent),
//           const SizedBox(height: 20),
//           const Text(
//             'Forgot Your Password?',
//             style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
//             textAlign: TextAlign.center,
//           ),
//           const SizedBox(height: 15),
//           Text(
//             'Enter your account email address below and we\'ll send you a link to reset your password.',
//             style: TextStyle(fontSize: 15, color: Colors.grey[600]),
//             textAlign: TextAlign.center,
//           ),
//           const SizedBox(height: 30),

//           TextFormField(
//             controller: _emailController,
//             focusNode: _emailFocusNode,
//             decoration: const InputDecoration(labelText: 'Email', prefixIcon: Icon(Icons.email_outlined)),
//             keyboardType: TextInputType.emailAddress,
//             autovalidateMode: AutovalidateMode.onUserInteraction,
//             textInputAction: TextInputAction.done,
//             onFieldSubmitted: (_) => _sendResetLink(),
//             validator: (value) {
//               if (value == null || value.trim().isEmpty) return 'Please enter your email';
//               if (!RegExp(r"^[a-zA-Z0-9.a-zA-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[a-zA-Z0-9]+\.[a-zA-Z]+").hasMatch(value.trim())) {
//                 return 'Please enter a valid email address';
//               }
//               return null;
//             },
//           ),
//           const SizedBox(height: 25),

//           if (_errorMessage != null && _errorMessage!.isNotEmpty)
//             Padding(
//               padding: const EdgeInsets.only(bottom: 15.0),
//               child: Text(
//                 _errorMessage!,
//                 style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
//                 textAlign: TextAlign.center,
//               ),
//             ),

//           if (_successMessage != null && _successMessage!.isNotEmpty)
//             Padding(
//               padding: const EdgeInsets.only(bottom: 15.0),
//               child: Text(
//                 _successMessage!,
//                 style: const TextStyle(color: Colors.green, fontSize: 14, fontWeight: FontWeight.w500),
//                 textAlign: TextAlign.center,
//               ),
//             ),

//           if (_isLoading)
//             const Center(child: Padding(padding: EdgeInsets.symmetric(vertical: 8.0), child: CircularProgressIndicator()))
//           else
//             ElevatedButton(
//               onPressed: _isButtonDisabled ? null : _sendResetLink,
//               style: ElevatedButton.styleFrom(
//                 backgroundColor: Colors.orange,
//                 disabledBackgroundColor: Colors.orange.withOpacity(0.5),
//                 padding: const EdgeInsets.symmetric(vertical: 14),
//               ),
//               child: Text(
//                 _isButtonDisabled ? 'Resend in $_countdownSeconds s' : 'Send Reset Link',
//                 style: const TextStyle(fontSize: 16, color: Colors.white),
//               ),
//             ),
          
//           // --- Start: "Back to Login" Button ---
//           if (_successMessage != null && _successMessage!.isNotEmpty && !_isLoading)
//             Padding(
//               padding: const EdgeInsets.only(top: 12.0),
//               child: TextButton(
//                 onPressed: () {
//                   // If this screen was pushed from LoginScreen, pop will return there.
//                   if (Navigator.canPop(context)) {
//                     Navigator.pop(context);
//                   } else {
//                     // Fallback: If it can't pop (e.g., it's the first screen or stack was cleared)
//                     // navigate to login. Ensure you have a '/login' route defined in your app.
//                     Navigator.pushReplacementNamed(context, '/login');
//                   }
//                 },
//                 child: Text(
//                   'Back to Login',
//                   style: TextStyle(color: Theme.of(context).colorScheme.primary),
//                 ),
//               ),
//             ),
//           // --- End: "Back to Login" Button ---

//           const SizedBox(height: 20), // Provides some spacing at the bottom
//         ],
//       ),
//     );

//     return Scaffold(
//       appBar: AppBar(
//         title: const Text('Reset Password'),
//       ),
//       body: SafeArea(
//         child: Center(
//           child: Padding(
//             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
//             child: Container(
//               constraints: const BoxConstraints(maxWidth: 400), // Added const
//               decoration: BoxDecoration(
//                 color: theme.cardColor,
//                 borderRadius: BorderRadius.circular(16.0),
//                 border: Border.all(
//                   color: theme.dividerColor.withOpacity(0.5),
//                   width: 1.0,
//                 ),
//                 boxShadow: [
//                   BoxShadow(
//                     color: Colors.black.withOpacity(0.08),
//                     blurRadius: 12.0,
//                     offset: const Offset(0, 4),
//                   ),
//                 ],
//               ),
//               child: ClipRRect(
//                 borderRadius: BorderRadius.circular(15.0),
//                 child: SingleChildScrollView(
//                   padding: const EdgeInsets.all(24.0),
//                   child: forgotPasswordFormContent,
//                 ),
//               ),
//             ),
//           ),
//         ),
//       ),
//     );
//   }
// }

import 'package:flutter/material.dart';
import '../services/auth_service.dart'; // Ensure this path is correct
import 'dart:async';

// If your AuthService throws FirebaseAuthException, you'd uncomment this and use it
// import 'package:firebase_auth/firebase_auth.dart';

class ForgotPasswordScreen extends StatefulWidget {
  const ForgotPasswordScreen({super.key});

  @override
  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
}

class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final AuthService _authService = AuthService();
  bool _isLoading = false;
  String? _errorMessage;
  String? _successMessage;

  // --- Static variable to store the cooldown end time ---
  static DateTime? _cooldownEndTime;
  // --- End static variable ---

  bool _isButtonDisabled = false;
  int _countdownSeconds = 60; // Default, will be overridden if cooldown active
  Timer? _uiUpdateTimer; // Renamed from _timer for clarity

  final FocusNode _emailFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _checkAndResumeCooldown();
  }

  void _checkAndResumeCooldown() {
    if (_cooldownEndTime != null && _cooldownEndTime!.isAfter(DateTime.now())) {
      final remainingDuration = _cooldownEndTime!.difference(DateTime.now());
      if (remainingDuration.inSeconds > 0) {
        if (!mounted) return;
        setState(() {
          _isButtonDisabled = true;
          _countdownSeconds = remainingDuration.inSeconds;
        });
        _startUiUpdateTimer(initialSeconds: _countdownSeconds);
      } else {
        // Cooldown might have just expired between navigations
        _cooldownEndTime = null;
        _isButtonDisabled = false; // Ensure button is enabled
      }
    } else {
      _cooldownEndTime = null; // Clear if expired or not set
      _isButtonDisabled = false; // Ensure button is enabled initially if no cooldown
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _uiUpdateTimer?.cancel();
    _emailFocusNode.dispose();
    super.dispose();
  }

  void _startUiUpdateTimer({int initialSeconds = 60}) {
    if (!mounted) return;
    // Ensure _isButtonDisabled is true when timer starts
    // and _countdownSeconds is set to the initial value for the display.
    setState(() {
      _isButtonDisabled = true;
      _countdownSeconds = initialSeconds;
    });

    _uiUpdateTimer?.cancel(); // Cancel any existing timer
    _uiUpdateTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }
      setState(() {
        if (_countdownSeconds > 0) {
          _countdownSeconds--;
        } else {
          _uiUpdateTimer?.cancel();
          _isButtonDisabled = false;
          _cooldownEndTime = null; // Cooldown finished, clear the global state
        }
      });
    });
  }

  Future<void> _sendResetLink() async {
    // Check against the global cooldown first
    if (_cooldownEndTime != null && _cooldownEndTime!.isAfter(DateTime.now())) {
       // Optionally show a message: "Please wait for cooldown to finish"
      return;
    }
    // Then check local state (isLoading, _isButtonDisabled should ideally reflect global)
    if (_isButtonDisabled || !mounted || _isLoading) return;


    if (!_formKey.currentState!.validate()) {
      return;
    }
    _emailFocusNode.unfocus();

    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _errorMessage = null;
      _successMessage = null;
    });

    final String email = _emailController.text.trim();

    try {
      await _authService.sendPasswordResetEmail(email);

      if (mounted) {
        // --- Set the global cooldown end time ---
        _cooldownEndTime = DateTime.now().add(const Duration(seconds: 60));
        // --- End set global ---

        _startUiUpdateTimer(initialSeconds: 60); // Start local UI timer with full duration
        _formKey.currentState?.reset();

        setState(() {
          _successMessage = 'Password reset link sent! Please check your email (including spam folder).';
          _isLoading = false;
        });

        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Password reset link sent!'),
                backgroundColor: Colors.green,
                behavior: SnackBarBehavior.floating,
                margin: EdgeInsets.all(10),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10))),
              ),
            );
          }
        });
      }
    } catch (e, s) {
      if (mounted) {
        debugPrint("Error sending password reset link: $e\nStack trace: $s");
        String displayMessage;
        final errorString = e.toString().toLowerCase();

        if (errorString.contains('user-not-found') || errorString.contains('no user record')) {
            displayMessage = 'No account found with this email. Please check the email or sign up.';
        } else if (errorString.contains('invalid-email') || errorString.contains('malformed')) {
            displayMessage = 'The email address provided is not valid. Please enter a valid email.';
        } else if (errorString.contains('network') || errorString.contains('socket') || errorString.contains('host lookup') || errorString.contains('timeout')) {
            displayMessage = 'Could not connect. Please check your internet connection and try again.';
        } else if (errorString.contains('too-many-requests')) {
            displayMessage = 'Too many requests. Please wait a moment and try again.';
             // If this error happens, we should respect it and start a cooldown
            _cooldownEndTime = DateTime.now().add(const Duration(seconds: 60)); // Or based on API hint
            _startUiUpdateTimer(initialSeconds: 60);
        }
        else {
            displayMessage = 'An unexpected error occurred. Please try again later.';
            debugPrint("Original error for unhandled case: $e");
        }
        setState(() {
          _errorMessage = displayMessage;
          _isLoading = false;
          // Do not re-enable button if "too-many-requests" just triggered a cooldown
          if (!errorString.contains('too-many-requests')) {
             _isButtonDisabled = false; // Re-enable button on other errors
             _cooldownEndTime = null; // Clear any previous cooldown if error wasn't 'too-many-requests'
          }
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);

    Widget forgotPasswordFormContent = Form(
      key: _formKey,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Icon(Icons.lock_reset_outlined, size: 60, color: Colors.orangeAccent),
          const SizedBox(height: 20),
          const Text(
            'Forgot Your Password?',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 15),
          Text(
            'Enter your account email address below and we\'ll send you a link to reset your password.',
            style: TextStyle(fontSize: 15, color: Colors.grey[600]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 30),

          TextFormField(
            controller: _emailController,
            focusNode: _emailFocusNode,
            decoration: const InputDecoration(labelText: 'Email', prefixIcon: Icon(Icons.email_outlined)),
            keyboardType: TextInputType.emailAddress,
            autovalidateMode: AutovalidateMode.onUserInteraction,
            textInputAction: TextInputAction.done,
            onFieldSubmitted: (_) => _sendResetLink(),
            validator: (value) {
              if (value == null || value.trim().isEmpty) return 'Please enter your email';
              if (!RegExp(r"^[a-zA-Z0-9.a-zA-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[a-zA-Z0-9]+\.[a-zA-Z]+").hasMatch(value.trim())) {
                return 'Please enter a valid email address';
              }
              return null;
            },
          ),
          const SizedBox(height: 25),

          if (_errorMessage != null && _errorMessage!.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 15.0),
              child: Text(
                _errorMessage!,
                style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
                textAlign: TextAlign.center,
              ),
            ),

          if (_successMessage != null && _successMessage!.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 15.0),
              child: Text(
                _successMessage!,
                style: const TextStyle(color: Colors.green, fontSize: 14, fontWeight: FontWeight.w500),
                textAlign: TextAlign.center,
              ),
            ),

          if (_isLoading)
            const Center(child: Padding(padding: EdgeInsets.symmetric(vertical: 8.0), child: CircularProgressIndicator()))
          else
            ElevatedButton(
              onPressed: _isButtonDisabled ? null : _sendResetLink, // The local _isButtonDisabled is key here
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.orange,
                disabledBackgroundColor: Colors.orange.withOpacity(0.5),
                padding: const EdgeInsets.symmetric(vertical: 14),
              ),
              child: Text(
                _isButtonDisabled ? 'Resend in $_countdownSeconds s' : 'Send Reset Link',
                style: const TextStyle(fontSize: 16, color: Colors.white),
              ),
            ),
          
          if (_successMessage != null && _successMessage!.isNotEmpty && !_isLoading)
            Padding(
              padding: const EdgeInsets.only(top: 12.0),
              child: ElevatedButton(
                onPressed: () {
                  if (Navigator.canPop(context)) {
                    Navigator.pop(context);
                  } else {
                    Navigator.pushReplacementNamed(context, '/login'); 
                  }
                },
                style: ElevatedButton.styleFrom( 
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text(
                  'Back to Login',
                  style: TextStyle(fontSize: 16),
                ),
              ),
            ),
          const SizedBox(height: 20), 
        ],
      ),
    );

    return Scaffold(
      appBar: AppBar(
        title: const Text('Reset Password'),
      ),
      body: SafeArea(
        child: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
            child: Container(
              constraints: const BoxConstraints(maxWidth: 400),
              decoration: BoxDecoration(
                color: theme.cardColor,
                borderRadius: BorderRadius.circular(16.0),
                border: Border.all(
                  color: theme.dividerColor.withOpacity(0.5),
                  width: 1.0,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.08),
                    blurRadius: 12.0,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(15.0),
                child: SingleChildScrollView(
                  padding: const EdgeInsets.all(24.0),
                  child: forgotPasswordFormContent,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== features\auth\screens\signin_screen.dart =====

import 'package:flutter/material.dart';
import '../services/auth_service.dart'; // Ensure this path is correct
import 'forgot_password_screen.dart';    // Ensure this path is correct
import 'package:flutter_signin_button/flutter_signin_button.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SignInScreen extends StatefulWidget {
  final VoidCallback showSignUpScreen;

  const SignInScreen({super.key, required this.showSignUpScreen});

  @override
  _SignInScreenState createState() => _SignInScreenState();
}

class _SignInScreenState extends State<SignInScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final AuthService _authService = AuthService();
  bool _isLoading = false;
  String? _errorMessage;
  bool _rememberMe = false;
  bool _obscurePassword = true;

  // --- NEW: FocusNodes ---
  final FocusNode _emailFocusNode = FocusNode();
  final FocusNode _passwordFocusNode = FocusNode();
  // --- END NEW ---

  static const String _rememberMeKey = 'remember_me_preference';
  static const String _emailKey = 'remembered_email';

  @override
  void initState() {
    super.initState();
    _loadRememberMePreference();
  }

  Future<void> _loadRememberMePreference() async {
    try {
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      final bool remembered = prefs.getBool(_rememberMeKey) ?? false;

      if (mounted) {
        setState(() {
          _rememberMe = remembered;
        });

        if (_rememberMe) {
          final String? savedEmail = prefs.getString(_emailKey);
          if (savedEmail != null) {
            _emailController.text = savedEmail;
          }
        }
      }
    } catch (e) {
      debugPrint("Error loading SharedPreferences: $e");
      if (mounted) {
        setState(() {
          _rememberMe = false;
        });
      }
    }
  }


  Future<void> _updateRememberMePreference(bool value, String? email) async {
     try {
       final SharedPreferences prefs = await SharedPreferences.getInstance();
       await prefs.setBool(_rememberMeKey, value);
       if (value && email != null && email.isNotEmpty) {
         await prefs.setString(_emailKey, email);
       } else {
         await prefs.remove(_emailKey);
       }
     } catch (e) {
        debugPrint("Error saving SharedPreferences: $e");
     }
  }


  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    // --- NEW: Dispose FocusNodes ---
    _emailFocusNode.dispose();
    _passwordFocusNode.dispose();
    // --- END NEW ---
    super.dispose();
  }

  Future<void> _signInWithEmail() async {
    // FocusScope.of(context).unfocus(); // No longer needed here as onFieldSubmitted handles it
    if (_isLoading) return; // Prevent multiple submissions

    if (_formKey.currentState!.validate()) {
      setState(() { _isLoading = true; _errorMessage = null; });
      final String currentEmail = _emailController.text.trim();
      try {
        await _authService.signInWithEmailPassword(
          currentEmail,
          _passwordController.text,
        );

        await _updateRememberMePreference(_rememberMe, currentEmail);

        // if (mounted) _passwordController.clear(); // Let AuthWrapper handle navigation/clearing

      } catch (e) {
        if (mounted) {
          setState(() { _errorMessage = e.toString().replaceFirst('Exception: ', ''); });
          _passwordController.clear();
        }
      } finally {
        if (mounted) {
          setState(() { _isLoading = false; });
        }
      }
    } else {
       _passwordController.clear();
    }
  }

  Future<void> _signInWithGoogle() async {
    if (_isLoading) return;
    setState(() { _isLoading = true; _errorMessage = null; });
    try {
      await _authService.signInWithGoogle();
       if (mounted) {
         setState(() { _errorMessage = null; });
       }
    } catch (e) {
       if (mounted) {
         setState(() { _errorMessage = e.toString().replaceFirst('Exception: ', ''); });
       }
    } finally {
       if (mounted) {
         setState(() { _isLoading = false; });
       }
    }
  }

  void _goToForgotPassword() {
     if (_isLoading) return;
     Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => const ForgotPasswordScreen()),
     );
  }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);

    Widget signInFormContent = Form(
      key: _formKey,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Text(
            'Welcome Back!',
            style: TextStyle(fontSize: 26, fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 10),
          Text(
            'Sign in to continue',
            style: TextStyle(fontSize: 16, color: Colors.grey[600]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 30),

          TextFormField(
            controller: _emailController,
            focusNode: _emailFocusNode, // --- NEW ---
            decoration: const InputDecoration(
              labelText: 'Email',
              prefixIcon: Icon(Icons.email_outlined),
            ),
            keyboardType: TextInputType.emailAddress,
            autovalidateMode: AutovalidateMode.onUserInteraction,
            textInputAction: TextInputAction.next, // --- NEW ---
            onFieldSubmitted: (_) { // --- NEW ---
              FocusScope.of(context).requestFocus(_passwordFocusNode);
            },
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter your email';
              }
              if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(value.trim())) {
                return 'Please enter a valid email address';
              }
              return null;
            },
          ),
          const SizedBox(height: 15),

          TextFormField(
            controller: _passwordController,
            focusNode: _passwordFocusNode, // --- NEW ---
            obscureText: _obscurePassword,
            decoration: InputDecoration(
              labelText: 'Password',
              prefixIcon: const Icon(Icons.lock_outline),
              suffixIcon: IconButton(
                icon: Icon(
                  _obscurePassword ? Icons.visibility_off : Icons.visibility,
                  color: Colors.grey,
                ),
                tooltip: _obscurePassword ? 'Show password' : 'Hide password',
                onPressed: () {
                  setState(() {
                    _obscurePassword = !_obscurePassword;
                  });
                },
              ),
            ),
            autovalidateMode: AutovalidateMode.disabled,
            textInputAction: TextInputAction.done, // --- NEW ---
            onFieldSubmitted: (_) => _signInWithEmail(), // --- NEW ---
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please enter your password';
              }
              return null;
            },
          ),
          const SizedBox(height: 10),

          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Semantics(
                  label: 'Remember my email address',
                  child: CheckboxListTile(
                    title: const Text("Remember Me", style: TextStyle(fontSize: 14)),
                    value: _rememberMe,
                    onChanged: _isLoading ? null : (newValue) {
                      if (newValue != null) {
                        setState(() {
                          _rememberMe = newValue;
                        });
                        String? emailToSave = newValue ? _emailController.text.trim() : null;
                        _updateRememberMePreference(newValue, emailToSave);
                      }
                    },
                    controlAffinity: ListTileControlAffinity.leading,
                    contentPadding: EdgeInsets.zero,
                    dense: true,
                    activeColor: Theme.of(context).primaryColor,
                  ),
                ),
              ),
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: TextButton(
                  onPressed: _isLoading ? null : _goToForgotPassword,
                  child: const Text('Forgot Password?'),
                  style: TextButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 8),
                    tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 15),

          if (_errorMessage != null && _errorMessage!.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 15.0),
              child: Text(
                _errorMessage!,
                style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
                textAlign: TextAlign.center,
              ),
            ),

          if (_isLoading)
            const Center(child: Padding(
              padding: EdgeInsets.symmetric(vertical: 16.0),
              child: CircularProgressIndicator(),
            ))
          else ...[
            ElevatedButton(
              onPressed: _signInWithEmail,
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 14),
              ),
              child: const Text('Sign In', style: TextStyle(fontSize: 16)),
            ),
            const SizedBox(height: 20),

            Row(
              children: <Widget>[
                Expanded(child: Divider(color: Colors.grey[400])),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 10),
                  child: Text("OR", style: TextStyle(color: Colors.grey[600])),
                ),
                Expanded(child: Divider(color: Colors.grey[400])),
              ],
            ),
            const SizedBox(height: 20),

            SignInButton(
              Buttons.Google,
              text: "Sign in with Google",
              onPressed: _signInWithGoogle,
              padding: const EdgeInsets.symmetric(vertical: 6),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8.0),
              ),
            ),
            const SizedBox(height: 25),

            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text("Don't have an account?"),
                TextButton(
                  onPressed: _isLoading ? null : widget.showSignUpScreen,
                  child: const Text('Sign Up'),
                ),
              ],
            ),
          ]
        ],
      ),
    );

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
            child: Container(
              constraints: BoxConstraints(
                maxWidth: 400,
              ),
              decoration: BoxDecoration(
                color: theme.cardColor,
                borderRadius: BorderRadius.circular(16.0),
                border: Border.all(
                  color: theme.dividerColor.withOpacity(0.5),
                  width: 1.0,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.08),
                    blurRadius: 12.0,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(15.0),
                child: SingleChildScrollView(
                  padding: const EdgeInsets.all(24.0),
                  child: signInFormContent,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== features\auth\screens\signup_screen.dart =====

import 'package:flutter/material.dart';
import '../services/auth_service.dart'; // Ensure this path is correct

class SignUpScreen extends StatefulWidget {
  final VoidCallback showSignInScreen;

  const SignUpScreen({super.key, required this.showSignInScreen});

  @override
  _SignUpScreenState createState() => _SignUpScreenState();
}

class _SignUpScreenState extends State<SignUpScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final AuthService _authService = AuthService();
  bool _isLoading = false;
  String? _errorMessage;
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  // --- NEW: FocusNodes ---
  final FocusNode _nameFocusNode = FocusNode();
  final FocusNode _emailFocusNode = FocusNode();
  final FocusNode _passwordFocusNode = FocusNode();
  final FocusNode _confirmPasswordFocusNode = FocusNode();
  // --- END NEW ---

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    // --- NEW: Dispose FocusNodes ---
    _nameFocusNode.dispose();
    _emailFocusNode.dispose();
    _passwordFocusNode.dispose();
    _confirmPasswordFocusNode.dispose();
    // --- END NEW ---
    super.dispose();
  }

  String? _validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Please enter a password';
    }
    if (value.length < 8) {
      return 'Password must be at least 8 characters long';
    }
    if (!RegExp(r'[A-Z]').hasMatch(value)) {
      return 'Password must contain at least one uppercase letter';
    }
    if (!RegExp(r'[a-z]').hasMatch(value)) {
      return 'Password must contain at least one lowercase letter';
    }
    if (!RegExp(r'[0-9]').hasMatch(value)) {
      return 'Password must contain at least one digit';
    }
    if (!RegExp(r'[!@#\$%^&*()_+=\-[\]{};'':"\\|,.<>\/?~`]').hasMatch(value)) {
      return 'Password must contain at least one special character';
    }
    return null;
  }

  Future<void> _signUp() async {
    // FocusScope.of(context).unfocus(); // No longer needed here
    if (_isLoading) return;

    if (!_formKey.currentState!.validate()) {
      // setState(() { _errorMessage = 'Please fix the errors above.'; }); // Optional, as fields show errors
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      await _authService.signUpWithEmailPassword(
        _nameController.text.trim(),
        _emailController.text.trim(),
        _passwordController.text,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text(
              'Sign up successful! Please check your email (including spam) to verify your account before signing in.',
              style: TextStyle(fontSize: 15),
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 8),
            behavior: SnackBarBehavior.floating,
            margin: EdgeInsets.all(10),
            padding: EdgeInsets.symmetric(horizontal: 20, vertical: 15),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10))),
          ),
        );
        widget.showSignInScreen();
      }

    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = e.toString().replaceFirst('Exception: ', '');
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);

    Widget signUpFormContent = Form(
      key: _formKey,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Text(
            'Create Your Account',
            style: TextStyle(fontSize: 26, fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 30),

          TextFormField(
            controller: _nameController,
            focusNode: _nameFocusNode, // --- NEW ---
            decoration: const InputDecoration(
              labelText: 'Full Name',
              prefixIcon: Icon(Icons.person_outline),
            ),
            keyboardType: TextInputType.name,
            textCapitalization: TextCapitalization.words,
            autovalidateMode: AutovalidateMode.onUserInteraction,
            textInputAction: TextInputAction.next, // --- NEW ---
            onFieldSubmitted: (_) { // --- NEW ---
              FocusScope.of(context).requestFocus(_emailFocusNode);
            },
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter your name';
              }
              if (value.trim().length < 2) {
                  return 'Please enter a valid name';
              }
              return null;
            },
          ),
          const SizedBox(height: 15),

          TextFormField(
            controller: _emailController,
            focusNode: _emailFocusNode, // --- NEW ---
            decoration: const InputDecoration(labelText: 'Email', prefixIcon: Icon(Icons.email_outlined)),
            keyboardType: TextInputType.emailAddress,
            autovalidateMode: AutovalidateMode.onUserInteraction,
            textInputAction: TextInputAction.next, // --- NEW ---
            onFieldSubmitted: (_) { // --- NEW ---
              FocusScope.of(context).requestFocus(_passwordFocusNode);
            },
            validator: (value) {
              if (value == null || value.trim().isEmpty) return 'Please enter your email';
              if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(value.trim())) return 'Please enter a valid email address';
              return null;
            },
          ),
          const SizedBox(height: 15),

          TextFormField(
            controller: _passwordController,
            focusNode: _passwordFocusNode, // --- NEW ---
            obscureText: _obscurePassword,
            decoration: InputDecoration(
                labelText: 'Password',
                prefixIcon: const Icon(Icons.lock_outline),
                suffixIcon: IconButton(
                  icon: Icon(
                    _obscurePassword ? Icons.visibility_off : Icons.visibility,
                    color: Colors.grey,
                  ),
                  tooltip: _obscurePassword ? 'Show password' : 'Hide password',
                  onPressed: () {
                    setState(() { _obscurePassword = !_obscurePassword; });
                  },
                ),
                helperText: 'Min 8 chars, upper, lower, digit, symbol',
                helperMaxLines: 2,
                helperStyle: TextStyle(fontSize: 11, color: Colors.grey[600]),
            ),
            autovalidateMode: AutovalidateMode.onUserInteraction,
            textInputAction: TextInputAction.next, // --- NEW ---
            onFieldSubmitted: (_) { // --- NEW ---
              FocusScope.of(context).requestFocus(_confirmPasswordFocusNode);
            },
            validator: _validatePassword,
          ),
          const SizedBox(height: 15),

            TextFormField(
            controller: _confirmPasswordController,
            focusNode: _confirmPasswordFocusNode, // --- NEW ---
            obscureText: _obscureConfirmPassword,
            decoration: InputDecoration(
                labelText: 'Confirm Password',
                prefixIcon: const Icon(Icons.lock_reset_outlined),
                suffixIcon: IconButton(
                  icon: Icon(
                    _obscureConfirmPassword ? Icons.visibility_off : Icons.visibility,
                    color: Colors.grey,
                  ),
                  tooltip: _obscureConfirmPassword ? 'Show password' : 'Hide password',
                  onPressed: () {
                    setState(() { _obscureConfirmPassword = !_obscureConfirmPassword; });
                  },
                ),
              ),
            autovalidateMode: AutovalidateMode.onUserInteraction,
            textInputAction: TextInputAction.done, // --- NEW ---
            onFieldSubmitted: (_) => _signUp(), // --- NEW ---
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Please confirm your password';
              }
              if (value != _passwordController.text) {
                  return 'Passwords do not match';
              }
              return null;
            },
          ),
          const SizedBox(height: 25),

          if (_errorMessage != null && _errorMessage!.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 15.0),
              child: Text(
                _errorMessage!,
                style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
                textAlign: TextAlign.center,
              ),
            ),

          _isLoading
              ? const Center(child: Padding(
                  padding: EdgeInsets.symmetric(vertical: 16.0),
                  child: CircularProgressIndicator(),
                ))
              : ElevatedButton(
                  onPressed: _signUp,
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 14),
                  ),
                  child: const Text('Sign Up', style: TextStyle(fontSize: 16)),
                ),
          const SizedBox(height: 20),

          Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text("Already have an account?"),
                TextButton(
                  onPressed: _isLoading ? null : widget.showSignInScreen,
                  child: const Text('Sign In'),
                ),
              ],
          ),
        ],
      ),
    );


    return Scaffold(
      body: SafeArea(
        child: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
            child: Container(
              constraints: BoxConstraints(
                maxWidth: 400,
              ),
              decoration: BoxDecoration(
                color: theme.cardColor,
                borderRadius: BorderRadius.circular(16.0),
                border: Border.all(
                  color: theme.dividerColor.withOpacity(0.5),
                  width: 1.0,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.08),
                    blurRadius: 12.0,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(15.0),
                child: SingleChildScrollView(
                  padding: const EdgeInsets.all(24.0),
                  child: signUpFormContent,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


// import 'package:flutter/material.dart';
// import 'package:firebase_auth/firebase_auth.dart'; // For PhoneAuthCredential, FirebaseAuthException
// import '../services/auth_service.dart'; // Ensure this path is correct

// // Enum to manage the different stages of the OTP and sign-up process
// enum OtpVerificationStep {
//   enterPhoneNumber, // User enters name, email, phone number
//   enterOtp,         // User enters OTP
//   phoneVerified,    // Phone is verified, user can set password and complete sign-up
// }

// class SignUpScreen extends StatefulWidget {
//   final VoidCallback showSignInScreen;

//   const SignUpScreen({super.key, required this.showSignInScreen});

//   @override
//   _SignUpScreenState createState() => _SignUpScreenState();
// }

// class _SignUpScreenState extends State<SignUpScreen> {
//   final _formKey = GlobalKey<FormState>();
//   final _nameController = TextEditingController();
//   final _emailController = TextEditingController();
//   final _passwordController = TextEditingController();
//   final _confirmPasswordController = TextEditingController();

//   // --- NEW: Phone and OTP ---
//   final _phoneController = TextEditingController();
//   final _otpController = TextEditingController();
//   // --- END NEW ---

//   final AuthService _authService = AuthService();
//   bool _isLoading = false; // General loading for the whole screen action
//   String? _errorMessage;
//   bool _obscurePassword = true;
//   bool _obscureConfirmPassword = true;

//   final FocusNode _nameFocusNode = FocusNode();
//   final FocusNode _emailFocusNode = FocusNode();
//   // --- NEW: Phone and OTP FocusNodes ---
//   final FocusNode _phoneFocusNode = FocusNode();
//   final FocusNode _otpFocusNode = FocusNode();
//   // --- END NEW ---
//   final FocusNode _passwordFocusNode = FocusNode();
//   final FocusNode _confirmPasswordFocusNode = FocusNode();

//   // --- NEW: State for OTP Flow ---
//   OtpVerificationStep _currentStep = OtpVerificationStep.enterPhoneNumber;
//   String? _verificationIdForSignUp; // Stores verification ID from AuthService
//   PhoneAuthCredential? _phoneAuthCredential; // Stores credential after OTP verification

//   bool _isSendingOtp = false;     // Specific loading state for sending OTP
//   bool _isVerifyingOtp = false;   // Specific loading state for verifying OTP
//   // --- END NEW ---

//   @override
//   void dispose() {
//     _nameController.dispose();
//     _emailController.dispose();
//     _passwordController.dispose();
//     _confirmPasswordController.dispose();
//     _phoneController.dispose(); // --- NEW ---
//     _otpController.dispose();   // --- NEW ---

//     _nameFocusNode.dispose();
//     _emailFocusNode.dispose();
//     _phoneFocusNode.dispose(); // --- NEW ---
//     _otpFocusNode.dispose();   // --- NEW ---
//     _passwordFocusNode.dispose();
//     _confirmPasswordFocusNode.dispose();
//     super.dispose();
//   }

//   void _setLoading(bool loading) {
//     if (mounted) {
//       setState(() {
//         _isLoading = loading;
//       });
//     }
//   }

//   void _setErrorMessage(String? message) {
//      if (mounted) {
//       setState(() {
//         _errorMessage = message;
//       });
//     }
//   }

//   void _showSuccessSnackbar(String message) {
//     if (mounted) {
//       ScaffoldMessenger.of(context).showSnackBar(
//         SnackBar(
//           content: Text(message, style: const TextStyle(fontSize: 15)),
//           backgroundColor: Colors.green,
//           duration: const Duration(seconds: 5),
//           behavior: SnackBarBehavior.floating,
//           margin: const EdgeInsets.all(10),
//           padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 15),
//           shape: const RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(10))),
//         ),
//       );
//     }
//   }

//   String? _validatePassword(String? value) {
//     if (value == null || value.isEmpty) {
//       return 'Please enter a password';
//     }
//     if (value.length < 8) {
//       return 'Password must be at least 8 characters long';
//     }
//     if (!RegExp(r'[A-Z]').hasMatch(value)) {
//       return 'Password must contain at least one uppercase letter';
//     }
//     // ... (rest of your password validations from original code)
//     if (!RegExp(r'[a-z]').hasMatch(value)) return 'Password must contain at least one lowercase letter';
//     if (!RegExp(r'[0-9]').hasMatch(value)) return 'Password must contain at least one digit';
//     if (!RegExp(r'[!@#\$%^&*()_+=\-[\]{};'':"\\|,.<>\/?~`]').hasMatch(value)) return 'Password must contain at least one special character';
//     return null;
//   }

//   String? _validatePhoneNumber(String? value) {
//     if (value == null || value.trim().isEmpty) {
//       return 'Please enter your phone number';
//     }
//     final pattern = r'^\+?[1-9]\d{1,14}$'; // Basic E.164-like pattern
//     final regExp = RegExp(pattern);
//     if (!regExp.hasMatch(value.trim())) {
//       return 'Enter a valid number with country code (e.g., +14155552671)';
//     }
//     return null;
//   }

//   // --- Action: Send OTP ---
//   Future<void> _handleSendOtp() async {
//     FocusScope.of(context).unfocus();
//     if (!_formKey.currentState!.validate()) { // Validates name, email, phone
//       _setErrorMessage("Please correct the errors above.");
//       return;
//     }
//     if (_isSendingOtp || _isLoading) return;

//     setState(() {
//       _isSendingOtp = true;
//       _isLoading = true; // Use general loader for now or a specific one for the button
//       _errorMessage = null;
//     });

//     try {
//       await _authService.sendOtpForSignUpProcess(
//         phoneNumber: _phoneController.text.trim(),
//         onVerificationCompleted: (PhoneAuthCredential credential) async {
//           // This callback is mainly for Android auto-retrieval.
//           if (mounted) {
//             _setErrorMessage(null); // Clear any previous error
//              _showSuccessSnackbar("Phone number auto-verified!");
//             setState(() {
//               _phoneAuthCredential = credential;
//               _otpController.text = credential.smsCode ?? ""; // Pre-fill OTP if available
//               _currentStep = OtpVerificationStep.phoneVerified; // Directly to verified
//               _isSendingOtp = false;
//               _isLoading = false;
//             });
//              _passwordFocusNode.requestFocus();
//           }
//         },
//         onVerificationFailed: (FirebaseAuthException e) {
//           if (mounted) {
//             setState(() {
//               _errorMessage = "OTP Send Failed: ${e.message}";
//               _isSendingOtp = false;
//               _isLoading = false;
//             });
//           }
//         },
//         onCodeSent: (String verificationId, int? resendToken) {
//           if (mounted) {
//              _showSuccessSnackbar("OTP sent to ${_phoneController.text.trim()}");
//             setState(() {
//               _verificationIdForSignUp = verificationId;
//               _currentStep = OtpVerificationStep.enterOtp;
//               _isSendingOtp = false;
//               _isLoading = false;
//             });
//             _otpFocusNode.requestFocus();
//           }
//         },
//         onCodeAutoRetrievalTimeout: (String verificationId) {
//           // You might want to update _verificationIdForSignUp here if it wasn't set by codeSent
//           // or inform the user. For now, we mainly rely on codeSent.
//           debugPrint("OTP auto-retrieval timed out. Verification ID: $verificationId");
//            if (mounted && _currentStep != OtpVerificationStep.enterOtp) { // If codeSent hasn't moved us already
//                _verificationIdForSignUp = verificationId;
//            }
//         },
//       );
//     } catch (e) {
//       if (mounted) {
//         setState(() {
//           _errorMessage = e.toString().replaceFirst('Exception: ', '');
//           _isSendingOtp = false;
//           _isLoading = false;
//         });
//       }
//     }
//   }

//   // --- Action: Verify OTP ---
//   Future<void> _handleVerifyOtp() async {
//     FocusScope.of(context).unfocus();
//     if (_otpController.text.trim().isEmpty || _otpController.text.trim().length != 6) {
//       _setErrorMessage("Please enter the 6-digit OTP.");
//       _otpFocusNode.requestFocus();
//       return;
//     }
//     if (_verificationIdForSignUp == null) {
//       _setErrorMessage("Verification process error. Please try sending OTP again.");
//       setState(() => _currentStep = OtpVerificationStep.enterPhoneNumber);
//       return;
//     }
//     if (_isVerifyingOtp || _isLoading) return;

//     setState(() {
//       _isVerifyingOtp = true;
//       _isLoading = true;
//       _errorMessage = null;
//     });

//     try {
//       final credential = await _authService.verifyOtpAndGetCredentialForSignUpProcess(
//         _otpController.text.trim(),
//       );
//       if (mounted) {
//         _showSuccessSnackbar("Phone number verified successfully!");
//         setState(() {
//           _phoneAuthCredential = credential;
//           _currentStep = OtpVerificationStep.phoneVerified;
//           _isVerifyingOtp = false;
//           _isLoading = false;
//         });
//         _passwordFocusNode.requestFocus();
//       }
//     } catch (e) {
//       if (mounted) {
//         setState(() {
//           _errorMessage = e.toString().replaceFirst('Exception: ', '');
//           _isVerifyingOtp = false;
//           _isLoading = false;
//         });
//         if (e.toString().contains("session-expired") || e.toString().contains("invalid-verification-id")){
//           setState(() {
//             _currentStep = OtpVerificationStep.enterPhoneNumber;
//              _verificationIdForSignUp = null; // Reset for resend
//           });
//         }
//       }
//     }
//   }


//   // --- Action: Complete Sign Up (after phone is verified) ---
//   Future<void> _completeSignUp() async {
//     FocusScope.of(context).unfocus();
//     if (_isLoading) return;

//     if (_currentStep != OtpVerificationStep.phoneVerified || _phoneAuthCredential == null) {
//       _setErrorMessage("Please verify your phone number first.");
//       // Guide user back if they somehow bypassed UI flow
//       if(_currentStep == OtpVerificationStep.enterPhoneNumber) _phoneFocusNode.requestFocus();
//       else if (_currentStep == OtpVerificationStep.enterOtp) _otpFocusNode.requestFocus();
//       return;
//     }

//     // Validate all fields now (name, email, phone should be valid, now password too)
//     if (!_formKey.currentState!.validate()) {
//       _setErrorMessage('Please fix the errors above.');
//       return;
//     }

//     _setLoading(true);
//     _setErrorMessage(null);

//     try {
//       // 1. Create email/password user
//       final newUser = await _authService.signUpWithEmailPassword(
//         _nameController.text.trim(),
//         _emailController.text.trim(),
//         _passwordController.text,
//         phoneNumberForRecord: _phoneController.text.trim(),
//       );

//       if (newUser == null) {
//         throw Exception("User account creation failed. Please try again.");
//       }

//       // 2. Link the verified phone credential to the newly created user
//       await _authService.linkOrUpdatePhoneForCurrentUser(_phoneAuthCredential!);

//       if (mounted) {
//          _showSuccessSnackbar('Sign up successful! Phone linked. Please check your email to verify your account.');
//         widget.showSignInScreen();
//       }

//     } catch (e) {
//       if (mounted) {
//         _setErrorMessage(e.toString().replaceFirst('Exception: ', ''));
//         // If email/password user was created but phone linking failed
//         if (_authService.getCurrentUser() != null && e.toString().contains("link")) {
//           debugPrint("SignUp Error: User created, but phone linking failed. Signing out user.");
//           await _authService.signOut(); // Sign out partially created user
//           _setErrorMessage("Account partly created, but phone linking failed. User signed out. Please try again. Error: ${e.toString().replaceFirst('Exception: ', '')}");
//           setState(() { // Reset phone verification state to allow retry
//             _phoneAuthCredential = null;
//             _currentStep = OtpVerificationStep.enterPhoneNumber; // Or keep them at phoneVerified to retry linking without re-entering details? For now, full reset.
//           });
//         }
//       }
//     } finally {
//       _setLoading(false);
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     final ThemeData theme = Theme.of(context);

//     Widget formActionButton;
//     String actionButtonText = "";

//     if (_currentStep == OtpVerificationStep.enterPhoneNumber) {
//       actionButtonText = 'Send OTP';
//       formActionButton = ElevatedButton(
//         onPressed: _isLoading || _isSendingOtp ? null : _handleSendOtp,
//         style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 14)),
//         child: _isSendingOtp ? const SizedBox(height: 18, width: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white)) : Text(actionButtonText, style: const TextStyle(fontSize: 16)),
//       );
//     } else if (_currentStep == OtpVerificationStep.enterOtp) {
//       actionButtonText = 'Verify OTP';
//       formActionButton = ElevatedButton(
//         onPressed: _isLoading || _isVerifyingOtp ? null : _handleVerifyOtp,
//         style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 14)),
//         child: _isVerifyingOtp ? const SizedBox(height: 18, width: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white)) : Text(actionButtonText, style: const TextStyle(fontSize: 16)),
//       );
//     } else { // OtpVerificationStep.phoneVerified
//       actionButtonText = 'Sign Up';
//       formActionButton = ElevatedButton(
//         onPressed: _isLoading ? null : _completeSignUp,
//         style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 14)),
//         child: _isLoading ? const SizedBox(height: 18, width: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white)) : Text(actionButtonText, style: const TextStyle(fontSize: 16)),
//       );
//     }


//     Widget signUpFormContent = Form(
//       key: _formKey,
//       child: Column(
//         mainAxisAlignment: MainAxisAlignment.center,
//         mainAxisSize: MainAxisSize.min,
//         crossAxisAlignment: CrossAxisAlignment.stretch,
//         children: [
//           const Text(
//             'Create Your Account',
//             style: TextStyle(fontSize: 26, fontWeight: FontWeight.bold),
//             textAlign: TextAlign.center,
//           ),
//           const SizedBox(height: 30),

//           // --- Name Field ---
//           TextFormField(
//             controller: _nameController,
//             focusNode: _nameFocusNode,
//             decoration: const InputDecoration(labelText: 'Full Name', prefixIcon: Icon(Icons.person_outline)),
//             keyboardType: TextInputType.name,
//             textCapitalization: TextCapitalization.words,
//             autovalidateMode: AutovalidateMode.onUserInteraction,
//             textInputAction: TextInputAction.next,
//             onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_emailFocusNode),
//             validator: (value) {
//               if (value == null || value.trim().isEmpty) return 'Please enter your name';
//               if (value.trim().length < 2) return 'Please enter a valid name';
//               return null;
//             },
//             enabled: _currentStep == OtpVerificationStep.enterPhoneNumber, // Disable if past this step for now
//           ),
//           const SizedBox(height: 15),

//           // --- Email Field ---
//           TextFormField(
//             controller: _emailController,
//             focusNode: _emailFocusNode,
//             decoration: const InputDecoration(labelText: 'Email', prefixIcon: Icon(Icons.email_outlined)),
//             keyboardType: TextInputType.emailAddress,
//             autovalidateMode: AutovalidateMode.onUserInteraction,
//             textInputAction: TextInputAction.next,
//             onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_phoneFocusNode),
//             validator: (value) {
//               if (value == null || value.trim().isEmpty) return 'Please enter your email';
//               if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(value.trim())) return 'Please enter a valid email address';
//               return null;
//             },
//              enabled: _currentStep == OtpVerificationStep.enterPhoneNumber,
//           ),
//           const SizedBox(height: 15),

//           // --- Phone Number Field ---
//           TextFormField(
//             controller: _phoneController,
//             focusNode: _phoneFocusNode,
//             decoration: const InputDecoration(labelText: 'Phone Number (e.g. +1415... )', prefixIcon: Icon(Icons.phone_outlined)),
//             keyboardType: TextInputType.phone,
//             autovalidateMode: AutovalidateMode.onUserInteraction,
//             textInputAction: _currentStep == OtpVerificationStep.enterPhoneNumber ? TextInputAction.done : TextInputAction.next,
//             onFieldSubmitted: (_) {
//                 if (_currentStep == OtpVerificationStep.enterPhoneNumber && !_isSendingOtp) {
//                    _handleSendOtp();
//                 } else if (_currentStep == OtpVerificationStep.phoneVerified) {
//                   FocusScope.of(context).requestFocus(_passwordFocusNode);
//                 }
//             },
//             validator: _validatePhoneNumber,
//             enabled: _currentStep == OtpVerificationStep.enterPhoneNumber, // Only editable at the start
//           ),
//           const SizedBox(height: 15),

//           // --- OTP Field (Conditional) ---
//           if (_currentStep == OtpVerificationStep.enterOtp) ...[
//             TextFormField(
//               controller: _otpController,
//               focusNode: _otpFocusNode,
//               decoration: const InputDecoration(labelText: 'OTP', prefixIcon: Icon(Icons.shield_outlined)),
//               keyboardType: TextInputType.number,
//               maxLength: 6,
//               autovalidateMode: AutovalidateMode.onUserInteraction,
//               textInputAction: TextInputAction.done,
//               onFieldSubmitted: (_) => _handleVerifyOtp(),
//               validator: (value) {
//                 if (value == null || value.trim().isEmpty) return 'Please enter OTP';
//                 if (value.trim().length != 6) return 'OTP must be 6 digits';
//                 return null;
//               },
//             ),
//             Row(
//               mainAxisAlignment: MainAxisAlignment.end,
//               children: [
//                 TextButton(
//                   onPressed: (_isLoading || _isSendingOtp) ? null : (){
//                     // Resend OTP logic - basically go back to phone step if user wants to change, or directly call send if phone number is same
//                     _setErrorMessage(null); // Clear previous error
//                     setState(() => _currentStep = OtpVerificationStep.enterPhoneNumber);
//                     _phoneFocusNode.requestFocus(); // Let them re-confirm phone then send
//                   },
//                   child: const Text('Change Phone / Resend OTP?'),
//                 ),
//               ],
//             ),
//             const SizedBox(height: 15),
//           ],

//           // --- Phone Verified Indicator (Conditional) ---
//           if (_currentStep == OtpVerificationStep.phoneVerified) ...[
//             Padding(
//               padding: const EdgeInsets.symmetric(vertical: 8.0),
//               child: Row(
//                 mainAxisAlignment: MainAxisAlignment.center,
//                 children: [
//                   const Icon(Icons.check_circle, color: Colors.green, size: 20),
//                   const SizedBox(width: 8),
//                   Text("Phone Verified: ${_phoneController.text}", style: const TextStyle(color: Colors.green)),
//                   TextButton(onPressed: (){
//                     setState(() {
//                       _currentStep = OtpVerificationStep.enterPhoneNumber;
//                       _phoneAuthCredential = null;
//                       _otpController.clear();
//                        _verificationIdForSignUp = null;
//                       _errorMessage = null;
//                       _passwordController.clear(); // Clear password if they go back
//                       _confirmPasswordController.clear();
//                     });
//                   }, child: const Text("(Change)"))
//                 ],
//               ),
//             ),
//              const SizedBox(height: 10),
//           ],


//           // --- Password Fields (Conditional - Show after phone verification) ---
//           if (_currentStep == OtpVerificationStep.phoneVerified) ...[
//             TextFormField(
//               controller: _passwordController,
//               focusNode: _passwordFocusNode,
//               obscureText: _obscurePassword,
//               decoration: InputDecoration(
//                   labelText: 'Password',
//                   prefixIcon: const Icon(Icons.lock_outline),
//                   suffixIcon: IconButton(
//                     icon: Icon(_obscurePassword ? Icons.visibility_off : Icons.visibility, color: Colors.grey),
//                     onPressed: () => setState(() => _obscurePassword = !_obscurePassword),
//                   ),
//                   helperText: 'Min 8 chars, upper, lower, digit, symbol',
//                   helperMaxLines: 2,
//                   helperStyle: TextStyle(fontSize: 11, color: Colors.grey[600]),
//               ),
//               autovalidateMode: AutovalidateMode.onUserInteraction,
//               textInputAction: TextInputAction.next,
//               onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_confirmPasswordFocusNode),
//               validator: _validatePassword,
//             ),
//             const SizedBox(height: 15),
//             TextFormField(
//               controller: _confirmPasswordController,
//               focusNode: _confirmPasswordFocusNode,
//               obscureText: _obscureConfirmPassword,
//               decoration: InputDecoration(
//                   labelText: 'Confirm Password',
//                   prefixIcon: const Icon(Icons.lock_reset_outlined),
//                   suffixIcon: IconButton(
//                     icon: Icon(_obscureConfirmPassword ? Icons.visibility_off : Icons.visibility, color: Colors.grey),
//                     onPressed: () => setState(() => _obscureConfirmPassword = !_obscureConfirmPassword),
//                   ),
//                 ),
//               autovalidateMode: AutovalidateMode.onUserInteraction,
//               textInputAction: TextInputAction.done,
//               onFieldSubmitted: (_) => _completeSignUp(),
//               validator: (value) {
//                 if (value == null || value.isEmpty) return 'Please confirm your password';
//                 if (value != _passwordController.text) return 'Passwords do not match';
//                 return null;
//               },
//             ),
//           ],
//           const SizedBox(height: 25),

//           // --- Error Message Display ---
//           if (_errorMessage != null && _errorMessage!.isNotEmpty)
//             Padding(
//               padding: const EdgeInsets.only(bottom: 15.0),
//               child: Text(
//                 _errorMessage!,
//                 style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
//                 textAlign: TextAlign.center,
//               ),
//             ),

//           // --- Dynamic Action Button ---
//           formActionButton,
//           const SizedBox(height: 20),

//           // --- Switch to Sign In ---
//           Row(
//               mainAxisAlignment: MainAxisAlignment.center,
//               children: [
//                 const Text("Already have an account?"),
//                 TextButton(
//                   onPressed: _isLoading ? null : widget.showSignInScreen,
//                   child: const Text('Sign In'),
//                 ),
//               ],
//           ),
//         ],
//       ),
//     );

//     return Scaffold(
//       body: SafeArea(
//         child: Center(
//           child: Padding(
//             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
//             child: Container(
//               constraints: const BoxConstraints(maxWidth: 400),
//               decoration: BoxDecoration(
//                 color: theme.cardColor,
//                 borderRadius: BorderRadius.circular(16.0),
//                 border: Border.all(color: theme.dividerColor.withOpacity(0.5), width: 1.0),
//                 boxShadow: [
//                   BoxShadow(
//                     color: Colors.black.withOpacity(0.08),
//                     blurRadius: 12.0,
//                     offset: const Offset(0, 4),
//                   ),
//                 ],
//               ),
//               child: ClipRRect(
//                 borderRadius: BorderRadius.circular(15.0),
//                 child: SingleChildScrollView(
//                   padding: const EdgeInsets.all(24.0),
//                   child: signUpFormContent,
//                 ),
//               ),
//             ),
//           ),
//         ),
//       ),
//     );
//   }
// }


===== features\auth\services\auth_service.dart =====

import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn();

  static const String _usersCollection = 'mm_users';

  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

  User? getCurrentUser() {
    return _firebaseAuth.currentUser;
  }

  Future<void> signUpWithEmailPassword(
      String name, String email, String password) async {
    try {
      UserCredential userCredential =
          await _firebaseAuth.createUserWithEmailAndPassword(
        email: email.trim(),
        password: password.trim(),
      );

      User? user = userCredential.user;
      if (user != null) {
        await user.sendEmailVerification();
        await _saveUserDataToFirestore(user, name: name, isNewUser: true);
        await _firebaseAuth.signOut();
      } else {
        throw Exception('User registration failed, user object is null.');
      }
    } on FirebaseAuthException catch (e) {
      String message = _handleAuthException(e, isSignUp: true);
      throw Exception(message);
    } catch (e) {
      debugPrint('General Exception (Sign Up): $e');
      throw Exception('An unknown error occurred during sign up.');
    }
  }

  Future<UserCredential?> signInWithEmailPassword(
      String email, String password) async {
    try {
      UserCredential userCredential =
          await _firebaseAuth.signInWithEmailAndPassword(
        email: email.trim(),
        password: password.trim(),
      );

      User? user = userCredential.user;
      if (user != null && !user.emailVerified) {
        await _firebaseAuth.signOut();
        throw Exception(
            'Please verify your email address before signing in. Check your inbox (and spam folder).');
      }
      return userCredential;
    } on FirebaseAuthException catch (e) {
      String message = _handleAuthException(e, isSignUp: false);
      throw Exception(message);
    } catch (e) {
      debugPrint('General Exception (Sign In): $e');
      if (e is Exception && e.toString().contains('verify your email')) {
        rethrow;
      }
      throw Exception('An unknown error occurred during sign in.');
    }
  }

  Future<void> sendPasswordResetEmail(String email) async {
    try {
      await _firebaseAuth.sendPasswordResetEmail(email: email.trim());
    } on FirebaseAuthException catch (e) {
      String message;
      switch (e.code) {
        case 'user-not-found':
          message = 'No user found for that email.';
          break;
        case 'invalid-email':
          message = 'The email address is not valid.';
          break;
        default:
          message = 'Failed to send password reset email. Please try again.';
          debugPrint(
              'Firebase Auth Exception (Password Reset): ${e.code} - ${e.message}');
      }
      throw Exception(message);
    } catch (e) {
      debugPrint('General Exception (Password Reset): $e');
      throw Exception('An unknown error occurred.');
    }
  }

  Future<UserCredential?> signInWithGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();

      if (googleUser == null) {
        return null;
      }

      final GoogleSignInAuthentication googleAuth =
          await googleUser.authentication;

      final OAuthCredential credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      UserCredential userCredential =
          await _firebaseAuth.signInWithCredential(credential);
      User? user = userCredential.user;

      if (user != null) {
        final userDocRef =
            _firestore.collection(_usersCollection).doc(user.uid);
        final userDoc = await userDocRef.get();
        if (!userDoc.exists) {
          await _saveUserDataToFirestore(user,
              name: googleUser.displayName, isNewUser: true);
        }
      }

      return userCredential;
    } on FirebaseAuthException catch (e) {
      String message = _handleAuthException(e, isSignUp: false);
      if (e.code == 'account-exists-with-different-credential') {
        message =
            'An account already exists with this email. Try signing in with your original method (e.g., Email/Password).';
      }
      throw Exception(message);
    } catch (e) {
      debugPrint('Google Sign In Error: $e');
      if (e.toString().contains('network_error')) {
        throw Exception(
            'Network error. Please check your connection and try again.');
      }
      if (e.toString().contains('sign_in_canceled')) {
        return null;
      }
      throw Exception(
          'An error occurred during Google Sign-In. Please try again.');
    }
  }

  Future<void> signOut() async {
    try {
      if (await _googleSignIn.isSignedIn()) {
        await _googleSignIn.signOut();
        debugPrint("Google user signed out.");
      }
      await _firebaseAuth.signOut();
      debugPrint("Firebase user signed out.");
    } catch (e) {
      debugPrint('Error signing out: $e');
    }
  }

  Future<void> _saveUserDataToFirestore(User user,
      {String? name, bool isNewUser = false}) async {
    try {
      final docRef = _firestore.collection(_usersCollection).doc(user.uid);
      final Map<String, dynamic> userData = {
        'uid': user.uid,
        'email': user.email,
        'name': name?.trim() ??
            user.displayName?.trim() ??
            _extractNameFromEmail(user.email) ??
            'User',
        if (isNewUser) 'createdAt': FieldValue.serverTimestamp(),
        'emailVerified': user.emailVerified,
        if (isNewUser) 'favoriteVenueIds': [],
        if (isNewUser) 'profilePictureUrl': null,
        if (isNewUser) 'phoneNumber': null,
      };

      if (isNewUser) {
        await docRef.set(userData);
      } else {
        await docRef.set(userData, SetOptions(merge: !isNewUser));
      }
    } catch (e) {
      debugPrint('Error saving user data to Firestore for UID ${user.uid}: $e');
    }
  }

  Stream<Map<String, dynamic>?> getUserProfileStream() {
    final String? uid = getCurrentUser()?.uid;
    if (uid == null) {
      return Stream.value(null);
    }
    try {
      return _firestore
          .collection(_usersCollection)
          .doc(uid)
          .snapshots()
          .map((snapshot) {
        if (snapshot.exists) {
          return snapshot.data();
        } else {
          return null;
        }
      }).handleError((error) {
        debugPrint('Error in user profile stream for UID $uid: $error');
        return null;
      });
    } catch (e) {
      debugPrint('Error creating user profile stream for UID $uid: $e');
      return Stream.value(null);
    }
  }

  Future<Map<String, dynamic>?> getUserProfileData() async {
    final String? uid = getCurrentUser()?.uid;
    if (uid == null) return null;
    try {
      DocumentSnapshot doc =
          await _firestore.collection(_usersCollection).doc(uid).get();
      if (doc.exists) {
        return doc.data() as Map<String, dynamic>?;
      }
      return null;
    } catch (e) {
      debugPrint('Error fetching user profile data for UID $uid: $e');
      throw Exception("Could not load profile data.");
    }
  }

  Future<Map<String, dynamic>?> getUserData(String uid) async {
    if (uid.isEmpty) return null;
    try {
      DocumentSnapshot doc =
          await _firestore.collection(_usersCollection).doc(uid).get();
      if (doc.exists) {
        return doc.data() as Map<String, dynamic>?;
      }
      return null;
    } catch (e) {
      debugPrint('Error fetching user data for UID $uid: $e');
      return null;
    }
  }

  Future<void> updateUserName(String name) async {
    final user = getCurrentUser();
    if (user == null) {
      throw Exception("User not logged in. Please sign in again.");
    }
    final String trimmedName = name.trim();
    if (trimmedName.isEmpty || trimmedName.length < 2) {
      throw Exception("Please enter a valid name (at least 2 characters).");
    }
    try {
      final docRef = _firestore.collection(_usersCollection).doc(user.uid);
      await docRef.update(
          {'name': trimmedName, 'updatedAt': FieldValue.serverTimestamp()});
    } catch (e) {
      debugPrint('Error updating user name for UID ${user.uid}: $e');
      throw Exception(
          "Failed to update name. Please check your connection and try again.");
    }
  }

  String? _extractNameFromEmail(String? email) {
    if (email == null || !email.contains('@')) return null;
    String namePart = email.split('@')[0];
    namePart = namePart.replaceAll(RegExp(r'[._-]'), ' ').trim();
    if (namePart.isEmpty) return null;
    return namePart
        .split(' ')
        .map((word) {
          if (word.isEmpty) return '';
          return '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}';
        })
        .join(' ')
        .trim();
  }

  String _handleAuthException(FirebaseAuthException e,
      {required bool isSignUp}) {
    String message;
    debugPrint(
        'Firebase Auth Exception (${isSignUp ? "Sign Up" : "Sign In/Other"}): ${e.code} - ${e.message}');
    switch (e.code) {
      case 'weak-password':
        message = 'The password provided is too weak.';
        break;
      case 'email-already-in-use':
        message =
            'An account already exists for that email. Please Sign In or use Forgot Password.';
        break;
      case 'invalid-email':
        message = 'The email address format is not valid.';
        break;
      case 'user-not-found':
        message =
            'No user found with this email. Please check the email or Sign Up.';
        break;
      case 'wrong-password':
        message =
            'Incorrect password. Please try again or use Forgot Password.';
        break;
      case 'user-disabled':
        message =
            'This user account has been disabled. Please contact support.';
        break;
      case 'account-exists-with-different-credential':
        message =
            'An account already exists with this email. Try signing in with your original method (e.g., Google or Email/Password).';
        break;
      case 'operation-not-allowed':
        message = 'Sign-in method not enabled. Please contact support.';
        break;
      case 'invalid-credential':
        message = 'The credentials provided are invalid.';
        break;
      case 'too-many-requests':
        message =
            'Too many attempts. Please wait a bit and try again or use Forgot Password.';
        break;
      case 'requires-recent-login':
        message =
            'This action requires you to recently sign in again for security.';
        break;
      case 'network-request-failed':
        message = 'Network error. Please check your connection and try again.';
        break;
      default:
        message = 'An unexpected error occurred. Please try again.';
    }
    return message;
  }

  Future<bool> reauthenticateWithPassword(String password) async {
    final user = getCurrentUser();
    if (user == null || user.email == null) {
      throw Exception("User not logged in or email missing.");
    }
    try {
      final AuthCredential credential = EmailAuthProvider.credential(
        email: user.email!,
        password: password,
      );
      await user.reauthenticateWithCredential(credential);
      return true; // Re-authentication successful
    } on FirebaseAuthException catch (e) {
      debugPrint("Re-authentication error: ${e.code}");
      // Handle specific errors like wrong-password if needed
      throw Exception("Re-authentication failed. Please check your password.");
    } catch (e) {
      debugPrint("Generic Re-authentication error: $e");
      throw Exception("An error occurred during re-authentication.");
    }
  }

  Future<void> updateUserEmailAndSendVerification(String newEmail) async {
    final user = getCurrentUser();
    if (user == null) throw Exception("User not logged in.");

    try {
      await user.updateEmail(newEmail.trim());
      // If successful, send verification to the NEW email
      await user.sendEmailVerification();
      // IMPORTANT: Firestore update happens separately in UserService AFTER this succeeds
    } on FirebaseAuthException catch (e) {
      String message = "Failed to update email.";
      if (e.code == 'email-already-in-use') {
        message = 'This email address is already in use by another account.';
      } else if (e.code == 'invalid-email') {
        message = 'The new email address is not valid.';
      } else if (e.code == 'requires-recent-login') {
        message =
            'This action requires you to have signed in recently. Please try again.';
        // You might want to trigger the re-auth flow from the calling UI here
      }
      debugPrint("Update email error: ${e.code}");
      throw Exception(message);
    } catch (e) {
      debugPrint("Generic Update email error: $e");
      throw Exception("An unknown error occurred while updating email.");
    }
  }

  Future<void> verifyPhoneNumberStart({
    required String phoneNumber,
    required Function(FirebaseAuthException) onVerificationFailed,
    required Function(String verificationId, int? resendToken) onCodeSent,
    required Function(PhoneAuthCredential credential) onVerificationCompleted,
    required Duration timeout,
    int? forceResendingToken, // Pass this for resending OTP
  }) async {
    final user = getCurrentUser();
    if (user == null) throw Exception("User not logged in.");

    await _firebaseAuth.verifyPhoneNumber(
      phoneNumber: phoneNumber, // Must be in E.164 format (e.g., +16505551234)
      verificationCompleted:
          onVerificationCompleted, // For Android instant verification
      verificationFailed: onVerificationFailed, // Handle errors
      codeSent: onCodeSent, // Store verificationId and prompt user
      codeAutoRetrievalTimeout: (String verificationId) {
        // Called when auto-retrieval times out.
        // You might just ignore this or use the verificationId provided
        debugPrint(
            "Phone auth code auto retrieval timeout. Verification ID: $verificationId");
      },
      timeout: timeout,
      forceResendingToken: forceResendingToken, // Use for resending
    );
  }

  Future<PhoneAuthCredential> createPhoneCredential(
      String verificationId, String smsCode) async {
    return PhoneAuthProvider.credential(
      verificationId: verificationId,
      smsCode: smsCode.trim(),
    );
  }

  // Use this after user enters OTP to link/verify the number with the logged-in user
  Future<void> confirmPhoneNumberUpdate(PhoneAuthCredential credential) async {
    final user = getCurrentUser();
    if (user == null) throw Exception("User not logged in.");
    try {
      await user.updatePhoneNumber(credential);
      // Firestore update happens separately in UserService after this succeeds
    } on FirebaseAuthException catch (e) {
      debugPrint("Confirm Phone Number Error: ${e.code}");
      String message = "Failed to verify phone number.";
      if (e.code == 'invalid-verification-code') {
        message = "The verification code is invalid.";
      } else if (e.code == 'session-expired') {
        message =
            "The verification session has expired. Please request a new code.";
      } else if (e.code == 'credential-already-in-use') {
        message = "This phone number is already linked to another account.";
      }
      throw Exception(message);
    } catch (e) {
      debugPrint("Generic Confirm Phone Number Error: $e");
      throw Exception("An unknown error occurred during phone verification.");
    }
  }
}


// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:google_sign_in/google_sign_in.dart';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart'; // For debugPrint, kept for consistency

// class AuthService {
//   final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
//   final FirebaseFirestore _firestore = FirebaseFirestore.instance;
//   final GoogleSignIn _googleSignIn = GoogleSignIn();

//   static const String _usersCollection = 'mm_users';

//   // --- NEW: For OTP Sign-Up Flow ---
//   String? _signUpVerificationId; // To store verification ID for the sign-up OTP process
//   // --- END NEW ---

//   Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

//   User? getCurrentUser() {
//     return _firebaseAuth.currentUser;
//   }

//   // MODIFIED:
//   // 1. Returns User? to allow access to the created user for phone linking.
//   // 2. Removed `await _firebaseAuth.signOut();` to keep the user logged in for immediate phone linking.
//   // 3. Added optional `phoneNumberForRecord` to store phone number from input during Firestore save.
//   Future<User?> signUpWithEmailPassword(
//       String name, String email, String password, {String? phoneNumberForRecord}) async {
//     try {
//       UserCredential userCredential =
//           await _firebaseAuth.createUserWithEmailAndPassword(
//         email: email.trim(),
//         password: password.trim(),
//       );

//       User? user = userCredential.user;
//       if (user != null) {
//         await user.sendEmailVerification();
//         await _saveUserDataToFirestore(user, name: name, phoneNumberIfKnown: phoneNumberForRecord, isNewUser: true);
//         // User remains logged in for subsequent actions like phone linking.
//         // Sign out should be handled by the UI after all steps are complete or on error.
//         return user;
//       } else {
//         throw Exception('User registration failed, user object is null.');
//       }
//     } on FirebaseAuthException catch (e) {
//       String message = _handleAuthException(e, isSignUp: true);
//       throw Exception(message);
//     } catch (e) {
//       debugPrint('General Exception (Sign Up): $e');
//       throw Exception('An unknown error occurred during sign up.');
//     }
//   }

//   Future<UserCredential?> signInWithEmailPassword(
//       String email, String password) async {
//     try {
//       UserCredential userCredential =
//           await _firebaseAuth.signInWithEmailAndPassword(
//         email: email.trim(),
//         password: password.trim(),
//       );

//       User? user = userCredential.user;
//       if (user != null && !user.emailVerified) {
//         // Optionally, if you ALWAYS require email verification before ANY access after sign-in:
//         // await _firebaseAuth.signOut();
//         // throw Exception(
//         // 'Please verify your email address before signing in. Check your inbox (and spam folder). Resent verification.');
//         // await user.sendEmailVerification(); // Optionally resend if not verified

//         // If you allow them in but show a banner, then don't sign out.
//         // The current implementation is strict.
//         await _firebaseAuth.signOut(); // Kept original behavior
//         throw Exception(
//             'Please verify your email address before signing in. Check your inbox (and spam folder).');
//       }
//       // If user is email verified, proceed to update Firestore data if needed (e.g. lastLogin)
//       if (user != null) {
//         await _saveUserDataToFirestore(user, isNewUser: false); // Save last login or other updates
//       }
//       return userCredential;
//     } on FirebaseAuthException catch (e) {
//       String message = _handleAuthException(e, isSignUp: false);
//       throw Exception(message);
//     } catch (e) {
//       debugPrint('General Exception (Sign In): $e');
//       if (e is Exception && e.toString().contains('verify your email')) {
//         rethrow;
//       }
//       throw Exception('An unknown error occurred during sign in.');
//     }
//   }

//   Future<void> sendPasswordResetEmail(String email) async {
//     try {
//       await _firebaseAuth.sendPasswordResetEmail(email: email.trim());
//     } on FirebaseAuthException catch (e) {
//       String message;
//       switch (e.code) {
//         case 'user-not-found':
//           message = 'No user found for that email.';
//           break;
//         case 'invalid-email':
//           message = 'The email address is not valid.';
//           break;
//         default:
//           message = 'Failed to send password reset email. Please try again.';
//           debugPrint(
//               'Firebase Auth Exception (Password Reset): ${e.code} - ${e.message}');
//       }
//       throw Exception(message);
//     } catch (e) {
//       debugPrint('General Exception (Password Reset): $e');
//       throw Exception('An unknown error occurred.');
//     }
//   }

//   Future<UserCredential?> signInWithGoogle() async {
//     try {
//       final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();

//       if (googleUser == null) {
//         return null; // User cancelled Google Sign-In
//       }

//       final GoogleSignInAuthentication googleAuth =
//           await googleUser.authentication;

//       final OAuthCredential credential = GoogleAuthProvider.credential(
//         accessToken: googleAuth.accessToken,
//         idToken: googleAuth.idToken,
//       );

//       UserCredential userCredential =
//           await _firebaseAuth.signInWithCredential(credential);
//       User? user = userCredential.user;

//       if (user != null) {
//         final userDocRef =
//             _firestore.collection(_usersCollection).doc(user.uid);
//         final userDoc = await userDocRef.get();
//         await _saveUserDataToFirestore(user,
//               name: googleUser.displayName, isNewUser: !userDoc.exists);
//       }

//       return userCredential;
//     } on FirebaseAuthException catch (e) {
//       String message = _handleAuthException(e, isSignUp: false);
//       if (e.code == 'account-exists-with-different-credential') {
//         message =
//             'An account already exists with this email. Try signing in with your original method (e.g., Email/Password).';
//       }
//       throw Exception(message);
//     } catch (e) {
//       debugPrint('Google Sign In Error: $e');
//       if (e.toString().contains('network_error')) {
//         throw Exception(
//             'Network error. Please check your connection and try again.');
//       }
//       if (e.toString().contains('sign_in_canceled') || e.toString().contains('popup_closed_by_user')) { // Common on web
//         return null;
//       }
//       throw Exception(
//           'An error occurred during Google Sign-In. Please try again.');
//     }
//   }

//   Future<void> signOut() async {
//     try {
//       if (await _googleSignIn.isSignedIn()) {
//         await _googleSignIn.signOut();
//         debugPrint("Google user signed out.");
//       }
//       await _firebaseAuth.signOut();
//       debugPrint("Firebase user signed out.");
//     } catch (e) {
//       debugPrint('Error signing out: $e');
//       // Potentially rethrow or handle differently
//     }
//   }

//   // MODIFIED:
//   // 1. Added `phoneNumberIfKnown` to store phone from input fields during initial save.
//   // 2. Ensures `user.phoneNumber` (from Firebase Auth after linking) takes precedence.
//   // 3. `profilePictureUrl` also tries to get `user.photoURL` (e.g. from Google).
//   // 4. Added `updatedAt` for non-new user updates.
//   Future<void> _saveUserDataToFirestore(User user,
//       {String? name, String? phoneNumberIfKnown, bool isNewUser = false}) async {
//     try {
//       final docRef = _firestore.collection(_usersCollection).doc(user.uid);
//       final Map<String, dynamic> userData = {
//         'uid': user.uid,
//         'email': user.email,
//         'name': name?.trim() ??
//             user.displayName?.trim() ??
//             _extractNameFromEmail(user.email) ??
//             'User',
//         'emailVerified': user.emailVerified,
//         // Prioritize actual linked phone number, fallback to provided one or null
//         'phoneNumber': user.phoneNumber ?? phoneNumberIfKnown,
//         'profilePictureUrl': user.photoURL, // Can be null if not available
//       };

//       if (isNewUser) {
//         userData['createdAt'] = FieldValue.serverTimestamp();
//         userData['favoriteVenueIds'] = []; // Default for new users
//         // If profilePictureUrl from user.photoURL is null, keep whatever was in Firestore or default
//         if(userData['profilePictureUrl'] == null && (await docRef.get()).exists) {
//             userData['profilePictureUrl'] = (await docRef.get()).data()?['profilePictureUrl'];
//         }
//         await docRef.set(userData);
//       } else {
//         // For updates, explicitly include updatedAt if merging other fields
//         userData['updatedAt'] = FieldValue.serverTimestamp();
//         await docRef.set(userData, SetOptions(merge: true)); // Use merge:true for updates
//       }
//     } catch (e) {
//       debugPrint('Error saving user data to Firestore for UID ${user.uid}: $e');
//       // Rethrow or handle error appropriately
//     }
//   }

//   Stream<Map<String, dynamic>?> getUserProfileStream() {
//     final String? uid = getCurrentUser()?.uid;
//     if (uid == null) {
//       return Stream.value(null);
//     }
//     try {
//       return _firestore
//           .collection(_usersCollection)
//           .doc(uid)
//           .snapshots()
//           .map((snapshot) {
//         if (snapshot.exists) {
//           return snapshot.data();
//         } else {
//           // If doc doesn't exist but user is authenticated, could create it here.
//           // For now, returning null if no doc.
//           return null;
//         }
//       }).handleError((error) {
//         debugPrint('Error in user profile stream for UID $uid: $error');
//         return null; // Emit null on error to keep stream alive if desired
//       });
//     } catch (e) {
//       debugPrint('Error creating user profile stream for UID $uid: $e');
//       return Stream.value(null);
//     }
//   }

//   Future<Map<String, dynamic>?> getUserProfileData() async {
//     final String? uid = getCurrentUser()?.uid;
//     if (uid == null) return null;
//     try {
//       DocumentSnapshot doc =
//           await _firestore.collection(_usersCollection).doc(uid).get();
//       if (doc.exists) {
//         return doc.data() as Map<String, dynamic>?;
//       }
//       return null;
//     } catch (e) {
//       debugPrint('Error fetching user profile data for UID $uid: $e');
//       throw Exception("Could not load profile data.");
//     }
//   }

//   Future<Map<String, dynamic>?> getUserData(String uid) async {
//     if (uid.isEmpty) return null;
//     try {
//       DocumentSnapshot doc =
//           await _firestore.collection(_usersCollection).doc(uid).get();
//       if (doc.exists) {
//         return doc.data() as Map<String, dynamic>?;
//       }
//       return null;
//     } catch (e) {
//       debugPrint('Error fetching user data for UID $uid: $e');
//       return null; // Or throw exception
//     }
//   }

//   Future<void> updateUserName(String name) async {
//     final user = getCurrentUser();
//     if (user == null) {
//       throw Exception("User not logged in. Please sign in again.");
//     }
//     final String trimmedName = name.trim();
//     if (trimmedName.isEmpty || trimmedName.length < 2) {
//       throw Exception("Please enter a valid name (at least 2 characters).");
//     }
//     try {
//       // Update Firebase Auth display name
//       await user.updateDisplayName(trimmedName);
//       // Update Firestore
//       final docRef = _firestore.collection(_usersCollection).doc(user.uid);
//       await docRef.update(
//           {'name': trimmedName, 'updatedAt': FieldValue.serverTimestamp()});
//     } catch (e) {
//       debugPrint('Error updating user name for UID ${user.uid}: $e');
//       throw Exception(
//           "Failed to update name. Please check your connection and try again.");
//     }
//   }

//   String? _extractNameFromEmail(String? email) {
//     if (email == null || !email.contains('@')) return null;
//     String namePart = email.split('@')[0];
//     namePart = namePart.replaceAll(RegExp(r'[._-]'), ' ').trim();
//     if (namePart.isEmpty) return null;
//     return namePart
//         .split(' ')
//         .map((word) {
//           if (word.isEmpty) return '';
//           return '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}';
//         })
//         .join(' ')
//         .trim();
//   }

//   String _handleAuthException(FirebaseAuthException e,
//       {required bool isSignUp}) {
//     String message;
//     debugPrint(
//         'Firebase Auth Exception (${isSignUp ? "Sign Up" : "Sign In/Other"}): ${e.code} - ${e.message}');
//     switch (e.code) {
//       case 'weak-password':
//         message = 'The password provided is too weak.';
//         break;
//       case 'email-already-in-use':
//         message =
//             'An account already exists for that email. Please Sign In or use Forgot Password.';
//         break;
//       case 'invalid-email':
//         message = 'The email address format is not valid.';
//         break;
//       case 'user-not-found':
//         message =
//             'No user found with this email. Please check the email or Sign Up.';
//         break;
//       case 'wrong-password':
//         message =
//             'Incorrect password. Please try again or use Forgot Password.';
//         break;
//       case 'user-disabled':
//         message =
//             'This user account has been disabled. Please contact support.';
//         break;
//       case 'account-exists-with-different-credential':
//         message =
//             'An account already exists with this email. Try signing in with your original method (e.g., Google or Email/Password).';
//         break;
//       case 'operation-not-allowed':
//         message = 'Sign-in method not enabled. Please contact support.';
//         break;
//       case 'invalid-credential':
//       case 'invalid-verification-code': // Specific to phone auth
//         message = 'The credential or code provided is invalid.';
//         break;
//       case 'invalid-verification-id': // Specific to phone auth
//           message = 'The verification process timed out or was invalid. Please try sending OTP again.';
//           break;
//       case 'session-expired': // Specific to phone auth
//         message = 'The OTP has expired. Please request a new one.';
//         break;
//       case 'too-many-requests':
//         message =
//             'Too many attempts. Please wait a bit and try again or use Forgot Password.';
//         break;
//       case 'requires-recent-login':
//         message =
//             'This action requires you to recently sign in again for security.';
//         break;
//       case 'network-request-failed':
//         message = 'Network error. Please check your connection and try again.';
//         break;
//       default:
//         message = 'An unexpected error occurred: ${e.message ?? e.code}.'; // Provide more details if available
//     }
//     return message;
//   }

//   Future<bool> reauthenticateWithPassword(String password) async {
//     final user = getCurrentUser();
//     if (user == null || user.email == null) {
//       throw Exception("User not logged in or email missing.");
//     }
//     try {
//       final AuthCredential credential = EmailAuthProvider.credential(
//         email: user.email!,
//         password: password,
//       );
//       await user.reauthenticateWithCredential(credential);
//       return true; // Re-authentication successful
//     } on FirebaseAuthException catch (e) {
//       debugPrint("Re-authentication error: ${e.code}");
//       throw Exception(_handleAuthException(e, isSignUp: false)); // Use centralized handler
//     } catch (e) {
//       debugPrint("Generic Re-authentication error: $e");
//       throw Exception("An error occurred during re-authentication.");
//     }
//   }

//   Future<void> updateUserEmailAndSendVerification(String newEmail) async {
//     final user = getCurrentUser();
//     if (user == null) throw Exception("User not logged in.");

//     try {
//       await user.updateEmail(newEmail.trim());
//       await user.sendEmailVerification(); // Send verification to the NEW email
//       // Update Firestore with the new email. Also mark emailVerified as false until new email is verified.
//       await _firestore.collection(_usersCollection).doc(user.uid).update({
//         'email': newEmail.trim(),
//         'emailVerified': false, // User needs to verify the new email
//         'updatedAt': FieldValue.serverTimestamp(),
//       });
//     } on FirebaseAuthException catch (e) {
//       throw Exception(_handleAuthException(e, isSignUp: false)); // Use centralized handler
//     } catch (e) {
//       debugPrint("Generic Update email error: $e");
//       throw Exception("An unknown error occurred while updating email.");
//     }
//   }


//   // --- NEW: Phone Authentication Methods for SIGN-UP Flow ---

//   /// Initiates phone number verification for the sign-up process.
//   /// This can be called BEFORE a Firebase user is created.
//   Future<void> sendOtpForSignUpProcess({
//     required String phoneNumber, // E.164 format (e.g., +1XXXXXXXXXX)
//     required Function(PhoneAuthCredential) onVerificationCompleted, // For auto-retrieval (Android)
//     required Function(FirebaseAuthException) onVerificationFailed,
//     required Function(String verificationId, int? resendToken) onCodeSent,
//     required Function(String verificationId) onCodeAutoRetrievalTimeout,
//     Duration timeout = const Duration(seconds: 60),
//     int? forceResendingToken,
//   }) async {
//     try {
//       await _firebaseAuth.verifyPhoneNumber(
//         phoneNumber: phoneNumber,
//         verificationCompleted: onVerificationCompleted,
//         verificationFailed: (FirebaseAuthException e) {
//           // Pass the original exception to the callback
//           onVerificationFailed(e);
//         },
//         codeSent: (String verificationId, int? resendToken) {
//           _signUpVerificationId = verificationId; // Store for this sign-up attempt
//           onCodeSent(verificationId, resendToken);
//         },
//         codeAutoRetrievalTimeout: (String verificationId) {
//           // If codeSent hasn't fired yet for some reason and this fires first
//           if (_signUpVerificationId == null || _signUpVerificationId != verificationId) {
//              _signUpVerificationId = verificationId;
//           }
//           onCodeAutoRetrievalTimeout(verificationId);
//         },
//         timeout: timeout,
//         forceResendingToken: forceResendingToken,
//       );
//     } catch (e) {
//       // This catch might not be strictly necessary if all paths call onVerificationFailed
//       // but can catch setup issues with verifyPhoneNumber itself.
//       debugPrint("Error initiating OTP send: $e");
//       if (e is FirebaseAuthException) {
//         onVerificationFailed(e);
//       } else {
//          onVerificationFailed(FirebaseAuthException(code: 'otp-send-error', message: e.toString()));
//       }
//     }
//   }

//   /// Verifies the OTP entered by the user during the sign-up process
//   /// and returns a [PhoneAuthCredential].
//   Future<PhoneAuthCredential> verifyOtpAndGetCredentialForSignUpProcess(String otp) async {
//     if (_signUpVerificationId == null) {
//       throw Exception("Verification ID not found for sign-up. Please request OTP again.");
//     }
//     try {
//       PhoneAuthCredential credential = PhoneAuthProvider.credential(
//         verificationId: _signUpVerificationId!,
//         smsCode: otp.trim(),
//       );
//       _signUpVerificationId = null; // Clear after use
//       return credential;
//     } on FirebaseAuthException catch (e) {
//       // Let the centralized handler format the message
//       throw Exception(_handleAuthException(e, isSignUp: false));
//     } catch (e) {
//       debugPrint("Generic OTP Verification Error (Sign Up): $e");
//       throw Exception("An unknown error occurred during OTP verification.");
//     }
//   }

//   // --- End NEW Phone Auth Methods for Sign-Up ---


//   // The existing methods below are for UPDATING phone for an ALREADY LOGGED-IN user.
//   // They are kept separate as their context is different (user is already authenticated).

//   /// Initiates phone number verification for an ALREADY LOGGED-IN user to update their phone.
//   Future<void> verifyPhoneNumberStartUpdate({ // Renamed for clarity
//     required String phoneNumber,
//     required Function(FirebaseAuthException) onVerificationFailed,
//     required Function(String verificationId, int? resendToken) onCodeSent,
//     required Function(PhoneAuthCredential credential) onVerificationCompleted,
//     required Duration timeout,
//     int? forceResendingToken,
//   }) async {
//     final user = getCurrentUser();
//     if (user == null) throw Exception("User not logged in for phone update.");

//     await _firebaseAuth.verifyPhoneNumber(
//       phoneNumber: phoneNumber,
//       verificationCompleted: onVerificationCompleted,
//       verificationFailed: onVerificationFailed,
//       codeSent: onCodeSent, // The calling UI will need to store this verificationId
//       codeAutoRetrievalTimeout: (String verificationId) {
//         debugPrint(
//             "Phone auth code auto retrieval timeout (update). Verification ID: $verificationId");
//       },
//       timeout: timeout,
//       forceResendingToken: forceResendingToken,
//     );
//   }

//   /// Creates a [PhoneAuthCredential] from verification ID and SMS code.
//   /// Used by the UI when updating phone number for an existing user.
//   PhoneAuthCredential createPhoneCredentialForUpdate( // Renamed for clarity
//       String verificationId, String smsCode) {
//     return PhoneAuthProvider.credential(
//       verificationId: verificationId,
//       smsCode: smsCode.trim(),
//     );
//   }

//   /// Links or updates the phone number for the CURRENTLY LOGGED-IN user using the provided credential.
//   /// This is used both after sign-up (linking new phone) and when user updates their phone.
//   Future<void> linkOrUpdatePhoneForCurrentUser(PhoneAuthCredential credential) async {
//     final user = getCurrentUser();
//     if (user == null) throw Exception("User not logged in to link/update phone number.");
//     try {
//       if (user.phoneNumber == null || user.phoneNumber!.isEmpty) {
//         // If user has no phone number, link this new one
//         await user.linkWithCredential(credential);
//       } else {
//         // If user already has a phone number, update it
//         await user.updatePhoneNumber(credential);
//       }
//       // Phone number is now updated in Firebase Auth.
//       // Update it in Firestore as well.
//       await _firestore.collection(_usersCollection).doc(user.uid).update({
//         'phoneNumber': user.phoneNumber, // This will be the newly verified number
//         'updatedAt': FieldValue.serverTimestamp(),
//       });
//     } on FirebaseAuthException catch (e) {
//       debugPrint("Link/Update Phone Number Error: ${e.code}");
//       String message = _handleAuthException(e, isSignUp: false); // Use centralized handler
//        if (e.code == 'credential-already-in-use') {
//         message = "This phone number is already linked to another account.";
//       } else if (e.code == 'provider-already-linked' && (user.phoneNumber != null && user.phoneNumber!.isNotEmpty)) {
//         // This case should ideally not happen if logic is correct (means trying to link when already has a phone via link)
//         message = "The account is already linked with a phone provider.";
//       }
//       throw Exception(message);
//     } catch (e) {
//       debugPrint("Generic Link/Update Phone Number Error: $e");
//       throw Exception("An unknown error occurred during phone verification/linking.");
//     }
//   }

//   // Renamed the original 'confirmPhoneNumberUpdate' to 'linkOrUpdatePhoneForCurrentUser' for clarity and broader use.
//   // The original 'createPhoneCredential' is now 'createPhoneCredentialForUpdate'.
//   // The original 'verifyPhoneNumberStart' is now 'verifyPhoneNumberStartUpdate'.
// }


===== features\auth\widgets\auth_gate.dart =====

// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:flutter/material.dart';
// import '../services/auth_service.dart';
// import 'auth_toggle.dart';
// import '../../home/screens/home_screen.dart';

// class AuthGate extends StatelessWidget {
//   const AuthGate({super.key});

//   @override
//   Widget build(BuildContext context) {
//     final AuthService authService = AuthService();

//     return StreamBuilder<User?>(
//       stream: authService.authStateChanges,
//       builder: (context, snapshot) {
//         if (snapshot.connectionState == ConnectionState.waiting) {
//           return const Scaffold(
//             body: Center(child: CircularProgressIndicator()),
//           );
//         }

//         if (snapshot.hasError) {
//           debugPrint('AuthGate Stream Error: ${snapshot.error}');
//           return const Scaffold(
//             body: Center(child: Text('Authentication Error. Please restart the app.')),
//           );
//         }

//         if (snapshot.hasData) {
//           final user = snapshot.data!;

//           bool isEmailPasswordProvider = user.providerData.any((providerInfo) => providerInfo.providerId == 'password');

//           if (isEmailPasswordProvider && !user.emailVerified) {
//             debugPrint("AuthGate: User is Email/Password but NOT verified. Routing to AuthToggle.");
//             return const AuthToggle();
//           } else {
//             debugPrint("AuthGate: User logged in (Verified Email/Pass or Google). Routing to HomeScreen.");
//             return const HomeScreen();
//           }

//         } else {
//           debugPrint("AuthGate: User is logged out. Routing to AuthToggle.");
//           return const AuthToggle();
//         }
//       },
//     );
//   }
// }
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import '../services/auth_service.dart';
import 'auth_toggle.dart';
// import '../../home/screens/home_screen.dart'; // <<< REMOVED THIS OLD IMPORT
import '../../home/screens/home_gate.dart';   // <<< ADDED THIS NEW IMPORT

class AuthGate extends StatelessWidget {
  const AuthGate({super.key});

  @override
  Widget build(BuildContext context) {
    final AuthService authService = AuthService();

    return StreamBuilder<User?>(
      stream: authService.authStateChanges,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        if (snapshot.hasError) {
          debugPrint('AuthGate Stream Error: ${snapshot.error}');
          return const Scaffold(
            body: Center(child: Text('Authentication Error. Please restart the app.')),
          );
        }

        if (snapshot.hasData) {
          final user = snapshot.data!;

          bool isEmailPasswordProvider = user.providerData.any((providerInfo) => providerInfo.providerId == 'password');

          if (isEmailPasswordProvider && !user.emailVerified) {
            debugPrint("AuthGate: User is Email/Password but NOT verified. Routing to AuthToggle.");
            return const AuthToggle();
          } else {
            // <<< THIS IS THE ONLY CHANGE REQUIRED >>>
            // Instead of going directly to HomeScreen, we go to HomeGate.
            // HomeGate will then check if the user is an admin and show the correct screen.
            debugPrint("AuthGate: User logged in. Routing to HomeGate to check role.");
            return const HomeGate();
          }

        } else {
          debugPrint("AuthGate: User is logged out. Routing to AuthToggle.");
          return const AuthToggle();
        }
      },
    );
  }
}


===== features\auth\widgets\auth_toggle.dart =====

import 'package:flutter/material.dart';
import '../screens/signin_screen.dart';
import '../screens/signup_screen.dart';

class AuthToggle extends StatefulWidget {
  const AuthToggle({super.key});

  @override
  _AuthToggleState createState() => _AuthToggleState();
}

class _AuthToggleState extends State<AuthToggle> {
  bool showSignIn = true;

  void toggleScreens() {
    setState(() {
      showSignIn = !showSignIn;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
       body: showSignIn
           ? SignInScreen(showSignUpScreen: toggleScreens)
           : SignUpScreen(showSignInScreen: toggleScreens),
    );
  }
}


===== features\bookings\screens\my_bookings_screen.dart =====

// lib/features/bookings/screens/my_bookings_screen.dart
import 'package:flutter/material.dart';
import 'package:mm_associates/features/bookings/services/booking_service.dart';
import 'package:mm_associates/features/bookings/widgets/booking_list_item.dart';

class MyBookingsScreen extends StatefulWidget {
  const MyBookingsScreen({super.key});

  @override
  State<MyBookingsScreen> createState() => _MyBookingsScreenState();
}

class _MyBookingsScreenState extends State<MyBookingsScreen> {
  final BookingService _bookingService = BookingService();
  List<Map<String, dynamic>> _bookings = [];
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _loadMyBookings();
  }

  Future<void> _loadMyBookings({bool showLoadingIndicator = true}) async {
    if (!mounted) return;
     if (showLoadingIndicator) {
        setState(() {
          _isLoading = true;
          _errorMessage = null;
        });
     }

    try {
      final bookingsData = await _bookingService.getMyBookings();
       if (!mounted) return;
      setState(() {
        _bookings = bookingsData;
        _isLoading = false;
      });
    } catch (e) {
       if (!mounted) return;
       debugPrint("Error loading user bookings: $e");
      setState(() {
        _isLoading = false;
        _errorMessage = e is Exception
            ? e.toString().replaceFirst("Exception: ", "")
            : "Failed to load bookings.";
      });
    }
  }

  // Method to handle cancellation from the list item
  Future<void> _cancelBooking(String bookingId) async {
     if (!mounted) return;

    // Optional: Show confirmation dialog
    bool? confirm = await showDialog<bool>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Confirm Cancellation'),
          content: const Text('Are you sure you want to cancel this booking request?'),
          actions: <Widget>[
            TextButton(
              child: const Text('No'),
              onPressed: () => Navigator.of(context).pop(false), // Not confirmed
            ),
            TextButton(
              child: const Text('Yes, Cancel', style: TextStyle(color: Colors.red)),
              onPressed: () => Navigator.of(context).pop(true), // Confirmed
            ),
          ],
        );
      },
    );

    if (confirm != true) return; // User pressed No or dismissed

     // Show loading feedback on the item potentially, or just globally?
     // For now, just show a general snackbar after operation.

    try {
        await _bookingService.cancelUserBooking(bookingId);
         if (mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
                 const SnackBar(content: Text("Booking cancelled successfully."), backgroundColor: Colors.orange),
              );
             // Refresh the list without full loading indicator
              _loadMyBookings(showLoadingIndicator: false);
              // Alternatively, update the specific item state locally for instant feedback
              // setState(() {
              //   final index = _bookings.indexWhere((b) => b['id'] == bookingId);
              //   if (index != -1) {
              //     _bookings[index]['status'] = 'cancelled_user';
              //   }
              // });
         }
     } catch (e) {
        if (mounted) {
             debugPrint("Error cancelling booking via UI: $e");
            ScaffoldMessenger.of(context).showSnackBar(
               SnackBar(content: Text("Failed to cancel booking: ${e.toString().replaceFirst("Exception: ", "")}"), backgroundColor: Colors.redAccent),
            );
         }
     }
  }


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Bookings'),
      ),
      body: RefreshIndicator(
        onRefresh: () => _loadMyBookings(showLoadingIndicator: true), // Full refresh on pull
        child: _buildBody(),
      ),
    );
  }

  Widget _buildBody() {
     if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_errorMessage != null) {
       return Center(
         child: Padding(
           padding: const EdgeInsets.all(16.0),
           child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.error_outline, color: Colors.red, size: 50),
                  const SizedBox(height: 10),
                  Text(_errorMessage!, style: const TextStyle(color: Colors.redAccent), textAlign: TextAlign.center),
                  const SizedBox(height: 10),
                   ElevatedButton.icon(
                      onPressed: () => _loadMyBookings(showLoadingIndicator: true),
                      icon: const Icon(Icons.refresh),
                       label: const Text("Try Again")
                   )
               ],
           ),
         ),
       );
    }

    if (_bookings.isEmpty) {
      return Center(
         child: Padding(
           padding: const EdgeInsets.all(20.0),
           child: Column(
             mainAxisAlignment: MainAxisAlignment.center,
             children: [
               Icon(Icons.event_busy_outlined, color: Colors.grey[400], size: 60),
               const SizedBox(height: 15),
               Text(
                 'You have no bookings yet.',
                 textAlign: TextAlign.center,
                 style: TextStyle(fontSize: 17, color: Colors.grey[600]),
               ),
                const SizedBox(height: 10),
               const Text( "Find a venue and book your next session!", style: TextStyle(color: Colors.grey), textAlign: TextAlign.center,)
             ],
           ),
         ),
       );
    }

    // Display the list of bookings
    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 8.0), // Padding around the whole list
      itemCount: _bookings.length,
      itemBuilder: (context, index) {
          final booking = _bookings[index];
           final String bookingId = booking['id'] as String? ?? '';

          return BookingListItem(
             bookingData: booking,
             onCancel: bookingId.isNotEmpty ? () => _cancelBooking(bookingId) : null, // Pass cancel callback
          );
       },
     );
  }
}


===== features\bookings\screens\venue_availability_screen.dart =====

import 'package:flutter/material.dart';
import 'package:table_calendar/table_calendar.dart';
import 'package:intl/intl.dart';
import 'package:mm_associates/features/bookings/services/booking_service.dart';
import 'package:mm_associates/features/bookings/widgets/time_slot_grid.dart';

enum TimePeriod { morning, afternoon, evening, all }

class VenueAvailabilityScreen extends StatefulWidget {
  final String venueId;
  final String venueName;
  final Map<String, dynamic>? operatingHours;
  final int slotDurationMinutes;

  const VenueAvailabilityScreen({
    super.key,
    required this.venueId,
    required this.venueName,
    required this.operatingHours,
    required this.slotDurationMinutes,
  });

  @override
  State<VenueAvailabilityScreen> createState() => _VenueAvailabilityScreenState();
}

class _VenueAvailabilityScreenState extends State<VenueAvailabilityScreen> {
  final BookingService _bookingService = BookingService();
  final CalendarFormat _calendarFormat = CalendarFormat.month;
  final TextEditingController _notesController = TextEditingController();

  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;

  List<DateTime> _allPotentialSlotsForDay = [];
  List<Map<String, dynamic>> _existingBookings = [];
  List<DateTime> _selectedSlotTimes = [];

  bool _isLoadingSlots = false;
  String? _slotLoadingError;
  bool _isBookingLoading = false;
  String? _bookingError;

  final int _maxSelectableSlots = 10;
  TimePeriod _activeDisplayFilter = TimePeriod.all;

  static const int morningEndHour = 12;
  static const int afternoonEndHour = 17;
  static const double wideScreenBreakpoint = 700;

  @override
  void initState() {
    super.initState();
    _selectedDay = _focusedDay;
    _setDefaultTimePeriodDisplayFilter(_selectedDay!);
    _loadSlotsForDate(_selectedDay!);
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  void _setDefaultTimePeriodDisplayFilter(DateTime date) {
    TimePeriod defaultFilter;
    if (isSameDay(date, DateTime.now())) {
      final currentHour = DateTime.now().hour;
      if (currentHour < morningEndHour) {
        defaultFilter = TimePeriod.morning;
      } else if (currentHour < afternoonEndHour) {
        defaultFilter = TimePeriod.afternoon;
      } else {
        defaultFilter = TimePeriod.evening;
      }
    } else {
      defaultFilter = TimePeriod.all;
    }
    if(mounted){
      setState(() {
        _activeDisplayFilter = defaultFilter;
      });
    }
  }

  void _onDaySelected(DateTime selectedDay, DateTime focusedDay) {
    if (!isSameDay(_selectedDay, selectedDay)) {
      setState(() {
        _selectedDay = selectedDay;
        _focusedDay = focusedDay;
        _selectedSlotTimes.clear();
        _allPotentialSlotsForDay = [];
        _existingBookings = [];
        _slotLoadingError = null;
        _bookingError = null;
        _setDefaultTimePeriodDisplayFilter(selectedDay);
      });
      _loadSlotsForDate(selectedDay);
    }
  }

  Future<void> _loadSlotsForDate(DateTime date) async {
    if (!mounted) return;
    setState(() {
      _isLoadingSlots = true;
      _slotLoadingError = null;
      _bookingError = null;
    });

    try {
      final results = await Future.wait([
        Future.value(_bookingService.getPotentialSlots(date, widget.operatingHours, widget.slotDurationMinutes)),
        _bookingService.getBookingsForDate(widget.venueId, date),
      ]);

      if (!mounted) return;

      setState(() {
         _allPotentialSlotsForDay = results[0] as List<DateTime>;
         _existingBookings = results[1] as List<Map<String, dynamic>>;
         _isLoadingSlots = false;
       });

    } catch (e) {
        if (mounted) {
           debugPrint("Error loading slots/bookings: $e");
            setState(() {
               _slotLoadingError = e is Exception ? e.toString().replaceFirst("Exception: ", "") : "Failed to load availability.";
               _isLoadingSlots = false;
             });
        }
    }
  }

  List<DateTime> _getDisplayFilteredPotentialSlots() {
    if (_allPotentialSlotsForDay.isEmpty) {
      return [];
    }
    if (_activeDisplayFilter == TimePeriod.all) {
      return List.from(_allPotentialSlotsForDay);
    }
    return _allPotentialSlotsForDay.where((slot) {
      switch (_activeDisplayFilter) {
        case TimePeriod.morning:
          return slot.hour < morningEndHour;
        case TimePeriod.afternoon:
          return slot.hour >= morningEndHour && slot.hour < afternoonEndHour;
        case TimePeriod.evening:
          return slot.hour >= afternoonEndHour;
        case TimePeriod.all:
          return true;
      }
    }).toList();
  }

  void _onSlotSelectedFromGrid(DateTime tappedSlot) {
     setState(() {
        final isCurrentlySelected = _selectedSlotTimes.any((slot) => slot.isAtSameMomentAs(tappedSlot));

        if (isCurrentlySelected) {
          _selectedSlotTimes.removeWhere((slot) => slot.isAtSameMomentAs(tappedSlot));
        } else {
          if (_selectedSlotTimes.length < _maxSelectableSlots) {
            _selectedSlotTimes.add(tappedSlot);
            _selectedSlotTimes.sort((a, b) => a.compareTo(b));
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text("You can select up to $_maxSelectableSlots slots."), duration: const Duration(seconds: 2)),
            );
          }
        }
        _bookingError = null;
     });
  }

  List<List<DateTime>> _groupConsecutiveSlots(List<DateTime> slots) {
    if (slots.isEmpty) return [];
    slots.sort((a, b) => a.compareTo(b));

    List<List<DateTime>> groups = [];
    List<DateTime> currentGroup = [slots.first];

    for (int i = 1; i < slots.length; i++) {
      Duration difference = slots[i].difference(slots[i-1]);
      if (difference == Duration(minutes: widget.slotDurationMinutes)) {
        currentGroup.add(slots[i]);
      } else {
        groups.add(List.from(currentGroup));
        currentGroup = [slots[i]];
      }
    }
    groups.add(List.from(currentGroup));
    return groups;
  }


  Future<void> _confirmAndCreateBooking() async {
     if (_selectedSlotTimes.isEmpty) return;

      setState(() { _isBookingLoading = true; _bookingError = null; });

      final String? notes = _notesController.text.trim().isNotEmpty ? _notesController.text.trim() : null;
      int successfulRequests = 0;
      int totalRequestsAttempted = 0;
      List<String> failedRequestDetails = [];

      final List<List<DateTime>> slotGroups = _groupConsecutiveSlots(List.from(_selectedSlotTimes));
      totalRequestsAttempted = slotGroups.length;

      for (List<DateTime> group in slotGroups) {
        if (group.isEmpty) continue;

        DateTime groupStartTime = group.first;
        int groupDurationMinutes = group.length * widget.slotDurationMinutes;

        try {
           final newBookingRef = await _bookingService.createBookingRequest(
                venueId: widget.venueId,
                venueName: widget.venueName,
                startTime: groupStartTime,
                durationMinutes: groupDurationMinutes,
                notes: notes,
           );
           debugPrint("Booking request created with ID: ${newBookingRef.id} for block starting ${DateFormat.jm().format(groupStartTime)} duration ${groupDurationMinutes}m");
           successfulRequests++;
         } catch (e) {
            debugPrint("Error creating booking for block starting ${DateFormat.jm().format(groupStartTime)}: $e");
            failedRequestDetails.add("Block from ${DateFormat.jm().format(groupStartTime)}: ${e.toString().replaceFirst("Exception: ","")}");
         }
      }

      if (mounted) {
        setState(() { _isBookingLoading = false; });

        if (successfulRequests == totalRequestsAttempted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(successfulRequests > 1 ? "$successfulRequests booking requests sent successfully!" : "Booking request sent successfully!"),
                backgroundColor: Colors.green
              ),
            );
            setState(() {
              _selectedSlotTimes.clear();
              _notesController.clear();
              _setDefaultTimePeriodDisplayFilter(_selectedDay!);
            });
            _loadSlotsForDate(_selectedDay!);
        } else if (successfulRequests > 0) {
            _bookingError = "Some booking requests failed. Successfully sent $successfulRequests of $totalRequestsAttempted.\nFailures:\n${failedRequestDetails.join('\n')}";
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text("Successfully sent $successfulRequests booking request(s). Some failed."), backgroundColor: Colors.orange),
            );
            _loadSlotsForDate(_selectedDay!);
            setState(() {
              _selectedSlotTimes.clear();
              _setDefaultTimePeriodDisplayFilter(_selectedDay!);
            });
        } else {
            _bookingError = "Could not send booking request(s). Errors:\n${failedRequestDetails.join('\n')}";
             ScaffoldMessenger.of(context).showSnackBar(
               const SnackBar(content: Text("All booking requests failed."), backgroundColor: Colors.red),
             );
        }
      }
   }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: Text('Book ${widget.venueName}'),
      ),
      body: LayoutBuilder(
        builder: (context, constraints) {
          bool isWideScreen = constraints.maxWidth > wideScreenBreakpoint;

          Widget calendarWidget = _buildCalendarCard(theme);

          Widget slotSelectionContent = Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Padding(
                padding: EdgeInsets.only(
                    top: isWideScreen ? 0 : 8.0,
                    bottom: 8.0,
                    left: 0.0,
                    right: 0.0),
                child: Text(
                  _selectedDay != null ? 'Available Slots for ${DateFormat.yMMMd().format(_selectedDay!)}' : 'Select a Date',
                  style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                  textAlign: TextAlign.center,
                ),
              ),
              _buildTimePeriodFilterSegmentedButton(theme),
              const SizedBox(height: 12),
              _buildSlotsSection(),
            ],
          );

          Widget slotSelectionWidget = Container(
            decoration: BoxDecoration(
              color: theme.cardColor,
              borderRadius: BorderRadius.circular(12.0),
              border: Border.all(
                color: theme.dividerColor.withOpacity(0.5),
                width: 0.8,
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 8.0,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 16.0),
            child: slotSelectionContent,
          );


          List<Widget> mainContentChildren;

          if (isWideScreen) {
            mainContentChildren = [
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    flex: 1,
                    child: calendarWidget,
                  ),
                  const SizedBox(width: 8),
                  SizedBox(
                    height: MediaQuery.of(context).size.height * 0.45,
                    child: const VerticalDivider(thickness: 1, width: 16),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    flex: 1,
                    child: slotSelectionWidget,
                  ),
                ],
              ),
            ];
          } else {
            mainContentChildren = [
              calendarWidget,
              const SizedBox(height: 16),
              slotSelectionWidget,
            ];
          }

          if (_selectedSlotTimes.isNotEmpty) {
            mainContentChildren.addAll([
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 16.0),
                child: Divider(color: Colors.grey[300])
              ),
              _buildBookingConfirmationSection(),
            ]);
          }

          return SingleChildScrollView(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: mainContentChildren,
            ),
          );
        },
      ),
    );
  }

  Widget _buildCalendarCard(ThemeData theme) {
    return Container(
      decoration: BoxDecoration(
        color: theme.cardColor,
        borderRadius: BorderRadius.circular(12.0),
        border: Border.all(
          color: theme.dividerColor.withOpacity(0.5),
          width: 0.8,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8.0,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(11.5),
        child: TableCalendar(
          firstDay: DateTime.now(),
          lastDay: DateTime.now().add(const Duration(days: 90)),
          focusedDay: _focusedDay,
          calendarFormat: _calendarFormat,
          selectedDayPredicate: (day) {
            return isSameDay(_selectedDay, day);
          },
          onDaySelected: _onDaySelected,
          onPageChanged: (focusedDay) {
           if(mounted) {
             setState(() {
                _focusedDay = focusedDay;
             });
           }
          },
          calendarBuilders: CalendarBuilders(
            headerTitleBuilder: (context, date) {
              return Center(
                child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: 6.0),
                  child: Text(
                    DateFormat.yMMMM().format(date),
                    style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
                  ),
                ),
              );
            },
          ),
          calendarStyle: CalendarStyle(
            outsideDaysVisible: false,
            todayDecoration: BoxDecoration(
              color: theme.primaryColorLight.withOpacity(0.5),
              shape: BoxShape.circle,
            ),
            selectedDecoration: BoxDecoration(
              color: theme.primaryColor,
              shape: BoxShape.circle,
            ),
            defaultTextStyle: theme.textTheme.bodySmall ?? const TextStyle(),
            weekendTextStyle: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.primary) ?? TextStyle(color: theme.primaryColor),
            selectedTextStyle: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onPrimary) ?? const TextStyle(color: Colors.white),
            todayTextStyle: theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.primary) ?? TextStyle(color: theme.primaryColor),
            tablePadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0),
            cellMargin: const EdgeInsets.all(1.5),
          ),
          headerStyle: HeaderStyle(
            titleCentered: true,
            formatButtonVisible: false,
            leftChevronIcon: Icon(Icons.chevron_left, color: theme.colorScheme.onSurfaceVariant, size: 18),
            rightChevronIcon: Icon(Icons.chevron_right, color: theme.colorScheme.onSurfaceVariant, size: 18),
            headerPadding: const EdgeInsets.symmetric(vertical: 0.0),
            titleTextStyle: theme.textTheme.labelLarge?.copyWith(fontWeight: FontWeight.bold) ?? const TextStyle(),
          ),
          availableGestures: AvailableGestures.horizontalSwipe,
          rowHeight: 36,
          daysOfWeekHeight: 16,
        ),
      ),
    );
  }

  // Widget _buildTimePeriodFilterSegmentedButton(ThemeData theme) {
  //   const labelTextStyle = TextStyle(fontSize: 14.0, fontWeight: FontWeight.bold);
  //   const iconSize = 16.0;

  //   // Helper to create the label with FittedBox
  //   Widget _buildSegmentLabel(String text) {
  //     return FittedBox(
  //       fit: BoxFit.scaleDown,
  //       child: Text(text, style: labelTextStyle, maxLines: 1, overflow: TextOverflow.ellipsis,),
  //     );
  //   }

  //   return Padding(
  //     padding: const EdgeInsets.symmetric(vertical: 2.0, horizontal: 0.0),
  //     child: SegmentedButton<TimePeriod>(
  //       segments: <ButtonSegment<TimePeriod>>[
  //         ButtonSegment<TimePeriod>(
  //             value: TimePeriod.all,
  //             label: _buildSegmentLabel('All'),
  //             icon: const Icon(Icons.all_inclusive, size: iconSize)
  //         ),
  //         ButtonSegment<TimePeriod>(
  //             value: TimePeriod.morning,
  //             label: _buildSegmentLabel('Morning'),
  //             icon: const Icon(Icons.wb_sunny_outlined, size: iconSize)
  //         ),
  //         ButtonSegment<TimePeriod>(
  //             value: TimePeriod.afternoon,
  //             label: _buildSegmentLabel('Afternoon'), // This will now scale down if needed
  //             icon: const Icon(Icons.brightness_medium_outlined, size: iconSize)
  //         ),
  //         ButtonSegment<TimePeriod>(
  //             value: TimePeriod.evening,
  //             label: _buildSegmentLabel('Evening'),
  //             icon: const Icon(Icons.nightlight_round_outlined, size: iconSize)
  //         ),
  //       ],
  //       selected: <TimePeriod>{_activeDisplayFilter},
  //       onSelectionChanged: (Set<TimePeriod> newSelection) {
  //         if (newSelection.isNotEmpty && mounted) {
  //           setState(() {
  //             _activeDisplayFilter = newSelection.first;
  //             _bookingError = null;
  //           });
  //         }
  //       },
  //       style: SegmentedButton.styleFrom(
  //         backgroundColor: theme.colorScheme.surface.withOpacity(0.5),
  //         foregroundColor: theme.colorScheme.onSurfaceVariant,
  //         selectedForegroundColor: theme.colorScheme.onPrimary,
  //         selectedBackgroundColor: theme.colorScheme.primary,
  //         // Use the textStyle here for defaults if needed, but explicit style in Text will override
  //         // For instance, if you removed fontWeight from labelTextStyle, you could set it here.
  //         // textStyle: theme.textTheme.labelMedium?.copyWith(fontSize: 14 /* or another base size */),
  //         padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 8), // Adjusted padding slightly
  //         side: BorderSide(color: theme.dividerColor.withOpacity(0.5)),
  //         tapTargetSize: MaterialTapTargetSize.shrinkWrap, // Keep this
  //       ),
  //       showSelectedIcon: false,
  //     ),
  //   );
  // }

  Widget _buildTimePeriodFilterSegmentedButton(ThemeData theme) {
    // Adjusted for more compact and consistent sizing
    const labelTextStyle = TextStyle(fontSize: 12.5, fontWeight: FontWeight.bold); // Reduced base font size
    const iconSize = 15.0; // Slightly reduced icon size

    // Helper to create the label with FittedBox
    Widget _buildSegmentLabel(String text) {
      return FittedBox(
        fit: BoxFit.scaleDown, // Ensures text scales down to fit if needed
        child: Text(
          text,
          style: labelTextStyle, // Applies the consistent base text style
          maxLines: 1,
          overflow: TextOverflow.ellipsis, // Fallback, though scaleDown should prevent this
        ),
      );
    }

    return Padding(
      // Keep parent padding as is, or adjust if the whole button needs to be closer to screen edges
      padding: const EdgeInsets.symmetric(vertical: 2.0, horizontal: 0.0),
      child: SegmentedButton<TimePeriod>(
        segments: <ButtonSegment<TimePeriod>>[
          ButtonSegment<TimePeriod>(
              value: TimePeriod.all,
              label: _buildSegmentLabel('All'),
              icon: const Icon(Icons.all_inclusive, size: iconSize)),
          ButtonSegment<TimePeriod>(
              value: TimePeriod.morning,
              label: _buildSegmentLabel('Morning'),
              icon: const Icon(Icons.wb_sunny_outlined, size: iconSize)),
          ButtonSegment<TimePeriod>(
              value: TimePeriod.afternoon,
              label: _buildSegmentLabel('Afternoon'),
              icon: const Icon(Icons.brightness_medium_outlined, size: iconSize)),
          ButtonSegment<TimePeriod>(
              value: TimePeriod.evening,
              label: _buildSegmentLabel('Evening'),
              icon: const Icon(Icons.nightlight_round_outlined, size: iconSize)),
        ],
        selected: <TimePeriod>{_activeDisplayFilter},
        onSelectionChanged: (Set<TimePeriod> newSelection) {
          if (newSelection.isNotEmpty && mounted) {
            setState(() {
              _activeDisplayFilter = newSelection.first;
              _bookingError = null;
            });
          }
        },
        style: SegmentedButton.styleFrom(
          backgroundColor: theme.colorScheme.surface.withOpacity(0.5),
          foregroundColor: theme.colorScheme.onSurfaceVariant, // For unselected icon and text
          selectedForegroundColor: theme.colorScheme.onPrimary, // For selected icon and text
          selectedBackgroundColor: theme.colorScheme.primary,
          
          // Reduced internal padding for each segment to make them more compact
          // This will reduce space to the left/right of content and implicitly make icon and text closer
          padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 7.0), // Adjusted horizontal and vertical padding

          side: BorderSide(color: theme.dividerColor.withOpacity(0.5)),
          tapTargetSize: MaterialTapTargetSize.shrinkWrap, // Important for allowing segments to be compact

          // You can also explicitly set a textStyle here. If done, it merges with
          // the style provided in the Text widget. This can be an alternative way to set base font size.
          // textStyle: const TextStyle(fontSize: 12.5), // Example
        ),
        showSelectedIcon: false,
      ),
    );
  }

  Widget _buildSlotsSection() {
     if (_isLoadingSlots) {
       return const Center(child: Padding(padding: EdgeInsets.all(30), child: CircularProgressIndicator()));
     }
     if (_slotLoadingError != null) {
        return Center(
           child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                 mainAxisAlignment: MainAxisAlignment.center,
                 children: [
                   Icon(Icons.error_outline, color: Colors.red[300], size: 40),
                   const SizedBox(height: 10),
                   Text(_slotLoadingError!, style: TextStyle(color: Colors.red[700]), textAlign: TextAlign.center),
                   const SizedBox(height: 10),
                   ElevatedButton(onPressed: () => _loadSlotsForDate(_selectedDay!), child: const Text("Try Again"))
                ],
             ),
            ),
         );
     }

     final displayFilteredSlots = _getDisplayFilteredPotentialSlots();

     if (displayFilteredSlots.isEmpty && _allPotentialSlotsForDay.isNotEmpty) {
        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 30.0, horizontal: 10.0),
            child: Text(
              _activeDisplayFilter == TimePeriod.all ? "No slots available for this day." : "No slots for selected period.",
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 15),
            ),
          ),
        );
     }
      if (displayFilteredSlots.isEmpty && _allPotentialSlotsForDay.isEmpty && !_isLoadingSlots) {
        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 30.0, horizontal: 10.0),
            child: Text(
              "No slots available for this day.",
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 15),
            ),
          ),
        );
     }

      return TimeSlotGrid(
         potentialSlots: displayFilteredSlots,
         existingBookings: _existingBookings,
         onSlotSelected: _onSlotSelectedFromGrid,
         currentlySelectedSlots: _selectedSlotTimes,
      );
  }

   Widget _buildBookingConfirmationSection() {
     final timeFormat = DateFormat.jm();
     final dateFormat = DateFormat.yMMMd();

     final List<List<DateTime>> displayGroups = _groupConsecutiveSlots(List.from(_selectedSlotTimes));

      return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 0.0, vertical: 10.0),
          child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
             children: [
                 Text("Confirm Your Booking(s)", style: Theme.of(context).textTheme.titleLarge?.copyWith(fontSize: 18)),
                  const SizedBox(height: 12),
                  Card(
                     elevation: 1,
                     shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                      child: Padding(
                          padding: const EdgeInsets.all(12.0),
                          child: Column(
                             crossAxisAlignment: CrossAxisAlignment.start,
                             children: [
                                 Text("Venue: ${widget.venueName}", style: const TextStyle(fontWeight: FontWeight.w500)),
                                 const SizedBox(height: 8),
                                 Text("Date: ${dateFormat.format(_selectedDay!)}", style: const TextStyle(fontWeight: FontWeight.w500)),
                                 const SizedBox(height: 8),
                                 Text("Selected Time Block(s):", style: const TextStyle(fontWeight: FontWeight.w500)),
                                 const SizedBox(height: 4),
                                 if (displayGroups.isNotEmpty)
                                   ListView.builder(
                                       shrinkWrap: true,
                                       physics: const NeverScrollableScrollPhysics(),
                                       itemCount: displayGroups.length,
                                       itemBuilder: (context, index) {
                                         final group = displayGroups[index];
                                         if (group.isEmpty) return const SizedBox.shrink();
                                         final blockStartTime = group.first;
                                         final blockEndTime = group.last.add(Duration(minutes: widget.slotDurationMinutes));
                                         final blockDurationMinutes = group.length * widget.slotDurationMinutes;

                                         String durationText;
                                         int hours = blockDurationMinutes ~/ 60;
                                         int minutes = blockDurationMinutes % 60;
                                         if (hours > 0 && minutes > 0) {
                                           durationText = "$hours hr $minutes min";
                                         } else if (hours > 0) {
                                           durationText = "$hours hr";
                                         } else {
                                           durationText = "$minutes min";
                                         }

                                         return Padding(
                                           padding: const EdgeInsets.symmetric(vertical: 3.0),
                                           child: Text(
                                             "• ${timeFormat.format(blockStartTime)} - ${timeFormat.format(blockEndTime)} ($durationText)",
                                           ),
                                         );
                                       },
                                     )
                                 else
                                     const Text("No slots selected."),
                               ],
                             ),
                       ),
                    ),
                 const SizedBox(height: 15),
                 TextField(
                      controller: _notesController,
                      decoration: const InputDecoration(
                           labelText: 'Booking Notes (Optional)',
                            hintText: 'e.g., Request for specific court, any special needs...',
                           border: OutlineInputBorder(),
                           contentPadding: EdgeInsets.symmetric(horizontal: 15, vertical: 12),
                        ),
                      maxLines: 2,
                      textCapitalization: TextCapitalization.sentences,
                     ),
                 const SizedBox(height: 15),
                 if (_bookingError != null)
                     Padding(
                         padding: const EdgeInsets.only(bottom: 10.0),
                         child: Text(
                           _bookingError!,
                           style: TextStyle(color: Theme.of(context).colorScheme.error),
                           textAlign: TextAlign.center,
                           overflow: TextOverflow.ellipsis,
                           maxLines: 5,
                         ),
                       ),
                 ElevatedButton.icon(
                      onPressed: _isBookingLoading ? null : _confirmAndCreateBooking,
                       icon: _isBookingLoading
                         ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                         : const Icon(Icons.check_circle_outline),
                       label: Text(_isBookingLoading ? 'Sending Request(s)...' : 'Send Booking Request(s)'),
                       style: ElevatedButton.styleFrom(
                           padding: const EdgeInsets.symmetric(vertical: 14),
                         ),
                    ),
              ],
            ),
        );
     }
}


===== features\bookings\services\booking_service.dart =====

// lib/features/bookings/services/booking_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart'; // To get user name

class BookingService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final AuthService _authService = AuthService(); // To get user details

  static const String _bookingsCollection = 'bookings';

  String? get _currentUserId => _firebaseAuth.currentUser?.uid;

  // --- Slot Calculation ---

  /// Calculates potential booking slots for a given date based on operating hours.
  List<DateTime> getPotentialSlots(DateTime date, Map<String, dynamic>? operatingHoursData, int slotDurationMinutes) {
    List<DateTime> slots = [];
    if (operatingHoursData == null || slotDurationMinutes <= 0) {
        debugPrint("Cannot calculate slots: Missing operating hours or invalid slot duration.");
        return slots;
    }

    String dayKey = _getDayKey(date.weekday);
    final dayHours = operatingHoursData[dayKey] as Map<String, dynamic>?;

    // Enhanced check for dayHours and its content
    if (dayHours == null || dayHours['start'] == null || dayHours['end'] == null || 
        dayHours['start'] == 'null' || dayHours['end'] == 'null') { // ADDED CHECK FOR STRING "null"
        debugPrint("Operating hours not defined, null, or string 'null' for $dayKey on $date. Start: ${dayHours?['start']}, End: ${dayHours?['end']}");
        return slots;
    }

    try {
      final String startTimeStr = dayHours['start'] as String; 
      final String endTimeStr = dayHours['end'] as String;   

      if (!startTimeStr.contains(':') || !endTimeStr.contains(':')) {
          debugPrint("Operating hours format error for $dayKey on $date. Start: '$startTimeStr', End: '$endTimeStr'. Expected HH:MM.");
          return slots;
      }
      
      final List<String> startParts = startTimeStr.split(':');
      final List<String> endParts = endTimeStr.split(':');

      if (startParts.length != 2 || endParts.length != 2) {
          debugPrint("Operating hours format error (parts) for $dayKey on $date. Start: '$startTimeStr', End: '$endTimeStr'. Expected HH:MM.");
          return slots;
      }

      final int? startHour = int.tryParse(startParts[0]);
      final int? startMinute = int.tryParse(startParts[1]);
      final int? endHour = int.tryParse(endParts[0]);
      final int? endMinute = int.tryParse(endParts[1]);

      if (startHour == null || startMinute == null || endHour == null || endMinute == null) {
        debugPrint("Operating hours format error (parsing int) for $dayKey on $date. Could not parse numbers from '$startTimeStr' or '$endTimeStr'.");
        return slots;
      }

      DateTime currentSlotTime = DateTime(date.year, date.month, date.day, startHour, startMinute);
      final closingTime = DateTime(date.year, date.month, date.day, endHour, endMinute);

      if (currentSlotTime.isAfter(closingTime) || currentSlotTime.isAtSameMomentAs(closingTime)) {
          debugPrint("Start time is at or after closing time for $dayKey on $date.");
          return slots;
      }

      while (currentSlotTime.add(Duration(minutes: slotDurationMinutes)).isBefore(closingTime) ||
             currentSlotTime.add(Duration(minutes: slotDurationMinutes)).isAtSameMomentAs(closingTime)) {
        slots.add(currentSlotTime);
        currentSlotTime = currentSlotTime.add(Duration(minutes: slotDurationMinutes));
        if (slots.length > 100) { 
            debugPrint("Potential infinite loop in slot generation for $dayKey on $date. Breaking after 100 slots.");
            break;
        }
      }
    } catch (e, stacktrace) { 
       debugPrint("Error parsing operating hours or calculating slots for $date ($dayKey): $e\nStacktrace: $stacktrace");
       return []; 
    }

    return slots;
  }

  // Helper to get the correct key for operatingHours map based on weekday
  String _getDayKey(int weekday) {
      // Assumes 1=Monday, 7=Sunday (DateTime.weekday)
      // Match this to the keys used in your Firestore `operatingHours` map
     switch (weekday) {
         case DateTime.saturday: return 'saturday';
         case DateTime.sunday: return 'sunday';
         default: return 'weekday'; // Or handle Mon, Tue, etc. individually
     }
  }


  // --- Booking Fetching ---

  /// Fetches bookings for a specific venue on a given date range (usually a single day).
  Future<List<Map<String, dynamic>>> getBookingsForDate(String venueId, DateTime date) async {
    try {
        // Create Timestamp range for the selected date
        final startOfDay = Timestamp.fromDate(DateTime(date.year, date.month, date.day, 0, 0, 0));
        final endOfDay = Timestamp.fromDate(DateTime(date.year, date.month, date.day, 23, 59, 59));

        final querySnapshot = await _firestore
            .collection(_bookingsCollection)
            .where('venueId', isEqualTo: venueId)
            .where('bookingStartTime', isGreaterThanOrEqualTo: startOfDay)
            .where('bookingStartTime', isLessThanOrEqualTo: endOfDay)
            // Fetch all statuses to determine booked slots (pending, confirmed etc.)
            .get();

        return querySnapshot.docs.map((doc) {
            final data = doc.data();
            data['id'] = doc.id; // Add document ID
            return data;
        }).toList();
    } catch (e) {
      debugPrint("Error fetching bookings for $venueId on $date: $e");
      throw Exception("Failed to load existing bookings.");
    }
  }

  /// Fetches all bookings for the current user.
  Future<List<Map<String, dynamic>>> getMyBookings() async {
    final userId = _currentUserId;
    if (userId == null) {
       // User not logged in, return empty or throw error depending on context
       debugPrint("getMyBookings: User not logged in.");
       return [];
    }

    try {
        final querySnapshot = await _firestore
            .collection(_bookingsCollection)
            .where('userId', isEqualTo: userId)
            .orderBy('bookingStartTime', descending: true) // Show newest first
            .get();

        return querySnapshot.docs.map((doc) {
           final data = doc.data();
           data['id'] = doc.id; // Add document ID
           return data;
       }).toList();
    } catch (e) {
        debugPrint("Error fetching user bookings for $userId: $e");
        throw Exception("Failed to load your bookings.");
    }
  }

  // --- Booking Actions ---

  /// Creates a new booking request document in Firestore.
  Future<DocumentReference> createBookingRequest({
    required String venueId,
    required String venueName, // Denormalized
    required DateTime startTime,
    required int durationMinutes,
    String? notes,
  }) async {
    final userId = _currentUserId;
    final currentUser = _firebaseAuth.currentUser;

    if (userId == null || currentUser == null) {
        throw Exception("User must be logged in to book.");
    }

    // Fetch user name for denormalization
    final userData = await _authService.getUserProfileData(); // Use existing service method
    final userName = userData?['name'] as String? ?? currentUser.email?.split('@')[0] ?? 'User';

    final DateTime endTime = startTime.add(Duration(minutes: durationMinutes));
    final bookingData = {
        'venueId': venueId,
        'venueName': venueName,
        'userId': userId,
        'userName': userName,
        'bookingStartTime': Timestamp.fromDate(startTime),
        'bookingEndTime': Timestamp.fromDate(endTime),
        'status': 'pending', // Initial status for MVP
        'createdAt': FieldValue.serverTimestamp(),
        if (notes != null && notes.trim().isNotEmpty) 'notes': notes.trim(),
    };

    try {
        // Add the new booking document
        return await _firestore.collection(_bookingsCollection).add(bookingData);
    } catch (e) {
        debugPrint("Error creating booking request: $e");
        throw Exception("Could not create booking request.");
    }
  }

  /// Allows a user to cancel their own booking (if status allows).
  Future<void> cancelUserBooking(String bookingId) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in.");
    if (bookingId.isEmpty) throw Exception("Invalid booking ID.");

    final bookingRef = _firestore.collection(_bookingsCollection).doc(bookingId);

    try {
      final bookingDoc = await bookingRef.get();
       if (!bookingDoc.exists) throw Exception("Booking not found.");

      final bookingData = bookingDoc.data()!;
       if (bookingData['userId'] != userId) throw Exception("Permission denied: Not your booking.");

      final currentStatus = bookingData['status'];
       // Allow cancellation only for 'pending' or 'confirmed' statuses by user
      if (currentStatus != 'pending' && currentStatus != 'confirmed') {
          throw Exception("Booking cannot be cancelled in its current state ($currentStatus).");
      }

      await bookingRef.update({
        'status': 'cancelled_user',
         // Optional: add cancellation timestamp
         'cancelledAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
        debugPrint("Error cancelling booking $bookingId: $e");
         if (e is FirebaseException) {
            throw Exception("Could not cancel booking (${e.code}). Please try again.");
         } else {
            rethrow; // Rethrow specific exceptions like permission denied or cannot cancel
         }
    }
  }

    // Potential Future Methods:
    // - updateBookingStatus (for Admins)
    // - deleteBooking (handle carefully, maybe just mark as deleted)
}


===== features\bookings\widgets\booking_list_item.dart =====

// lib/features/bookings/widgets/booking_list_item.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';

class BookingListItem extends StatelessWidget {
  final Map<String, dynamic> bookingData;
  final VoidCallback? onCancel; // Callback to trigger cancellation

  const BookingListItem({
    super.key,
    required this.bookingData,
    this.onCancel,
  });

  // Helper to get color based on status
  Color _getStatusColor(String status) {
    switch (status.toLowerCase()) {
      case 'confirmed':
        return Colors.green.shade700;
      case 'pending':
        return Colors.orange.shade800;
      case 'rejected':
      case 'cancelled_user':
      case 'cancelled_venue':
        return Colors.red.shade700;
      case 'completed':
        return Colors.blueGrey;
      default:
        return Colors.grey.shade600;
    }
  }

  // Helper to format status text nicely
  String _formatStatus(String status) {
    switch (status.toLowerCase()) {
      case 'confirmed': return 'Confirmed';
      case 'pending': return 'Pending Confirmation';
      case 'rejected': return 'Rejected';
      case 'cancelled_user': return 'Cancelled by You';
      case 'cancelled_venue': return 'Cancelled by Venue';
      case 'completed': return 'Completed';
      default: return status; // Show raw status if unknown
    }
  }

  @override
  Widget build(BuildContext context) {
    final String venueName = bookingData['venueName'] as String? ?? 'Unknown Venue';
    final Timestamp? startTimestamp = bookingData['bookingStartTime'] as Timestamp?;
    final Timestamp? endTimestamp = bookingData['bookingEndTime'] as Timestamp?;
    final String status = (bookingData['status'] as String?)?.toLowerCase() ?? 'unknown';
    final String? notes = bookingData['notes'] as String?;
    final bool canCancel = onCancel != null && (status == 'pending' || status == 'confirmed');

    String dateTimeString = "Date/Time Unavailable";
    if (startTimestamp != null && endTimestamp != null) {
      final startTime = startTimestamp.toDate();
      final endTime = endTimestamp.toDate();
      // Example Format: Wed, Aug 23, 2023 | 9:00 AM - 10:00 AM
      dateTimeString =
          "${DateFormat('E, MMM d, yyyy').format(startTime)} | ${DateFormat.jm().format(startTime)} - ${DateFormat.jm().format(endTime)}";
    }

    final Color statusColor = _getStatusColor(status);
    final String formattedStatus = _formatStatus(status);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: BorderSide(color: Colors.grey[300]!, width: 0.5),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Top Row: Venue Name and Status Badge
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    venueName,
                    style: const TextStyle(
                        fontSize: 16, fontWeight: FontWeight.bold),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: statusColor.withOpacity(0.15),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    formattedStatus,
                    style: TextStyle(
                        color: statusColor,
                        fontSize: 12,
                        fontWeight: FontWeight.w500),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),

            // Date & Time Row
            Row(
              children: [
                Icon(Icons.calendar_today_outlined, size: 16, color: Colors.grey[700]),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    dateTimeString,
                    style: TextStyle(fontSize: 14, color: Colors.grey[800]),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),

            // Notes if available
            if (notes != null && notes.isNotEmpty) ...[
               Row(
                 crossAxisAlignment: CrossAxisAlignment.start,
                 children: [
                   Icon(Icons.note_alt_outlined, size: 16, color: Colors.grey[700]),
                   const SizedBox(width: 8),
                   Expanded(
                     child: Text(
                        notes,
                        style: TextStyle(fontSize: 14, color: Colors.grey[800], fontStyle: FontStyle.italic),
                     ),
                   ),
                 ],
               ),
               const SizedBox(height: 12),
            ],

            // Cancel Button (Conditional)
            if (canCancel) ...[
               const Divider(height: 16),
              Align(
                 alignment: Alignment.centerRight,
                 child: TextButton.icon(
                   icon: const Icon(Icons.cancel_outlined, size: 18),
                    label: const Text("Cancel Booking"),
                    onPressed: onCancel, // Trigger the callback passed from parent
                    style: TextButton.styleFrom(
                       foregroundColor: Colors.red.shade700,
                       // visualDensity: VisualDensity.compact,
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    ),
                  ),
               ),
            ]
          ],
        ),
      ),
    );
  }
}


===== features\bookings\widgets\time_slot_grid.dart =====

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

enum TimeSlotStatus { available, booked, selected, past }

class TimeSlotGrid extends StatelessWidget {
  final List<DateTime> potentialSlots;
  final List<Map<String, dynamic>> existingBookings;
  final Function(DateTime selectedSlot) onSlotSelected;
  final List<DateTime> currentlySelectedSlots;

  const TimeSlotGrid({
    super.key,
    required this.potentialSlots,
    required this.existingBookings,
    required this.onSlotSelected,
    this.currentlySelectedSlots = const [],
  });

  // --- MODIFIED FUNCTION ---
  /// Checks if a given potential slot time falls within any existing, non-cancelled booking.
  bool isSlotBooked(DateTime potentialSlotTime) {
    for (var booking in existingBookings) {
      final bookingStart = (booking['bookingStartTime'] as Timestamp?)?.toDate();
      final bookingEnd = (booking['bookingEndTime'] as Timestamp?)?.toDate();
      final status = booking['status'] as String?;

      // Consider a slot booked if the booking is pending or confirmed
      bool isBookingActive = status == 'pending' || status == 'confirmed';

      if (isBookingActive && bookingStart != null && bookingEnd != null) {
        // Check if the potential slot's start time is within the booking range.
        // It's booked if:
        // potentialSlotTime >= bookingStart AND potentialSlotTime < bookingEnd
        // (A slot starting exactly at bookingEnd is considered available)
        if ((potentialSlotTime.isAtSameMomentAs(bookingStart) || potentialSlotTime.isAfter(bookingStart)) &&
            potentialSlotTime.isBefore(bookingEnd)) {
          // This potential slot falls within an active booking's time range.
          return true;
        }
      }
    }
    // If no active booking range contains this slot time, it's not booked.
    return false;
  }
  // --- END OF MODIFIED FUNCTION ---


  TimeSlotStatus getSlotStatus(DateTime slotTime) {
    // Check if the slot end time is in the past (more robust than just start time)
    // Assuming slotDurationMinutes is needed here - let's estimate or pass it if available.
    // For simplicity, we'll stick to the original check for now, but ideally,
    // you'd compare slotTime + slotDuration with DateTime.now().
    if (slotTime.isBefore(DateTime.now().subtract(const Duration(minutes: 1)))) {
       return TimeSlotStatus.past;
    }
    if (currentlySelectedSlots.any((selected) => selected.isAtSameMomentAs(slotTime))) {
      return TimeSlotStatus.selected;
    } else if (isSlotBooked(slotTime)) { // This now uses the updated logic
      return TimeSlotStatus.booked;
    } else {
      return TimeSlotStatus.available;
    }
  }

  @override
  Widget build(BuildContext context) {
    if (potentialSlots.isEmpty) {
      return const Center(
          child: Padding(
              padding: EdgeInsets.all(20.0),
              child: Text("No available slots found for this date.")));
    }

    final timeFormat = DateFormat.jm();

    return LayoutBuilder(
      builder: (context, constraints) {
        final double availableWidth = constraints.maxWidth;
        const double minButtonWidth = 70.0;
        const double maxButtonWidth = 110.0;
        const double buttonHeight = 40.0;
        const double buttonSpacing = 8.0;
        const int maxItemsPerRow = 6;

        int itemsPerRow = (availableWidth + buttonSpacing) ~/ (minButtonWidth + buttonSpacing);
        if (itemsPerRow == 0) itemsPerRow = 1; // Ensure at least one item fits
        itemsPerRow = itemsPerRow.clamp(1, maxItemsPerRow); // Clamp to maxItemsPerRow

        double calculatedButtonWidth = (availableWidth - (itemsPerRow - 1) * buttonSpacing) / itemsPerRow;
        calculatedButtonWidth = calculatedButtonWidth.clamp(minButtonWidth, maxButtonWidth);

        return Wrap(
          spacing: buttonSpacing,
          runSpacing: buttonSpacing,
          alignment: WrapAlignment.center,
          children: potentialSlots.map((slotTime) {
            final status = getSlotStatus(slotTime);
            bool canSelect = status == TimeSlotStatus.available || status == TimeSlotStatus.selected;

            return SizedBox(
              width: calculatedButtonWidth,
              height: buttonHeight,
              child: ElevatedButton(
                onPressed: canSelect
                    ? () => onSlotSelected(slotTime)
                    : null, // Button is disabled if booked, past, or selection not allowed
                style: ElevatedButton.styleFrom(
                  backgroundColor: status == TimeSlotStatus.available
                      ? Theme.of(context).primaryColorLight.withOpacity(0.7)
                      : status == TimeSlotStatus.selected
                          ? Theme.of(context).primaryColor
                          : status == TimeSlotStatus.past
                              ? Colors.grey[500] // Past slots
                              : Colors.grey[350], // Booked slots
                  foregroundColor: status == TimeSlotStatus.selected
                      ? Colors.white
                      : status == TimeSlotStatus.available
                          ? Theme.of(context).primaryColorDark
                          : status == TimeSlotStatus.past
                              ? Colors.white70 // Past text color
                              : Colors.grey[600], // Booked text color
                  padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 4),
                  textStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                  elevation: status == TimeSlotStatus.selected ? 4 : 1,
                  // Ensure booked slots look distinctly disabled
                  disabledForegroundColor: Colors.grey[600]?.withOpacity(0.8),
                  disabledBackgroundColor: Colors.grey[350]?.withOpacity(0.8),
                ),
                child: Text(timeFormat.format(slotTime)),
              ),
            );
          }).toList(),
        );
      }
    );
  }
}


===== features\data\services\firestore_service.dart =====

// // import 'package:cloud_firestore/cloud_firestore.dart';
// // import 'package:flutter/foundation.dart';
// // import 'package:geolocator/geolocator.dart';
// // import 'package:mm_associates/core/services/location_service.dart'; // Assuming this is the correct path

// // class FirestoreService {
// //   final FirebaseFirestore _db = FirebaseFirestore.instance;
// //   final LocationService _locationService = LocationService();

// //   static const String _usersCollection = 'mm_users';
// //   static const String _venuesCollection = 'mm_venues';
// //   static const String _reviewsSubCollection = 'mm_reviews';

// // Future<bool> checkVenueNameExists(String nameLowercase, String? currentVenueIdToExclude) async {
// //   Query query = _db.collection('mm_venues').where('name_lowercase', isEqualTo: nameLowercase);
// //   // If in edit mode, we want to see if *another* venue has this name.
// //   // So, we exclude the current venue being edited from the check.
// //   if (currentVenueIdToExclude != null) {
// //     query = query.where(FieldPath.documentId, isNotEqualTo: currentVenueIdToExclude);
// //   }
// //   final snapshot = await query.limit(1).get();
// //   return snapshot.docs.isNotEmpty;
// // }

// //   Future<Map<String, dynamic>?> getUserData(String uid) async {
// //     try {
// //       DocumentSnapshot doc = await _db.collection(_usersCollection).doc(uid).get();
// //       if (doc.exists) {
// //         return doc.data() as Map<String, dynamic>?;
// //       }
// //       return null;
// //     } catch (e) {
// //       debugPrint('Error fetching user data for UID $uid from FirestoreService: $e');
// //       return null;
// //     }
// //   }

// // Future<List<Map<String, dynamic>>> getVenues({
// //     Position? userLocation,
// //     double? radiusInKm,
// //     String? cityFilter,
// //     String? searchQuery,
// //     String? sportFilter,
// //     int? limit,
// //     bool forSuggestions = false, // Hint to distinguish calls
// //   }) async {
// //     try {
// //       Query query = _db.collection(_venuesCollection).where('isActive', isEqualTo: true);

// //       // --- SERVER-SIDE FILTERING ---

// //       if (cityFilter != null && cityFilter.isNotEmpty) {
// //         query = query.where('city', isEqualTo: cityFilter);
// //         debugPrint("FirestoreService: Applying SERVER-SIDE city filter: '$cityFilter'");
// //       }

// //       final bool hasSearchQuery = searchQuery != null && searchQuery.trim().isNotEmpty;

// //       if (hasSearchQuery) {
// //         // Split the search query into individual lowercase words/terms
// //         // Using a Set first removes duplicates if user types "new new"
// //         List<String> searchTerms = searchQuery.trim().toLowerCase().split(' ').where((term) => term.isNotEmpty).toSet().toList();

// //         if (searchTerms.isNotEmpty) {
// //           // Use array-contains-any for matching keywords
// //           // Firestore limits array-contains-any to 10 items in the 'values' list.
// //           // If searchTerms could be longer, you might need to take only the first 10
// //           // or perform multiple queries (more complex). For typical search, <10 is common.
// //           query = query.where('searchKeywords', arrayContainsAny: searchTerms.take(10).toList());
// //           debugPrint("FirestoreService: Applying SERVER-SIDE keyword search (arrayContainsAny on searchKeywords): $searchTerms");
// //         }
// //       }

// //       // Sport Filter:
// //       // If you have a search query using arrayContainsAny, adding another arrayContains
// //       // for sportFilter on the server might require very specific composite indexes
// //       // or might not be supported directly with complex arrayContainsAny.
// //       // It's often safer to apply sport filter client-side when a keyword search is active.
// //       if (sportFilter != null && sportFilter.isNotEmpty) {
// //         if (!hasSearchQuery) { // Apply server-side only if no keyword search
// //           query = query.where('sportType', arrayContains: sportFilter);
// //           debugPrint("FirestoreService: Applying SERVER-SIDE sport filter (arrayContains): '$sportFilter'");
// //         } else {
// //           debugPrint("FirestoreService: Sport filter ('$sportFilter') will be applied CLIENT-SIDE due to active keyword search.");
// //         }
// //       }
// //       if ((!hasSearchQuery || !forSuggestions)) { // Default sort for general lists or if search doesn't dictate order
// //           query = query.orderBy('name');
// //       }
// //       if (forSuggestions && hasSearchQuery) {
// //           query = query.orderBy('name'); // Assuming index supports this
// //       }


// //       if (limit != null && limit > 0) {
// //         query = query.limit(limit);
// //       }

// //       debugPrint("FirestoreService: Final Query (before .get()): ${query.parameters}"); // Helps see constructed query

// //       QuerySnapshot snapshot = await query.get();

// //       List<Map<String, dynamic>> fetchedVenues = snapshot.docs.map((doc) {
// //         Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
// //         data['id'] = doc.id;
// //         data['averageRating'] = data['averageRating'] ?? 0.0;
// //         data['reviewCount'] = data['reviewCount'] ?? 0;
// //         return data;
// //       }).toList();

// //       debugPrint("FirestoreService: Fetched ${fetchedVenues.length} venues from server (Query: '$searchQuery', Limit: $limit, ForSuggestions: $forSuggestions)");
// //       if (fetchedVenues.isEmpty && hasSearchQuery) {
// //           debugPrint("FirestoreService: No venues found directly from server keyword search for '$searchQuery'.");
// //       }

// //       List<Map<String, dynamic>> results = fetchedVenues;


// //       if (hasSearchQuery && sportFilter != null && sportFilter.isNotEmpty) {
// //         String lowerCaseSportFilter = sportFilter.trim().toLowerCase();
// //         results = results.where((venue) {
// //           final List<String> sportTypesInVenue = (venue['sportType'] as List<dynamic>?)
// //               ?.whereType<String>().map((s) => s.toLowerCase()).toList() ?? [];
// //           return sportTypesInVenue.contains(lowerCaseSportFilter);
// //         }).toList();
// //         debugPrint("FirestoreService: Applied CLIENT-SIDE sport filter. Results count: ${results.length}");
// //       }
// //       if (hasSearchQuery && !forSuggestions && results.isNotEmpty) {
// //           String fullQueryLower = searchQuery.trim().toLowerCase();
// //           List<Map<String, dynamic>> clientSideRefinedResults = results.where((venue) {
// //               final String name = (venue['name'] as String? ?? '').toLowerCase();
// //               if (name.contains(fullQueryLower)) return true;
// //               return false; // if no explicit client-side match criteria here pass, then rely on server only.
// //           }).toList();
// //       }


// //       if (userLocation != null) {
// //         for (var venue in results) {
// //           final GeoPoint? venueGeoPoint = venue['location'] as GeoPoint?;
// //           final num? venueLatNum = venue['latitude'] as num?;
// //           final num? venueLngNum = venue['longitude'] as num?;
// //           double? venueLat, venueLng;

// //           if (venueGeoPoint != null) {
// //             venueLat = venueGeoPoint.latitude;
// //             venueLng = venueGeoPoint.longitude;
// //           } else if (venueLatNum != null && venueLngNum != null) {
// //             venueLat = venueLatNum.toDouble();
// //             venueLng = venueLngNum.toDouble();
// //           }

// //           if (venueLat != null && venueLng != null) {
// //             try {
// //               venue['distance'] = _locationService.calculateDistance(
// //                 userLocation.latitude, userLocation.longitude, venueLat, venueLng,
// //               );
// //             } catch (e) {
// //               debugPrint("Error calculating distance for venue ${venue['id']}: $e");
// //               venue['distance'] = null;
// //             }
// //           } else {
// //             venue['distance'] = null;
// //           }
// //         }
// //       }

// //       if (radiusInKm != null && userLocation != null && results.any((v) => v['distance'] != null)) {
// //         if (!hasSearchQuery && (sportFilter == null || sportFilter.isEmpty)) { // Apply radius only if no search/sport filter
// //           debugPrint("FirestoreService: Applying proximity filter (radius: $radiusInKm km)");
// //           results = results.where((venue) {
// //             final distance = venue['distance'] as double?;
// //             return distance != null && distance <= radiusInKm;
// //           }).toList();
// //         }
// //       }

// //       // Client-Side Sorting (Important if server couldn't order perfectly or for distance)
// //       if (results.isNotEmpty) {
// //         results.sort((a, b) {
// //           final distA = a['distance'] as double?;
// //           final distB = b['distance'] as double?;

// //           // If userLocation is provided, distance is the primary sort criteria for "nearby" or relevance
// //           if (userLocation != null) {
// //             if (distA != null && distB != null) {
// //               int distComparison = distA.compareTo(distB);
// //               if (distComparison != 0) return distComparison;
// //             } else if (distA != null) { return -1; } // a has distance, b doesn't
// //             else if (distB != null) { return 1;  } // b has distance, a doesn't
// //           }

// //           // Fallback or secondary sort: by name (especially if no location or distances are equal)
// //           final String nameA = (a['name'] as String? ?? '').toLowerCase();
// //           final String nameB = (b['name'] as String? ?? '').toLowerCase();
// //           return nameA.compareTo(nameB);
// //         });
// //       }

// //       return results;

// //     } catch (e) {
// //       debugPrint("Error getting venues from FirestoreService: $e");
// //       if (e.toString().toLowerCase().contains('index') || (e is FirebaseException && e.code == 'failed-precondition')) {
// //         debugPrint("Firestore Error Details: Code: ${(e as FirebaseException).code}, Message: ${e.message}");
// //         debugPrint("An index is likely required. Check Firestore console for index creation suggestions or errors in logs.");
// //         throw Exception("Database query failed (likely missing index). Details: ${e.message}");
// //       }
// //       throw Exception("Failed to retrieve venues: ${e.toString()}");
// //     }
// //   }
// // //    Future<List<Map<String, dynamic>>> getVenues({
// // //      Position? userLocation,
// // //      double? radiusInKm,
// // //      String? cityFilter,
// // //      String? searchQuery,
// // //      String? sportFilter,
// // //      int? limit,
// // //    }) async {
// // //      try {
// // //        Query query = _db.collection(_venuesCollection).where('isActive', isEqualTo: true);

// // //        if (cityFilter != null && cityFilter.isNotEmpty) { 
// // //          query = query.where('city', isEqualTo: cityFilter);
// // //          debugPrint("Applying SERVER-SIDE city filter: '$cityFilter'");
// // //        }

// // //        // MODIFIED: Changed to arrayContains for sportFilter
// // //        if (sportFilter != null && sportFilter.isNotEmpty && (searchQuery == null || searchQuery.trim().isEmpty)) {
// // //          query = query.where('sportType', arrayContains: sportFilter); // <<< CHANGED HERE
// // //          debugPrint("Applying SERVER-SIDE sport filter (arrayContains): '$sportFilter'");
// // //        }
// // //        // If there's a search query, sport filtering might be done client-side after initial fetch,
// // //        // or you might decide to also apply arrayContains here if your index supports it with search.
// // //        // For now, the logic handles client-side sport filtering when a search query is present.

// // //        query = query.orderBy('name'); // Default ordering

// // //        if (limit != null && limit > 0) {
// // //          query = query.limit(limit);
// // //        }

// // //        QuerySnapshot snapshot = await query.get();

// // //        List<Map<String, dynamic>> fetchedVenues = snapshot.docs.map((doc) {
// // //          Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
// // //          data['id'] = doc.id;
// // //          data['averageRating'] = data['averageRating'] ?? 0.0;
// // //          data['reviewCount'] = data['reviewCount'] ?? 0;
// // //          return data;
// // //        }).toList();

// // //       List<Map<String, dynamic>> results = fetchedVenues;
// // //       final bool hasSearchQuery = searchQuery != null && searchQuery.trim().isNotEmpty;
// // //       // Client-side sport filter is applied if there's a search query AND a sport filter
// // //       final bool applyClientSideSportFilter = sportFilter != null && sportFilter.isNotEmpty && hasSearchQuery;

// // //       if (hasSearchQuery || applyClientSideSportFilter) {
// // //         String lowerCaseQuery = searchQuery.trim().toLowerCase();
// // //         String lowerCaseSportFilter = sportFilter?.trim().toLowerCase() ?? "";
// // //         debugPrint("Applying CLIENT-SIDE filters: Query: '$lowerCaseQuery', Sport for client-side: '$lowerCaseSportFilter'");
// // // debugPrint("FirestoreService: Fetched ${fetchedVenues.length} venues from server BEFORE client-side filtering. For query: '$searchQuery'");
// // // for (var venueData in fetchedVenues) {
// // //     debugPrint("  - Server fetched: ${venueData['name']} (ID: ${venueData['id']}, isActive: ${venueData['isActive']})");
// // // }
// // //         results = fetchedVenues.where((venue) {
// // //           bool queryMatch = !hasSearchQuery; // True if no search query, otherwise needs to match
// // //           bool sportMatch = !applyClientSideSportFilter; // True if no client-side sport filter, otherwise needs to match

// // //           if (hasSearchQuery) {
// // //             final String name = (venue['name'] as String? ?? '').toLowerCase();
// // //             if (name.contains(lowerCaseQuery)) { queryMatch = true; }
// // //             final String address = (venue['address'] as String? ?? '').toLowerCase();
// // //             if (!queryMatch && address.contains(lowerCaseQuery)) { queryMatch = true; }
// // //             final String city = (venue['city'] as String? ?? '').toLowerCase();
// // //             if (!queryMatch && city.contains(lowerCaseQuery)) { queryMatch = true; }
// // //             final String description = (venue['description'] as String? ?? '').toLowerCase();
// // //             if (!queryMatch && description.contains(lowerCaseQuery)) { queryMatch = true; }
            
// // //             // Search within sportType array if no specific client-side sport filter is active OR if it is active but we also want to match query text in sports
// // //             final List<String> sportTypesInVenue = (venue['sportType'] as List<dynamic>?)
// // //                 ?.whereType<String>().map((s) => s.toLowerCase()).toList() ?? [];
// // //             if (!queryMatch && sportTypesInVenue.any((sport) => sport.contains(lowerCaseQuery))) {
// // //                 queryMatch = true;
// // //             }
            
// // //             final List<String> facilities = (venue['facilities'] as List<dynamic>?)
// // //                 ?.whereType<String>().map((s) => s.toLowerCase()).toList() ?? [];
// // //              if (!queryMatch && facilities.any((f) => f.contains(lowerCaseQuery))) {
// // //                  queryMatch = true;
// // //              }
// // //           }

// // //           if (applyClientSideSportFilter) {
// // //              final List<String> sportTypesInVenue = (venue['sportType'] as List<dynamic>?)
// // //                 ?.whereType<String>().map((s) => s.toLowerCase()).toList() ?? [];
// // //             if (sportTypesInVenue.contains(lowerCaseSportFilter)) {
// // //               sportMatch = true;
// // //             }
// // //           }
// // //           return queryMatch && sportMatch;
// // //        }).toList();
// // //        }

// // //        if (userLocation != null) {
// // //          for (var venue in results) {
// // //            // Assuming 'location' field is a GeoPoint in Firestore
// // //            // or 'latitude' and 'longitude' are separate number fields.
// // //            // Let's adjust based on your previous use of GeoPoint
// // //            final GeoPoint? venueGeoPoint = venue['location'] as GeoPoint?;
// // //            final num? venueLatNum = venue['latitude'] as num?;
// // //            final num? venueLngNum = venue['longitude'] as num?;

// // //            double? venueLat, venueLng;

// // //            if (venueGeoPoint != null) {
// // //              venueLat = venueGeoPoint.latitude;
// // //              venueLng = venueGeoPoint.longitude;
// // //            } else if (venueLatNum != null && venueLngNum != null) {
// // //              venueLat = venueLatNum.toDouble();
// // //              venueLng = venueLngNum.toDouble();
// // //            }

// // //            if (venueLat != null && venueLng != null) {
// // //              try {
// // //                 venue['distance'] = _locationService.calculateDistance(
// // //                   userLocation.latitude, userLocation.longitude,
// // //                   venueLat, venueLng,
// // //                 );
// // //              } catch (e) {
// // //                 debugPrint("Error calculating distance for venue ${venue['id']}: $e");
// // //                 venue['distance'] = null;
// // //              }
// // //            } else {
// // //              venue['distance'] = null;
// // //            }
// // //          }
// // //        }

// // //        // Proximity filtering
// // //        if (radiusInKm != null && userLocation != null && results.any((v) => v['distance'] != null) ) {
// // //             if (cityFilter == null && !hasSearchQuery && (sportFilter == null || sportFilter.isEmpty)) {
// // //                 // Only apply radius filter if no other major filters are active (for "Venues Near You" default view)
// // //                 debugPrint("Applying proximity filter (radius: $radiusInKm km)");
// // //                 results = results.where((venue) {
// // //                     final distance = venue['distance'] as double?;
// // //                     return distance != null && distance <= radiusInKm;
// // //                 }).toList();
// // //             }
// // //        }
       
// // //        // Sort results, prioritizing distance if available
// // //        if (results.isNotEmpty) {
// // //          results.sort((a, b) {
// // //            final distA = a['distance'] as double?;
// // //            final distB = b['distance'] as double?;

// // //            if (userLocation != null) { // If location is available, distance is primary sort
// // //              if (distA != null && distB != null) {
// // //                int distComparison = distA.compareTo(distB);
// // //                if (distComparison != 0) return distComparison;
// // //              } else if (distA != null) {
// // //                return -1; // a comes first if it has distance and b doesn't
// // //              } else if (distB != null) {
// // //                return 1;  // b comes first if it has distance and a doesn't
// // //              }
// // //            }
// // //            // Fallback to sorting by name if distances are equal or not available
// // //            final String nameA = (a['name'] as String? ?? '').toLowerCase();
// // //            final String nameB = (b['name'] as String? ?? '').toLowerCase();
// // //            return nameA.compareTo(nameB);
// // //          });
// // //        }

// // //        return results;

// // //      } catch (e) {
// // //        debugPrint("Error getting venues from FirestoreService: $e");
// // //        // Check if the error is related to an index.
// // //        if (e.toString().toLowerCase().contains('index') || (e is FirebaseException && e.code == 'failed-precondition')) {
// // //          debugPrint("Firestore Error: An index is likely required for the query being attempted. Please check Firebase console logs or look for index creation suggestions.");
// // //          // You could throw a more specific exception or return an empty list with a status.
// // //          throw Exception("Database query failed, possibly due to a missing index. Check server logs.");
// // //        }
// // //        throw Exception("Failed to retrieve venues.");
// // //      }
// // //    }

// //   Future<Map<String, dynamic>?> getVenueDetails(String venueId) async {
// //      try {
// //        DocumentSnapshot doc = await _db.collection(_venuesCollection).doc(venueId).get();
// //        if (doc.exists) {
// //          Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
// //          data['id'] = doc.id;
// //          data['averageRating'] = data['averageRating'] ?? 0.0;
// //          data['reviewCount'] = data['reviewCount'] ?? 0;
// //          return data;
// //        }
// //        return null;
// //      } catch (e) {
// //        debugPrint('Error fetching venue details for ID $venueId: $e');
// //        rethrow;
// //      }
// //    }

// //      Future<void> addReviewForVenue(String venueId, String userId, String userName, double rating, String? comment) async {
// //         if (venueId.isEmpty || userId.isEmpty || userName.isEmpty) {
// //             throw Exception("Missing required review data.");
// //         }
// //         try {
// //             final reviewData = {
// //                 'userId': userId,
// //                 'userName': userName,
// //                 'rating': rating,
// //                 'venueId': venueId, 
// //                 'createdAt': FieldValue.serverTimestamp(),
// //                 'updatedAt': FieldValue.serverTimestamp(), 
// //                 if (comment != null && comment.trim().isNotEmpty) 'comment': comment.trim(),
// //             };
// //             await _db.collection(_venuesCollection).doc(venueId).collection(_reviewsSubCollection).add(reviewData);
// //             debugPrint("Review added successfully for venue $venueId by user $userId");
// //         } catch (e) {
// //             debugPrint("Error adding review for venue $venueId by user $userId: $e");
// //             if (e is FirebaseException) {
// //               throw FirebaseException(
// //                 plugin: e.plugin,
// //                 code: e.code,
// //                 message: "Failed to submit review for $venueId. ${e.message}"
// //               );
// //             }
// //             throw Exception("Failed to submit review for $venueId.");
// //         }
// //    }

// //   Future<List<Map<String, dynamic>>> getReviewsForVenue(String venueId, {int limit = 20}) async {
// //     if (venueId.isEmpty) return [];
// //     try {
// //         QuerySnapshot snapshot = await _db.collection(_venuesCollection).doc(venueId)
// //             .collection(_reviewsSubCollection).orderBy('createdAt', descending: true).limit(limit).get();
// //         return snapshot.docs.map((doc) {
// //             Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
// //             data['id'] = doc.id;
// //             return data;
// //         }).toList();
// //     } catch (e) {
// //         debugPrint("Error fetching reviews for venue $venueId: $e");
// //         throw Exception("Could not load reviews.");
// //     }
// //   }

// //   Future<List<Map<String, dynamic>>> getReviewsByUser(String userId, {int limit = 50}) async {
// //     if (userId.isEmpty) return [];
// //     try {
// //         // Make sure _reviewsSubCollection is defined, e.g.,
// //         // static const String _reviewsSubCollection = "mm_reviews";
// //         // static const String _venuesCollection = "mm_venues";

// //         QuerySnapshot snapshot = await _db.collectionGroup(_reviewsSubCollection)
// //             .where('userId', isEqualTo: userId)
// //             .orderBy('createdAt', descending: true)
// //             .limit(limit)
// //             .get();

// //         List<Map<String, dynamic>> userReviews = [];
// //         for (var doc in snapshot.docs) {
// //             Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
// //             data['id'] = doc.id; // This is the reviewId
// //             String path = doc.reference.path;
// //             List<String> parts = path.split('/');

// //             // Path example: "mm_venues/THE_ACTUAL_VENUE_ID/mm_reviews/THE_ACTUAL_REVIEW_ID"
// //             // parts[0] = "mm_venues" (_venuesCollection)
// //             // parts[1] = "THE_ACTUAL_VENUE_ID" (This is what we want)
// //             // parts[2] = "mm_reviews" (_reviewsSubCollection)
// //             // parts[3] = "THE_ACTUAL_REVIEW_ID"

// //             if (parts.length >= 4 && parts[0] == _venuesCollection && parts[2] == _reviewsSubCollection) {
// //                 data['venueId'] = parts[1]; // Correctly assign the venueId
// //             } else {
// //                 data['venueId'] = null; // Fallback if path structure is unexpected
// //                 // Corrected line below:
// //                 debugPrint("Warning: Could not extract venueId from review path: $path. Path parts: ${parts.join('/')}. Expected structure: $_venuesCollection/{venueId}/$_reviewsSubCollection/{reviewId}");
// //             }

// //             data['venueName'] = null; // You'll need to fetch this separately if needed
// //             userReviews.add(data);
// //         }
// //         return userReviews;
// //     } catch (e) {
// //         debugPrint("Error fetching reviews for user $userId: $e");
// //         if (e.toString().toLowerCase().contains('index')) {
// //             debugPrint("Firestore Error: An index is likely required for the query. Check Firebase console logs or index suggestions.");
// //             throw Exception("Database index configuration needed. Please contact support or check logs.");
// //         }
// //         throw Exception("Could not load your reviews.");
// //     }
// // }

// //   Future<void> deleteReview(String venueId, String reviewId) async {
// //     if (venueId.isEmpty || reviewId.isEmpty) throw ArgumentError("Venue ID and Review ID cannot be empty.");
// //     try {
// //        await _db.collection(_venuesCollection).doc(venueId).collection(_reviewsSubCollection).doc(reviewId).delete();
// //     } catch (e) {
// //        debugPrint("Error deleting review $reviewId for venue $venueId: $e");
// //        throw Exception("Failed to delete review.");
// //     }
// //   }

// //   Future<DocumentReference> addVenue(Map<String, dynamic> venueData) async {
// //      try {
// //         // venueData['createdAt'] = FieldValue.serverTimestamp();
// //         // venueData['updatedAt'] = FieldValue.serverTimestamp(); // Also add updatedAt on creation
// //         // venueData['averageRating'] = 0.0;
// //         // venueData['reviewCount'] = 0;
// //         // venueData['isActive'] = true; // Default to active
// //         return await _db.collection(_venuesCollection).add(venueData);
// //      } catch (e) {
// //          debugPrint("Error adding venue in FirestoreService: $e");
// //          throw Exception("Failed to add venue data.");
// //      }
// //    }

// //   Future<void> updateVenue(String venueId, Map<String, dynamic> venueData) async {
// //        if (venueId.isEmpty) throw Exception("Venue ID cannot be empty.");
// //        try {
// //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// //           await _db.collection(_venuesCollection).doc(venueId).update(venueData);
// //        } catch (e) {
// //            debugPrint("Error updating venue $venueId: $e");
// //            throw Exception("Failed to update venue data.");
// //        }
// //   }

// //    Future<void> deleteVenue(String venueId) async {
// //        if (venueId.isEmpty) throw Exception("Venue ID cannot be empty.");
// //        try {
// //            // Optionally, also delete subcollections like reviews if needed (requires more complex logic)
// //            await _db.collection(_venuesCollection).doc(venueId).delete();
// //        } catch (e) {
// //            debugPrint("Error deleting venue $venueId: $e");
// //            throw Exception("Failed to delete venue data.");
// //        }
// //   }
// // }

// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:flutter/foundation.dart';
// import 'package:geolocator/geolocator.dart';
// import 'package:mm_associates/core/services/location_service.dart';

// class FirestoreService {
//   final FirebaseFirestore _db = FirebaseFirestore.instance;
//   final LocationService _locationService = LocationService();

//   static const String _usersCollection = 'mm_users';
//   static const String _venuesCollection = 'mm_venues';
//   static const String _reviewsSubCollection = 'mm_reviews';

// Future<bool> checkVenueNameExists(String nameLowercase, String? currentVenueIdToExclude) async {
//   Query query = _db.collection('mm_venues').where('name_lowercase', isEqualTo: nameLowercase);
//   if (currentVenueIdToExclude != null) {
//     query = query.where(FieldPath.documentId, isNotEqualTo: currentVenueIdToExclude);
//   }
//   final snapshot = await query.limit(1).get();
//   return snapshot.docs.isNotEmpty;
// }

//   Future<Map<String, dynamic>?> getUserData(String uid) async {
//     try {
//       DocumentSnapshot doc = await _db.collection(_usersCollection).doc(uid).get();
//       if (doc.exists) {
//         return doc.data() as Map<String, dynamic>?;
//       }
//       return null;
//     } catch (e) {
//       debugPrint('Error fetching user data for UID $uid from FirestoreService: $e');
//       return null;
//     }
//   }

// Future<List<Map<String, dynamic>>> getVenues({
//     Position? userLocation,
//     double? radiusInKm,
//     String? cityFilter,
//     String? searchQuery,
//     String? sportFilter,
//     int? limit,
//     bool forSuggestions = false,
//   }) async {
//     try {
//       Query query = _db.collection(_venuesCollection).where('isActive', isEqualTo: true);

//       if (cityFilter != null && cityFilter.isNotEmpty) {
//         query = query.where('city', isEqualTo: cityFilter);
//         debugPrint("FirestoreService: Applying SERVER-SIDE city filter: '$cityFilter'");
//       }

//       final bool hasSearchQuery = searchQuery != null && searchQuery.trim().isNotEmpty;

//       if (hasSearchQuery) {
//         List<String> searchTerms = searchQuery.trim().toLowerCase().split(' ').where((term) => term.isNotEmpty).toSet().toList();
//         if (searchTerms.isNotEmpty) {
//           query = query.where('searchKeywords', arrayContainsAny: searchTerms.take(10).toList());
//           debugPrint("FirestoreService: Applying SERVER-SIDE keyword search (arrayContainsAny on searchKeywords): $searchTerms");
//         }
//       }

//       if (sportFilter != null && sportFilter.isNotEmpty) {
//         if (!hasSearchQuery) { 
//           query = query.where('sportType', arrayContains: sportFilter);
//           debugPrint("FirestoreService: Applying SERVER-SIDE sport filter (arrayContains): '$sportFilter'");
//         } else {
//           debugPrint("FirestoreService: Sport filter ('$sportFilter') will be applied CLIENT-SIDE due to active keyword search.");
//         }
//       }
      
//       // Default sort should usually be on a consistently available field
//       // If `forSuggestions` or a keyword search is active, name is good.
//       // Otherwise, you might want another default (e.g., creation date, popularity) if not already filtered heavily
//       if ((forSuggestions && hasSearchQuery) || !hasSearchQuery ) {
//           query = query.orderBy('name'); 
//       }
//       // If `hasSearchQuery` is true BUT `forSuggestions` is false (i.e., displaying search results, not just suggestions),
//       // the server's keyword matching should ideally be good enough for initial order,
//       // and client-side will refine with distance or other factors.
//       // Or you might add more complex server-side ordering if your search engine supports it.

//       if (limit != null && limit > 0) {
//         query = query.limit(limit);
//       }

//       debugPrint("FirestoreService: Final Query (before .get()): ${query.parameters}"); 

//       QuerySnapshot snapshot = await query.get();

//       List<Map<String, dynamic>> fetchedVenues = snapshot.docs.map((doc) {
//         Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
//         data['id'] = doc.id;
//         data['averageRating'] = data['averageRating'] ?? 0.0;
//         data['reviewCount'] = data['reviewCount'] ?? 0;
//         return data;
//       }).toList();

//       debugPrint("FirestoreService: Fetched ${fetchedVenues.length} venues from server (Query: '$searchQuery', Limit: $limit, ForSuggestions: $forSuggestions)");
      
//       List<Map<String, dynamic>> results = fetchedVenues;

//       // Client-side filtering if sportFilter was not applied on server
//       if (hasSearchQuery && sportFilter != null && sportFilter.isNotEmpty) {
//         String lowerCaseSportFilter = sportFilter.trim().toLowerCase();
//         results = results.where((venue) {
//           final List<String> sportTypesInVenue = (venue['sportType'] as List<dynamic>?)
//               ?.whereType<String>().map((s) => s.toLowerCase()).toList() ?? [];
//           return sportTypesInVenue.contains(lowerCaseSportFilter);
//         }).toList();
//         debugPrint("FirestoreService: Applied CLIENT-SIDE sport filter. Results count: ${results.length}");
//       }
//       // Client-side refinement of search query IF NEEDED (usually server 'searchKeywords' is enough)
//       // if (hasSearchQuery && !forSuggestions && results.isNotEmpty) {
//       //     String fullQueryLower = searchQuery.trim().toLowerCase();
//       //     results = results.where((venue) {
//       //         final String name = (venue['name'] as String? ?? '').toLowerCase();
//       //         // Add other fields to search client-side if needed, e.g., description
//       //         return name.contains(fullQueryLower);
//       //     }).toList();
//       //     debugPrint("FirestoreService: Applied CLIENT-SIDE query refinement. Results count: ${results.length}");
//       // }


//       if (userLocation != null) {
//         for (var venue in results) {
//           final GeoPoint? venueGeoPoint = venue['location'] as GeoPoint?;
//           double? venueLat, venueLng;

//           if (venueGeoPoint != null) {
//             venueLat = venueGeoPoint.latitude;
//             venueLng = venueGeoPoint.longitude;
//           }
//           // Remove num checks for lat/lng if 'location' GeoPoint is always primary source

//           if (venueLat != null && venueLng != null) {
//             try {
//               venue['distance'] = _locationService.calculateDistance(
//                 userLocation.latitude, userLocation.longitude, venueLat, venueLng,
//               );
//             } catch (e) {
//               debugPrint("Error calculating distance for venue ${venue['id']}: $e");
//               venue['distance'] = null;
//             }
//           } else {
//             venue['distance'] = null;
//           }
//         }
//       }

//       if (radiusInKm != null && userLocation != null && results.any((v) => v['distance'] != null)) {
//         if (!hasSearchQuery && (sportFilter == null || sportFilter.isEmpty)) { 
//           debugPrint("FirestoreService: Applying proximity filter (radius: $radiusInKm km)");
//           results = results.where((venue) {
//             final distance = venue['distance'] as double?;
//             return distance != null && distance <= radiusInKm;
//           }).toList();
//         }
//       }

//       if (results.isNotEmpty) {
//         results.sort((a, b) {
//           final distA = a['distance'] as double?;
//           final distB = b['distance'] as double?;

//           if (userLocation != null) {
//             if (distA != null && distB != null) {
//               int distComparison = distA.compareTo(distB);
//               if (distComparison != 0) return distComparison;
//             } else if (distA != null) { return -1; } 
//             else if (distB != null) { return 1;  } 
//           }

//           final String nameA = (a['name'] as String? ?? '').toLowerCase();
//           final String nameB = (b['name'] as String? ?? '').toLowerCase();
//           return nameA.compareTo(nameB);
//         });
//       }

//       return results;

//     } catch (e) {
//       debugPrint("Error getting venues from FirestoreService: $e");
//       if (e is FirebaseException && (e.toString().toLowerCase().contains('index') || e.code == 'failed-precondition')) {
//         debugPrint("Firestore Error Details: Code: ${e.code}, Message: ${e.message}");
//         debugPrint("An index is likely required. Check Firestore console for index creation suggestions or errors in logs.");
//         throw Exception("Database query failed (likely missing index). Details: ${e.message}");
//       }
//       throw Exception("Failed to retrieve venues: ${e.toString()}");
//     }
//   }

//   Future<Map<String, dynamic>?> getVenueDetails(String venueId) async {
//      try {
//        DocumentSnapshot doc = await _db.collection(_venuesCollection).doc(venueId).get();
//        if (doc.exists) {
//          Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
//          data['id'] = doc.id;
//          data['averageRating'] = data['averageRating'] ?? 0.0;
//          data['reviewCount'] = data['reviewCount'] ?? 0;
//          return data;
//        }
//        return null;
//      } catch (e) {
//        debugPrint('Error fetching venue details for ID $venueId: $e');
//        rethrow;
//      }
//    }

//   Future<void> addReviewForVenue(String venueId, String userId, String userName, double rating, String? comment) async {
//       if (venueId.isEmpty || userId.isEmpty || userName.isEmpty) {
//           throw Exception("Missing required review data.");
//       }
//       try {
//           final reviewData = {
//               'userId': userId,
//               'userName': userName,
//               'rating': rating,
//               'venueId': venueId, 
//               'createdAt': FieldValue.serverTimestamp(),
//               'updatedAt': FieldValue.serverTimestamp(), 
//               if (comment != null && comment.trim().isNotEmpty) 'comment': comment.trim(),
//           };
//           await _db.collection(_venuesCollection).doc(venueId).collection(_reviewsSubCollection).add(reviewData);
//           debugPrint("Review added successfully for venue $venueId by user $userId");
//       } catch (e) {
//           debugPrint("Error adding review for venue $venueId by user $userId: $e");
//           if (e is FirebaseException) {
//             throw FirebaseException(
//               plugin: e.plugin,
//               code: e.code,
//               message: "Failed to submit review for $venueId. ${e.message}"
//             );
//           }
//           throw Exception("Failed to submit review for $venueId.");
//       }
//   }

//   Future<List<Map<String, dynamic>>> getReviewsForVenue(String venueId, {int limit = 20}) async {
//     if (venueId.isEmpty) return [];
//     try {
//         QuerySnapshot snapshot = await _db.collection(_venuesCollection).doc(venueId)
//             .collection(_reviewsSubCollection).orderBy('createdAt', descending: true).limit(limit).get();
//         return snapshot.docs.map((doc) {
//             Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
//             data['id'] = doc.id;
//             return data;
//         }).toList();
//     } catch (e) {
//         debugPrint("Error fetching reviews for venue $venueId: $e");
//         throw Exception("Could not load reviews.");
//     }
//   }

//   Future<List<Map<String, dynamic>>> getReviewsByUser(String userId, {int limit = 50}) async {
//     if (userId.isEmpty) return [];
//     try {
//         QuerySnapshot snapshot = await _db.collectionGroup(_reviewsSubCollection)
//             .where('userId', isEqualTo: userId)
//             .orderBy('createdAt', descending: true)
//             .limit(limit)
//             .get();

//         List<Map<String, dynamic>> userReviews = [];
//         for (var doc in snapshot.docs) {
//             Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
//             data['id'] = doc.id;
//             String path = doc.reference.path;
//             List<String> parts = path.split('/');
//             if (parts.length >= 4 && parts[0] == _venuesCollection && parts[2] == _reviewsSubCollection) {
//                 data['venueId'] = parts[1];
//             } else {
//                 data['venueId'] = null; 
//                 debugPrint("Warning: Could not extract venueId from review path: $path. Path parts: ${parts.join('/')}. Expected structure: $_venuesCollection/{venueId}/$_reviewsSubCollection/{reviewId}");
//             }
//             data['venueName'] = null; 
//             userReviews.add(data);
//         }
//         return userReviews;
//     } catch (e) {
//         debugPrint("Error fetching reviews for user $userId: $e");
//         if (e is FirebaseException && (e.toString().toLowerCase().contains('index') || e.code == 'failed-precondition')) {
//             debugPrint("Firestore Error: An index is likely required for the query. Check Firebase console logs or index suggestions.");
//             throw Exception("Database index configuration needed. Please contact support or check logs.");
//         }
//         throw Exception("Could not load your reviews.");
//     }
//   }

//   Future<void> deleteReview(String venueId, String reviewId) async {
//     if (venueId.isEmpty || reviewId.isEmpty) throw ArgumentError("Venue ID and Review ID cannot be empty.");
//     try {
//        await _db.collection(_venuesCollection).doc(venueId).collection(_reviewsSubCollection).doc(reviewId).delete();
//     } catch (e) {
//        debugPrint("Error deleting review $reviewId for venue $venueId: $e");
//        throw Exception("Failed to delete review.");
//     }
//   }

//   Future<DocumentReference> addVenue(Map<String, dynamic> venueData) async {
//      try {
//         return await _db.collection(_venuesCollection).add(venueData);
//      } catch (e) {
//          debugPrint("Error adding venue in FirestoreService: $e");
//          throw Exception("Failed to add venue data.");
//      }
//    }

//   Future<void> updateVenue(String venueId, Map<String, dynamic> venueData) async {
//        if (venueId.isEmpty) throw Exception("Venue ID cannot be empty.");
//        try {
//           venueData['updatedAt'] = FieldValue.serverTimestamp();
//           await _db.collection(_venuesCollection).doc(venueId).update(venueData);
//        } catch (e) {
//            debugPrint("Error updating venue $venueId: $e");
//            throw Exception("Failed to update venue data.");
//        }
//   }

//    // <<<< EXISTING deleteVenue method - no changes needed, it's already good >>>>
//    Future<void> deleteVenue(String venueId) async {
//        if (venueId.isEmpty) throw Exception("Venue ID cannot be empty.");
//        try {
//            // If you need to delete subcollections (like all reviews for this venue), 
//            // you'd typically do this via a Firebase Function or iterate and delete.
//            // For simplicity here, we're just deleting the venue document.
//            await _db.collection(_venuesCollection).doc(venueId).delete();
//            debugPrint("Venue $venueId deleted successfully.");
//        } catch (e) {
//            debugPrint("Error deleting venue $venueId: $e");
//            throw Exception("Failed to delete venue data.");
//        }
//   }

//   // <<<< NEW METHOD >>>>
//   Future<List<Map<String, dynamic>>> getVenuesByCreator(String creatorUid) async {
//     if (creatorUid.isEmpty) return [];
//     try {
//       final querySnapshot = await _db
//           .collection(_venuesCollection)
//           .where('creatorUid', isEqualTo: creatorUid)
//           .orderBy('name') // Optionally order by name or createdAt
//           .get();

//       return querySnapshot.docs.map((doc) {
//         Map<String, dynamic> data = doc.data();
//         data['id'] = doc.id;
//         // Ensure essential fields used in MyVenuesScreen ListTile are present or defaulted
//         data['name'] = data['name'] ?? 'Unnamed Venue';
//         data['city'] = data['city'] ?? 'N/A';
//         data['isActive'] = data['isActive'] ?? false; // Default if not present
//         data['imageUrl'] = data['imageUrl'] as String?;
//         return data;
//       }).toList();
//     } catch (e) {
//       debugPrint("Error fetching venues for creator $creatorUid: $e");
//       if (e is FirebaseException && (e.toString().toLowerCase().contains('index') || e.code == 'failed-precondition')) {
//         debugPrint("Firestore Error: An index on 'creatorUid' (and 'name' if ordered) is likely required for collection '$_venuesCollection'.");
//         throw Exception("Database index required. ${e.message}");
//       }
//       throw Exception("Could not load your created venues.");
//     }
//   }
// }



//------admin venue name check based on location
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:mm_associates/core/services/location_service.dart';

class FirestoreService {
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  final LocationService _locationService = LocationService();

  static const String _usersCollection = 'mm_users';
  static const String _venuesCollection = 'mm_venues';
  static const String _reviewsSubCollection = 'mm_reviews';

  /// Checks if a venue name already exists within a specific city and area.
  ///
  /// This requires a composite index in Firestore on:
  /// `mm_venues`: `name_lowercase` (Ascending), `city` (Ascending), `area` (Ascending).
  Future<bool> checkVenueNameExists(String nameLowercase, String city, String area, String? currentVenueIdToExclude) async {
    // If identifying info is missing, a valid check can't be performed.
    // The form's validation should prevent this, but this is a safeguard.
    if (nameLowercase.isEmpty || city.isEmpty || area.isEmpty) {
      return false;
    }
    
    Query query = _db
        .collection(_venuesCollection)
        .where('name_lowercase', isEqualTo: nameLowercase)
        .where('city', isEqualTo: city)
        .where('area_lowercase', isEqualTo: area); // Assumes 'area' is stored consistently (e.g., trimmed)

    if (currentVenueIdToExclude != null) {
      query = query.where(FieldPath.documentId, isNotEqualTo: currentVenueIdToExclude);
    }
    
    final snapshot = await query.limit(1).get();
    debugPrint("Checking for venue: name='$nameLowercase', city='$city', area='$area'. Found: ${snapshot.docs.isNotEmpty}");
    return snapshot.docs.isNotEmpty;
  }

  Future<Map<String, dynamic>?> getUserData(String uid) async {
    try {
      DocumentSnapshot doc = await _db.collection(_usersCollection).doc(uid).get();
      if (doc.exists) {
        return doc.data() as Map<String, dynamic>?;
      }
      return null;
    } catch (e) {
      debugPrint('Error fetching user data for UID $uid from FirestoreService: $e');
      return null;
    }
  }

Future<List<Map<String, dynamic>>> getVenues({
    Position? userLocation,
    double? radiusInKm,
    String? cityFilter,
    String? searchQuery,
    String? sportFilter,
    int? limit,
    bool forSuggestions = false,
  }) async {
    try {
      Query query = _db.collection(_venuesCollection).where('isActive', isEqualTo: true);

      if (cityFilter != null && cityFilter.isNotEmpty) {
        query = query.where('city', isEqualTo: cityFilter);
        debugPrint("FirestoreService: Applying SERVER-SIDE city filter: '$cityFilter'");
      }

      final bool hasSearchQuery = searchQuery != null && searchQuery.trim().isNotEmpty;

      if (hasSearchQuery) {
        List<String> searchTerms = searchQuery.trim().toLowerCase().split(' ').where((term) => term.isNotEmpty).toSet().toList();
        if (searchTerms.isNotEmpty) {
          query = query.where('searchKeywords', arrayContainsAny: searchTerms.take(10).toList());
          debugPrint("FirestoreService: Applying SERVER-SIDE keyword search (arrayContainsAny on searchKeywords): $searchTerms");
        }
      }

      if (sportFilter != null && sportFilter.isNotEmpty) {
        if (!hasSearchQuery) { 
          query = query.where('sportType', arrayContains: sportFilter);
          debugPrint("FirestoreService: Applying SERVER-SIDE sport filter (arrayContains): '$sportFilter'");
        } else {
          debugPrint("FirestoreService: Sport filter ('$sportFilter') will be applied CLIENT-SIDE due to active keyword search.");
        }
      }
      
      // Default sort should usually be on a consistently available field
      // If `forSuggestions` or a keyword search is active, name is good.
      // Otherwise, you might want another default (e.g., creation date, popularity) if not already filtered heavily
      if ((forSuggestions && hasSearchQuery) || !hasSearchQuery ) {
          query = query.orderBy('name'); 
      }
      // If `hasSearchQuery` is true BUT `forSuggestions` is false (i.e., displaying search results, not just suggestions),
      // the server's keyword matching should ideally be good enough for initial order,
      // and client-side will refine with distance or other factors.
      // Or you might add more complex server-side ordering if your search engine supports it.

      if (limit != null && limit > 0) {
        query = query.limit(limit);
      }

      debugPrint("FirestoreService: Final Query (before .get()): ${query.parameters}"); 

      QuerySnapshot snapshot = await query.get();

      List<Map<String, dynamic>> fetchedVenues = snapshot.docs.map((doc) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        data['averageRating'] = data['averageRating'] ?? 0.0;
        data['reviewCount'] = data['reviewCount'] ?? 0;
        return data;
      }).toList();

      debugPrint("FirestoreService: Fetched ${fetchedVenues.length} venues from server (Query: '$searchQuery', Limit: $limit, ForSuggestions: $forSuggestions)");
      
      List<Map<String, dynamic>> results = fetchedVenues;

      // Client-side filtering if sportFilter was not applied on server
      if (hasSearchQuery && sportFilter != null && sportFilter.isNotEmpty) {
        String lowerCaseSportFilter = sportFilter.trim().toLowerCase();
        results = results.where((venue) {
          final List<String> sportTypesInVenue = (venue['sportType'] as List<dynamic>?)
              ?.whereType<String>().map((s) => s.toLowerCase()).toList() ?? [];
          return sportTypesInVenue.contains(lowerCaseSportFilter);
        }).toList();
        debugPrint("FirestoreService: Applied CLIENT-SIDE sport filter. Results count: ${results.length}");
      }
      // Client-side refinement of search query IF NEEDED (usually server 'searchKeywords' is enough)
      // if (hasSearchQuery && !forSuggestions && results.isNotEmpty) {
      //     String fullQueryLower = searchQuery.trim().toLowerCase();
      //     results = results.where((venue) {
      //         final String name = (venue['name'] as String? ?? '').toLowerCase();
      //         // Add other fields to search client-side if needed, e.g., description
      //         return name.contains(fullQueryLower);
      //     }).toList();
      //     debugPrint("FirestoreService: Applied CLIENT-SIDE query refinement. Results count: ${results.length}");
      // }


      if (userLocation != null) {
        for (var venue in results) {
          final GeoPoint? venueGeoPoint = venue['location'] as GeoPoint?;
          double? venueLat, venueLng;

          if (venueGeoPoint != null) {
            venueLat = venueGeoPoint.latitude;
            venueLng = venueGeoPoint.longitude;
          }
          // Remove num checks for lat/lng if 'location' GeoPoint is always primary source

          if (venueLat != null && venueLng != null) {
            try {
              venue['distance'] = _locationService.calculateDistance(
                userLocation.latitude, userLocation.longitude, venueLat, venueLng,
              );
            } catch (e) {
              debugPrint("Error calculating distance for venue ${venue['id']}: $e");
              venue['distance'] = null;
            }
          } else {
            venue['distance'] = null;
          }
        }
      }

      if (radiusInKm != null && userLocation != null && results.any((v) => v['distance'] != null)) {
        if (!hasSearchQuery && (sportFilter == null || sportFilter.isEmpty)) { 
          debugPrint("FirestoreService: Applying proximity filter (radius: $radiusInKm km)");
          results = results.where((venue) {
            final distance = venue['distance'] as double?;
            return distance != null && distance <= radiusInKm;
          }).toList();
        }
      }

      if (results.isNotEmpty) {
        results.sort((a, b) {
          final distA = a['distance'] as double?;
          final distB = b['distance'] as double?;

          if (userLocation != null) {
            if (distA != null && distB != null) {
              int distComparison = distA.compareTo(distB);
              if (distComparison != 0) return distComparison;
            } else if (distA != null) { return -1; } 
            else if (distB != null) { return 1;  } 
          }

          final String nameA = (a['name'] as String? ?? '').toLowerCase();
          final String nameB = (b['name'] as String? ?? '').toLowerCase();
          return nameA.compareTo(nameB);
        });
      }

      return results;

    } catch (e) {
      debugPrint("Error getting venues from FirestoreService: $e");
      if (e is FirebaseException && (e.toString().toLowerCase().contains('index') || e.code == 'failed-precondition')) {
        debugPrint("Firestore Error Details: Code: ${e.code}, Message: ${e.message}");
        debugPrint("An index is likely required. Check Firestore console for index creation suggestions or errors in logs.");
        throw Exception("Database query failed (likely missing index). Details: ${e.message}");
      }
      throw Exception("Failed to retrieve venues: ${e.toString()}");
    }
  }

  Future<Map<String, dynamic>?> getVenueDetails(String venueId) async {
     try {
       DocumentSnapshot doc = await _db.collection(_venuesCollection).doc(venueId).get();
       if (doc.exists) {
         Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
         data['id'] = doc.id;
         data['averageRating'] = data['averageRating'] ?? 0.0;
         data['reviewCount'] = data['reviewCount'] ?? 0;
         return data;
       }
       return null;
     } catch (e) {
       debugPrint('Error fetching venue details for ID $venueId: $e');
       rethrow;
     }
   }

  Future<void> addReviewForVenue(String venueId, String userId, String userName, double rating, String? comment) async {
      if (venueId.isEmpty || userId.isEmpty || userName.isEmpty) {
          throw Exception("Missing required review data.");
      }
      try {
          final reviewData = {
              'userId': userId,
              'userName': userName,
              'rating': rating,
              'venueId': venueId, 
              'createdAt': FieldValue.serverTimestamp(),
              'updatedAt': FieldValue.serverTimestamp(), 
              if (comment != null && comment.trim().isNotEmpty) 'comment': comment.trim(),
          };
          await _db.collection(_venuesCollection).doc(venueId).collection(_reviewsSubCollection).add(reviewData);
          debugPrint("Review added successfully for venue $venueId by user $userId");
      } catch (e) {
          debugPrint("Error adding review for venue $venueId by user $userId: $e");
          if (e is FirebaseException) {
            throw FirebaseException(
              plugin: e.plugin,
              code: e.code,
              message: "Failed to submit review for $venueId. ${e.message}"
            );
          }
          throw Exception("Failed to submit review for $venueId.");
      }
  }

  Future<List<Map<String, dynamic>>> getReviewsForVenue(String venueId, {int limit = 20}) async {
    if (venueId.isEmpty) return [];
    try {
        QuerySnapshot snapshot = await _db.collection(_venuesCollection).doc(venueId)
            .collection(_reviewsSubCollection).orderBy('createdAt', descending: true).limit(limit).get();
        return snapshot.docs.map((doc) {
            Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
            data['id'] = doc.id;
            return data;
        }).toList();
    } catch (e) {
        debugPrint("Error fetching reviews for venue $venueId: $e");
        throw Exception("Could not load reviews.");
    }
  }

  Future<List<Map<String, dynamic>>> getReviewsByUser(String userId, {int limit = 50}) async {
    if (userId.isEmpty) return [];
    try {
        QuerySnapshot snapshot = await _db.collectionGroup(_reviewsSubCollection)
            .where('userId', isEqualTo: userId)
            .orderBy('createdAt', descending: true)
            .limit(limit)
            .get();

        List<Map<String, dynamic>> userReviews = [];
        for (var doc in snapshot.docs) {
            Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
            data['id'] = doc.id;
            String path = doc.reference.path;
            List<String> parts = path.split('/');
            if (parts.length >= 4 && parts[0] == _venuesCollection && parts[2] == _reviewsSubCollection) {
                data['venueId'] = parts[1];
            } else {
                data['venueId'] = null; 
                debugPrint("Warning: Could not extract venueId from review path: $path. Path parts: ${parts.join('/')}. Expected structure: $_venuesCollection/{venueId}/$_reviewsSubCollection/{reviewId}");
            }
            data['venueName'] = null; 
            userReviews.add(data);
        }
        return userReviews;
    } catch (e) {
        debugPrint("Error fetching reviews for user $userId: $e");
        if (e is FirebaseException && (e.toString().toLowerCase().contains('index') || e.code == 'failed-precondition')) {
            debugPrint("Firestore Error: An index is likely required for the query. Check Firebase console logs or index suggestions.");
            throw Exception("Database index configuration needed. Please contact support or check logs.");
        }
        throw Exception("Could not load your reviews.");
    }
  }

  Future<void> deleteReview(String venueId, String reviewId) async {
    if (venueId.isEmpty || reviewId.isEmpty) throw ArgumentError("Venue ID and Review ID cannot be empty.");
    try {
       await _db.collection(_venuesCollection).doc(venueId).collection(_reviewsSubCollection).doc(reviewId).delete();
    } catch (e) {
       debugPrint("Error deleting review $reviewId for venue $venueId: $e");
       throw Exception("Failed to delete review.");
    }
  }

  Future<DocumentReference> addVenue(Map<String, dynamic> venueData) async {
     try {
        return await _db.collection(_venuesCollection).add(venueData);
     } catch (e) {
         debugPrint("Error adding venue in FirestoreService: $e");
         throw Exception("Failed to add venue data.");
     }
   }

  Future<void> updateVenue(String venueId, Map<String, dynamic> venueData) async {
       if (venueId.isEmpty) throw Exception("Venue ID cannot be empty.");
       try {
          venueData['updatedAt'] = FieldValue.serverTimestamp();
          await _db.collection(_venuesCollection).doc(venueId).update(venueData);
       } catch (e) {
           debugPrint("Error updating venue $venueId: $e");
           throw Exception("Failed to update venue data.");
       }
  }

   // <<<< EXISTING deleteVenue method - no changes needed, it's already good >>>>
   Future<void> deleteVenue(String venueId) async {
       if (venueId.isEmpty) throw Exception("Venue ID cannot be empty.");
       try {
           // If you need to delete subcollections (like all reviews for this venue), 
           // you'd typically do this via a Firebase Function or iterate and delete.
           // For simplicity here, we're just deleting the venue document.
           await _db.collection(_venuesCollection).doc(venueId).delete();
           debugPrint("Venue $venueId deleted successfully.");
       } catch (e) {
           debugPrint("Error deleting venue $venueId: $e");
           throw Exception("Failed to delete venue data.");
       }
  }

  // <<<< NEW METHOD >>>>
  Future<List<Map<String, dynamic>>> getVenuesByCreator(String creatorUid) async {
    if (creatorUid.isEmpty) return [];
    try {
      final querySnapshot = await _db
          .collection(_venuesCollection)
          .where('creatorUid', isEqualTo: creatorUid)
          .orderBy('name') // Optionally order by name or createdAt
          .get();

      return querySnapshot.docs.map((doc) {
        Map<String, dynamic> data = doc.data();
        data['id'] = doc.id;
        // Ensure essential fields used in MyVenuesScreen ListTile are present or defaulted
        data['name'] = data['name'] ?? 'Unnamed Venue';
        data['city'] = data['city'] ?? 'N/A';
        data['isActive'] = data['isActive'] ?? false; // Default if not present
        data['imageUrl'] = data['imageUrl'] as String?;
        return data;
      }).toList();
    } catch (e) {
      debugPrint("Error fetching venues for creator $creatorUid: $e");
      if (e is FirebaseException && (e.toString().toLowerCase().contains('index') || e.code == 'failed-precondition')) {
        debugPrint("Firestore Error: An index on 'creatorUid' (and 'name' if ordered) is likely required for collection '$_venuesCollection'.");
        throw Exception("Database index required. ${e.message}");
      }
      throw Exception("Could not load your created venues.");
    }
  }
}


===== features\favorites\screens\favorites_screen.dart =====

import 'package:flutter/material.dart';
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:mm_associates/features/home/screens/venue_detail_screen.dart'; // Reuse venue detail screen

class FavoritesScreen extends StatefulWidget {
  const FavoritesScreen({super.key});

  @override
  State<FavoritesScreen> createState() => _FavoritesScreenState();
}

class _FavoritesScreenState extends State<FavoritesScreen> {
  final UserService _userService = UserService();
  List<Map<String, dynamic>> _favoriteVenues = [];
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _loadFavorites();
  }

  Future<void> _loadFavorites() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    try {
      final venues = await _userService.getFavoriteVenues();
      if (mounted) {
        setState(() {
          _favoriteVenues = venues;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = e.toString().replaceFirst("Exception: ", "");
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Favorite Venues'),
      ),
      body: RefreshIndicator(
        onRefresh: _loadFavorites,
        child: _buildBody(),
      ),
    );
  }

  Widget _buildBody() {
     if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_errorMessage != null) {
       return Center(
         child: Padding(
           padding: const EdgeInsets.all(16.0),
           child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.error_outline, color: Colors.red, size: 50),
                  const SizedBox(height: 10),
                  Text(_errorMessage!, style: const TextStyle(color: Colors.redAccent), textAlign: TextAlign.center),
                  const SizedBox(height: 10),
                  ElevatedButton.icon(onPressed: _loadFavorites, icon: const Icon(Icons.refresh), label: const Text("Try Again"))
               ],
           ),
         ),
       );
    }

    if (_favoriteVenues.isEmpty) {
      return Center(
         child: Padding(
           padding: const EdgeInsets.all(20.0),
           child: Column(
             mainAxisAlignment: MainAxisAlignment.center,
             children: [
               Icon(Icons.favorite_border, color: Colors.grey[400], size: 60),
               const SizedBox(height: 15),
               Text(
                 'You haven\'t favorited any venues yet.',
                 textAlign: TextAlign.center,
                 style: TextStyle(fontSize: 17, color: Colors.grey[600]),
               ),
                const SizedBox(height: 10),
               const Text( "Tap the heart icon on a venue to add it here.", style: TextStyle(color: Colors.grey), textAlign: TextAlign.center,)
             ],
           ),
         ),
       );
    }

    // Use ListView for favorites
    return ListView.builder(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        itemCount: _favoriteVenues.length,
        itemBuilder: (context, index) {
          final venue = _favoriteVenues[index];
          return _buildFavoriteVenueTile(venue);
        },
      );
  }

  // Using ListTile for favorites screen for potentially longer text
   Widget _buildFavoriteVenueTile(Map<String, dynamic> venue) {
      final String name = venue['name'] as String? ?? 'Unnamed Venue';
      final dynamic sportRaw = venue['sportType'];
      String sport = (sportRaw is List) ? sportRaw.join(', ') : (sportRaw as String? ?? 'Various');
      final String city = venue['city'] as String? ?? '';
      final String address = venue['address'] as String? ?? 'No address';
      final String venueId = venue['id'] as String? ?? '';
      final String? imageUrl = venue['imageUrl'] as String?;
       // Assuming averageRating and reviewCount might be on the venue data now
      final double averageRating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;
      final int reviewCount = (venue['reviewCount'] as num?)?.toInt() ?? 0;


       return Card( // Wrap ListTile in Card for better separation
          margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          elevation: 1.5,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          child: ListTile(
               contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
              leading: SizedBox( // Control size of the leading image
                 width: 60,
                 height: 60,
                 child: ClipRRect(
                    borderRadius: BorderRadius.circular(6),
                    child: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
                       ? Image.network(
                          imageUrl,
                          fit: BoxFit.cover,
                          loadingBuilder: (context, child, progress) => progress == null ? child : Center(child: CircularProgressIndicator(strokeWidth: 2, value: progress.expectedTotalBytes != null ? progress.cumulativeBytesLoaded / progress.expectedTotalBytes! : null)),
                          errorBuilder: (_, __, ___) => Container(color: Colors.grey[200], child: Icon(Icons.sports_rounded, color: Colors.grey[400])),
                         )
                       : Container(color: Colors.grey[200], child: Icon(Icons.sports_rounded, color: Colors.grey[400])),
                  ),
               ),
               title: Text(name, style: const TextStyle(fontWeight: FontWeight.w600)),
               subtitle: Column(
                   crossAxisAlignment: CrossAxisAlignment.start,
                   children: [
                      const SizedBox(height: 4),
                      Text("$sport - $address, $city", maxLines: 1, overflow: TextOverflow.ellipsis, style: TextStyle(fontSize: 13, color: Colors.grey[700])),
                       if (reviewCount > 0) ...[
                         const SizedBox(height: 4),
                         Row(
                            children: [
                              Icon(Icons.star, color: Colors.amber, size: 16),
                              const SizedBox(width: 4),
                              Text(averageRating.toStringAsFixed(1), style: const TextStyle(fontWeight: FontWeight.w500)),
                              const SizedBox(width: 4),
                              Text("($reviewCount reviews)", style: TextStyle(fontSize: 12, color: Colors.grey[600])),
                             ],
                           ),
                       ],
                    ]
                  ),
               trailing: const Icon(Icons.chevron_right, color: Colors.grey),
               onTap: () {
                 Navigator.push(
                     context,
                     MaterialPageRoute(
                       builder: (context) => VenueDetailScreen(
                          venueId: venueId,
                          initialVenueData: venue,
                          heroTagContext: 'favorite_list',
                        ),
                      ),
                   ).then((_) {
                        // Refresh favorites list if a venue was removed from favorites on detail screen
                        // A more robust way would use Streams or state management
                         _loadFavorites();
                   });
                },
            ),
       );
    }
}


===== features\home\screens\city_selection_screen.dart =====

// import 'package:flutter/material.dart';

// class CityInfo {
//   final String name;
//   final IconData icon; 

//   CityInfo({
//     required this.name,
//     required this.icon,
//   });
// }

// class CitySelectionScreen extends StatefulWidget {
//   final String? currentSelectedCity;

//   const CitySelectionScreen({Key? key, this.currentSelectedCity}) : super(key: key);

//   @override
//   State<CitySelectionScreen> createState() => _CitySelectionScreenState();
// }

// class _CitySelectionScreenState extends State<CitySelectionScreen> {
//   final TextEditingController _searchController = TextEditingController();
//   late List<CityInfo> _filteredCities;

//   // IMPORTANT: This is an expanded example list with corrected and UNIQUE icons.
//   // CUSTOMIZE this list with cities relevant to your app.
//   // For actual logos, replace IconData with image asset paths.
//   // To use these icons on the HomeScreen, the HomeScreen will need access to this
//   // list (or a similar data structure) to map the returned city name to its icon.
//   // Consider making this list accessible globally or passing it to the HomeScreen.
//   final List<CityInfo> _allCities = [
//     // Metros & Tier 1 (Examples) - Icons have been changed for uniqueness
//     CityInfo(name: 'Agra', icon: Icons.camera_alt_outlined), // Taj Mahal (unique)
//     CityInfo(name: 'Ahmedabad', icon: Icons.architecture_outlined), // Sidi Saiyyed Mosque / Sabarmati Ashram (unique)
//     CityInfo(name: 'Aligarh', icon: Icons.lock_open_outlined), // Locks / University (unique)
//     CityInfo(name: 'Allahabad (Prayagraj)', icon: Icons.waves_outlined),// Sangam (unique)
//     CityInfo(name: 'Amritsar', icon: Icons.temple_hindu_outlined), // Golden Temple (generic temple, unique instance)
//     CityInfo(name: 'Aurangabad', icon: Icons.landscape_outlined), // Ajanta/Ellora nearby (unique)
//     CityInfo(name: 'Bangalore', icon: Icons.laptop_chromebook_outlined), // IT Hub (unique)
//     CityInfo(name: 'Bhopal', icon: Icons.water_drop_outlined), // City of Lakes (unique)
//     CityInfo(name: 'Bhubaneswar', icon: Icons.account_balance_outlined), // Temple City (unique)
//     CityInfo(name: 'Chandigarh', icon: Icons.grid_on_outlined),// Planned City / Rock Garden (unique)
//     CityInfo(name: 'Chennai', icon: Icons.beach_access_outlined), // Marina Beach / Temples (unique)
//     CityInfo(name: 'Coimbatore', icon: Icons.texture_outlined), // Textiles (unique)
//     CityInfo(name: 'Dehradun', icon: Icons.forest_outlined), // Doon Valley / IMA (unique)
//     CityInfo(name: 'Delhi', icon: Icons.flag_outlined), // India Gate / Capital (unique)
//     CityInfo(name: 'Dhanbad', icon: Icons.construction_outlined), // Coal Capital (unique)
//     CityInfo(name: 'Faridabad', icon: Icons.precision_manufacturing_outlined), // Industrial (unique)
//     CityInfo(name: 'Ghaziabad', icon: Icons.apartment_outlined), // NCR City (unique)
//     CityInfo(name: 'Gurgaon (Gurugram)', icon: Icons.business_center_outlined), // Corporate Hub (unique)
//     CityInfo(name: 'Guwahati', icon: Icons.self_improvement_outlined), // Kamakhya Temple (unique)
//     CityInfo(name: 'Gwalior', icon: Icons.shield_outlined), // Gwalior Fort (unique)
//     CityInfo(name: 'Howrah', icon: Icons.train_outlined), // Howrah Station (unique)
//     CityInfo(name: 'Hyderabad', icon: Icons.castle_outlined), // Charminar (unique)
//     CityInfo(name: 'Indore', icon: Icons.cleaning_services_outlined), // Cleanest City / Rajwada (unique)
//     CityInfo(name: 'Jabalpur', icon: Icons.layers_outlined), // Marble Rocks (unique)
//     CityInfo(name: 'Jaipur', icon: Icons.fort_outlined), // Hawa Mahal / Amber Fort (unique)
//     CityInfo(name: 'Jalandhar', icon: Icons.sports_soccer_outlined), // Sports Industry (unique)
//     CityInfo(name: 'Jodhpur', icon: Icons.brightness_3_outlined), // Blue City / Mehrangarh Fort (unique)
//     CityInfo(name: 'Kanpur', icon: Icons.factory_outlined), // Industrial City (unique)
//     CityInfo(name: 'Kochi (Cochin)', icon: Icons.sailing_outlined), // Chinese Fishing Nets / Backwaters (unique)
//     CityInfo(name: 'Kolkata', icon: Icons.museum_outlined), // Howrah Bridge / Victoria Memorial (unique, architecture_outlined used for Ahmedabad)
//     CityInfo(name: 'Kota', icon: Icons.school_outlined), // Coaching Hub (unique)
//     CityInfo(name: 'Lucknow', icon: Icons.mosque_outlined), // Bara Imambara (unique)
//     CityInfo(name: 'Ludhiana', icon: Icons.agriculture_outlined), // Industrial / Agricultural Hub (unique)
//     CityInfo(name: 'Madurai', icon: Icons.brightness_7_outlined), // Meenakshi Temple (unique)
//     CityInfo(name: 'Meerut', icon: Icons.sports_kabaddi_outlined), // Sports Goods / Historical (unique)
//     CityInfo(name: 'Mumbai', icon: Icons.account_balance_wallet_outlined), // Gateway of India / Financial Capital (unique)
//     CityInfo(name: 'Mysore (Mysuru)', icon: Icons.palette_outlined), // Mysore Palace (unique)
//     CityInfo(name: 'Nagpur', icon: Icons.public_outlined), // Central location / "Orange City" (generic, unique)
//     CityInfo(name: 'Nashik', icon: Icons.wine_bar_outlined), // Vineyards / Temples (unique)
//     CityInfo(name: 'Patna', icon: Icons.history_edu_outlined), // Golghar / Ancient City (unique)
//     CityInfo(name: 'Pune', icon: Icons.computer_outlined), // IT / Shaniwar Wada (unique)
//     CityInfo(name: 'Raipur', icon: Icons.park_outlined), // City with many parks (unique)
//     CityInfo(name: 'Rajkot', icon: Icons.engineering_outlined), // Engineering Hub (unique)
//     CityInfo(name: 'Ranchi', icon: Icons.waterfall_chart_outlined), // Waterfalls (unique)
//     CityInfo(name: 'Salem', icon: Icons.terrain_outlined), // Steel City / Yercaud Hills nearby (unique)
//     CityInfo(name: 'Srinagar', icon: Icons.downhill_skiing_outlined), // Dal Lake / Mountains (unique, landscape_outlined used for Aurangabad)
//     CityInfo(name: 'Surat', icon: Icons.diamond_outlined), // Diamond Industry (unique)
//     CityInfo(name: 'Thane', icon: Icons.directions_boat_outlined), // Lakes (unique, was waves, waves is used for Allahabad)
//     CityInfo(name: 'Tiruchirappalli', icon: Icons.security_outlined), // Rockfort Temple (generic fort-like, unique, fort_outlined used for Jaipur/Warangal)
//     CityInfo(name: 'Vadodara', icon: Icons.color_lens_outlined), // Art / Palace (unique)
//     CityInfo(name: 'Varanasi', icon: Icons.waving_hand_outlined), // Ghats / Spiritual (unique)
//     CityInfo(name: 'Vijayawada', icon: Icons.brightness_6_outlined),// Kanaka Durga (unique)
//     CityInfo(name: 'Visakhapatnam', icon: Icons.anchor_outlined),// Port City / Beaches (unique)
//     CityInfo(name: 'Warangal', icon: Icons.foundation_outlined), // Warangal Fort / Thousand Pillar Temple (unique)

//     // Add more cities as per your app's target audience and scope!
//     // Ensure each new city gets a unique icon.
//   ];


//   @override
//   void initState() {
//     super.initState();
//     // Sort cities alphabetically by name
//     _allCities.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
//     _filteredCities = _allCities;
//     _searchController.addListener(_filterCities);
//   }

//   @override
//   void dispose() {
//     _searchController.removeListener(_filterCities);
//     _searchController.dispose();
//     super.dispose();
//   }

//   void _filterCities() {
//     final query = _searchController.text.toLowerCase();
//     setState(() {
//       _filteredCities = _allCities.where((city) {
//         return city.name.toLowerCase().contains(query);
//       }).toList();
//     });
//   }

//   void _onCitySelected(String? cityName) {
//     // Returns the city name (or null for "Near Me").
//     // The HomeScreen will then need to use this cityName to find the
//     // corresponding CityInfo object (from a list like _allCities) to get its icon.
//     Navigator.pop(context, cityName);
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     return Scaffold(
//       appBar: AppBar(
//         title: const Text('Select Location'),
//         elevation: 1.0,
//         bottom: PreferredSize(
//           preferredSize: const Size.fromHeight(60.0), // Height for the search bar container
//           child: Padding(
//             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
//             child: Center( // Center the TextField
//               child: SizedBox(
//                 child: TextField(
//                   controller: _searchController,
//                   decoration: InputDecoration(
//                     hintText: 'Search city...',
//                     prefixIcon: const Icon(Icons.search),
//                     border: OutlineInputBorder(
//                       borderRadius: BorderRadius.circular(30.0),
//                       borderSide: BorderSide.none,
//                     ),
//                     filled: true,
//                     fillColor: theme.brightness == Brightness.dark
//                         ? Colors.grey[800]
//                         : Colors.grey[200],
//                     contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 20),
//                   ),
//                   textAlignVertical: TextAlignVertical.center,
//                 ),
//               ),
//             ),
//           ),
//         ),
//       ),
//       body: ListView.separated(
//         itemCount: _filteredCities.length + 1, // +1 for "Near Me" option
//         separatorBuilder: (context, index) => const Divider(height: 1, indent: 16, endIndent: 16),
//         itemBuilder: (context, index) {
//           // "Near Me" option as the first item
//           if (index == 0) {
//             bool isSelected = widget.currentSelectedCity == null;
//             return ListTile(
//               leading: Icon(
//                 Icons.my_location, // This icon can remain standard for "Near Me"
//                 color: isSelected ? theme.primaryColor : theme.iconTheme.color,
//               ),
//               title: Text(
//                 'Near Me',
//                 style: TextStyle(
//                   fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
//                   color: isSelected ? theme.primaryColor : theme.textTheme.bodyLarge?.color,
//                 ),
//               ),
//               selected: isSelected,
//               selectedTileColor: isSelected ? theme.primaryColor.withOpacity(0.1) : null,
//               onTap: () {
//                 _onCitySelected(null); // null signifies "Near Me" behavior in HomeScreen
//               },
//             );
//           }

//           // City items
//           final city = _filteredCities[index - 1];
//           bool isSelected = widget.currentSelectedCity == city.name;

//           return ListTile(
//             // Example for using actual image assets:
//             // leading: Image.asset(city.logoAssetPath, width: 30, height: 30, fit: BoxFit.contain),
//             leading: Icon(
//               city.icon, // Now uses the unique icon assigned
//               color: isSelected ? theme.primaryColor : theme.iconTheme.color,
//               size: 28,
//             ),
//             title: Text(
//               city.name,
//               style: TextStyle(
//                 fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
//                 color: isSelected ? theme.primaryColor : theme.textTheme.bodyLarge?.color,
//               ),
//             ),
//             selected: isSelected,
//             selectedTileColor: isSelected ? theme.primaryColor.withOpacity(0.1) : null,
//             onTap: () {
//               _onCitySelected(city.name);
//             },
//           );
//         },
//       ),
//     );
//   }
// }

// File: lib/features/home/screens/city_selection_screen.dart
import 'package:flutter/material.dart';

// Data model for city information.
class CityInfo {
  final String name;
  final IconData icon;

  const CityInfo({ // Made constructor const
    required this.name,
    required this.icon,
  });
}

// Moved the list of cities here to be globally accessible and pre-sorted.
// This list is the source of truth for city data including icons.
// You can keep this list updated here.
final List<CityInfo> kAppAllCities = [
  // Metros & Tier 1 (Examples) - Icons have been changed for uniqueness
  CityInfo(name: 'Agra', icon: Icons.camera_alt_outlined),
  CityInfo(name: 'Ahmedabad', icon: Icons.architecture_outlined),
  CityInfo(name: 'Aligarh', icon: Icons.lock_open_outlined),
  CityInfo(name: 'Allahabad (Prayagraj)', icon: Icons.waves_outlined),
  CityInfo(name: 'Amritsar', icon: Icons.temple_hindu_outlined),
  CityInfo(name: 'Aurangabad', icon: Icons.landscape_outlined),
  CityInfo(name: 'Bangalore', icon: Icons.laptop_chromebook_outlined),
  CityInfo(name: 'Bhopal', icon: Icons.water_drop_outlined),
  CityInfo(name: 'Bhubaneswar', icon: Icons.account_balance_outlined),
  CityInfo(name: 'Chandigarh', icon: Icons.grid_on_outlined),
  CityInfo(name: 'Chennai', icon: Icons.beach_access_outlined),
  CityInfo(name: 'Coimbatore', icon: Icons.texture_outlined),
  CityInfo(name: 'Dehradun', icon: Icons.forest_outlined),
  CityInfo(name: 'Delhi', icon: Icons.flag_outlined),
  CityInfo(name: 'Dhanbad', icon: Icons.construction_outlined),
  CityInfo(name: 'Faridabad', icon: Icons.precision_manufacturing_outlined),
  CityInfo(name: 'Ghaziabad', icon: Icons.apartment_outlined),
  CityInfo(name: 'Gurgaon (Gurugram)', icon: Icons.business_center_outlined),
  CityInfo(name: 'Guwahati', icon: Icons.self_improvement_outlined),
  CityInfo(name: 'Gwalior', icon: Icons.shield_outlined),
  CityInfo(name: 'Howrah', icon: Icons.train_outlined),
  CityInfo(name: 'Hyderabad', icon: Icons.castle_outlined),
  CityInfo(name: 'Indore', icon: Icons.cleaning_services_outlined),
  CityInfo(name: 'Jabalpur', icon: Icons.layers_outlined),
  CityInfo(name: 'Jaipur', icon: Icons.fort_outlined),
  CityInfo(name: 'Jalandhar', icon: Icons.sports_soccer_outlined),
  CityInfo(name: 'Jodhpur', icon: Icons.brightness_3_outlined),
  CityInfo(name: 'Kanpur', icon: Icons.factory_outlined),
  CityInfo(name: 'Kochi (Cochin)', icon: Icons.sailing_outlined),
  CityInfo(name: 'Kolkata', icon: Icons.museum_outlined),
  CityInfo(name: 'Kota', icon: Icons.school_outlined),
  CityInfo(name: 'Lucknow', icon: Icons.mosque_outlined),
  CityInfo(name: 'Ludhiana', icon: Icons.agriculture_outlined),
  CityInfo(name: 'Madurai', icon: Icons.brightness_7_outlined),
  CityInfo(name: 'Meerut', icon: Icons.sports_kabaddi_outlined),
  CityInfo(name: 'Mumbai', icon: Icons.account_balance_wallet_outlined),
  CityInfo(name: 'Mysore (Mysuru)', icon: Icons.palette_outlined),
  CityInfo(name: 'Nagpur', icon: Icons.public_outlined),
  CityInfo(name: 'Nashik', icon: Icons.wine_bar_outlined),
  CityInfo(name: 'Patna', icon: Icons.history_edu_outlined),
  CityInfo(name: 'Pune', icon: Icons.computer_outlined),
  CityInfo(name: 'Raipur', icon: Icons.park_outlined),
  CityInfo(name: 'Rajkot', icon: Icons.engineering_outlined),
  CityInfo(name: 'Ranchi', icon: Icons.waterfall_chart_outlined),
  CityInfo(name: 'Salem', icon: Icons.terrain_outlined),
  CityInfo(name: 'Srinagar', icon: Icons.downhill_skiing_outlined),
  CityInfo(name: 'Surat', icon: Icons.diamond_outlined),
  CityInfo(name: 'Thane', icon: Icons.directions_boat_outlined),
  CityInfo(name: 'Tiruchirappalli', icon: Icons.security_outlined),
  CityInfo(name: 'Vadodara', icon: Icons.color_lens_outlined),
  CityInfo(name: 'Varanasi', icon: Icons.waving_hand_outlined),
  CityInfo(name: 'Vijayawada', icon: Icons.brightness_6_outlined),
  CityInfo(name: 'Visakhapatnam', icon: Icons.anchor_outlined),
  CityInfo(name: 'Warangal', icon: Icons.foundation_outlined),
  // Add more cities as per your app's target audience and scope!
  // Ensure each new city gets a unique icon.
]..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase())); // Sort the list once here

class CitySelectionScreen extends StatefulWidget {
  final String? currentSelectedCity;

  const CitySelectionScreen({Key? key, this.currentSelectedCity}) : super(key: key);

  @override
  State<CitySelectionScreen> createState() => _CitySelectionScreenState();
}

class _CitySelectionScreenState extends State<CitySelectionScreen> {
  final TextEditingController _searchController = TextEditingController();
  late List<CityInfo> _filteredCities;

  // Note: _allCities instance variable is removed from here.
  // We will use kAppAllCities (the global final list) as the source.

  @override
  void initState() {
    super.initState();
    // Initialize _filteredCities with all cities from the globally sorted list
    _filteredCities = List.from(kAppAllCities);
    _searchController.addListener(_filterCities);
  }

  @override
  void dispose() {
    _searchController.removeListener(_filterCities);
    _searchController.dispose();
    super.dispose();
  }

  void _filterCities() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      // Filter from the original kAppAllCities list
      _filteredCities = kAppAllCities.where((city) {
        return city.name.toLowerCase().contains(query);
      }).toList();
    });
  }

  void _onCitySelected(String? cityName) {
    Navigator.pop(context, cityName);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select Location'),
        elevation: 1.0,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(60.0),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: Center(
              child: SizedBox(
                child: TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: 'Search city...',
                    prefixIcon: const Icon(Icons.search),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(30.0),
                      borderSide: BorderSide.none,
                    ),
                    filled: true,
                    fillColor: theme.brightness == Brightness.dark
                        ? Colors.grey[800]
                        : Colors.grey[200],
                    contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 20),
                  ),
                  textAlignVertical: TextAlignVertical.center,
                ),
              ),
            ),
          ),
        ),
      ),
      body: ListView.separated(
        itemCount: _filteredCities.length + 1, // +1 for "Near Me" option
        separatorBuilder: (context, index) => const Divider(height: 1, indent: 16, endIndent: 16),
        itemBuilder: (context, index) {
          if (index == 0) {
            bool isSelected = widget.currentSelectedCity == null;
            return ListTile(
              leading: Icon(
                Icons.my_location,
                color: isSelected ? theme.primaryColor : theme.iconTheme.color,
              ),
              title: Text(
                'Near Me',
                style: TextStyle(
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                  color: isSelected ? theme.primaryColor : theme.textTheme.bodyLarge?.color,
                ),
              ),
              selected: isSelected,
              selectedTileColor: isSelected ? theme.primaryColor.withOpacity(0.1) : null,
              onTap: () {
                _onCitySelected(null);
              },
            );
          }
          final city = _filteredCities[index - 1];
          bool isSelected = widget.currentSelectedCity == city.name;
          return ListTile(
            leading: Icon(
              city.icon, // Uses the icon from CityInfo
              color: isSelected ? theme.primaryColor : theme.iconTheme.color,
              size: 28,
            ),
            title: Text(
              city.name,
              style: TextStyle(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: isSelected ? theme.primaryColor : theme.textTheme.bodyLarge?.color,
              ),
            ),
            selected: isSelected,
            selectedTileColor: isSelected ? theme.primaryColor.withOpacity(0.1) : null,
            onTap: () {
              _onCitySelected(city.name);
            },
          );
        },
      ),
    );
  }
}


===== features\home\screens\home_gate.dart =====


import 'package:flutter/material.dart';
import 'package:mm_associates/features/home/screens/home_screen.dart';
import 'package:mm_associates/features/home/screens/venue_form.dart';
import 'package:mm_associates/features/user/services/user_service.dart';

class HomeGate extends StatefulWidget {
  const HomeGate({super.key});

  @override
  State<HomeGate> createState() => _HomeGateState();
}

class _HomeGateState extends State<HomeGate> {
  final UserService _userService = UserService();
  late Future<bool> _isAdminFuture;

  @override
  void initState() {
    super.initState();
    // Initialize the future in initState to prevent it from being called
    // on every rebuild.
    _isAdminFuture = _userService.isCurrentUserAdmin();
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<bool>(
      future: _isAdminFuture,
      builder: (context, snapshot) {
        // While waiting for the future to resolve, show a loading screen.
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(
              child: CircularProgressIndicator(),
            ),
          );
        }

        // If there's an error, show the standard user screen for safety.
        if (snapshot.hasError) {
          debugPrint("Error in HomeGate FutureBuilder: ${snapshot.error}");
          // Show non-admin home screen, without the 'Add Venue' button.
          return const HomeScreen(showAddVenueButton: false);
        }

        final bool isAdmin = snapshot.data ?? false;

        if (isAdmin) {
          return const AddVenueFormScreen(isDirectAdminAccess: true);
        } else {
          return const HomeScreen(showAddVenueButton: false);
        }
      },
    );
  }
}


===== features\home\screens\home_screen.dart =====

// // features/home/screens/home_screen.dart

// import 'package:flutter/material.dart';
// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:geolocator/geolocator.dart';
// import 'package:mm_associates/features/data/services/firestore_service.dart';
// import 'package:mm_associates/features/home/screens/venue_form.dart';
// import 'package:mm_associates/features/auth/services/auth_service.dart';
// import 'package:mm_associates/features/user/services/user_service.dart';
// import 'package:mm_associates/core/services/location_service.dart';
// import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// import 'venue_detail_screen.dart';
// import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
// import 'dart:async';
// import 'package:shimmer/shimmer.dart';
// import 'city_selection_screen.dart' show CitySelectionScreen, kAppAllCities;
// import 'package:mm_associates/features/home/widgets/home_search_components.dart';

// class HomeScreen extends StatefulWidget {
//   final bool showAddVenueButton;

//   const HomeScreen({
//     super.key,
//     required this.showAddVenueButton,
//   });

//   @override
//   State<HomeScreen> createState() => _HomeScreenState();
// }

// class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
//   final AuthService _authService = AuthService();
//   final FirestoreService _firestoreService = FirestoreService();
//   final LocationService _locationService = LocationService();
//   final UserService _userService = UserService();

//   // State Variables
//   String? _searchQuery;
//   String? _selectedCityFilter;
//   IconData? _selectedCityIcon;
//   String? _selectedSportFilter;

//   User? _currentUser;
//   String? _userName;
//   String? _userProfilePicUrl;
//   bool _isLoadingName = true;

//   List<Map<String, dynamic>> _filteredVenues = [];
//   bool _isLoadingFilteredVenues = true;
//   String? _filteredVenueFetchError;

//   List<Map<String, dynamic>> _nearbyVenues = [];
//   bool _isLoadingNearbyVenues = true;
//   String? _nearbyVenueFetchError;

//   List<Map<String, dynamic>> _exploreVenues = [];
//   bool _isLoadingExploreVenues = true;
//   String? _exploreVenueFetchError;

//   Position? _currentPosition;
//   bool _isFetchingLocation = false;
//   String? _locationStatusMessage;

//   // Favorites State
//   List<String> _favoriteVenueIds = [];
//   bool _isLoadingFavorites = true;
//   Stream<List<String>>? _favoritesStream;
//   StreamSubscription<List<String>>? _favoritesSubscription;

//   final List<String> _supportedCities = [
//     'Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'
//   ];
//   final List<String> _quickSportFilters = [
//     'Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'
//   ];

//   bool get _isSearchingOrFiltering =>
//       (_searchQuery != null && _searchQuery!.isNotEmpty) ||
//       _selectedCityFilter != null ||
//       _selectedSportFilter != null;

//   @override
//   void initState() {
//     super.initState();
//     _currentUser = _authService.getCurrentUser();
//     _initializeScreen();
//   }
  
//   // <<< MODIFICATION 2: Changed return type from `void` to `Future<void>` to fix the await error. >>>
//   Future<void> _initializeScreen() async {
//     _fetchUserNameAndPic();
//     _setupFavoritesStream();

//     await _checkAndRequestLocationPermission();

//     if (_isSearchingOrFiltering) {
//       _onFilterOrSearchChanged();
//     } else {
//       _fetchPrimaryVenueData();
//     }
    
//     if(mounted) {
//        _updateSelectedCityIconFromFilter();
//     }
//   }

//   Future<void> _checkAndRequestLocationPermission() async {
//     if (!mounted) return;
//     setState(() {
//       _isFetchingLocation = true;
//       _locationStatusMessage = 'Initializing location services...';
//     });
    
//     try {
//       final position = await _locationService.getCurrentLocation();
//       if (mounted) {
//         setState(() {
//           _currentPosition = position;
//           _locationStatusMessage = position != null ? 'Location acquired.' : 'Could not determine location.';
//           _isFetchingLocation = false;
//         });
//       }
//     } catch (e) {
//       if (mounted) {
//         debugPrint("Error in _checkAndRequestLocationPermission: $e");
//         setState(() {
//           _locationStatusMessage = 'Failed to get location.';
//           _isFetchingLocation = false;
//         });
//       }
//     }
//   }
  
//   Future<void> _fetchPrimaryVenueData() async {
//     if (!mounted) return;
//     await Future.wait([
//       _fetchNearbyVenuesScoped(), 
//       _fetchExploreVenuesFromOtherCities()
//     ]);
//   }
  
//   @override
//   void dispose() {
//     _favoritesSubscription?.cancel();
//     super.dispose();
//   }

//   void setStateIfMounted(VoidCallback fn) {
//     if (mounted) setState(fn);
//   }
  
//   Future<void> _fetchUserNameAndPic() async {
//     if (!mounted) return;
//     setState(() => _isLoadingName = true);
    
//     // <<< MODIFICATION 1: Changed `_auth.currentUser` to `_authService.getCurrentUser()`. >>>
//     final currentUser = _authService.getCurrentUser();
    
//     if (currentUser == null) {
//       if (mounted) {
//         setState(() {
//           _userName = 'Guest';
//           _userProfilePicUrl = null;
//           _isLoadingName = false;
//         });
//       }
//       return;
//     }
//     try {
//       final userData = await _userService.getUserProfileData();
//       if (!mounted) return;
//       final fetchedName = userData?['name'] as String? ??
//           currentUser.displayName ??
//           currentUser.email?.split('@')[0] ??
//           'User';
//       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
//       setState(() {
//         _userName = fetchedName;
//         _userProfilePicUrl = fetchedPicUrl;
//       });
//     } catch (e) {
//       if (!mounted) return;
//       final fallbackName = currentUser.displayName ??
//           currentUser.email?.split('@')[0] ??
//           'User';
//       setState(() {
//         _userName = fallbackName;
//         _userProfilePicUrl = null;
//       });
//       debugPrint("Error fetching user name: $e");
//     } finally {
//       if (mounted) setState(() => _isLoadingName = false);
//     }
//   }

//   void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
//     if (!mounted) return;

//     setState(() {
//       _searchQuery =
//           (explicitSearchQuery?.trim().isEmpty ?? true) ? null : explicitSearchQuery!.trim();
//     });

//     if (_isSearchingOrFiltering) {
//       _fetchVenuesForFilterOrSearch();
//     } else {
//       _fetchPrimaryVenueData();
//     }
//   }

//   Future<void> _fetchVenuesForFilterOrSearch() async {
//     if (!mounted) return;
//     setStateIfMounted(() {
//       _isLoadingFilteredVenues = true;
//       _filteredVenueFetchError = null;
//       _filteredVenues = [];
//     });

//     try {
//       final venuesData = await _firestoreService.getVenues(
//         userLocation: _currentPosition,
//         radiusInKm:
//             _selectedCityFilter != null ? null : (_currentPosition != null ? 50.0 : null),
//         cityFilter: _selectedCityFilter,
//         searchQuery: _searchQuery,
//         sportFilter: _selectedSportFilter,
//       );
//       if (!mounted) return;
//       setStateIfMounted(() {
//         _filteredVenues = venuesData;
//       });
//     } catch (e) {
//       debugPrint("Error fetching filtered/search venues: $e");
//       if (!mounted) return;
//       setStateIfMounted(
//           () => _filteredVenueFetchError = "Could not load venues: ${e.toString()}");
//     } finally {
//       if (!mounted) return;
//       setStateIfMounted(() => _isLoadingFilteredVenues = false);
//     }
//   }

//   void _setupFavoritesStream() {
//     _favoritesSubscription?.cancel();
//     if (_currentUser != null) {
//       _favoritesStream = _userService.getFavoriteVenueIdsStream();
//       _favoritesSubscription = _favoritesStream?.listen((favoriteIds) {
//         if (mounted) {
//           final newIdsSet = favoriteIds.toSet();
//           final currentIdsSet = _favoriteVenueIds.toSet();
//           if (newIdsSet.difference(currentIdsSet).isNotEmpty ||
//               currentIdsSet.difference(newIdsSet).isNotEmpty) {
//             setStateIfMounted(() => _favoriteVenueIds = favoriteIds);
//           }
//         }
//       }, onError: (error) {
//         debugPrint("Error in favorites stream: $error");
//       });
//       if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);
//     } else {
//       if (mounted) {
//         setStateIfMounted(() {
//           _favoriteVenueIds = [];
//           _isLoadingFavorites = false;
//           _favoritesStream = null;
//           _favoritesSubscription = null;
//         });
//       }
//     }
//   }
  
//   @override
//   void didChangeDependencies() {
//     super.didChangeDependencies();
//     final currentAuthUser = _authService.getCurrentUser();
//     if (currentAuthUser?.uid != _currentUser?.uid) {
//       _currentUser = currentAuthUser;
//       _initializeScreen();
//     }
//   }

//   Future<void> _fetchNearbyVenuesScoped() async {
//     if (!mounted) return;
//     if (_currentPosition == null) {
//       if (mounted)
//         setStateIfMounted(() {
//           _isLoadingNearbyVenues = false;
//           _nearbyVenueFetchError = "Location not available.";
//           _nearbyVenues = [];
//         });
//       return;
//     }
//     setStateIfMounted(() {
//       _isLoadingNearbyVenues = true;
//       _nearbyVenueFetchError = null;
//       _nearbyVenues = [];
//     });
//     try {
//       final venuesData =
//           await _firestoreService.getVenues(userLocation: _currentPosition, radiusInKm: 25.0);
//       if (!mounted) return;
//       setStateIfMounted(() => _nearbyVenues = venuesData);
//     } catch (e) {
//       if (!mounted) return;
//       setStateIfMounted(() => _nearbyVenueFetchError = "Could not load nearby venues.");
//     } finally {
//       if (!mounted) return;
//       setStateIfMounted(() => _isLoadingNearbyVenues = false);
//     }
//   }

//   Future<void> _fetchExploreVenuesFromOtherCities() async {
//     if (!mounted) return;
//     setStateIfMounted(() {
//       _isLoadingExploreVenues = true;
//       _exploreVenueFetchError = null;
//       _exploreVenues = [];
//     });
//     List<Map<String, dynamic>> allExploreVenues = [];
//     try {
//       for (String city in _supportedCities) {
//         final cityVenues = await _firestoreService.getVenues(
//             cityFilter: city, userLocation: _currentPosition, limit: 5);
//         allExploreVenues.addAll(cityVenues);
//         if (!mounted) return;
//       }
//       final uniqueExploreVenues = allExploreVenues.fold<Map<String, Map<String, dynamic>>>({},
//           (map, venue) {
//         final String? venueId = venue['id'] as String?;
//         if (venueId != null) map[venueId] = venue;
//         return map;
//       }).values.toList();

//       if (_currentPosition != null) {
//         uniqueExploreVenues.sort((a, b) {
//           final distA = a['distance'] as double?;
//           final distB = b['distance'] as double?;
//           if (distA != null && distB != null) return distA.compareTo(distB);
//           if (distA != null) return -1;
//           if (distB != null) return 1;
//           return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
//         });
//       } else {
//         uniqueExploreVenues
//             .sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
//       }
//       if (!mounted) return;
//       setStateIfMounted(() => _exploreVenues = uniqueExploreVenues.take(15).toList());
//     } catch (e) {
//       if (!mounted) return;
//       setStateIfMounted(() => _exploreVenueFetchError = "Could not load explore venues.");
//     } finally {
//       if (!mounted) return;
//       setStateIfMounted(() => _isLoadingExploreVenues = false);
//     }
//   }
  
//   void _updateSelectedCityIconFromFilter() {
//     if (_selectedCityFilter == null) {
//       _selectedCityIcon = Icons.my_location;
//     } else {
//       try {
//         final cityInfo =
//             kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
//         _selectedCityIcon = cityInfo.icon;
//       } catch (e) {
//         _selectedCityIcon = Icons.location_city_outlined;
//       }
//     }
//   }
  
//   Future<void> _handleRefresh() async {
//     if (mounted) {
//       setState(() {
//         _searchQuery = null;
//         _selectedSportFilter = null;
//       });
//       await _initializeScreen();
//     }
//   }

//   void _navigateToVenueDetail(Map<String, dynamic> venue) {
//     if (!context.mounted) return;
//     Navigator.push(
//         context,
//         MaterialPageRoute(
//             builder: (context) => VenueDetailScreen(
//                 venueId: venue['id'] as String, initialVenueData: venue)));
//   }

//   void _openSearchMobile() async {
//     if (!context.mounted) return;
//     final String? submittedQuery = await showSearch<String?>(
//         context: context,
//         delegate: VenueSearchDelegate(
//             firestoreService: _firestoreService, initialCityFilter: _selectedCityFilter));
//     _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
//   }

//   Future<void> _openCitySelectionScreen() async {
//     if (!context.mounted) return;
//     final String? newSelectedCityName = await Navigator.push<String?>(
//       context,
//       MaterialPageRoute(
//           builder: (context) =>
//               CitySelectionScreen(currentSelectedCity: _selectedCityFilter)),
//     );

//     if (mounted && newSelectedCityName != _selectedCityFilter) {
//       setStateIfMounted(() {
//         _selectedCityFilter = newSelectedCityName;
//         _updateSelectedCityIconFromFilter();
//       });
//       _onFilterOrSearchChanged();
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     final appBarBackgroundColor = theme.appBarTheme.backgroundColor ?? theme.primaryColor;
//     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ??
//         theme.appBarTheme.iconTheme?.color ??
//         (kIsWeb
//             ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87)
//             : Colors.white);
//     final bool isLoggedIn = _currentUser != null;

//     return Scaffold(
//       appBar: AppBar(
//         toolbarHeight: 70.0,
//         automaticallyImplyLeading: false,
//         title: kIsWeb
//             ? _buildWebAppBarTitle(context)
//             : _buildMobileAppBarTitle(context, theme),
//         actions: _buildAppBarActions(context, isLoggedIn, actionsIconColor),
//         backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
//         elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
//         iconTheme: theme.iconTheme.copyWith(
//             color: kIsWeb
//                 ? (theme.brightness == Brightness.dark
//                     ? Colors.white70
//                     : Colors.black87)
//                 : Colors.white),
//         actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
//         titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(
//                 color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ??
//             TextStyle(
//                 color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white,
//                 fontSize: 20,
//                 fontWeight: FontWeight.w500),
//       ),
//       floatingActionButton: widget.showAddVenueButton
//           ? FloatingActionButton.extended(
//               onPressed: () {
//                 Navigator.push(
//                   context,
//                   MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
//                 ).then((result) {
//                   if (result == true && mounted) {
//                     _handleRefresh();
//                     ScaffoldMessenger.of(context).showSnackBar(
//                       const SnackBar(
//                           content: Text("Venue list updated."),
//                           backgroundColor: Colors.blueAccent),
//                     );
//                   }
//                 });
//               },
//               icon: const Icon(Icons.add_location_alt_outlined),
//               label: const Text("Add Venue"),
//               tooltip: 'Add New Venue',
//             )
//           : null,
//       floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
//       body: _buildBodyContent(),
//     );
//   }

//   Widget _buildWebAppBarTitle(BuildContext context) {
//     final theme = Theme.of(context);
//     final currentUser = _currentUser;
//     double screenWidth = MediaQuery.of(context).size.width;
//     double leadingWidth = 150 + (_userName != null ? 100 : 0);
//     double searchWidthFraction = 0.4;
//     double minSearchWidth = 200;
//     double maxSearchWidth = 500;
//     double actionsWidth =
//         80 + (_currentUser != null ? 120 : 0);
//     double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
//     double calculatedSearchWidth =
//         (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);
        
//     return Row(children: [
//       Text('MM Associates',
//           style: TextStyle(
//               fontSize: 20,
//               fontWeight: FontWeight.bold,
//               color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
//       const SizedBox(width: 24),
//       if (_isLoadingName && currentUser != null)
//         const Padding(
//             padding: EdgeInsets.only(right: 16.0),
//             child: SizedBox(
//                 width: 18,
//                 height: 18,
//                 child: CircularProgressIndicator(strokeWidth: 2)))
//       else if (_userName != null && currentUser != null)
//         Padding(
//             padding: const EdgeInsets.only(right: 16.0),
//             child: Text('Hi, ${_userName!.split(' ')[0]}!',
//                 style: TextStyle(
//                     fontSize: 16,
//                     fontWeight: FontWeight.w500,
//                     color: theme.textTheme.bodyLarge?.color),
//                 overflow: TextOverflow.ellipsis)),
//       const Spacer(),
//       SizedBox(
//         width: calculatedSearchWidth,
//         child: WebSearchBar(
//           key: ValueKey(_searchQuery ?? 'initial'),
//           initialValue: _searchQuery ?? '',
//           cityFilter: _selectedCityFilter,
//           firestoreService: _firestoreService,
//           onSearchSubmitted: (query) {
//             _onFilterOrSearchChanged(explicitSearchQuery: query);
//           },
//           onSuggestionSelected: (suggestionName) {
//             _onFilterOrSearchChanged(explicitSearchQuery: suggestionName);
//           },
//           onClear: () {
//             _onFilterOrSearchChanged(explicitSearchQuery: null);
//           },
//         ),
//       ),
//       const Spacer(),
//     ]);
//   }
  
//   List<Widget> _buildAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
//     final String cityNameText = _selectedCityFilter ?? 'Near Me';
//     const double textSize = 10.0;

//     final locationButton = Tooltip(
//       message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
//       child: Transform.translate(
//         offset: const Offset(0, 9.0),
//         child: TextButton(
//           onPressed: _openCitySelectionScreen,
//           style: TextButton.styleFrom(
//             padding: const EdgeInsets.symmetric(horizontal: 4),
//             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
//             foregroundColor: iconColor,
//           ),
//           child: Column(
//             mainAxisSize: MainAxisSize.min,
//             children: [
//               Icon(
//                 _selectedCityIcon ??
//                     (_selectedCityFilter == null
//                         ? Icons.my_location
//                         : Icons.location_city_outlined),
//                 size: 24,
//               ),
//               const SizedBox(height: 2),
//               Text(
//                 cityNameText,
//                 style: TextStyle(fontSize: textSize, fontWeight: FontWeight.w500),
//                 overflow: TextOverflow.ellipsis,
//               ),
//             ],
//           ),
//         ),
//       ),
//     );

//     final profileButton = isLoggedIn
//         ? IconButton(
//             icon: Icon(Icons.person_outline_rounded, color: iconColor),
//             tooltip: 'My Profile',
//             onPressed: () {
//               if (!context.mounted) return;
//               Navigator.push(context,
//                       MaterialPageRoute(builder: (context) => const ProfileScreen()))
//                   .then((_) => {if (mounted) _fetchUserNameAndPic()});
//             },
//           )
//         : null;

//     return [
//       Row(
//         crossAxisAlignment: CrossAxisAlignment.center,
//         children: kIsWeb
//             ? [ // Web Layout
//                 locationButton,
//                 if (profileButton != null) const SizedBox(width: 8),
//                 if (profileButton != null) profileButton,
//                 const SizedBox(width: 8),
//               ]
//             : [ // Mobile Layout
//                 IconButton(
//                   icon: Icon(Icons.search_outlined, color: iconColor),
//                   tooltip: 'Search Venues',
//                   onPressed: _openSearchMobile,
//                 ),
//                 locationButton,
//                 if (profileButton != null) profileButton,
//                 if (profileButton == null) const SizedBox(width: 8),
//               ],
//       )
//     ];
//   }
  
//   Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
//     final titleStyle = theme.appBarTheme.titleTextStyle ??
//         theme.primaryTextTheme.titleLarge ??
//         const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
//     final currentUser = _currentUser;
//     return Row(children: [
//       if (currentUser != null)
//         GestureDetector(
//           onTap: () {
//             if (!context.mounted) return;
//             Navigator.push(context,
//                     MaterialPageRoute(builder: (context) => const ProfileScreen()))
//                 .then((_) {
//               if (mounted) _fetchUserNameAndPic();
//             });
//           },
//           child: Tooltip(
//             message: "My Profile",
//             child: Padding(
//               padding: const EdgeInsets.only(right: 10.0),
//               child: CircleAvatar(
//                   radius: 18,
//                   backgroundColor: Colors.white24,
//                   backgroundImage:
//                       _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty
//                           ? NetworkImage(_userProfilePicUrl!)
//                           : null,
//                   child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty
//                       ? Icon(Icons.person_outline,
//                           size: 20, color: Colors.white.withOpacity(0.8))
//                       : null),
//             ),
//           ),
//         ),
//       if (_isLoadingName && currentUser != null)
//         const Padding(
//             padding: EdgeInsets.only(left: 6.0),
//             child: SizedBox(
//                 width: 18,
//                 height: 18,
//                 child: CircularProgressIndicator(
//                     strokeWidth: 2,
//                     valueColor: AlwaysStoppedAnimation<Color>(Colors.white70))))
//       else if (_userName != null && currentUser != null)
//         Expanded(
//           child: Padding(
//               padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
//               child: Text(
//                 'Hi, ${_userName!.split(' ')[0]}!',
//                 style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
//                 overflow: TextOverflow.ellipsis,
//               )),
//         )
//       else
//         Text('MM Associates', style: titleStyle),
//     ]);
//   }
  
//   Widget _buildBodyContent() {
//     return Column(children: [
//       _buildQuickSportFilters(),
//       Expanded(
//         child: RefreshIndicator(
//           onRefresh: _handleRefresh,
//           child: ListView(
//             padding: EdgeInsets.zero,
//             children: [
//               if (_isSearchingOrFiltering) ...[
//                 _buildSectionHeader(context,
//                     _searchQuery != null && _searchQuery!.isNotEmpty
//                         ? "Results for \"$_searchQuery\""
//                         : (_selectedCityFilter != null
//                             ? "Venues in $_selectedCityFilter"
//                             : (_selectedSportFilter != null
//                                 ? "Venues for $_selectedSportFilter"
//                                 : "Filtered Venues"))),
//                 _buildVenueList(_filteredVenues, _isLoadingFilteredVenues,
//                     _filteredVenueFetchError, "No venues found for your selection.", isNearbySection: false),
//               ] else ...[
//                  if (!_isFetchingLocation && _currentPosition == null)
//                   _buildNoLocationWarning(),
//                 if (_currentPosition != null || _isLoadingNearbyVenues)
//                   _buildSectionHeader(context, "Venues Near You"),
//                 _buildVenueList(
//                     _nearbyVenues,
//                     _isLoadingNearbyVenues,
//                     _nearbyVenueFetchError,
//                     "No venues found nearby. Try exploring other cities.",
//                     isNearbySection: true),
//                 const SizedBox(height: 16),
//                 _buildSectionHeader(context, "Explore Venues"),
//                 _buildVenueList(
//                     _exploreVenues,
//                     _isLoadingExploreVenues,
//                     _exploreVenueFetchError,
//                     "No venues to explore at the moment.", isNearbySection: false),
//               ],
//               const SizedBox(height: 80),
//             ],
//           ),
//         ),
//       ),
//     ]);
//   }

//   Widget _buildNoLocationWarning() {
//     return Container(
//       color: Colors.amber.withOpacity(0.1),
//       padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
//       child: Row(
//         children: [
//           Icon(Icons.location_off_outlined, color: Colors.amber.shade800),
//           const SizedBox(width: 12.0),
//           Expanded(
//             child: Text(
//               'Location is off or denied. "Venues Near You" will not be shown.',
//               style: TextStyle(color: Colors.amber.shade900),
//             ),
//           ),
//         ],
//       ),
//     );
//   }

//   Widget _buildQuickSportFilters() {
//     final theme = Theme.of(context);
//     return Container(
//       height: 55,
//       color: theme.cardColor,
//       child: ListView.separated(
//         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
//         scrollDirection: Axis.horizontal,
//         itemCount: _quickSportFilters.length + 1,
//         separatorBuilder: (context, index) => const SizedBox(width: 10),
//         itemBuilder: (context, index) {
//           if (index == 0) {
//             final bool isSelected = _selectedSportFilter == null;
//             return ChoiceChip(
//               label: const Text('All Sports'),
//               selected: isSelected,
//               onSelected: (bool nowSelected) {
//                 if (nowSelected && _selectedSportFilter != null) {
//                   setStateIfMounted(() => _selectedSportFilter = null);
//                   _onFilterOrSearchChanged();
//                 }
//               },
//               selectedColor: theme.colorScheme.primary.withOpacity(0.2),
//               backgroundColor:
//                   theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
//               labelStyle: TextStyle(
//                   color: isSelected
//                       ? theme.colorScheme.primary
//                       : theme.textTheme.bodyMedium?.color,
//                   fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
//                   fontSize: 13),
//               shape: RoundedRectangleBorder(
//                   borderRadius: BorderRadius.circular(20),
//                   side: BorderSide(
//                       color: isSelected
//                           ? theme.colorScheme.primary.withOpacity(0.5)
//                           : Colors.grey.shade300)),
//               padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
//               visualDensity: VisualDensity.compact,
//               showCheckmark: false,
//             );
//           }
//           final sport = _quickSportFilters[index - 1];
//           final bool isSelected = _selectedSportFilter == sport;
//           return ChoiceChip(
//             label: Text(sport),
//             selected: isSelected,
//             onSelected: (bool isNowSelected) {
//               final newFilter = isNowSelected ? sport : null;
//               if (_selectedSportFilter != newFilter) {
//                 setStateIfMounted(() => _selectedSportFilter = newFilter);
//                 _onFilterOrSearchChanged();
//               }
//             },
//             selectedColor: theme.colorScheme.primary.withOpacity(0.2),
//             backgroundColor:
//                 theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
//             labelStyle: TextStyle(
//                 color: isSelected
//                     ? theme.colorScheme.primary
//                     : theme.textTheme.bodyMedium?.color,
//                 fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
//                 fontSize: 13),
//             shape: RoundedRectangleBorder(
//                 borderRadius: BorderRadius.circular(20),
//                 side: BorderSide(
//                     color: isSelected
//                         ? theme.colorScheme.primary.withOpacity(0.5)
//                         : Colors.grey.shade300)),
//             padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
//             visualDensity: VisualDensity.compact,
//             showCheckmark: false,
//           );
//         },
//       ),
//     );
//   }
  
//   Widget _buildSectionHeader(BuildContext context, String title) {
//     return Padding(
//         padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
//         child: Text(title,
//             style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
//   }

//   Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg,
//       String emptyMsg, {bool isNearbySection = false}) {
//     if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
//     if (errorMsg != null)
//       return Center(
//           child: Padding(
//               padding: const EdgeInsets.all(20),
//               child: Text(errorMsg,
//                   textAlign: TextAlign.center,
//                   style: const TextStyle(color: Colors.red, fontSize: 16))));
//     if (venues.isEmpty)
//       return Center(
//           child: Padding(
//               padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0),
//               child: Text(emptyMsg,
//                   textAlign: TextAlign.center,
//                   style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

//     return GridView.builder(
//       shrinkWrap: true,
//       physics: const NeverScrollableScrollPhysics(),
//       padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
//       gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
//           maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
//           mainAxisSpacing: 16.0,
//           crossAxisSpacing: 16.0,
//           childAspectRatio: 0.70),
//       itemCount: venues.length,
//       itemBuilder: (context, index) {
//         final venue = venues[index];
//         final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
//         return _buildVenueGridCard(venue, isFavorite: isFavorite);
//       },
//     );
//   }

//   Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
//     return Shimmer.fromColors(
//         baseColor: Colors.grey[350]!,
//         highlightColor: Colors.grey[200]!,
//         child: GridView.builder(
//             shrinkWrap: true,
//             physics: const NeverScrollableScrollPhysics(),
//             padding: const EdgeInsets.all(16.0),
//             gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
//                 maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0,
//                 mainAxisSpacing: 16.0,
//                 crossAxisSpacing: 16.0,
//                 childAspectRatio: 0.70),
//             itemCount: itemCount,
//             itemBuilder: (context, index) => _buildVenueShimmerCard()));
//   }

//   Widget _buildVenueShimmerCard() {
//     return Card(
//         margin: EdgeInsets.zero,
//         elevation: 2,
//         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
//         clipBehavior: Clip.antiAlias,
//         child: Column(children: [
//           Container(height: 130, width: double.infinity, color: Colors.white),
//           Expanded(
//               child: Padding(
//                   padding: const EdgeInsets.all(10.0),
//                   child: Column(
//                       crossAxisAlignment: CrossAxisAlignment.start,
//                       mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                       children: [
//                         Column(
//                             crossAxisAlignment: CrossAxisAlignment.start,
//                             children: [
//                               Container(
//                                   width: double.infinity,
//                                   height: 18.0,
//                                   color: Colors.white,
//                                   margin: const EdgeInsets.only(bottom: 6)),
//                               Container(
//                                   width: MediaQuery.of(context).size.width * 0.3,
//                                   height: 14.0,
//                                   color: Colors.white,
//                                   margin: const EdgeInsets.only(bottom: 6)),
//                               Container(
//                                   width: MediaQuery.of(context).size.width * 0.2,
//                                   height: 12.0,
//                                   color: Colors.white)
//                             ]),
//                         Container(width: double.infinity, height: 12.0, color: Colors.white)
//                       ])))
//         ]));
//   }

//   Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite}) {
//     final String venueId = venue['id'] as String? ?? '';
//     return _VenueCardWidget(
//       key: ValueKey(venueId),
//       venue: venue,
//       isFavorite: isFavorite,
//       onTapCard: () => _navigateToVenueDetail(venue),
//       onTapFavorite: () => _toggleFavorite(venueId),
//     );
//   }

//   Future<void> _toggleFavorite(String venueId) async {
//     if (!mounted) return;
//     final currentUser = _currentUser;
//     if (currentUser == null) {
//       ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
//         content: Text("Please log in to manage favorites."),
//       ));
//       return;
//     }
//     if (venueId.isEmpty) return;

//     final currentIsFavorite = _favoriteVenueIds.contains(venueId);

//     try {
//       if (!currentIsFavorite) {
//         await _userService.addFavorite(venueId);
//       } else {
//         await _userService.removeFavorite(venueId);
//       }
//     } catch (e) {
//       if (mounted)
//         ScaffoldMessenger.of(context).showSnackBar(SnackBar(
//           content: Text("Error updating favorites: ${e.toString()}"),
//         ));
//     }
//   }
// }

// class _VenueCardWidget extends StatefulWidget {
//   final Map<String, dynamic> venue;
//   final bool isFavorite;
//   final VoidCallback onTapCard;
//   final Future<void> Function() onTapFavorite;

//   const _VenueCardWidget({
//     required Key key,
//     required this.venue,
//     required this.isFavorite,
//     required this.onTapCard,
//     required this.onTapFavorite,
//   }) : super(key: key);

//   @override
//   _VenueCardWidgetState createState() => _VenueCardWidgetState();
// }

// class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
//   late AnimationController _favoriteAnimationController;
//   late Animation<double> _favoriteScaleAnimation;

//   @override
//   void initState() {
//     super.initState();
//     _favoriteAnimationController = AnimationController(
//       duration: const Duration(milliseconds: 300),
//       vsync: this,
//     );
//     _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
//       CurvedAnimation(
//           parent: _favoriteAnimationController,
//           curve: Curves.elasticOut,
//           reverseCurve: Curves.easeInCubic),
//     );
//     if(widget.isFavorite) {
//       _favoriteAnimationController.value = 1.0;
//     }
//   }

//   @override
//   void didUpdateWidget(_VenueCardWidget oldWidget) {
//     super.didUpdateWidget(oldWidget);
//     if (widget.isFavorite != oldWidget.isFavorite && mounted) {
//       if (widget.isFavorite) {
//         _favoriteAnimationController.forward(from: 0.0).catchError((e) {
//           if (e is! TickerCanceled) debugPrint("Error playing fav animation: $e");
//         });
//       } else {
//         _favoriteAnimationController.reverse().catchError((e) {
//           if (e is! TickerCanceled) debugPrint("Error reversing fav animation: $e");
//         });
//       }
//     }
//   }

//   @override
//   void dispose() {
//     _favoriteAnimationController.dispose();
//     super.dispose();
//   }

//   @override
//   Widget build(BuildContext context) {
//     final ThemeData theme = Theme.of(context);
//     final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
//     final dynamic sportRaw = widget.venue['sportType'];
//     final String sport = (sportRaw is String)
//         ? sportRaw
//         : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
//     final String? imageUrl = widget.venue['imageUrl'] as String?;
//     final String city = widget.venue['city'] as String? ?? '';
//     final String venueId = widget.venue['id'] as String? ?? '';
//     final double? distance = widget.venue['distance'] as double?;
//     final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
//     final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

//     return MouseRegion(
//       cursor: SystemMouseCursors.click,
//       child: Card(
//         margin: EdgeInsets.zero,
//         elevation: 3,
//         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
//         clipBehavior: Clip.antiAlias,
//         child: Column(
//           crossAxisAlignment: CrossAxisAlignment.start,
//           children: [
//             SizedBox(
//               height: 130,
//               width: double.infinity,
//               child: Stack(
//                 children: [
//                   Positioned.fill(
//                     child: InkWell(
//                       onTap: widget.onTapCard,
//                       child: (imageUrl != null &&
//                               imageUrl.isNotEmpty &&
//                               Uri.tryParse(imageUrl)?.isAbsolute == true)
//                           ? Hero(
//                               tag: 'venue_image_$venueId',
//                               child: Image.network(
//                                 imageUrl,
//                                 height: 130,
//                                 width: double.infinity,
//                                 fit: BoxFit.cover,
//                                 loadingBuilder: (context, child, loadingProgress) =>
//                                     (loadingProgress == null)
//                                         ? child
//                                         : Container(
//                                             height: 130,
//                                             color: Colors.grey[200],
//                                             child: Center(
//                                                 child: CircularProgressIndicator(
//                                                     strokeWidth: 2,
//                                                     value: loadingProgress
//                                                                 .expectedTotalBytes !=
//                                                             null
//                                                         ? loadingProgress.cumulativeBytesLoaded /
//                                                             loadingProgress.expectedTotalBytes!
//                                                         : null))),
//                                 errorBuilder: (context, error, stackTrace) => Container(
//                                     height: 130,
//                                     color: Colors.grey[200],
//                                     child: Center(
//                                         child: Icon(Icons.broken_image_outlined,
//                                             color: Colors.grey[400], size: 40))),
//                               ),
//                             )
//                           : Container(
//                               height: 130,
//                               color: theme.primaryColor.withOpacity(0.08),
//                               child: Center(
//                                   child: Icon(Icons.sports_soccer_outlined,
//                                       size: 50, color: theme.primaryColor.withOpacity(0.7)))),
//                     ),
//                   ),
//                   Positioned(
//                     top: 6,
//                     right: 6,
//                     child: Material(
//                       color: Colors.black.withOpacity(0.45),
//                       shape: const CircleBorder(),
//                       child: InkWell(
//                         borderRadius: BorderRadius.circular(20),
//                         onTap: widget.onTapFavorite,
//                         child: Padding(
//                           padding: const EdgeInsets.all(7.0),
//                           child: ScaleTransition(
//                             scale: _favoriteScaleAnimation,
//                             child: Icon(
//                               widget.isFavorite
//                                   ? Icons.favorite_rounded
//                                   : Icons.favorite_border_rounded,
//                               color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
//                               size: 22,
//                             ),
//                           ),
//                         ),
//                       ),
//                     ),
//                   ),
//                   if (distance != null)
//                     Positioned(
//                       bottom: 6,
//                       left: 6,
//                       child: Container(
//                         padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
//                         decoration: BoxDecoration(
//                             color: Colors.black.withOpacity(0.6),
//                             borderRadius: BorderRadius.circular(4)),
//                         child: Text('${distance.toStringAsFixed(1)} km',
//                             style: const TextStyle(
//                                 color: Colors.white,
//                                 fontSize: 11,
//                                 fontWeight: FontWeight.w500)),
//                       ),
//                     ),
//                 ],
//               ),
//             ),
//             Expanded(
//               child: InkWell(
//                 onTap: widget.onTapCard,
//                 child: Padding(
//                   padding: const EdgeInsets.all(10.0),
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.start,
//                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                     children: [
//                       Column(
//                         crossAxisAlignment: CrossAxisAlignment.start,
//                         mainAxisSize: MainAxisSize.min,
//                         children: [
//                           Text(name,
//                               style: theme.textTheme.titleMedium
//                                   ?.copyWith(fontWeight: FontWeight.w600, fontSize: 15),
//                               maxLines: 2,
//                               overflow: TextOverflow.ellipsis),
//                           const SizedBox(height: 4),
//                           Row(children: [
//                             Icon(Icons.sports_kabaddi_outlined,
//                                 size: 14, color: theme.colorScheme.secondary),
//                             const SizedBox(width: 4),
//                             Expanded(
//                                 child: Text(sport,
//                                     style: theme.textTheme.bodyMedium
//                                         ?.copyWith(color: Colors.grey[800], fontSize: 12),
//                                     maxLines: 1,
//                                     overflow: TextOverflow.ellipsis)),
//                           ]),
//                           if (reviewCount > 0)
//                             Padding(
//                               padding: const EdgeInsets.only(top: 5.0),
//                               child: Row(children: [
//                                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
//                                 const SizedBox(width: 4),
//                                 Text(averageRating.toStringAsFixed(1),
//                                     style:
//                                         const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
//                                 const SizedBox(width: 4),
//                                 Text("($reviewCount reviews)",
//                                     style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
//                               ]),
//                             ),
//                         ],
//                       ),
//                       Row(
//                         children: [
//                           Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
//                           const SizedBox(width: 4),
//                           Expanded(
//                               child: Text(city,
//                                   style: theme.textTheme.bodySmall
//                                       ?.copyWith(color: Colors.grey[700], fontSize: 12),
//                                   maxLines: 1,
//                                   overflow: TextOverflow.ellipsis)),
//                         ],
//                       ),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }



// features/home/screens/home_screen.dart

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:geolocator/geolocator.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:mm_associates/features/home/screens/venue_form.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:mm_associates/core/services/location_service.dart';
import 'package:mm_associates/features/profile/screens/profile_screen.dart';
import 'venue_detail_screen.dart';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
import 'dart:async';
import 'package:shimmer/shimmer.dart';
import 'city_selection_screen.dart' show CitySelectionScreen, kAppAllCities;
import 'package:mm_associates/features/home/widgets/home_search_components.dart';

class HomeScreen extends StatefulWidget {
  final bool showAddVenueButton;

  const HomeScreen({
    super.key,
    required this.showAddVenueButton,
  });

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
  final AuthService _authService = AuthService();
  final FirestoreService _firestoreService = FirestoreService();
  final LocationService _locationService = LocationService();
  final UserService _userService = UserService();

  // State Variables
  String? _searchQuery;
  String? _selectedCityFilter;
  IconData? _selectedCityIcon;
  String? _selectedSportFilter;

  User? _currentUser;
  String? _userName;
  String? _userProfilePicUrl;
  bool _isLoadingName = true;

  List<Map<String, dynamic>> _filteredVenues = [];
  bool _isLoadingFilteredVenues = true;
  String? _filteredVenueFetchError;

  List<Map<String, dynamic>> _nearbyVenues = [];
  bool _isLoadingNearbyVenues = true;
  String? _nearbyVenueFetchError;

  List<Map<String, dynamic>> _exploreVenues = [];
  bool _isLoadingExploreVenues = true;
  String? _exploreVenueFetchError;

  Position? _currentPosition;
  bool _isFetchingLocation = false;
  String? _locationStatusMessage;

  // Favorites State
  List<String> _favoriteVenueIds = [];
  bool _isLoadingFavorites = true;
  Stream<List<String>>? _favoritesStream;
  StreamSubscription<List<String>>? _favoritesSubscription;

  final List<String> _supportedCities = [
    'Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'
  ];
  final List<String> _quickSportFilters = [
    'Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'
  ];

  bool get _isSearchingOrFiltering =>
      (_searchQuery != null && _searchQuery!.isNotEmpty) ||
      _selectedCityFilter != null ||
      _selectedSportFilter != null;

  @override
  void initState() {
    super.initState();
    _currentUser = _authService.getCurrentUser();
    _initializeScreen();
  }

  // <<< FIX 2 of 2: Changed return type from `void` to `Future<void>`.
  Future<void> _initializeScreen() async {
    _fetchUserNameAndPic();
    _setupFavoritesStream();

    await _checkAndRequestLocationPermission();

    if (_isSearchingOrFiltering) {
      _onFilterOrSearchChanged();
    } else {
      _fetchPrimaryVenueData();
    }

    if (mounted) {
      _updateSelectedCityIconFromFilter();
    }
  }

  Future<void> _checkAndRequestLocationPermission() async {
    if (!mounted) return;
    setState(() {
      _isFetchingLocation = true;
      _locationStatusMessage = 'Initializing location services...';
    });

    try {
      final position = await _locationService.getCurrentLocation();
      if (mounted) {
        setState(() {
          _currentPosition = position;
          _locationStatusMessage =
              position != null ? 'Location acquired.' : 'Could not determine location.';
          _isFetchingLocation = false;
        });
      }
    } catch (e) {
      if (mounted) {
        debugPrint("Error in _checkAndRequestLocationPermission: $e");
        setState(() {
          _locationStatusMessage = 'Failed to get location.';
          _isFetchingLocation = false;
        });
      }
    }
  }

  Future<void> _fetchPrimaryVenueData() async {
    if (!mounted) return;
    await Future.wait(
        [_fetchNearbyVenuesScoped(), _fetchExploreVenuesFromOtherCities()]);
  }

  @override
  void dispose() {
    _favoritesSubscription?.cancel();
    super.dispose();
  }

  void setStateIfMounted(VoidCallback fn) {
    if (mounted) setState(fn);
  }

  Future<void> _fetchUserNameAndPic() async {
    if (!mounted) return;
    setState(() => _isLoadingName = true);

    // <<< FIX 1 of 2: Changed `_auth.currentUser` to `_authService.getCurrentUser()`.
    final currentUser = _authService.getCurrentUser();

    if (currentUser == null) {
      if (mounted) {
        setState(() {
          _userName = 'Guest';
          _userProfilePicUrl = null;
          _isLoadingName = false;
        });
      }
      return;
    }
    try {
      final userData = await _userService.getUserProfileData();
      if (!mounted) return;
      final fetchedName = userData?['name'] as String? ??
          currentUser.displayName ??
          currentUser.email?.split('@')[0] ??
          'User';
      final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
      setState(() {
        _userName = fetchedName;
        _userProfilePicUrl = fetchedPicUrl;
      });
    } catch (e) {
      if (!mounted) return;
      final fallbackName = currentUser.displayName ??
          currentUser.email?.split('@')[0] ??
          'User';
      setState(() {
        _userName = fallbackName;
        _userProfilePicUrl = null;
      });
      debugPrint("Error fetching user name: $e");
    } finally {
      if (mounted) setState(() => _isLoadingName = false);
    }
  }

  void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
    if (!mounted) return;

    setState(() {
      _searchQuery = (explicitSearchQuery?.trim().isEmpty ?? true)
          ? null
          : explicitSearchQuery!.trim();
    });

    if (_isSearchingOrFiltering) {
      _fetchVenuesForFilterOrSearch();
    } else {
      _fetchPrimaryVenueData();
    }
  }

  Future<void> _fetchVenuesForFilterOrSearch() async {
    if (!mounted) return;
    setStateIfMounted(() {
      _isLoadingFilteredVenues = true;
      _filteredVenueFetchError = null;
      _filteredVenues = [];
    });

    try {
      final venuesData = await _firestoreService.getVenues(
        userLocation: _currentPosition,
        radiusInKm: _selectedCityFilter != null
            ? null
            : (_currentPosition != null ? 50.0 : null),
        cityFilter: _selectedCityFilter,
        searchQuery: _searchQuery,
        sportFilter: _selectedSportFilter,
      );
      if (!mounted) return;
      setStateIfMounted(() {
        _filteredVenues = venuesData;
      });
    } catch (e) {
      debugPrint("Error fetching filtered/search venues: $e");
      if (!mounted) return;
      setStateIfMounted(
          () => _filteredVenueFetchError = "Could not load venues: ${e.toString()}");
    } finally {
      if (!mounted) return;
      setStateIfMounted(() => _isLoadingFilteredVenues = false);
    }
  }

  void _setupFavoritesStream() {
    _favoritesSubscription?.cancel();
    if (_currentUser != null) {
      _favoritesStream = _userService.getFavoriteVenueIdsStream();
      _favoritesSubscription = _favoritesStream?.listen((favoriteIds) {
        if (mounted) {
          final newIdsSet = favoriteIds.toSet();
          final currentIdsSet = _favoriteVenueIds.toSet();
          if (newIdsSet.difference(currentIdsSet).isNotEmpty ||
              currentIdsSet.difference(newIdsSet).isNotEmpty) {
            setStateIfMounted(() => _favoriteVenueIds = favoriteIds);
          }
        }
      }, onError: (error) {
        debugPrint("Error in favorites stream: $error");
      });
      if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);
    } else {
      if (mounted) {
        setStateIfMounted(() {
          _favoriteVenueIds = [];
          _isLoadingFavorites = false;
          _favoritesStream = null;
          _favoritesSubscription = null;
        });
      }
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final currentAuthUser = _authService.getCurrentUser();
    if (currentAuthUser?.uid != _currentUser?.uid) {
      _currentUser = currentAuthUser;
      _initializeScreen();
    }
  }

  Future<void> _fetchNearbyVenuesScoped() async {
    if (!mounted) return;
    if (_currentPosition == null) {
      if (mounted)
        setStateIfMounted(() {
          _isLoadingNearbyVenues = false;
          _nearbyVenueFetchError = "Location not available.";
          _nearbyVenues = [];
        });
      return;
    }
    setStateIfMounted(() {
      _isLoadingNearbyVenues = true;
      _nearbyVenueFetchError = null;
      _nearbyVenues = [];
    });
    try {
      final venuesData = await _firestoreService.getVenues(
          userLocation: _currentPosition, radiusInKm: 25.0);
      if (!mounted) return;
      setStateIfMounted(() => _nearbyVenues = venuesData);
    } catch (e) {
      if (!mounted) return;
      setStateIfMounted(
          () => _nearbyVenueFetchError = "Could not load nearby venues.");
    } finally {
      if (!mounted) return;
      setStateIfMounted(() => _isLoadingNearbyVenues = false);
    }
  }

  Future<void> _fetchExploreVenuesFromOtherCities() async {
    if (!mounted) return;
    setStateIfMounted(() {
      _isLoadingExploreVenues = true;
      _exploreVenueFetchError = null;
      _exploreVenues = [];
    });
    List<Map<String, dynamic>> allExploreVenues = [];
    try {
      for (String city in _supportedCities) {
        final cityVenues = await _firestoreService.getVenues(
            cityFilter: city, userLocation: _currentPosition, limit: 5);
        allExploreVenues.addAll(cityVenues);
        if (!mounted) return;
      }
      final uniqueExploreVenues = allExploreVenues
          .fold<Map<String, Map<String, dynamic>>>({}, (map, venue) {
        final String? venueId = venue['id'] as String?;
        if (venueId != null) map[venueId] = venue;
        return map;
      }).values.toList();

      if (_currentPosition != null) {
        uniqueExploreVenues.sort((a, b) {
          final distA = a['distance'] as double?;
          final distB = b['distance'] as double?;
          if (distA != null && distB != null) return distA.compareTo(distB);
          if (distA != null) return -1;
          if (distB != null) return 1;
          return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
        });
      } else {
        uniqueExploreVenues.sort(
            (a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
      }
      if (!mounted) return;
      setStateIfMounted(
          () => _exploreVenues = uniqueExploreVenues.take(15).toList());
    } catch (e) {
      if (!mounted) return;
      setStateIfMounted(
          () => _exploreVenueFetchError = "Could not load explore venues.");
    } finally {
      if (!mounted) return;
      setStateIfMounted(() => _isLoadingExploreVenues = false);
    }
  }

  void _updateSelectedCityIconFromFilter() {
    if (_selectedCityFilter == null) {
      _selectedCityIcon = Icons.my_location;
    } else {
      try {
        final cityInfo =
            kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
        _selectedCityIcon = cityInfo.icon;
      } catch (e) {
        _selectedCityIcon = Icons.location_city_outlined;
      }
    }
  }

  Future<void> _handleRefresh() async {
    if (mounted) {
      setState(() {
        _searchQuery = null;
        _selectedSportFilter = null;
      });
      await _initializeScreen();
    }
  }

  // <<< MODIFIED: Now takes `heroTagContext` to pass down >>>
  void _navigateToVenueDetail(Map<String, dynamic> venue, String heroTagContext) {
    if (!context.mounted) return;
    Navigator.push(
        context,
        MaterialPageRoute(
            builder: (context) => VenueDetailScreen(
                venueId: venue['id'] as String,
                initialVenueData: venue,
                heroTagContext: heroTagContext))); // <<< MODIFIED: Pass the context
  }

  void _openSearchMobile() async {
    if (!context.mounted) return;
    final String? submittedQuery = await showSearch<String?>(
        context: context,
        delegate: VenueSearchDelegate(
            firestoreService: _firestoreService,
            initialCityFilter: _selectedCityFilter));
    _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
  }

  Future<void> _openCitySelectionScreen() async {
    if (!context.mounted) return;
    final String? newSelectedCityName = await Navigator.push<String?>(
      context,
      MaterialPageRoute(
          builder: (context) =>
              CitySelectionScreen(currentSelectedCity: _selectedCityFilter)),
    );

    if (mounted && newSelectedCityName != _selectedCityFilter) {
      setStateIfMounted(() {
        _selectedCityFilter = newSelectedCityName;
        _updateSelectedCityIconFromFilter();
      });
      _onFilterOrSearchChanged();
    }
  }

  @override
  Widget build(BuildContext context) {
    // ... All build-related methods remain the same until we get to _buildVenueList and _buildVenueGridCard
    final theme = Theme.of(context);
    final appBarBackgroundColor =
        theme.appBarTheme.backgroundColor ?? theme.primaryColor;
    final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ??
        theme.appBarTheme.iconTheme?.color ??
        (kIsWeb
            ? (theme.brightness == Brightness.dark
                ? Colors.white70
                : Colors.black87)
            : Colors.white);
    final bool isLoggedIn = _currentUser != null;

    return Scaffold(
      appBar: AppBar(
        toolbarHeight: 70.0,
        automaticallyImplyLeading: false,
        title: kIsWeb
            ? _buildWebAppBarTitle(context)
            : _buildMobileAppBarTitle(context, theme),
        actions: _buildAppBarActions(context, isLoggedIn, actionsIconColor),
        backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
        elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
        iconTheme: theme.iconTheme.copyWith(
            color: kIsWeb
                ? (theme.brightness == Brightness.dark
                    ? Colors.white70
                    : Colors.black87)
                : Colors.white),
        actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
        titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(
                color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ??
            TextStyle(
                color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white,
                fontSize: 20,
                fontWeight: FontWeight.w500),
      ),
      floatingActionButton: widget.showAddVenueButton
          ? FloatingActionButton.extended(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                      builder: (context) => const AddVenueFormScreen()),
                ).then((result) {
                  if (result == true && mounted) {
                    _handleRefresh();
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                          content: Text("Venue list updated."),
                          backgroundColor: Colors.blueAccent),
                    );
                  }
                });
              },
              icon: const Icon(Icons.add_location_alt_outlined),
              label: const Text("Add Venue"),
              tooltip: 'Add New Venue',
            )
          : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      body: _buildBodyContent(),
    );
  }

  // ... (All other UI build methods are exactly the same as before until _buildBodyContent) ...
   Widget _buildWebAppBarTitle(BuildContext context) {
    final theme = Theme.of(context);
    final currentUser = _currentUser;
    double screenWidth = MediaQuery.of(context).size.width;
    double leadingWidth = 150 + (_userName != null ? 100 : 0);
    double searchWidthFraction = 0.4;
    double minSearchWidth = 200;
    double maxSearchWidth = 500;
    double actionsWidth =
        80 + (_currentUser != null ? 120 : 0); // Simplified calculation
    double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
    double calculatedSearchWidth =
        (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);
        
    return Row(children: [
      Text('MM Associates',
          style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
      const SizedBox(width: 24),
      if (_isLoadingName && currentUser != null)
        const Padding(
            padding: EdgeInsets.only(right: 16.0),
            child: SizedBox(
                width: 18,
                height: 18,
                child: CircularProgressIndicator(strokeWidth: 2)))
      else if (_userName != null && currentUser != null)
        Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: Text('Hi, ${_userName!.split(' ')[0]}!',
                style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                    color: theme.textTheme.bodyLarge?.color),
                overflow: TextOverflow.ellipsis)),
      const Spacer(),
      SizedBox(
        width: calculatedSearchWidth,
        child: WebSearchBar(
          key: ValueKey(_searchQuery ?? 'initial'),
          initialValue: _searchQuery ?? '',
          cityFilter: _selectedCityFilter,
          firestoreService: _firestoreService,
          onSearchSubmitted: (query) {
            _onFilterOrSearchChanged(explicitSearchQuery: query);
          },
          onSuggestionSelected: (suggestionName) {
            _onFilterOrSearchChanged(explicitSearchQuery: suggestionName);
          },
          onClear: () {
            _onFilterOrSearchChanged(explicitSearchQuery: null);
          },
        ),
      ),
      const Spacer(),
    ]);
  }
  
  List<Widget> _buildAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
    final String cityNameText = _selectedCityFilter ?? 'Near Me';
    const double textSize = 10.0;

    final locationButton = Tooltip(
      message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
      child: Transform.translate(
        offset: const Offset(0, 9.0),
        child: TextButton(
          onPressed: _openCitySelectionScreen,
          style: TextButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 4),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            foregroundColor: iconColor,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                _selectedCityIcon ??
                    (_selectedCityFilter == null
                        ? Icons.my_location
                        : Icons.location_city_outlined),
                size: 24,
              ),
              const SizedBox(height: 2),
              Text(
                cityNameText,
                style: TextStyle(fontSize: textSize, fontWeight: FontWeight.w500),
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );

    final profileButton = isLoggedIn
        ? IconButton(
            icon: Icon(Icons.person_outline_rounded, color: iconColor),
            tooltip: 'My Profile',
            onPressed: () {
              if (!context.mounted) return;
              Navigator.push(context,
                      MaterialPageRoute(builder: (context) => const ProfileScreen()))
                  .then((_) => {if (mounted) _fetchUserNameAndPic()});
            },
          )
        : null;

    return [
      Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: kIsWeb
            ? [ // Web Layout
                locationButton,
                if (profileButton != null) const SizedBox(width: 8),
                if (profileButton != null) profileButton,
                const SizedBox(width: 8),
              ]
            : [ // Mobile Layout
                IconButton(
                  icon: Icon(Icons.search_outlined, color: iconColor),
                  tooltip: 'Search Venues',
                  onPressed: _openSearchMobile,
                ),
                locationButton,
                if (profileButton != null) profileButton,
                if (profileButton == null) const SizedBox(width: 8),
              ],
      )
    ];
  }
  
  Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
    final titleStyle = theme.appBarTheme.titleTextStyle ??
        theme.primaryTextTheme.titleLarge ??
        const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
    final currentUser = _currentUser;
    return Row(children: [
      if (currentUser != null)
        GestureDetector(
          onTap: () {
            if (!context.mounted) return;
            Navigator.push(context,
                    MaterialPageRoute(builder: (context) => const ProfileScreen()))
                .then((_) {
              if (mounted) _fetchUserNameAndPic();
            });
          },
          child: Tooltip(
            message: "My Profile",
            child: Padding(
              padding: const EdgeInsets.only(right: 10.0),
              child: CircleAvatar(
                  radius: 18,
                  backgroundColor: Colors.white24,
                  backgroundImage:
                      _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty
                          ? NetworkImage(_userProfilePicUrl!)
                          : null,
                  child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty
                      ? Icon(Icons.person_outline,
                          size: 20, color: Colors.white.withOpacity(0.8))
                      : null),
            ),
          ),
        ),
      if (_isLoadingName && currentUser != null)
        const Padding(
            padding: EdgeInsets.only(left: 6.0),
            child: SizedBox(
                width: 18,
                height: 18,
                child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white70))))
      else if (_userName != null && currentUser != null)
        Expanded(
          child: Padding(
              padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
              child: Text(
                'Hi, ${_userName!.split(' ')[0]}!',
                style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
                overflow: TextOverflow.ellipsis,
              )),
        )
      else
        Text('MM Associates', style: titleStyle),
    ]);
  }
  
  Widget _buildBodyContent() {
    return Column(children: [
      _buildQuickSportFilters(),
      Expanded(
        child: RefreshIndicator(
          onRefresh: _handleRefresh,
          child: ListView(
            padding: EdgeInsets.zero,
            children: [
              if (_isSearchingOrFiltering) ...[
                _buildSectionHeader(
                    context,
                    _searchQuery != null && _searchQuery!.isNotEmpty
                        ? "Results for \"$_searchQuery\""
                        : (_selectedCityFilter != null
                            ? "Venues in $_selectedCityFilter"
                            : (_selectedSportFilter != null
                                ? "Venues for $_selectedSportFilter"
                                : "Filtered Venues"))),
                // <<< MODIFIED: Pass section identifier >>>
                _buildVenueList(_filteredVenues, _isLoadingFilteredVenues,
                    _filteredVenueFetchError, "No venues found for your selection.",
                    sectionIdentifier: 'search', isNearbySection: false),
              ] else ...[
                 if (!_isFetchingLocation && _currentPosition == null)
                  _buildNoLocationWarning(),
                if (_currentPosition != null || _isLoadingNearbyVenues)
                  _buildSectionHeader(context, "Venues Near You"),
                // <<< MODIFIED: Pass section identifier >>>
                _buildVenueList(
                    _nearbyVenues,
                    _isLoadingNearbyVenues,
                    _nearbyVenueFetchError,
                    "No venues found nearby. Try exploring other cities.",
                    sectionIdentifier: 'nearby', isNearbySection: true),
                const SizedBox(height: 16),
                _buildSectionHeader(context, "Explore Venues"),
                // <<< MODIFIED: Pass section identifier >>>
                _buildVenueList(
                    _exploreVenues,
                    _isLoadingExploreVenues,
                    _exploreVenueFetchError,
                    "No venues to explore at the moment.",
                    sectionIdentifier: 'explore', isNearbySection: false),
              ],
              const SizedBox(height: 80),
            ],
          ),
        ),
      ),
    ]);
  }

  Widget _buildNoLocationWarning() {
    // ... same code ...
    return Container(
      color: Colors.amber.withOpacity(0.1),
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
      child: Row(
        children: [
          Icon(Icons.location_off_outlined, color: Colors.amber.shade800),
          const SizedBox(width: 12.0),
          Expanded(
            child: Text(
              'Location is off or denied. "Venues Near You" will not be shown.',
              style: TextStyle(color: Colors.amber.shade900),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildQuickSportFilters() {
    // ... same code ...
    final theme = Theme.of(context);
    return Container(
      height: 55,
      color: theme.cardColor,
      child: ListView.separated(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
        scrollDirection: Axis.horizontal,
        itemCount: _quickSportFilters.length + 1,
        separatorBuilder: (context, index) => const SizedBox(width: 10),
        itemBuilder: (context, index) {
          if (index == 0) {
            final bool isSelected = _selectedSportFilter == null;
            return ChoiceChip(
              label: const Text('All Sports'),
              selected: isSelected,
              onSelected: (bool nowSelected) {
                if (nowSelected && _selectedSportFilter != null) {
                  setStateIfMounted(() => _selectedSportFilter = null);
                  _onFilterOrSearchChanged();
                }
              },
              selectedColor: theme.colorScheme.primary.withOpacity(0.2),
              backgroundColor:
                  theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
              labelStyle: TextStyle(
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.textTheme.bodyMedium?.color,
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                  fontSize: 13),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                  side: BorderSide(
                      color: isSelected
                          ? theme.colorScheme.primary.withOpacity(0.5)
                          : Colors.grey.shade300)),
              padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
              visualDensity: VisualDensity.compact,
              showCheckmark: false,
            );
          }
          final sport = _quickSportFilters[index - 1];
          final bool isSelected = _selectedSportFilter == sport;
          return ChoiceChip(
            label: Text(sport),
            selected: isSelected,
            onSelected: (bool isNowSelected) {
              final newFilter = isNowSelected ? sport : null;
              if (_selectedSportFilter != newFilter) {
                setStateIfMounted(() => _selectedSportFilter = newFilter);
                _onFilterOrSearchChanged();
              }
            },
            selectedColor: theme.colorScheme.primary.withOpacity(0.2),
            backgroundColor:
                theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
            labelStyle: TextStyle(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.textTheme.bodyMedium?.color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                fontSize: 13),
            shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
                side: BorderSide(
                    color: isSelected
                        ? theme.colorScheme.primary.withOpacity(0.5)
                        : Colors.grey.shade300)),
            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
            visualDensity: VisualDensity.compact,
            showCheckmark: false,
          );
        },
      ),
    );
  }
  
  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
        child: Text(title,
            style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
  }
  
  // <<< MODIFIED: Pass `sectionIdentifier` down >>>
  Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg,
      String emptyMsg, {required String sectionIdentifier, bool isNearbySection = false}) {
    if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
    if (errorMsg != null)
      return Center(
          child: Padding(
              padding: const EdgeInsets.all(20),
              child: Text(errorMsg,
                  textAlign: TextAlign.center,
                  style: const TextStyle(color: Colors.red, fontSize: 16))));
    if (venues.isEmpty)
      return Center(
          child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0),
              child: Text(emptyMsg,
                  textAlign: TextAlign.center,
                  style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
      gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
          maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
          mainAxisSpacing: 16.0,
          crossAxisSpacing: 16.0,
          childAspectRatio: 0.70),
      itemCount: venues.length,
      itemBuilder: (context, index) {
        final venue = venues[index];
        final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
        return _buildVenueGridCard(venue,
            isFavorite: isFavorite, heroTagContext: sectionIdentifier); // <<< MODIFIED: Pass identifier
      },
    );
  }

  Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
    // ... same code ...
     return Shimmer.fromColors(
        baseColor: Colors.grey[350]!,
        highlightColor: Colors.grey[200]!,
        child: GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            padding: const EdgeInsets.all(16.0),
            gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0,
                mainAxisSpacing: 16.0,
                crossAxisSpacing: 16.0,
                childAspectRatio: 0.70),
            itemCount: itemCount,
            itemBuilder: (context, index) => _buildVenueShimmerCard()));
  }

  Widget _buildVenueShimmerCard() {
    // ... same code ...
     return Card(
        margin: EdgeInsets.zero,
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        clipBehavior: Clip.antiAlias,
        child: Column(children: [
          Container(height: 130, width: double.infinity, color: Colors.white),
          Expanded(
              child: Padding(
                  padding: const EdgeInsets.all(10.0),
                  child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Container(
                                  width: double.infinity,
                                  height: 18.0,
                                  color: Colors.white,
                                  margin: const EdgeInsets.only(bottom: 6)),
                              Container(
                                  width: MediaQuery.of(context).size.width * 0.3,
                                  height: 14.0,
                                  color: Colors.white,
                                  margin: const EdgeInsets.only(bottom: 6)),
                              Container(
                                  width: MediaQuery.of(context).size.width * 0.2,
                                  height: 12.0,
                                  color: Colors.white)
                            ]),
                        Container(width: double.infinity, height: 12.0, color: Colors.white)
                      ])))
        ]));
  }
  
  // <<< MODIFIED: Added `heroTagContext` parameter >>>
  Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite, required String heroTagContext}) {
      final String venueId = venue['id'] as String? ?? '';
      return _VenueCardWidget(
        key: ValueKey('${heroTagContext}_$venueId'), // <<< MODIFIED: Make ValueKey unique
        venue: venue,
        isFavorite: isFavorite,
        onTapCard: () => _navigateToVenueDetail(venue, heroTagContext), // <<< MODIFIED: Pass context
        onTapFavorite: () => _toggleFavorite(venueId),
        heroTagContext: heroTagContext, // <<< MODIFIED: Pass to widget
      );
  }

  Future<void> _toggleFavorite(String venueId) async {
    // ... same code ...
    if (!mounted) return;
    final currentUser = _currentUser;
    if (currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
        content: Text("Please log in to manage favorites."),
      ));
      return;
    }
    if (venueId.isEmpty) return;

    final currentIsFavorite = _favoriteVenueIds.contains(venueId);

    try {
      if (!currentIsFavorite) {
        await _userService.addFavorite(venueId);
      } else {
        await _userService.removeFavorite(venueId);
      }
    } catch (e) {
      if (mounted)
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text("Error updating favorites: ${e.toString()}"),
        ));
    }
  }
}

class _VenueCardWidget extends StatefulWidget {
  final Map<String, dynamic> venue;
  final bool isFavorite;
  final VoidCallback onTapCard;
  final Future<void> Function() onTapFavorite;
  final String heroTagContext; // <<< MODIFIED: Added parameter

  const _VenueCardWidget({
    required Key key,
    required this.venue,
    required this.isFavorite,
    required this.onTapCard,
    required this.onTapFavorite,
    required this.heroTagContext, // <<< MODIFIED: Added parameter
  }) : super(key: key);

  @override
  _VenueCardWidgetState createState() => _VenueCardWidgetState();
}

class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
  late AnimationController _favoriteAnimationController;
  late Animation<double> _favoriteScaleAnimation;

  @override
  void initState() {
    super.initState();
    _favoriteAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
      CurvedAnimation(
          parent: _favoriteAnimationController,
          curve: Curves.elasticOut,
          reverseCurve: Curves.easeInCubic),
    );
    if(widget.isFavorite) {
      _favoriteAnimationController.value = 1.0;
    }
  }

  @override
  void didUpdateWidget(_VenueCardWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isFavorite != oldWidget.isFavorite && mounted) {
      if (widget.isFavorite) {
        _favoriteAnimationController.forward(from: 0.0).catchError((e) {
          if (e is! TickerCanceled) debugPrint("Error playing fav animation: $e");
        });
      } else {
        _favoriteAnimationController.reverse().catchError((e) {
          if (e is! TickerCanceled) debugPrint("Error reversing fav animation: $e");
        });
      }
    }
  }

  @override
  void dispose() {
    _favoriteAnimationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
    final dynamic sportRaw = widget.venue['sportType'];
    final String sport = (sportRaw is String)
        ? sportRaw
        : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
    final String? imageUrl = widget.venue['imageUrl'] as String?;
    final String city = widget.venue['city'] as String? ?? '';
    final String venueId = widget.venue['id'] as String? ?? '';
    final double? distance = widget.venue['distance'] as double?;
    final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
    final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      child: Card(
        margin: EdgeInsets.zero,
        elevation: 3,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        clipBehavior: Clip.antiAlias,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(
              height: 130,
              width: double.infinity,
              child: Stack(
                children: [
                  Positioned.fill(
                    child: InkWell(
                      onTap: widget.onTapCard,
                      child: (imageUrl != null &&
                              imageUrl.isNotEmpty &&
                              Uri.tryParse(imageUrl)?.isAbsolute == true)
                          ? Hero(
                              // <<< MODIFIED: Using the unique context in the Hero tag
                              tag: '${widget.heroTagContext}_venue_image_$venueId',
                              child: Image.network(
                                imageUrl,
                                height: 130,
                                width: double.infinity,
                                fit: BoxFit.cover,
                                loadingBuilder: (context, child, loadingProgress) =>
                                    (loadingProgress == null)
                                        ? child
                                        : Container(
                                            height: 130,
                                            color: Colors.grey[200],
                                            child: Center(
                                                child: CircularProgressIndicator(
                                                    strokeWidth: 2,
                                                    value: loadingProgress
                                                                .expectedTotalBytes !=
                                                            null
                                                        ? loadingProgress.cumulativeBytesLoaded /
                                                            loadingProgress.expectedTotalBytes!
                                                        : null))),
                                errorBuilder: (context, error, stackTrace) => Container(
                                    height: 130,
                                    color: Colors.grey[200],
                                    child: Center(
                                        child: Icon(Icons.broken_image_outlined,
                                            color: Colors.grey[400], size: 40))),
                              ),
                            )
                          : Container(
                              height: 130,
                              color: theme.primaryColor.withOpacity(0.08),
                              child: Center(
                                  child: Icon(Icons.sports_soccer_outlined,
                                      size: 50, color: theme.primaryColor.withOpacity(0.7)))),
                    ),
                  ),
                  Positioned(
                    top: 6,
                    right: 6,
                    child: Material(
                      color: Colors.black.withOpacity(0.45),
                      shape: const CircleBorder(),
                      child: InkWell(
                        borderRadius: BorderRadius.circular(20),
                        onTap: widget.onTapFavorite,
                        child: Padding(
                          padding: const EdgeInsets.all(7.0),
                          child: ScaleTransition(
                            scale: _favoriteScaleAnimation,
                            child: Icon(
                              widget.isFavorite
                                  ? Icons.favorite_rounded
                                  : Icons.favorite_border_rounded,
                              color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
                              size: 22,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                  if (distance != null)
                    Positioned(
                      bottom: 6,
                      left: 6,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
                        decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.6),
                            borderRadius: BorderRadius.circular(4)),
                        child: Text('${distance.toStringAsFixed(1)} km',
                            style: const TextStyle(
                                color: Colors.white,
                                fontSize: 11,
                                fontWeight: FontWeight.w500)),
                      ),
                    ),
                ],
              ),
            ),
            Expanded(
              child: InkWell(
                onTap: widget.onTapCard,
                child: Padding(
                  padding: const EdgeInsets.all(10.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(name,
                              style: theme.textTheme.titleMedium
                                  ?.copyWith(fontWeight: FontWeight.w600, fontSize: 15),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis),
                          const SizedBox(height: 4),
                          Row(children: [
                            Icon(Icons.sports_kabaddi_outlined,
                                size: 14, color: theme.colorScheme.secondary),
                            const SizedBox(width: 4),
                            Expanded(
                                child: Text(sport,
                                    style: theme.textTheme.bodyMedium
                                        ?.copyWith(color: Colors.grey[800], fontSize: 12),
                                    maxLines: 1,
                                    overflow: TextOverflow.ellipsis)),
                          ]),
                          if (reviewCount > 0)
                            Padding(
                              padding: const EdgeInsets.only(top: 5.0),
                              child: Row(children: [
                                Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
                                const SizedBox(width: 4),
                                Text(averageRating.toStringAsFixed(1),
                                    style:
                                        const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
                                const SizedBox(width: 4),
                                Text("($reviewCount reviews)",
                                    style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
                              ]),
                            ),
                        ],
                      ),
                      Row(
                        children: [
                          Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
                          const SizedBox(width: 4),
                          Expanded(
                              child: Text(city,
                                  style: theme.textTheme.bodySmall
                                      ?.copyWith(color: Colors.grey[700], fontSize: 12),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis)),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== features\home\screens\home_screen_copy.dart =====

// // // // // //------------original code starts here------------

// // // // // //// import 'package:flutter/material.dart';
// // // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // // import 'package:geolocator/geolocator.dart';
// // // // // // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // // // // // import 'package:mm_associates/features/home/screens/venue_form.dart';
// // // // // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // // // // import 'package:mm_associates/features/user/services/user_service.dart';
// // // // // // import 'package:mm_associates/core/services/location_service.dart';
// // // // // // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // // // // // import 'venue_detail_screen.dart';
// // // // // // import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
// // // // // // import 'dart:async';
// // // // // // import 'package:shimmer/shimmer.dart';
// // // // // // import 'city_selection_screen.dart' show CitySelectionScreen, CityInfo, kAppAllCities;
// // // // // // import 'package:flutter/scheduler.dart';

// // // // // // class HomeScreen extends StatefulWidget {
// // // // // //   const HomeScreen({super.key});

// // // // // //   @override
// // // // // //   State<HomeScreen> createState() => _HomeScreenState();
// // // // // // }

// // // // // // class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
// // // // // //   final AuthService _authService = AuthService();
// // // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // // //   final LocationService _locationService = LocationService();
// // // // // //   final UserService _userService = UserService();

// // // // // //   final TextEditingController _webSearchController = TextEditingController();
// // // // // //   final FocusNode _webSearchFocusNode = FocusNode();
// // // // // //   List<Map<String, dynamic>> _webSearchSuggestions = [];
// // // // // //   bool _isLoadingWebSuggestions = false;
// // // // // //   bool _showWebSuggestions = false;
// // // // // //   Timer? _webSearchDebounce;

// // // // // //   User? _currentUser;
// // // // // //   String? _userName;
// // // // // //   String? _userProfilePicUrl;
// // // // // //   bool _isLoadingName = true;

// // // // // //   List<Map<String, dynamic>> _filteredVenues = [];
// // // // // //   bool _isLoadingFilteredVenues = true;
// // // // // //   String? _filteredVenueFetchError;

// // // // // //   List<Map<String, dynamic>> _nearbyVenues = [];
// // // // // //   bool _isLoadingNearbyVenues = true;
// // // // // //   String? _nearbyVenueFetchError;

// // // // // //   List<Map<String, dynamic>> _exploreVenues = [];
// // // // // //   bool _isLoadingExploreVenues = true;
// // // // // //   String? _exploreVenueFetchError;

// // // // // //   Position? _currentPosition;
// // // // // //   bool _isFetchingLocation = false;
// // // // // //   String? _locationStatusMessage;

// // // // // //   String? _selectedCityFilter;
// // // // // //   IconData? _selectedCityIcon; // ADDED: To store the icon of the selected city
// // // // // //   String? _selectedSportFilter;
// // // // // //   String? _searchQuery;

// // // // // //   final List<String> _supportedCities = ['Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'];
// // // // // //   final List<String> _quickSportFilters = ['Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'];

// // // // // //   List<String> _favoriteVenueIds = [];
// // // // // //   bool _isLoadingFavorites = true;
// // // // // //   Stream<List<String>>? _favoritesStream;
// // // // // //   StreamSubscription<List<String>>? _favoritesSubscription;

// // // // // //   bool get _isSearchingOrFiltering => (_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null;

// // // // // //   final GlobalKey _webSearchBarKey = GlobalKey();

// // // // // //   @override
// // // // // //   void initState() {
// // // // // //     super.initState();
// // // // // //     _currentUser = FirebaseAuth.instance.currentUser;
// // // // // //     _initializeScreen();
// // // // // //     _setupFavoritesStream();

// // // // // //     _webSearchController.addListener(_onWebSearchChanged);
// // // // // //     _webSearchFocusNode.addListener(_onWebSearchFocusChanged);

// // // // // //     // ADDED: Initialize selected city icon based on the current filter state
// // // // // //     _updateSelectedCityIconFromFilter();
// // // // // //   }

// // // // // //   // ADDED: Helper method to set the city icon based on _selectedCityFilter
// // // // // //   void _updateSelectedCityIconFromFilter() {
// // // // // //     if (_selectedCityFilter == null) {
// // // // // //       _selectedCityIcon = Icons.my_location; // Default "Near Me" icon
// // // // // //     } else {
// // // // // //       try {
// // // // // //         // Find the city in our global list (kAppAllCities) to get its icon
// // // // // //         final cityInfo = kAppAllCities.firstWhere(
// // // // // //           (city) => city.name == _selectedCityFilter,
// // // // // //         );
// // // // // //         _selectedCityIcon = cityInfo.icon;
// // // // // //       } catch (e) {
// // // // // //         // Fallback if city not found in list (should ideally not happen if data is consistent)
// // // // // //         _selectedCityIcon = Icons.location_city_outlined;
// // // // // //         debugPrint("HomeScreen initState: Selected city '$_selectedCityFilter' not found in kAppAllCities. Using fallback icon. Error: $e");
// // // // // //       }
// // // // // //     }
// // // // // //   }

// // // // // //   @override
// // // // // //   void dispose() {
// // // // // //     _webSearchController.removeListener(_onWebSearchChanged);
// // // // // //     _webSearchController.dispose();
// // // // // //     _webSearchFocusNode.removeListener(_onWebSearchFocusChanged);
// // // // // //     _webSearchFocusNode.dispose();
// // // // // //     _webSearchDebounce?.cancel();
// // // // // //     _favoritesSubscription?.cancel();
// // // // // //     super.dispose();
// // // // // //   }

// // // // // //   void _onWebSearchChanged() {
// // // // // //     if (_webSearchDebounce?.isActive ?? false) _webSearchDebounce!.cancel();
// // // // // //     _webSearchDebounce = Timer(const Duration(milliseconds: 500), () {
// // // // // //       if (mounted && _webSearchController.text.trim().isNotEmpty && _webSearchFocusNode.hasFocus) {
// // // // // //         _fetchWebSearchSuggestions(_webSearchController.text.trim());
// // // // // //       } else if (mounted) {
// // // // // //         setStateIfMounted(() {
// // // // // //           _webSearchSuggestions = [];
// // // // // //           _showWebSuggestions = false;
// // // // // //         });
// // // // // //       }
// // // // // //     });
// // // // // //     if (mounted) {
// // // // // //      setStateIfMounted(() {});
// // // // // //     }
// // // // // //   }

// // // // // //   void _onWebSearchFocusChanged() {
// // // // // //     if (!mounted) return;
// // // // // //     setStateIfMounted(() {
// // // // // //       if (_webSearchFocusNode.hasFocus && _webSearchController.text.trim().isNotEmpty) {
// // // // // //         _showWebSuggestions = true;
// // // // // //         if(_webSearchSuggestions.isEmpty && _webSearchController.text.trim().isNotEmpty) {
// // // // // //           _fetchWebSearchSuggestions(_webSearchController.text.trim());
// // // // // //         }
// // // // // //       } else if (_webSearchFocusNode.hasFocus && _webSearchController.text.trim().isEmpty) {
// // // // // //          _webSearchSuggestions = [];
// // // // // //          _showWebSuggestions = true;
// // // // // //       }
// // // // // //       else {
// // // // // //         Future.delayed(const Duration(milliseconds: 200), () {
// // // // // //            if (!mounted || !_webSearchFocusNode.hasFocus) {
// // // // // //               setStateIfMounted(() => _showWebSuggestions = false);
// // // // // //            }
// // // // // //         });
// // // // // //       }
// // // // // //     });
// // // // // //   }

// // // // // //   Future<void> _fetchWebSearchSuggestions(String query) async {
// // // // // //     if (query.isEmpty) {
// // // // // //       if(mounted) {
// // // // // //         setStateIfMounted(() {
// // // // // //           _webSearchSuggestions = [];
// // // // // //           _isLoadingWebSuggestions = false;
// // // // // //         });
// // // // // //       }
// // // // // //       return;
// // // // // //     }
// // // // // //     if(mounted) {
// // // // // //       setStateIfMounted(() {
// // // // // //         _isLoadingWebSuggestions = true;
// // // // // //         _showWebSuggestions = true;
// // // // // //       });
// // // // // //     }
// // // // // //     try {
// // // // // //       final suggestions = await _firestoreService.getVenues(
// // // // // //         searchQuery: query,
// // // // // //         cityFilter: _selectedCityFilter,
// // // // // //         limit: 500,
// // // // // //         forSuggestions: true,
// // // // // //       );
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() {
// // // // // //         _webSearchSuggestions = suggestions;
// // // // // //         _isLoadingWebSuggestions = false;
// // // // // //       });
// // // // // //     } catch (e) {
// // // // // //       debugPrint("Error fetching web search suggestions: $e");
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() {
// // // // // //         _isLoadingWebSuggestions = false;
// // // // // //         _webSearchSuggestions = [];
// // // // // //       });
// // // // // //     }
// // // // // //   }


// // // // // //   Future<void> _initializeScreen() async {
// // // // // //     await _fetchUserNameAndPic();
// // // // // //     await _fetchPrimaryVenueData();
// // // // // //   }

// // // // // //   Future<void> _fetchPrimaryVenueData() async {
// // // // // //     if (!mounted) return;
// // // // // //     setStateIfMounted(() {
// // // // // //       _isFetchingLocation = true; _isLoadingNearbyVenues = true; _isLoadingExploreVenues = true;
// // // // // //       _locationStatusMessage = 'Fetching your location...';
// // // // // //       _nearbyVenues = []; _exploreVenues = [];
// // // // // //       _nearbyVenueFetchError = null; _exploreVenueFetchError = null;
// // // // // //     });
// // // // // //     _currentPosition = await _locationService.getCurrentLocation();
// // // // // //     if (!mounted) return;
// // // // // //     setStateIfMounted(() {
// // // // // //       _isFetchingLocation = false;
// // // // // //       _locationStatusMessage = _currentPosition != null ? 'Location acquired.' : 'Could not get location.';
// // // // // //     });
// // // // // //     await Future.wait([_fetchNearbyVenuesScoped(), _fetchExploreVenuesFromOtherCities()]);
// // // // // //   }

// // // // // //   void _setupFavoritesStream() {
// // // // // //     _favoritesSubscription?.cancel();
// // // // // //     if (_currentUser != null) {
// // // // // //         _favoritesStream = _userService.getFavoriteVenueIdsStream();
// // // // // //         _favoritesSubscription = _favoritesStream?.listen(
// // // // // //           (favoriteIds) {
// // // // // //             if (mounted) {
// // // // // //               final newIdsSet = favoriteIds.toSet();
// // // // // //               final currentIdsSet = _favoriteVenueIds.toSet();
// // // // // //               if (newIdsSet.difference(currentIdsSet).isNotEmpty || currentIdsSet.difference(newIdsSet).isNotEmpty) {
// // // // // //                 setStateIfMounted(() {
// // // // // //                   _favoriteVenueIds = favoriteIds;
// // // // // //                 });
// // // // // //               }
// // // // // //             }
// // // // // //           },
// // // // // //           onError: (error) {
// // // // // //             debugPrint("Error in favorites stream: $error");
// // // // // //              if (mounted) {
// // // // // //                 ScaffoldMessenger.of(context).showSnackBar(
// // // // // //                     const SnackBar(content: Text("Could not update favorites."),
// // // // // //                     backgroundColor: Colors.orangeAccent,
// // // // // //                     behavior: SnackBarBehavior.floating)
// // // // // //                 );
// // // // // //              }
// // // // // //           }
// // // // // //         );
// // // // // //         if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);

// // // // // //     } else {
// // // // // //       if (mounted) {
// // // // // //          setStateIfMounted(() {
// // // // // //            _favoriteVenueIds = [];
// // // // // //            _isLoadingFavorites = false;
// // // // // //            _favoritesStream = null;
// // // // // //            _favoritesSubscription = null;
// // // // // //          });
// // // // // //       }
// // // // // //     }
// // // // // //   }

// // // // // //   @override
// // // // // //   void didChangeDependencies() {
// // // // // //     super.didChangeDependencies();
// // // // // //     final currentAuthUser = FirebaseAuth.instance.currentUser;
// // // // // //     if (currentAuthUser != _currentUser) {
// // // // // //       _currentUser = currentAuthUser;
// // // // // //       _initializeScreen();
// // // // // //       _setupFavoritesStream();
// // // // // //       // ADDED: Also update city icon if user changes, though it's not user-specific
// // // // // //       // this call is harmless and ensures consistency if _selectedCityFilter somehow depended on user.
// // // // // //       if (mounted) {
// // // // // //         setStateIfMounted(() {
// // // // // //           _updateSelectedCityIconFromFilter();
// // // // // //         });
// // // // // //       }
// // // // // //     }
// // // // // //   }


// // // // // //   void setStateIfMounted(VoidCallback fn) { if (mounted) setState(fn); }

// // // // // //   Future<void> _fetchVenuesForFilterOrSearch({String? newSearchQuery}) async {
// // // // // //     if (!mounted) return;
// // // // // //     final currentSearchQuery = newSearchQuery ?? (kIsWeb ? _webSearchController.text.trim() : _searchQuery);

// // // // // //     if (mounted) {
// // // // // //       setStateIfMounted(() {
// // // // // //         _isLoadingFilteredVenues = true; _filteredVenueFetchError = null;
// // // // // //         _searchQuery = currentSearchQuery;
// // // // // //         _filteredVenues = [];
// // // // // //         if(kIsWeb && currentSearchQuery == null) _webSearchController.clear();
// // // // // //         if(kIsWeb) _showWebSuggestions = false;
// // // // // //       });
// // // // // //     }

// // // // // //     try {
// // // // // //       debugPrint("Fetching FILTERED/SEARCH venues: City: $_selectedCityFilter, Sport: $_selectedSportFilter, Search: $_searchQuery, Location: $_currentPosition");
// // // // // //       final venuesData = await _firestoreService.getVenues(
// // // // // //         userLocation: _currentPosition,
// // // // // //         radiusInKm: _selectedCityFilter != null ? null : (_currentPosition != null ? 50.0 : null),
// // // // // //         cityFilter: _selectedCityFilter,
// // // // // //         searchQuery: _searchQuery,
// // // // // //         sportFilter: _selectedSportFilter,
// // // // // //       );
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() {
// // // // // //           _filteredVenues = venuesData;
// // // // // //         });
// // // // // //     } catch (e) {
// // // // // //       debugPrint("Error fetching filtered/search venues: $e");
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() => _filteredVenueFetchError = "Could not load venues: ${e.toString().replaceFirst('Exception: ', '')}");
// // // // // //     } finally {
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() => _isLoadingFilteredVenues = false);
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _fetchNearbyVenuesScoped() async {
// // // // // //     if (!mounted) return;
// // // // // //     if (_currentPosition == null) {
// // // // // //       if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = false; _nearbyVenueFetchError = "Location not available."; _nearbyVenues = []; });
// // // // // //       return;
// // // // // //     }
// // // // // //     if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = true; _nearbyVenueFetchError = null; _nearbyVenues = []; });
// // // // // //     try {
// // // // // //       final venuesData = await _firestoreService.getVenues(userLocation: _currentPosition, radiusInKm: 25.0);
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() {
// // // // // //         _nearbyVenues = venuesData;
// // // // // //       });
// // // // // //     } catch (e) {
// // // // // //       debugPrint("Error fetching nearby venues: $e");
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() => _nearbyVenueFetchError = "Could not load nearby venues.");
// // // // // //     } finally {
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() => _isLoadingNearbyVenues = false);
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _fetchExploreVenuesFromOtherCities() async {
// // // // // //     if (!mounted) return;
// // // // // //     setStateIfMounted(() { _isLoadingExploreVenues = true; _exploreVenueFetchError = null; _exploreVenues = [];});
// // // // // //     List<Map<String, dynamic>> allExploreVenues = [];
// // // // // //     try {
// // // // // //       for (String city in _supportedCities) {
// // // // // //         final cityVenues = await _firestoreService.getVenues(cityFilter: city, userLocation: _currentPosition, limit: 5);
// // // // // //         allExploreVenues.addAll(cityVenues);
// // // // // //         if (!mounted) return;
// // // // // //       }
// // // // // //       final uniqueExploreVenues = allExploreVenues.fold<Map<String, Map<String, dynamic>>>({}, (map, venue) {
// // // // // //           final String? venueId = venue['id'] as String?;
// // // // // //           if (venueId != null) map[venueId] = venue;
// // // // // //           return map;
// // // // // //         }).values.toList();

// // // // // //       if (_currentPosition != null) {
// // // // // //         uniqueExploreVenues.sort((a, b) {
// // // // // //           final distA = a['distance'] as double?; final distB = b['distance'] as double?;
// // // // // //           if (distA != null && distB != null) return distA.compareTo(distB);
// // // // // //           if (distA != null) return -1;
// // // // // //           if (distB != null) return 1;
// // // // // //           return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
// // // // // //         });
// // // // // //       } else {
// // // // // //          uniqueExploreVenues.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
// // // // // //       }
// // // // // //       if(!mounted) return;
// // // // // //       setStateIfMounted(() {
// // // // // //         _exploreVenues = uniqueExploreVenues.take(15).toList();
// // // // // //       });
// // // // // //     } catch (e) {
// // // // // //       debugPrint("Error fetching explore venues: $e");
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() => _exploreVenueFetchError = "Could not load explore venues.");
// // // // // //     } finally {
// // // // // //       if (!mounted) return;
// // // // // //       setStateIfMounted(() => _isLoadingExploreVenues = false);
// // // // // //     }
// // // // // //   }


// // // // // //   Future<void> _fetchUserNameAndPic() async {
// // // // // //     _setLoadingName(true); final currentUser = _currentUser;
// // // // // //     if (currentUser == null) { if(mounted) _updateUserNameAndPic('Guest', null); _setLoadingName(false); return; }
// // // // // //     try {
// // // // // //       final userData = await _userService.getUserProfileData();
// // // // // //       if (!mounted) return;
// // // // // //       final fetchedName = userData?['name'] as String? ?? currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // // // // //       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
// // // // // //       _updateUserNameAndPic(fetchedName, fetchedPicUrl);
// // // // // //     } catch (e) {
// // // // // //       debugPrint("Error fetching user name/pic via UserService: $e"); if (!mounted) return;
// // // // // //       final fallbackName = currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // // // // //       _updateUserNameAndPic(fallbackName, null);
// // // // // //     } finally { if(mounted) _setLoadingName(false); }
// // // // // //   }


// // // // // //   void _setLoadingName(bool isLoading) => {if(mounted) setStateIfMounted(() => _isLoadingName = isLoading)};
// // // // // //   void _updateUserNameAndPic(String name, String? picUrl) => {if(mounted) setStateIfMounted(() { _userName = name; _userProfilePicUrl = picUrl; })};

// // // // // //   Future<void> _handleRefresh() async {
// // // // // //     if(mounted) {
// // // // // //       setStateIfMounted(() {
// // // // // //           _searchQuery = null;
// // // // // //           _selectedSportFilter = null;
// // // // // //           if (kIsWeb) {
// // // // // //               _webSearchController.clear();
// // // // // //               _showWebSuggestions = false;
// // // // // //               _webSearchSuggestions = [];
// // // // // //           }
// // // // // //       });
// // // // // //     }
// // // // // //     if (_isSearchingOrFiltering) {
// // // // // //       _onFilterOrSearchChanged();
// // // // // //     } else {
// // // // // //       await _fetchPrimaryVenueData();
// // // // // //     }
// // // // // //   }

// // // // // //   void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
// // // // // //       String? currentSearchText = explicitSearchQuery ?? (kIsWeb ? _webSearchController.text.trim() : _searchQuery);

// // // // // //       if (mounted) {
// // // // // //         setStateIfMounted(() {
// // // // // //           _searchQuery = currentSearchText;
// // // // // //           if(kIsWeb && currentSearchText != null) { _webSearchController.text = currentSearchText;}
// // // // // //           else if (kIsWeb && currentSearchText == null && _selectedCityFilter == null && _selectedSportFilter == null) {
// // // // // //               _webSearchController.clear();
// // // // // //           }
// // // // // //         });
// // // // // //       }

// // // // // //       if ((_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null) {
// // // // // //            _fetchVenuesForFilterOrSearch(newSearchQuery: _searchQuery);
// // // // // //       } else {
// // // // // //           _fetchPrimaryVenueData();
// // // // // //       }
// // // // // //   }

// // // // // //   Future<void> _showLogoutConfirmationDialog(BuildContext context) async {
// // // // // //       if (!context.mounted) return;
// // // // // //       return showDialog<void>(context: context, barrierDismissible: false, builder: (BuildContext dialogContext) {
// // // // // //           return AlertDialog(title: const Text('Confirm Logout'), content: const SingleChildScrollView(child: ListBody(children: <Widget>[Text('Are you sure you want to sign out?')])),
// // // // // //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
// // // // // //             actions: <Widget>[
// // // // // //               TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
// // // // // //               TextButton(child: const Text('Logout', style: TextStyle(color: Colors.red)), onPressed: () async {
// // // // // //                   Navigator.of(dialogContext).pop(); try { await _authService.signOut();
// // // // // //                    } catch (e) {
// // // // // //                     debugPrint("Error during sign out: $e"); if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error signing out: ${e.toString()}'), backgroundColor: Colors.redAccent, behavior: SnackBarBehavior.floating, margin: const EdgeInsets.all(10)));
// // // // // //                   }},), ],); },);
// // // // // //     }


// // // // // //   void _navigateToVenueDetail(Map<String, dynamic> venue) {
// // // // // //     if (!context.mounted) return;
// // // // // //     Navigator.push(context, MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venue['id'] as String, initialVenueData: venue))).then((_) {
// // // // // //     });
// // // // // //   }


// // // // // //   void _openSearchMobile() async {
// // // // // //      if (!context.mounted) return;
// // // // // //      final String? submittedQuery = await showSearch<String?>(
// // // // // //         context: context,
// // // // // //         delegate: VenueSearchDelegate(
// // // // // //             firestoreService: _firestoreService,
// // // // // //             initialCityFilter: _selectedCityFilter,
// // // // // //         )
// // // // // //     );
// // // // // //     if (submittedQuery != null && submittedQuery.isNotEmpty) {
// // // // // //         _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
// // // // // //     }
// // // // // //   }

// // // // // //   void _performWebSearch() {
// // // // // //     if(mounted) FocusScope.of(context).unfocus();
// // // // // //     _onFilterOrSearchChanged();
// // // // // //   }

// // // // // //   // MODIFIED: Method for city selection to also update the icon
// // // // // //   Future<void> _openCitySelectionScreen() async {
// // // // // //     if (!mounted) return;
// // // // // //     final String? newSelectedCityName = await Navigator.push<String?>(
// // // // // //       context,
// // // // // //       MaterialPageRoute(
// // // // // //         builder: (context) => CitySelectionScreen(currentSelectedCity: _selectedCityFilter),
// // // // // //       ),
// // // // // //     );

// // // // // //     if (mounted) {
// // // // // //       // Check if the city selection actually changed
// // // // // //       if (newSelectedCityName != _selectedCityFilter) {
// // // // // //         setStateIfMounted(() {
// // // // // //           _selectedCityFilter = newSelectedCityName; // null represents "Near Me"
// // // // // //           _updateSelectedCityIconFromFilter(); // Update the icon based on the new selection
// // // // // //         });
// // // // // //         _onFilterOrSearchChanged(); // Trigger data fetch with the new filter
// // // // // //       } else {
// // // // // //         // If the same city (or "Near Me") was re-selected, ensure the icon is correctly set.
// // // // // //         // This mainly handles cases where the icon might not have been set if _selectedCityFilter was initialized
// // // // // //         // through other means without also setting _selectedCityIcon (which initState now handles).
// // // // // //         IconData currentExpectedIcon = Icons.location_city_outlined; // Fallback
// // // // // //         if (_selectedCityFilter == null) {
// // // // // //             currentExpectedIcon = Icons.my_location;
// // // // // //         } else {
// // // // // //             try {
// // // // // //                 final cityInfo = kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
// // // // // //                 currentExpectedIcon = cityInfo.icon;
// // // // // //             } catch (e) {
// // // // // //                 debugPrint("Error re-validating icon for city '$_selectedCityFilter': $e. Using fallback.");
// // // // // //             }
// // // // // //         }
// // // // // //         if (_selectedCityIcon != currentExpectedIcon) {
// // // // // //             setStateIfMounted(() {
// // // // // //               _selectedCityIcon = currentExpectedIcon;
// // // // // //             });
// // // // // //         }
// // // // // //       }
// // // // // //     }
// // // // // //   }


// // // // // //   @override
// // // // // //   Widget build(BuildContext context) {
// // // // // //     final theme = Theme.of(context);
// // // // // //     final appBarBackgroundColor = theme.appBarTheme.backgroundColor ?? theme.primaryColor;
// // // // // //     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ?? theme.appBarTheme.iconTheme?.color ?? (kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white);
// // // // // //     final bool isLoggedIn = _currentUser != null;

// // // // // //     Widget mainScaffold = Scaffold(
// // // // // //       appBar: AppBar(
// // // // // //         automaticallyImplyLeading: false,
// // // // // //         title: kIsWeb ? _buildWebAppBarTitle(context) : _buildMobileAppBarTitle(context, theme),
// // // // // //         actions: kIsWeb ? _buildWebAppBarActions(context, isLoggedIn, actionsIconColor) : _buildMobileAppBarActions(context, isLoggedIn, actionsIconColor),
// // // // // //         backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
// // // // // //         elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
// // // // // //         iconTheme: theme.iconTheme.copyWith(color: kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white),
// // // // // //         actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
// // // // // //         titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ?? TextStyle(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white, fontSize: 20, fontWeight: FontWeight.w500),
// // // // // //       ),
// // // // // //   floatingActionButton: FloatingActionButton.extended(
// // // // // //     onPressed: () {
// // // // // //       Navigator.push(
// // // // // //         context,
// // // // // //         MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
// // // // // //       ).then((result) {
// // // // // //         if (result == true && mounted) {
// // // // // //           _handleRefresh();
// // // // // //           ScaffoldMessenger.of(context).showSnackBar(
// // // // // //             const SnackBar(content: Text("Venue list updated."), backgroundColor: Colors.blueAccent),
// // // // // //           );
// // // // // //         }
// // // // // //       });
// // // // // //     },
// // // // // //     icon: const Icon(Icons.add_location_alt_outlined),
// // // // // //     label: const Text("Add Venue"),
// // // // // //     tooltip: 'Add New Venue',
// // // // // //   ),
// // // // // //   floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
// // // // // //   body: _buildBodyContent(),
// // // // // //     );

// // // // // //     if (kIsWeb) {
// // // // // //       Rect? searchBarRect;
// // // // // //       final searchBarContext = _webSearchBarKey.currentContext;
// // // // // //       if (searchBarContext != null) {
// // // // // //         final RenderBox? renderBox = searchBarContext.findRenderObject() as RenderBox?;
// // // // // //         if (renderBox != null && renderBox.hasSize) {
// // // // // //             final overlayContext = Overlay.of(context, rootOverlay: true)?.context;
// // // // // //             if (overlayContext != null) {
// // // // // //                  final RenderBox? overlayRenderBox = overlayContext.findRenderObject() as RenderBox?;
// // // // // //                  if (overlayRenderBox != null) {
// // // // // //                     final Offset offsetInOverlay = renderBox.localToGlobal(Offset.zero, ancestor: overlayRenderBox);
// // // // // //                     searchBarRect = Rect.fromLTWH(offsetInOverlay.dx, offsetInOverlay.dy, renderBox.size.width, renderBox.size.height);
// // // // // //                  }
// // // // // //             }
// // // // // //         }
// // // // // //       }

// // // // // //       return Stack(
// // // // // //         children: [
// // // // // //           GestureDetector(
// // // // // //             onTap: () {
// // // // // //               if (_showWebSuggestions) {
// // // // // //                 if(mounted) {
// // // // // //                   setStateIfMounted(() {
// // // // // //                     _showWebSuggestions = false;
// // // // // //                     _webSearchFocusNode.unfocus();
// // // // // //                   });
// // // // // //                 }
// // // // // //               }
// // // // // //             },
// // // // // //             child: mainScaffold,
// // // // // //           ),
// // // // // //           if (_showWebSuggestions && searchBarRect != null)
// // // // // //             Positioned(
// // // // // //               top: searchBarRect.bottom + 4.0,
// // // // // //               left: searchBarRect.left,
// // // // // //               width: searchBarRect.width,
// // // // // //               child: Material(
// // // // // //                 elevation: 4.0,
// // // // // //                 borderRadius: BorderRadius.circular(8),
// // // // // //                 child: Container(
// // // // // //                   constraints: const BoxConstraints(maxHeight: 250),
// // // // // //                   decoration: BoxDecoration(
// // // // // //                     color: Theme.of(context).cardColor,
// // // // // //                     borderRadius: BorderRadius.circular(8),
// // // // // //                      boxShadow: [
// // // // // //                         BoxShadow( color: Colors.black.withOpacity(0.1), blurRadius: 6, offset: const Offset(0,3) )
// // // // // //                      ]
// // // // // //                   ),
// // // // // //                   child: _isLoadingWebSuggestions
// // // // // //                       ? const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)))
// // // // // //                       : _webSearchSuggestions.isEmpty
// // // // // //                           ? Padding(
// // // // // //                               padding: const EdgeInsets.all(16.0),
// // // // // //                               child: Text(
// // // // // //                                 _webSearchController.text.isEmpty && _webSearchFocusNode.hasFocus ? "Start typing to search..." : "No suggestions found.",
// // // // // //                                 textAlign: TextAlign.center,
// // // // // //                                 style: TextStyle(color: Theme.of(context).hintColor),
// // // // // //                               ),
// // // // // //                             )
// // // // // //                           : ListView.builder(
// // // // // //                               shrinkWrap: true,
// // // // // //                               padding: EdgeInsets.zero,
// // // // // //                               itemCount: _webSearchSuggestions.length,
// // // // // //                               itemBuilder: (context, index) {
// // // // // //                                 final venue = _webSearchSuggestions[index];
// // // // // //                                 final String name = venue['name'] as String? ?? 'N/A';
// // // // // //                                 final String city = venue['city'] as String? ?? '';
// // // // // //                                 return ListTile(
// // // // // //                                   title: Text(name, style: const TextStyle(fontSize: 14)),
// // // // // //                                   subtitle: city.isNotEmpty ? Text(city, style: const TextStyle(fontSize: 12)) : null,
// // // // // //                                   dense: true,
// // // // // //                                   contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
// // // // // //                                   onTap: () {
// // // // // //                                     _webSearchController.text = name;
// // // // // //                                     _webSearchController.selection = TextSelection.fromPosition(TextPosition(offset: _webSearchController.text.length));
// // // // // //                                     _performWebSearch();
// // // // // //                                     if(mounted) {
// // // // // //                                       _webSearchFocusNode.unfocus();
// // // // // //                                       setStateIfMounted(() => _showWebSuggestions = false);
// // // // // //                                     }
// // // // // //                                   },
// // // // // //                                 );
// // // // // //                               },
// // // // // //                             ),
// // // // // //                 ),
// // // // // //               ),
// // // // // //             ),
// // // // // //         ],
// // // // // //       );
// // // // // //     }
// // // // // //     return mainScaffold;
// // // // // //   }


// // // // // //   Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
// // // // // //     final titleStyle = theme.appBarTheme.titleTextStyle ?? theme.primaryTextTheme.titleLarge ?? const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
// // // // // //     final currentUser = _currentUser;
// // // // // //     return Row(children: [
// // // // // //         if (currentUser != null)
// // // // // //           GestureDetector(
// // // // // //             onTap: () {
// // // // // //               if (!context.mounted) return;
// // // // // //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // // //                   .then((_) { if (mounted) _fetchUserNameAndPic(); });
// // // // // //             },
// // // // // //             child: Tooltip(
// // // // // //               message: "My Profile",
// // // // // //               child: Padding(
// // // // // //                 padding: const EdgeInsets.only(right: 10.0),
// // // // // //                 child: CircleAvatar(
// // // // // //                   radius: 18,
// // // // // //                   backgroundColor: Colors.white24,
// // // // // //                   backgroundImage: _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty ? NetworkImage(_userProfilePicUrl!) : null,
// // // // // //                   child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty ? Icon(Icons.person_outline, size: 20, color: Colors.white.withOpacity(0.8)) : null
// // // // // //                 )
// // // // // //               ),
// // // // // //             ),
// // // // // //           ),
// // // // // //         if (_isLoadingName && currentUser != null)
// // // // // //           const Padding(
// // // // // //             padding: EdgeInsets.only(left: 6.0),
// // // // // //             child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(Colors.white70)))
// // // // // //           )
// // // // // //         else if (_userName != null && currentUser != null)
// // // // // //           Expanded(
// // // // // //             child: Padding(
// // // // // //                padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
// // // // // //               child: Text(
// // // // // //                 'Hi, ${_userName!.split(' ')[0]}!',
// // // // // //                 style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
// // // // // //                 overflow: TextOverflow.ellipsis
// // // // // //               )
// // // // // //             )
// // // // // //           )
// // // // // //         else
// // // // // //           Text('MM Associates', style: titleStyle),
// // // // // //       ]
// // // // // //     );
// // // // // //   }

// // // // // //   // MODIFIED: To use _selectedCityIcon
// // // // // //   // List<Widget> _buildMobileAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // // // //   //   return [
// // // // // //   //     IconButton(
// // // // // //   //       icon: Icon(Icons.search_outlined, color: iconColor),
// // // // // //   //       tooltip: 'Search Venues',
// // // // // //   //       onPressed: _openSearchMobile,
// // // // // //   //       padding: const EdgeInsets.symmetric(horizontal: 8),
// // // // // //   //       constraints: const BoxConstraints()
// // // // // //   //     ),
// // // // // //   //     IconButton(
// // // // // //   //       icon: Icon(
// // // // // //   //         // Use the stored icon, with fallbacks
// // // // // //   //         _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // // // //   //         color: iconColor,
// // // // // //   //       ),
// // // // // //   //       tooltip: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // // // //   //       onPressed: _openCitySelectionScreen,
// // // // // //   //       padding: const EdgeInsets.symmetric(horizontal: 8.0),
// // // // // //   //       constraints: const BoxConstraints(),
// // // // // //   //     ),
// // // // // //   //     if (isLoggedIn) IconButton(
// // // // // //   //       icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // // // //   //       tooltip: 'My Profile',
// // // // // //   //         onPressed: () { if (!context.mounted) return; Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen())).then((_) { if (mounted) _fetchUserNameAndPic(); }); },
// // // // // //   //         padding: const EdgeInsets.symmetric(horizontal: 8), constraints: const BoxConstraints()),
// // // // // //   //   ];
// // // // // //   // }

// // // // // //   List<Widget> _buildMobileAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // // // //   final String cityNameText = _selectedCityFilter ?? 'Near Me';
// // // // // //   final double textSize = 10.0; // Small text size for below icon

// // // // // //   return [
// // // // // //     IconButton(
// // // // // //       icon: Icon(Icons.search_outlined, color: iconColor),
// // // // // //       tooltip: 'Search Venues',
// // // // // //       onPressed: _openSearchMobile,
// // // // // //       padding: const EdgeInsets.symmetric(horizontal: 8),
// // // // // //       constraints: const BoxConstraints(),
// // // // // //     ),
// // // // // //     Tooltip( // Added Tooltip here for consistency and for the composite icon
// // // // // //       message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // // // //       child: IconButton(
// // // // // //         icon: Column(
// // // // // //           mainAxisAlignment: MainAxisAlignment.center,
// // // // // //           mainAxisSize: MainAxisSize.min, // Important to keep the column compact
// // // // // //           children: [
// // // // // //             Icon(
// // // // // //               _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // // // //               color: iconColor,
// // // // // //               size: 24, // Default IconButton icon size
// // // // // //             ),
// // // // // //             const SizedBox(height: 2), // Spacing between icon and text
// // // // // //             Text(
// // // // // //               cityNameText,
// // // // // //               style: TextStyle(
// // // // // //                 color: iconColor,
// // // // // //                 fontSize: textSize,
// // // // // //                 fontWeight: FontWeight.w500, // Slightly bolder for readability
// // // // // //               ),
// // // // // //               overflow: TextOverflow.ellipsis,
// // // // // //               maxLines: 1,
// // // // // //             ),
// // // // // //           ],
// // // // // //         ),
// // // // // //         onPressed: _openCitySelectionScreen,
// // // // // //         padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0), // Adjust padding if needed
// // // // // //         constraints: const BoxConstraints(),
// // // // // //       ),
// // // // // //     ),
// // // // // //     if (isLoggedIn)
// // // // // //       IconButton(
// // // // // //         icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // // // //         tooltip: 'My Profile',
// // // // // //         onPressed: () {
// // // // // //           if (!context.mounted) return;
// // // // // //           Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // // //               .then((_) {
// // // // // //             if (mounted) _fetchUserNameAndPic();
// // // // // //           });
// // // // // //         },
// // // // // //         padding: const EdgeInsets.symmetric(horizontal: 8),
// // // // // //         constraints: const BoxConstraints(),
// // // // // //       ),
// // // // // //   ];
// // // // // // }

// // // // // //   Widget _buildWebAppBarTitle(BuildContext context) {
// // // // // //      final theme = Theme.of(context);
// // // // // //      final currentUser = _currentUser;
// // // // // //      double screenWidth = MediaQuery.of(context).size.width;
// // // // // //      double leadingWidth = 150 + (_userName != null ? 100 : 0);
// // // // // //      double searchWidthFraction = 0.4;
// // // // // //      double minSearchWidth = 200;
// // // // // //      double maxSearchWidth = 500;
// // // // // //      double actionsWidth = 80 + (_currentUser != null ? 120 : 0);
// // // // // //      double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
// // // // // //      double calculatedSearchWidth = (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);
// // // // // //      double spacerFlexFactor = (availableWidth > calculatedSearchWidth + 40)
// // // // // //          ? (availableWidth - calculatedSearchWidth) / 2 / availableWidth
// // // // // //          : 0.05;
// // // // // //      int searchFlex = (searchWidthFraction * 100).toInt();
// // // // // //      int spacerFlex = (spacerFlexFactor * 100).toInt().clamp(5, 50);

// // // // // //      return Row(children: [
// // // // // //        Text('MM Associates', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
// // // // // //        const SizedBox(width: 24),
// // // // // //        if (_isLoadingName && currentUser != null)
// // // // // //           const Padding(padding: EdgeInsets.only(right: 16.0), child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))
// // // // // //        else if (_userName != null && currentUser != null)
// // // // // //           Padding(
// // // // // //             padding: const EdgeInsets.only(right: 16.0),
// // // // // //             child: Text('Hi, ${_userName!.split(' ')[0]}!', style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: theme.textTheme.bodyLarge?.color), overflow: TextOverflow.ellipsis)
// // // // // //           ),
// // // // // //        Spacer(flex: spacerFlex),
// // // // // //        Expanded(
// // // // // //          flex: searchFlex,
// // // // // //          child: Container(
// // // // // //            key: _webSearchBarKey,
// // // // // //            constraints: BoxConstraints(maxWidth: maxSearchWidth),
// // // // // //            height: 40,
// // // // // //            decoration: BoxDecoration(
// // // // // //              color: theme.inputDecorationTheme.fillColor ?? theme.colorScheme.surfaceContainerLowest,
// // // // // //              borderRadius: BorderRadius.circular(20),
// // // // // //            ),
// // // // // //            child: Center(
// // // // // //              child: TextField(
// // // // // //                controller: _webSearchController,
// // // // // //                focusNode: _webSearchFocusNode,
// // // // // //                style: theme.textTheme.bodyMedium,
// // // // // //                textAlignVertical: TextAlignVertical.center,
// // // // // //                decoration: InputDecoration(
// // // // // //                  hintText: 'Search venues by name, sport, or city...',
// // // // // //                  hintStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
// // // // // //                  prefixIcon: Icon(Icons.search_outlined, color: theme.hintColor, size: 20),
// // // // // //                  border: InputBorder.none,
// // // // // //                  contentPadding: const EdgeInsets.only(left: 0, right: 10, top: 11, bottom: 11),
// // // // // //                  isDense: true,
// // // // // //                  suffixIcon: _webSearchController.text.isNotEmpty
// // // // // //                    ? IconButton(
// // // // // //                        icon: Icon(Icons.clear_rounded, size: 20, color: theme.hintColor),
// // // // // //                        tooltip: 'Clear Search',
// // // // // //                        onPressed: () {
// // // // // //                           _webSearchController.clear();
// // // // // //                            if (_webSearchFocusNode.hasFocus) {
// // // // // //                                _onWebSearchChanged();
// // // // // //                            }
// // // // // //                        },
// // // // // //                        splashRadius: 18,
// // // // // //                        constraints: const BoxConstraints(),
// // // // // //                        padding: EdgeInsets.zero,
// // // // // //                       )
// // // // // //                    : null
// // // // // //                 ),
// // // // // //                onSubmitted: (_) => _performWebSearch(),
// // // // // //              )
// // // // // //            )
// // // // // //          )
// // // // // //        ),
// // // // // //        Spacer(flex: spacerFlex),
// // // // // //      ]);
// // // // // //    }

// // // // // //   // MODIFIED: To use _selectedCityIcon
// // // // // //   // List<Widget> _buildWebAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // // // //   //   return [
// // // // // //   //     Tooltip(
// // // // // //   //       message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // // // //   //       child: IconButton(
// // // // // //   //         icon: Icon(
// // // // // //   //           // Use the stored icon, with fallbacks
// // // // // //   //           _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // // // //   //           color: iconColor,
// // // // // //   //         ),
// // // // // //   //         onPressed: _openCitySelectionScreen,
// // // // // //   //         padding: const EdgeInsets.symmetric(horizontal: 16),
// // // // // //   //         constraints: const BoxConstraints(),
// // // // // //   //       ),
// // // // // //   //     ),
// // // // // //   //     if (isLoggedIn)
// // // // // //   //       Tooltip(
// // // // // //   //         message: 'My Profile',
// // // // // //   //         child: IconButton(
// // // // // //   //           icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // // // //   //           onPressed: () {
// // // // // //   //             if (!context.mounted) return;
// // // // // //   //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // // //   //                 .then((_) { if (mounted) _fetchUserNameAndPic();});
// // // // // //   //           },
// // // // // //   //           padding: const EdgeInsets.symmetric(horizontal: 16),
// // // // // //   //           constraints: const BoxConstraints(),
// // // // // //   //         ),
// // // // // //   //       ),
// // // // // //   //     const SizedBox(width: 8)
// // // // // //   //   ];
// // // // // //   // }

// // // // // // List<Widget> _buildWebAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // // // //   final String cityNameText = _selectedCityFilter ?? 'Near Me';
// // // // // //   final double textSize = 10.0; // Small text size

// // // // // //   return [
// // // // // //     Tooltip(
// // // // // //       message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // // // //       child: IconButton(
// // // // // //         icon: Column(
// // // // // //           mainAxisAlignment: MainAxisAlignment.center,
// // // // // //           mainAxisSize: MainAxisSize.min, // Important
// // // // // //           children: [
// // // // // //             Icon(
// // // // // //               _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // // // //               color: iconColor,
// // // // // //               size: 24,
// // // // // //             ),
// // // // // //             const SizedBox(height: 2),
// // // // // //             Text(
// // // // // //               cityNameText,
// // // // // //               style: TextStyle(
// // // // // //                 color: iconColor,
// // // // // //                 fontSize: textSize,
// // // // // //                 fontWeight: FontWeight.w500,
// // // // // //               ),
// // // // // //               overflow: TextOverflow.ellipsis,
// // // // // //               maxLines: 1,
// // // // // //             ),
// // // // // //           ],
// // // // // //         ),
// // // // // //         onPressed: _openCitySelectionScreen,
// // // // // //         padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0), // Adjust padding for web
// // // // // //         constraints: const BoxConstraints(),
// // // // // //       ),
// // // // // //     ),
// // // // // //     if (isLoggedIn)
// // // // // //       Tooltip(
// // // // // //         message: 'My Profile',
// // // // // //         child: IconButton(
// // // // // //           icon: Icon(Icons.person_outline_rounded, color: iconColor), // Kept this simple
// // // // // //           onPressed: () {
// // // // // //             if (!context.mounted) return;
// // // // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // // //                 .then((_) {
// // // // // //               if (mounted) _fetchUserNameAndPic();
// // // // // //             });
// // // // // //           },
// // // // // //           padding: const EdgeInsets.symmetric(horizontal: 16),
// // // // // //           constraints: const BoxConstraints(),
// // // // // //         ),
// // // // // //       ),
// // // // // //     const SizedBox(width: 8)
// // // // // //   ];
// // // // // // }
// // // // // //   Widget _buildQuickSportFilters() {
// // // // // //     if (_quickSportFilters.isEmpty) return const SizedBox.shrink();
// // // // // //     final theme = Theme.of(context);
// // // // // //     return Container(
// // // // // //       height: 55,
// // // // // //       color: theme.cardColor,
// // // // // //       child: ListView.separated(
// // // // // //         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
// // // // // //         scrollDirection: Axis.horizontal,
// // // // // //         itemCount: _quickSportFilters.length + 1,
// // // // // //         separatorBuilder: (context, index) => const SizedBox(width: 10),
// // // // // //         itemBuilder: (context, index) {
// // // // // //           if (index == 0) {
// // // // // //             final bool isSelected = _selectedSportFilter == null;
// // // // // //             return ChoiceChip(
// // // // // //               label: const Text('All Sports'),
// // // // // //               selected: isSelected,
// // // // // //               onSelected: (bool nowSelected) {
// // // // // //                 if (nowSelected && _selectedSportFilter != null) {
// // // // // //                     setStateIfMounted(() => _selectedSportFilter = null);
// // // // // //                     _onFilterOrSearchChanged();
// // // // // //                 }
// // // // // //               },
// // // // // //               selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// // // // // //               backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// // // // // //               labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// // // // // //               shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// // // // // //               padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// // // // // //               visualDensity: VisualDensity.compact,
// // // // // //                showCheckmark: false,
// // // // // //             );
// // // // // //           }
// // // // // //           final sport = _quickSportFilters[index - 1];
// // // // // //           final bool isSelected = _selectedSportFilter == sport;
// // // // // //           return ChoiceChip(
// // // // // //             label: Text(sport),
// // // // // //             selected: isSelected,
// // // // // //             onSelected: (bool isNowSelected) {
// // // // // //               String? newFilterValue = isNowSelected ? sport : null;
// // // // // //               if (_selectedSportFilter != newFilterValue) {
// // // // // //                 setStateIfMounted(() { _selectedSportFilter = newFilterValue; });
// // // // // //                 _onFilterOrSearchChanged();
// // // // // //               }
// // // // // //             },
// // // // // //             selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// // // // // //             backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// // // // // //             labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// // // // // //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// // // // // //             padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// // // // // //             visualDensity: VisualDensity.compact,
// // // // // //             showCheckmark: false,
// // // // // //           );
// // // // // //         },
// // // // // //       ),
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildSectionHeader(BuildContext context, String title) {
// // // // // //     return Padding(padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
// // // // // //       child: Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
// // // // // //   }

// // // // // //   Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg, String emptyMsg, {bool isNearbySection = false}) {
// // // // // //      if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
// // // // // //      if (errorMsg != null) return Center(child: Padding(padding: const EdgeInsets.all(20), child: Text(errorMsg, textAlign: TextAlign.center, style: const TextStyle(color: Colors.red, fontSize: 16))));
// // // // // //      if (venues.isEmpty) return Center(child: Padding(padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0), child: Text(emptyMsg, textAlign: TextAlign.center, style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

// // // // // //      return GridView.builder(
// // // // // //        shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// // // // // //        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
// // // // // //        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
// // // // // //            maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
// // // // // //            mainAxisSpacing: 16.0,
// // // // // //            crossAxisSpacing: 16.0,
// // // // // //            childAspectRatio: 0.70
// // // // // //         ),
// // // // // //        itemCount: venues.length,
// // // // // //        itemBuilder: (context, index) {
// // // // // //          final venue = venues[index];
// // // // // //          final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
// // // // // //          return _buildVenueGridCard(venue, isFavorite: isFavorite);
// // // // // //        },
// // // // // //      );
// // // // // //    }

// // // // // //   Widget _buildBodyContent() {
// // // // // //      return Column(children: [
// // // // // //          _buildQuickSportFilters(),
// // // // // //          Expanded(
// // // // // //            child: RefreshIndicator(
// // // // // //              onRefresh: _handleRefresh,
// // // // // //              child: ListView(
// // // // // //                padding: EdgeInsets.zero,
// // // // // //                children: [
// // // // // //                  if (_isSearchingOrFiltering) ...[
// // // // // //                    _buildSectionHeader(context,
// // // // // //                         _searchQuery != null && _searchQuery!.isNotEmpty
// // // // // //                             ? "Results for \"$_searchQuery\""
// // // // // //                             : (_selectedCityFilter != null
// // // // // //                                 ? "Venues in $_selectedCityFilter"
// // // // // //                                 : (_selectedSportFilter != null ? "Venues for $_selectedSportFilter" : "Filtered Venues")
// // // // // //                             )
// // // // // //                     ),
// // // // // //                    _buildVenueList(_filteredVenues, _isLoadingFilteredVenues, _filteredVenueFetchError, "No venues found for your selection.", isNearbySection: false),
// // // // // //                  ] else ...[
// // // // // //                    if (_currentPosition != null || _isLoadingNearbyVenues)
// // // // // //                        _buildSectionHeader(context, "Venues Near You"),
// // // // // //                    _buildVenueList(_nearbyVenues, _isLoadingNearbyVenues, _nearbyVenueFetchError, "No venues found nearby. Try exploring other cities or check location permissions.", isNearbySection: true),

// // // // // //                    const SizedBox(height: 16),
// // // // // //                    _buildSectionHeader(context, "Explore Venues"),
// // // // // //                    _buildVenueList(_exploreVenues, _isLoadingExploreVenues, _exploreVenueFetchError, "No venues to explore at the moment.", isNearbySection: false),
// // // // // //                   ],
// // // // // //                  const SizedBox(height: 80),
// // // // // //                ],
// // // // // //              ),
// // // // // //            ),
// // // // // //          ),
// // // // // //        ]
// // // // // //      );
// // // // // //   }

// // // // // //   Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
// // // // // //     return Shimmer.fromColors(baseColor: Colors.grey[350]!, highlightColor: Colors.grey[200]!,
// // // // // //       child: GridView.builder(
// // // // // //         shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// // // // // //         padding: const EdgeInsets.all(16.0),
// // // // // //         gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0, mainAxisSpacing: 16.0, crossAxisSpacing: 16.0, childAspectRatio: 0.70),
// // // // // //         itemCount: itemCount, itemBuilder: (context, index) => _buildVenueShimmerCard())
// // // // // //       );
// // // // // //   }
// // // // // //   Widget _buildVenueShimmerCard() {
// // // // // //     return Card(
// // // // // //       margin: EdgeInsets.zero, elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), clipBehavior: Clip.antiAlias,
// // // // // //       child: Column(children: [
// // // // // //         Container(height: 130, width: double.infinity, color: Colors.white),
// // // // // //         Expanded(child: Padding(padding: const EdgeInsets.all(10.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
// // // // // //           Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
// // // // // //             Container(width: double.infinity, height: 18.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// // // // // //             Container(width: MediaQuery.of(context).size.width * 0.3, height: 14.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// // // // // //             Container(width: MediaQuery.of(context).size.width * 0.2, height: 12.0, color: Colors.white)]),
// // // // // //           Container(width: double.infinity, height: 12.0, color: Colors.white)
// // // // // //           ])))
// // // // // //       ]));
// // // // // //   }

// // // // // //   Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite}) {
// // // // // //       final String venueId = venue['id'] as String? ?? '';
// // // // // //       return _VenueCardWidget(
// // // // // //         key: ValueKey(venueId),
// // // // // //         venue: venue,
// // // // // //         isFavorite: isFavorite,
// // // // // //         onTapCard: () => _navigateToVenueDetail(venue),
// // // // // //         onTapFavorite: () => _toggleFavorite(venueId, isFavorite, venue),
// // // // // //       );
// // // // // //     }

// // // // // //   Future<void> _toggleFavorite(String venueId, bool currentIsFavorite, Map<String, dynamic> venue) async {
// // // // // //     if (!mounted) return;
// // // // // //     final currentUser = _currentUser;
// // // // // //     if (currentUser == null) {
// // // // // //       ScaffoldMessenger.of(context).showSnackBar(
// // // // // //         const SnackBar(content: Text("Please log in to manage favorites."), behavior: SnackBarBehavior.floating, margin: EdgeInsets.all(10)),
// // // // // //       );
// // // // // //       return;
// // // // // //     }
// // // // // //     if (venueId.isEmpty) return;

// // // // // //     try {
// // // // // //       if (!currentIsFavorite) {
// // // // // //         await _userService.addFavorite(venueId);
// // // // // //       } else {
// // // // // //         await _userService.removeFavorite(venueId);
// // // // // //       }
// // // // // //     } catch (e) {
// // // // // //       debugPrint("Error toggling favorite: $e");
// // // // // //       if (mounted) {
// // // // // //         ScaffoldMessenger.of(context).showSnackBar(
// // // // // //           SnackBar(content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"), backgroundColor: Colors.redAccent, behavior: SnackBarBehavior.floating, margin: const EdgeInsets.all(10)),
// // // // // //         );
// // // // // //       }
// // // // // //     }
// // // // // //   }

// // // // // // } // End _HomeScreenState


// // // // // // // --- _VenueCardWidget (Stateful Card - Kept from your provided code) ---
// // // // // // class _VenueCardWidget extends StatefulWidget {
// // // // // //   final Map<String, dynamic> venue;
// // // // // //   final bool isFavorite;
// // // // // //   final VoidCallback onTapCard;
// // // // // //   final Future<void> Function() onTapFavorite;

// // // // // //   const _VenueCardWidget({
// // // // // //     required Key key,
// // // // // //     required this.venue,
// // // // // //     required this.isFavorite,
// // // // // //     required this.onTapCard,
// // // // // //     required this.onTapFavorite,
// // // // // //   }) : super(key: key);

// // // // // //   @override
// // // // // //   _VenueCardWidgetState createState() => _VenueCardWidgetState();
// // // // // // }

// // // // // // class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
// // // // // //   late AnimationController _favoriteAnimationController;
// // // // // //   late Animation<double> _favoriteScaleAnimation;

// // // // // //   @override
// // // // // //   void initState() {
// // // // // //     super.initState();
// // // // // //     _favoriteAnimationController = AnimationController(
// // // // // //       duration: const Duration(milliseconds: 300),
// // // // // //       vsync: this,
// // // // // //     );
// // // // // //     _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
// // // // // //       CurvedAnimation(parent: _favoriteAnimationController, curve: Curves.elasticOut, reverseCurve: Curves.easeInCubic),
// // // // // //     );
// // // // // //   }

// // // // // //   @override
// // // // // //   void didUpdateWidget(_VenueCardWidget oldWidget) {
// // // // // //     super.didUpdateWidget(oldWidget);
// // // // // //     if (widget.isFavorite != oldWidget.isFavorite && mounted) {
// // // // // //       if (widget.isFavorite) {
// // // // // //         _favoriteAnimationController.forward(from: 0.0).catchError((e) {
// // // // // //           if (e is! TickerCanceled) { debugPrint("Error playing fav add animation: $e"); }
// // // // // //         });
// // // // // //       } else {
// // // // // //          _favoriteAnimationController.reverse().catchError((e) {
// // // // // //              if (e is! TickerCanceled) { debugPrint("Error reversing fav remove animation: $e"); }
// // // // // //          });
// // // // // //       }
// // // // // //     }
// // // // // //   }

// // // // // //   @override
// // // // // //   void dispose() {
// // // // // //     _favoriteAnimationController.dispose();
// // // // // //     super.dispose();
// // // // // //   }

// // // // // //   @override
// // // // // //   Widget build(BuildContext context) {
// // // // // //     final ThemeData theme = Theme.of(context);
// // // // // //     final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
// // // // // //     final dynamic sportRaw = widget.venue['sportType'];
// // // // // //     final String sport = (sportRaw is String) ? sportRaw : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
// // // // // //     final String? imageUrl = widget.venue['imageUrl'] as String?;
// // // // // //     final String city = widget.venue['city'] as String? ?? '';
// // // // // //     final String venueId = widget.venue['id'] as String? ?? '';
// // // // // //     final double? distance = widget.venue['distance'] as double?;
// // // // // //     final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
// // // // // //     final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

// // // // // //     return MouseRegion(
// // // // // //       cursor: SystemMouseCursors.click,
// // // // // //       child: Card(
// // // // // //         margin: EdgeInsets.zero,
// // // // // //         elevation: 3,
// // // // // //         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
// // // // // //         clipBehavior: Clip.antiAlias,
// // // // // //         child: Column(
// // // // // //           crossAxisAlignment: CrossAxisAlignment.start,
// // // // // //           children: [
// // // // // //             SizedBox(
// // // // // //               height: 130,
// // // // // //               width: double.infinity,
// // // // // //               child: Stack(
// // // // // //                 children: [
// // // // // //                   Positioned.fill(
// // // // // //                     child: InkWell(
// // // // // //                       onTap: widget.onTapCard,
// // // // // //                       child: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// // // // // //                           ? Hero(
// // // // // //                               tag: 'venue_image_$venueId',
// // // // // //                               child: Image.network(
// // // // // //                                 imageUrl, height: 130, width: double.infinity, fit: BoxFit.cover,
// // // // // //                                 loadingBuilder: (context, child, loadingProgress) =>
// // // // // //                                     (loadingProgress == null) ? child : Container(height: 130, color: Colors.grey[200], child: Center(child: CircularProgressIndicator(strokeWidth: 2, value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null))),
// // // // // //                                 errorBuilder: (context, error, stackTrace) =>
// // // // // //                                     Container(height: 130, color: Colors.grey[200], child: Center(child: Icon(Icons.broken_image_outlined, color: Colors.grey[400], size: 40))),
// // // // // //                               ),
// // // // // //                             )
// // // // // //                           : Container(height: 130, color: theme.primaryColor.withOpacity(0.08), child: Center(child: Icon(Icons.sports_soccer_outlined, size: 50, color: theme.primaryColor.withOpacity(0.7)))),
// // // // // //                     ),
// // // // // //                   ),
// // // // // //                   Positioned(
// // // // // //                     top: 6, right: 6,
// // // // // //                     child: Material(
// // // // // //                       color: Colors.black.withOpacity(0.45), shape: const CircleBorder(),
// // // // // //                       child: InkWell(
// // // // // //                         borderRadius: BorderRadius.circular(20),
// // // // // //                         onTap: widget.onTapFavorite,
// // // // // //                         child: Padding(
// // // // // //                           padding: const EdgeInsets.all(7.0),
// // // // // //                           child: ScaleTransition(
// // // // // //                             scale: _favoriteScaleAnimation,
// // // // // //                             child: Icon(
// // // // // //                               widget.isFavorite ? Icons.favorite_rounded : Icons.favorite_border_rounded,
// // // // // //                               color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
// // // // // //                               size: 22,
// // // // // //                             ),
// // // // // //                           ),
// // // // // //                         ),
// // // // // //                       ),
// // // // // //                     ),
// // // // // //                   ),
// // // // // //                   if (distance != null)
// // // // // //                     Positioned(
// // // // // //                       bottom: 6, left: 6,
// // // // // //                       child: Container(
// // // // // //                         padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
// // // // // //                         decoration: BoxDecoration(color: Colors.black.withOpacity(0.6), borderRadius: BorderRadius.circular(4)),
// // // // // //                         child: Text('${distance.toStringAsFixed(1)} km', style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.w500)),
// // // // // //                       ),
// // // // // //                     ),
// // // // // //                 ],
// // // // // //               ),
// // // // // //             ),
// // // // // //             Expanded(
// // // // // //               child: InkWell(
// // // // // //                 onTap: widget.onTapCard,
// // // // // //                 child: Padding(
// // // // // //                   padding: const EdgeInsets.all(10.0),
// // // // // //                   child: Column(
// // // // // //                     crossAxisAlignment: CrossAxisAlignment.start,
// // // // // //                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
// // // // // //                     children: [
// // // // // //                       Column(
// // // // // //                         crossAxisAlignment: CrossAxisAlignment.start,
// // // // // //                         mainAxisSize: MainAxisSize.min,
// // // // // //                         children: [
// // // // // //                           Text(name, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 2, overflow: TextOverflow.ellipsis),
// // // // // //                           const SizedBox(height: 4),
// // // // // //                           Row(children: [
// // // // // //                             Icon(Icons.sports_kabaddi_outlined, size: 14, color: theme.colorScheme.secondary),
// // // // // //                             const SizedBox(width: 4),
// // // // // //                             Expanded(child: Text(sport, style: theme.textTheme.bodyMedium?.copyWith(color: Colors.grey[800], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// // // // // //                           ]),
// // // // // //                           if (reviewCount > 0)
// // // // // //                             Padding(
// // // // // //                                padding: const EdgeInsets.only(top: 5.0),
// // // // // //                                child: Row(children: [
// // // // // //                                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// // // // // //                                 const SizedBox(width: 4),
// // // // // //                                 Text(averageRating.toStringAsFixed(1), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
// // // // // //                                 const SizedBox(width: 4),
// // // // // //                                 Text("($reviewCount reviews)", style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
// // // // // //                               ]),
// // // // // //                              ),
// // // // // //                         ],
// // // // // //                       ),
// // // // // //                       Row(
// // // // // //                         children: [
// // // // // //                           Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
// // // // // //                           const SizedBox(width: 4),
// // // // // //                           Expanded(child: Text(city, style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[700], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// // // // // //                         ],
// // // // // //                       ),
// // // // // //                     ],
// // // // // //                   ),
// // // // // //                 ),
// // // // // //               ),
// // // // // //             ),
// // // // // //           ],
// // // // // //         ),
// // // // // //       ),
// // // // // //     );
// // // // // //   }
// // // // // // }


// // // // // // // --- VenueSearchDelegate Class (Kept from your provided code) ---
// // // // // // class VenueSearchDelegate extends SearchDelegate<String?> {
// // // // // //   final FirestoreService firestoreService;
// // // // // //   final String? initialCityFilter;

// // // // // //   Timer? _debounce;
// // // // // //   Future<List<Map<String, dynamic>>>? _suggestionFuture;
// // // // // //   String _currentFetchingSuggestionQuery = "";

// // // // // //   VenueSearchDelegate({
// // // // // //     required this.firestoreService,
// // // // // //     this.initialCityFilter,
// // // // // //   }) : super(
// // // // // //           searchFieldLabel: initialCityFilter != null
// // // // // //               ? 'Search in $initialCityFilter...'
// // // // // //               : 'Search venues...',
// // // // // //         );

// // // // // //   @override
// // // // // //   void dispose() {
// // // // // //     _debounce?.cancel();
// // // // // //     super.dispose();
// // // // // //   }

// // // // // //   void _updateSuggestionFuture(BuildContext delegateContext, String currentQuery) {
// // // // // //     if (currentQuery.isEmpty) {
// // // // // //       if (_suggestionFuture != null || _currentFetchingSuggestionQuery.isNotEmpty) {
// // // // // //         _currentFetchingSuggestionQuery = "";
// // // // // //         _suggestionFuture = Future.value([]);
// // // // // //         if(WidgetsBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {
// // // // // //            WidgetsBinding.instance.addPostFrameCallback((_) {
// // // // // //               if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // // // //            });
// // // // // //         } else {
// // // // // //            if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // // // //         }
// // // // // //       }
// // // // // //       return;
// // // // // //     }

// // // // // //     if (currentQuery != _currentFetchingSuggestionQuery || _suggestionFuture == null) {
// // // // // //       _currentFetchingSuggestionQuery = currentQuery;
// // // // // //       _suggestionFuture = firestoreService.getVenues(
// // // // // //         searchQuery: currentQuery,
// // // // // //         cityFilter: initialCityFilter,
// // // // // //         limit: 700,
// // // // // //         forSuggestions: true,
// // // // // //       );
// // // // // //         if(WidgetsBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {
// // // // // //            WidgetsBinding.instance.addPostFrameCallback((_) {
// // // // // //              if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // // // //            });
// // // // // //         } else {
// // // // // //            if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // // // //         }
// // // // // //     }
// // // // // //   }

// // // // // //   @override
// // // // // //   void showSuggestions(BuildContext context) {
// // // // // //     super.showSuggestions(context);
// // // // // //     _debounce?.cancel();
// // // // // //     _debounce = Timer(const Duration(milliseconds: 350), () {
// // // // // //       final String trimmedQuery = query.trim();
// // // // // //       _updateSuggestionFuture(context, trimmedQuery);
// // // // // //     });
// // // // // //   }

// // // // // //   @override
// // // // // //   ThemeData appBarTheme(BuildContext context) {
// // // // // //     final theme = Theme.of(context);
// // // // // //     final Color primaryColor = theme.primaryColor;
// // // // // //     final Color appBarFgColor = theme.colorScheme.onPrimary;

// // // // // //     return theme.copyWith(
// // // // // //       primaryColor: primaryColor,
// // // // // //       scaffoldBackgroundColor: theme.canvasColor,
// // // // // //       appBarTheme: theme.appBarTheme.copyWith(
// // // // // //         backgroundColor: primaryColor,
// // // // // //         elevation: 1.0,
// // // // // //         iconTheme: IconThemeData(color: appBarFgColor),
// // // // // //         actionsIconTheme: IconThemeData(color: appBarFgColor),
// // // // // //         titleTextStyle:
// // // // // //             theme.textTheme.titleLarge?.copyWith(color: appBarFgColor),
// // // // // //         toolbarTextStyle:
// // // // // //             theme.textTheme.bodyMedium?.copyWith(color: appBarFgColor),
// // // // // //       ),
// // // // // //       inputDecorationTheme: InputDecorationTheme(
// // // // // //         hintStyle: theme.textTheme.titleMedium
// // // // // //             ?.copyWith(color: appBarFgColor.withOpacity(0.7)),
// // // // // //         border: InputBorder.none,
// // // // // //       ),
// // // // // //       textSelectionTheme: TextSelectionThemeData(
// // // // // //           cursorColor: appBarFgColor,
// // // // // //           selectionColor: appBarFgColor.withOpacity(0.3),
// // // // // //           selectionHandleColor: appBarFgColor),
// // // // // //     );
// // // // // //   }

// // // // // //   @override
// // // // // //   List<Widget>? buildActions(BuildContext context) {
// // // // // //     return [
// // // // // //       if (query.isNotEmpty)
// // // // // //         IconButton(
// // // // // //           icon: const Icon(Icons.search_outlined),
// // // // // //           tooltip: 'Search',
// // // // // //           onPressed: () {
// // // // // //             if (query.trim().isNotEmpty) {
// // // // // //               close(context, query.trim());
// // // // // //             }
// // // // // //           },
// // // // // //         ),
// // // // // //       if (query.isNotEmpty)
// // // // // //         IconButton(
// // // // // //           icon: const Icon(Icons.clear_rounded),
// // // // // //           tooltip: 'Clear',
// // // // // //           onPressed: () {
// // // // // //             query = '';
// // // // // //           },
// // // // // //         ),
// // // // // //     ];
// // // // // //   }

// // // // // //   @override
// // // // // //   Widget? buildLeading(BuildContext context) {
// // // // // //     return IconButton(
// // // // // //       icon: const Icon(Icons.arrow_back_ios_new_rounded),
// // // // // //       tooltip: 'Back',
// // // // // //       onPressed: () {
// // // // // //         close(context, null);
// // // // // //       },
// // // // // //     );
// // // // // //   }

// // // // // //   @override
// // // // // //   Widget buildResults(BuildContext context) {
// // // // // //     final trimmedQuery = query.trim();

// // // // // //     if (trimmedQuery.isEmpty) {
// // // // // //       return _buildInfoWidget("Please enter a search term.");
// // // // // //     }

// // // // // //     debugPrint("VenueSearchDelegate: Building results for '$trimmedQuery'");

// // // // // //     return FutureBuilder<List<Map<String, dynamic>>>(
// // // // // //       future: firestoreService.getVenues(
// // // // // //         searchQuery: trimmedQuery,
// // // // // //         cityFilter: initialCityFilter,
// // // // // //       ),
// // // // // //       builder: (context, snapshot) {
// // // // // //         if (snapshot.connectionState == ConnectionState.waiting) {
// // // // // //           return const Center(child: CircularProgressIndicator());
// // // // // //         }
// // // // // //         if (snapshot.hasError) {
// // // // // //           debugPrint("SearchDelegate Results Error: ${snapshot.error}");
// // // // // //           return _buildErrorWidget(
// // // // // //               "Error searching venues. Please try again.");
// // // // // //         }
// // // // // //         if (!snapshot.hasData || snapshot.data!.isEmpty) {
// // // // // //           return _buildNoResultsWidget();
// // // // // //         }

// // // // // //         final results = snapshot.data!;
// // // // // //         return ListView.builder(
// // // // // //           itemCount: results.length,
// // // // // //           itemBuilder: (context, index) {
// // // // // //             final venue = results[index];
// // // // // //             return _buildVenueListTileForResult(context, venue);
// // // // // //           },
// // // // // //         );
// // // // // //       },
// // // // // //     );
// // // // // //   }

// // // // // //   @override
// // // // // //   Widget buildSuggestions(BuildContext context) {
// // // // // //     final currentQuery = query.trim();

// // // // // //     if (currentQuery.isEmpty) {
// // // // // //          return _buildInfoWidget("Start typing to search for venues...");
// // // // // //     }

// // // // // //     if (_suggestionFuture == null || _currentFetchingSuggestionQuery != currentQuery) {
// // // // // //         if (_debounce?.isActive ?? false) { 
// // // // // //              return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // // // // //         }
// // // // // //         return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // // // // //     }

// // // // // //     return FutureBuilder<List<Map<String, dynamic>>>(
// // // // // //       future: _suggestionFuture,
// // // // // //       builder: (context, snapshot) {
// // // // // //         if (snapshot.connectionState == ConnectionState.waiting && currentQuery.isNotEmpty) {
// // // // // //           return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // // // // //         }
// // // // // //         if (snapshot.hasError) {
// // // // // //           debugPrint("Suggestion Error: ${snapshot.error}");
// // // // // //           return _buildErrorWidget("Could not load suggestions.");
// // // // // //         }

// // // // // //         if (!snapshot.hasData || snapshot.data!.isEmpty) {
// // // // // //              return _buildInfoWidget('No suggestions for "$currentQuery".');
// // // // // //         }

// // // // // //         final suggestions = snapshot.data!;
// // // // // //         return ListView.builder(
// // // // // //           itemCount: suggestions.length,
// // // // // //           itemBuilder: (context, index) {
// // // // // //             final venue = suggestions[index];
// // // // // //             return _buildSuggestionTile(context, venue);
// // // // // //           },
// // // // // //         );
// // // // // //       },
// // // // // //     );
// // // // // //   }


// // // // // //   Widget _buildSuggestionTile(BuildContext context, Map<String, dynamic> venue) {
// // // // // //     final String name = venue['name'] as String? ?? 'No Name';
// // // // // //     final String city = venue['city'] as String? ?? '';
// // // // // //     return ListTile(
// // // // // //       leading: Icon(Icons.search_outlined, color: Theme.of(context).hintColor),
// // // // // //       title: Text(name),
// // // // // //       subtitle: Text(city, maxLines: 1, overflow: TextOverflow.ellipsis),
// // // // // //       onTap: () {
// // // // // //         query = name;
// // // // // //         close(context, name);
// // // // // //       },
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildVenueListTileForResult(
// // // // // //       BuildContext context, Map<String, dynamic> venue) {
// // // // // //     final String name = venue['name'] as String? ?? 'No Name';
// // // // // //     final String city = venue['city'] as String? ?? '';
// // // // // //     final String address = venue['address'] as String? ?? '';
// // // // // //     final String venueId = venue['id'] as String;
// // // // // //     final List<String> sports =
// // // // // //         (venue['sportType'] as List<dynamic>?)?.whereType<String>().toList() ?? [];
// // // // // //     final String? imageUrl = venue['imageUrl'] as String?;
// // // // // //     final double rating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;

// // // // // //     return ListTile(
// // // // // //       leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// // // // // //           ? CircleAvatar(backgroundImage: NetworkImage(imageUrl), radius: 25, backgroundColor: Colors.grey[200])
// // // // // //           : CircleAvatar(child: Icon(Icons.sports_soccer_outlined, size: 20), radius: 25, backgroundColor: Colors.grey[200]),
// // // // // //       title: Text(name, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
// // // // // //       subtitle: Text("${sports.isNotEmpty ? sports.join(', ') : 'Venue'} - ${address.isNotEmpty ? '$address, ' : ''}$city", maxLines: 1, overflow: TextOverflow.ellipsis, style: Theme.of(context).textTheme.bodySmall),
// // // // // //       trailing: rating > 0 ? Row(mainAxisSize: MainAxisSize.min, children: [
// // // // // //                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// // // // // //                 const SizedBox(width: 4),
// // // // // //                 Text(rating.toStringAsFixed(1), style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // // // //               ]) : null,
// // // // // //       onTap: () {
// // // // // //         close(context, null); 
// // // // // //         WidgetsBinding.instance.addPostFrameCallback((_) {
// // // // // //           if (context.mounted) {
// // // // // //              Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venueId, initialVenueData: venue)));
// // // // // //           }
// // // // // //         });
// // // // // //       },
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildNoResultsWidget() {
// // // // // //     return Center(
// // // // // //       child: Padding(
// // // // // //         padding: const EdgeInsets.all(20.0),
// // // // // //         child: Column(
// // // // // //           mainAxisAlignment: MainAxisAlignment.center,
// // // // // //           children: [
// // // // // //             Icon(Icons.search_off_rounded, size: 60, color: Colors.grey[400]),
// // // // // //             const SizedBox(height: 15),
// // // // // //             Text('No venues found matching "$query"${initialCityFilter != null ? ' in $initialCityFilter' : ''}.', textAlign: TextAlign.center, style: TextStyle(fontSize: 17, color: Colors.grey[600])),
// // // // // //             const SizedBox(height: 10),
// // // // // //             const Text("Try different keywords or check spelling.", style: TextStyle(color: Colors.grey))
// // // // // //           ],
// // // // // //         ),
// // // // // //       ),
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildErrorWidget(String message) {
// // // // // //     return Center(
// // // // // //       child: Padding(
// // // // // //         padding: const EdgeInsets.all(16.0),
// // // // // //         child: Column(
// // // // // //           mainAxisAlignment: MainAxisAlignment.center,
// // // // // //           children: [
// // // // // //             const Icon(Icons.error_outline_rounded, color: Colors.red, size: 50),
// // // // // //             const SizedBox(height: 10),
// // // // // //             Text(message, textAlign: TextAlign.center, style: const TextStyle(color: Colors.redAccent)),
// // // // // //           ],
// // // // // //         ),
// // // // // //       ),
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildInfoWidget(String message) {
// // // // // //     return Center(
// // // // // //       child: Padding(
// // // // // //         padding: const EdgeInsets.all(16.0),
// // // // // //         child: Text(message, style: TextStyle(fontSize: 16, color: Colors.grey[600])),
// // // // // //       ),
// // // // // //     );
// // // // // //   }
// // // // // // }

// // // // // //-----------------------seperated search components from homescreen-----------------------
// // // // // import 'package:flutter/material.dart';
// // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // import 'package:geolocator/geolocator.dart';
// // // // // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // // // // import 'package:mm_associates/features/home/screens/venue_form.dart';
// // // // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // // // import 'package:mm_associates/features/user/services/user_service.dart';
// // // // // import 'package:mm_associates/core/services/location_service.dart';
// // // // // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // // // // import 'venue_detail_screen.dart';
// // // // // import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
// // // // // import 'dart:async';
// // // // // import 'package:shimmer/shimmer.dart';
// // // // // import 'city_selection_screen.dart' show CitySelectionScreen, CityInfo, kAppAllCities;

// // // // // // Import the new search components file
// // // // // import 'package:mm_associates/features/home/widgets/home_search_components.dart';

// // // // // class HomeScreen extends StatefulWidget {
// // // // //   const HomeScreen({super.key});

// // // // //   @override
// // // // //   State<HomeScreen> createState() => _HomeScreenState();
// // // // // }

// // // // // class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
// // // // //   final AuthService _authService = AuthService();
// // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // //   final LocationService _locationService = LocationService();
// // // // //   final UserService _userService = UserService();

// // // // //   // Search and Filter State
// // // // //   String? _searchQuery;
// // // // //   String? _selectedCityFilter;
// // // // //   IconData? _selectedCityIcon;
// // // // //   String? _selectedSportFilter;

// // // // //   // User State
// // // // //   User? _currentUser;
// // // // //   String? _userName;
// // // // //   String? _userProfilePicUrl;
// // // // //   bool _isLoadingName = true;

// // // // //   // Venue Data State
// // // // //   List<Map<String, dynamic>> _filteredVenues = [];
// // // // //   bool _isLoadingFilteredVenues = true;
// // // // //   String? _filteredVenueFetchError;

// // // // //   List<Map<String, dynamic>> _nearbyVenues = [];
// // // // //   bool _isLoadingNearbyVenues = true;
// // // // //   String? _nearbyVenueFetchError;

// // // // //   List<Map<String, dynamic>> _exploreVenues = [];
// // // // //   bool _isLoadingExploreVenues = true;
// // // // //   String? _exploreVenueFetchError;

// // // // //   // Location State
// // // // //   Position? _currentPosition;
// // // // //   bool _isFetchingLocation = false;
// // // // //   String? _locationStatusMessage;

// // // // //   // Favorite Venues State
// // // // //   List<String> _favoriteVenueIds = [];
// // // // //   bool _isLoadingFavorites = true;
// // // // //   Stream<List<String>>? _favoritesStream;
// // // // //   StreamSubscription<List<String>>? _favoritesSubscription;

// // // // //   // UI Helper data
// // // // //   final List<String> _supportedCities = ['Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'];
// // // // //   final List<String> _quickSportFilters = ['Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'];

// // // // //   // Getter to determine if we are in a search/filter mode
// // // // //   bool get _isSearchingOrFiltering => (_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null;

// // // // //   @override
// // // // //   void initState() {
// // // // //     super.initState();
// // // // //     _currentUser = FirebaseAuth.instance.currentUser;
// // // // //     _initializeScreen();
// // // // //     _setupFavoritesStream();
// // // // //     _updateSelectedCityIconFromFilter();
// // // // //   }

// // // // //   @override
// // // // //   void dispose() {
// // // // //     _favoritesSubscription?.cancel();
// // // // //     super.dispose();
// // // // //   }

// // // // //   void setStateIfMounted(VoidCallback fn) {
// // // // //     if (mounted) setState(fn);
// // // // //   }

// // // // //   void _updateSelectedCityIconFromFilter() {
// // // // //     if (_selectedCityFilter == null) {
// // // // //       _selectedCityIcon = Icons.my_location; // Default "Near Me" icon
// // // // //     } else {
// // // // //       try {
// // // // //         final cityInfo = kAppAllCities.firstWhere(
// // // // //           (city) => city.name == _selectedCityFilter,
// // // // //         );
// // // // //         _selectedCityIcon = cityInfo.icon;
// // // // //       } catch (e) {
// // // // //         _selectedCityIcon = Icons.location_city_outlined;
// // // // //         debugPrint("HomeScreen initState: Selected city '$_selectedCityFilter' not found in kAppAllCities. Using fallback icon. Error: $e");
// // // // //       }
// // // // //     }
// // // // //   }
  
// // // // //   Future<void> _initializeScreen() async {
// // // // //     await _fetchUserNameAndPic();
// // // // //     await _fetchPrimaryVenueData();
// // // // //   }

// // // // //   Future<void> _fetchPrimaryVenueData() async {
// // // // //     if (!mounted) return;
// // // // //     setStateIfMounted(() {
// // // // //       _isFetchingLocation = true; _isLoadingNearbyVenues = true; _isLoadingExploreVenues = true;
// // // // //       _locationStatusMessage = 'Fetching your location...';
// // // // //       _nearbyVenues = []; _exploreVenues = [];
// // // // //       _nearbyVenueFetchError = null; _exploreVenueFetchError = null;
// // // // //     });
// // // // //     _currentPosition = await _locationService.getCurrentLocation();
// // // // //     if (!mounted) return;
// // // // //     setStateIfMounted(() {
// // // // //       _isFetchingLocation = false;
// // // // //       _locationStatusMessage = _currentPosition != null ? 'Location acquired.' : 'Could not get location.';
// // // // //     });
// // // // //     await Future.wait([_fetchNearbyVenuesScoped(), _fetchExploreVenuesFromOtherCities()]);
// // // // //   }

// // // // //   void _setupFavoritesStream() {
// // // // //     _favoritesSubscription?.cancel();
// // // // //     if (_currentUser != null) {
// // // // //         _favoritesStream = _userService.getFavoriteVenueIdsStream();
// // // // //         _favoritesSubscription = _favoritesStream?.listen(
// // // // //           (favoriteIds) {
// // // // //             if (mounted) {
// // // // //               final newIdsSet = favoriteIds.toSet();
// // // // //               final currentIdsSet = _favoriteVenueIds.toSet();
// // // // //               if (newIdsSet.difference(currentIdsSet).isNotEmpty || currentIdsSet.difference(newIdsSet).isNotEmpty) {
// // // // //                 setStateIfMounted(() {
// // // // //                   _favoriteVenueIds = favoriteIds;
// // // // //                 });
// // // // //               }
// // // // //             }
// // // // //           },
// // // // //           onError: (error) {
// // // // //             debugPrint("Error in favorites stream: $error");
// // // // //              if (mounted) {
// // // // //                 ScaffoldMessenger.of(context).showSnackBar(
// // // // //                     const SnackBar(content: Text("Could not update favorites."),
// // // // //                     backgroundColor: Colors.orangeAccent,
// // // // //                     behavior: SnackBarBehavior.floating)
// // // // //                 );
// // // // //              }
// // // // //           }
// // // // //         );
// // // // //         if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);
// // // // //     } else {
// // // // //       if (mounted) {
// // // // //          setStateIfMounted(() {
// // // // //            _favoriteVenueIds = [];
// // // // //            _isLoadingFavorites = false;
// // // // //            _favoritesStream = null;
// // // // //            _favoritesSubscription = null;
// // // // //          });
// // // // //       }
// // // // //     }
// // // // //   }

// // // // //   @override
// // // // //   void didChangeDependencies() {
// // // // //     super.didChangeDependencies();
// // // // //     final currentAuthUser = FirebaseAuth.instance.currentUser;
// // // // //     if (currentAuthUser != _currentUser) {
// // // // //       _currentUser = currentAuthUser;
// // // // //       _initializeScreen();
// // // // //       _setupFavoritesStream();
// // // // //       if (mounted) {
// // // // //         setStateIfMounted(() {
// // // // //           _updateSelectedCityIconFromFilter();
// // // // //         });
// // // // //       }
// // // // //     }
// // // // //   }

// // // // //   Future<void> _fetchVenuesForFilterOrSearch({String? newSearchQuery}) async {
// // // // //     if (!mounted) return;
// // // // //     setStateIfMounted(() {
// // // // //       _isLoadingFilteredVenues = true;
// // // // //       _filteredVenueFetchError = null;
// // // // //       _filteredVenues = [];
// // // // //     });

// // // // //     try {
// // // // //       debugPrint("Fetching FILTERED/SEARCH venues: City: $_selectedCityFilter, Sport: $_selectedSportFilter, Search: $newSearchQuery, Location: $_currentPosition");
// // // // //       final venuesData = await _firestoreService.getVenues(
// // // // //         userLocation: _currentPosition,
// // // // //         radiusInKm: _selectedCityFilter != null ? null : (_currentPosition != null ? 50.0 : null),
// // // // //         cityFilter: _selectedCityFilter,
// // // // //         searchQuery: newSearchQuery,
// // // // //         sportFilter: _selectedSportFilter,
// // // // //       );
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() {
// // // // //           _filteredVenues = venuesData;
// // // // //         });
// // // // //     } catch (e) {
// // // // //       debugPrint("Error fetching filtered/search venues: $e");
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() => _filteredVenueFetchError = "Could not load venues: ${e.toString().replaceFirst('Exception: ', '')}");
// // // // //     } finally {
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() => _isLoadingFilteredVenues = false);
// // // // //     }
// // // // //   }

// // // // //   Future<void> _fetchNearbyVenuesScoped() async {
// // // // //     if (!mounted) return;
// // // // //     if (_currentPosition == null) {
// // // // //       if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = false; _nearbyVenueFetchError = "Location not available."; _nearbyVenues = []; });
// // // // //       return;
// // // // //     }
// // // // //     if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = true; _nearbyVenueFetchError = null; _nearbyVenues = []; });
// // // // //     try {
// // // // //       final venuesData = await _firestoreService.getVenues(userLocation: _currentPosition, radiusInKm: 25.0);
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() {
// // // // //         _nearbyVenues = venuesData;
// // // // //       });
// // // // //     } catch (e) {
// // // // //       debugPrint("Error fetching nearby venues: $e");
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() => _nearbyVenueFetchError = "Could not load nearby venues.");
// // // // //     } finally {
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() => _isLoadingNearbyVenues = false);
// // // // //     }
// // // // //   }

// // // // //   Future<void> _fetchExploreVenuesFromOtherCities() async {
// // // // //     if (!mounted) return;
// // // // //     setStateIfMounted(() { _isLoadingExploreVenues = true; _exploreVenueFetchError = null; _exploreVenues = [];});
// // // // //     List<Map<String, dynamic>> allExploreVenues = [];
// // // // //     try {
// // // // //       for (String city in _supportedCities) {
// // // // //         final cityVenues = await _firestoreService.getVenues(cityFilter: city, userLocation: _currentPosition, limit: 5);
// // // // //         allExploreVenues.addAll(cityVenues);
// // // // //         if (!mounted) return;
// // // // //       }
// // // // //       final uniqueExploreVenues = allExploreVenues.fold<Map<String, Map<String, dynamic>>>({}, (map, venue) {
// // // // //           final String? venueId = venue['id'] as String?;
// // // // //           if (venueId != null) map[venueId] = venue;
// // // // //           return map;
// // // // //         }).values.toList();

// // // // //       if (_currentPosition != null) {
// // // // //         uniqueExploreVenues.sort((a, b) {
// // // // //           final distA = a['distance'] as double?; final distB = b['distance'] as double?;
// // // // //           if (distA != null && distB != null) return distA.compareTo(distB);
// // // // //           if (distA != null) return -1;
// // // // //           if (distB != null) return 1;
// // // // //           return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
// // // // //         });
// // // // //       } else {
// // // // //          uniqueExploreVenues.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
// // // // //       }
// // // // //       if(!mounted) return;
// // // // //       setStateIfMounted(() {
// // // // //         _exploreVenues = uniqueExploreVenues.take(15).toList();
// // // // //       });
// // // // //     } catch (e) {
// // // // //       debugPrint("Error fetching explore venues: $e");
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() => _exploreVenueFetchError = "Could not load explore venues.");
// // // // //     } finally {
// // // // //       if (!mounted) return;
// // // // //       setStateIfMounted(() => _isLoadingExploreVenues = false);
// // // // //     }
// // // // //   }

// // // // //   Future<void> _fetchUserNameAndPic() async {
// // // // //     _setLoadingName(true); final currentUser = _currentUser;
// // // // //     if (currentUser == null) { if(mounted) _updateUserNameAndPic('Guest', null); _setLoadingName(false); return; }
// // // // //     try {
// // // // //       final userData = await _userService.getUserProfileData();
// // // // //       if (!mounted) return;
// // // // //       final fetchedName = userData?['name'] as String? ?? currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // // // //       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
// // // // //       _updateUserNameAndPic(fetchedName, fetchedPicUrl);
// // // // //     } catch (e) {
// // // // //       debugPrint("Error fetching user name/pic via UserService: $e"); if (!mounted) return;
// // // // //       final fallbackName = currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // // // //       _updateUserNameAndPic(fallbackName, null);
// // // // //     } finally { if(mounted) _setLoadingName(false); }
// // // // //   }

// // // // //   void _setLoadingName(bool isLoading) => {if(mounted) setStateIfMounted(() => _isLoadingName = isLoading)};
// // // // //   void _updateUserNameAndPic(String name, String? picUrl) => {if(mounted) setStateIfMounted(() { _userName = name; _userProfilePicUrl = picUrl; })};

// // // // //   Future<void> _handleRefresh() async {
// // // // //     if(mounted) {
// // // // //       setStateIfMounted(() {
// // // // //           _searchQuery = null;
// // // // //           _selectedSportFilter = null;
// // // // //       });
// // // // //     }
// // // // //     // _onFilterOrSearchChanged handles both filter/search and default views
// // // // //     _onFilterOrSearchChanged();
// // // // //   }

// // // // //   void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
// // // // //     // If an explicit query is passed (from search bar), use it.
// // // // //     // Otherwise, use the existing state _searchQuery (e.g., when a filter changes).
// // // // //     final newSearchQuery = explicitSearchQuery ?? _searchQuery;

// // // // //     // Use a local variable to prevent race conditions with setState
// // // // //     bool queryChanged = _searchQuery != newSearchQuery;

// // // // //     if (mounted) {
// // // // //       setStateIfMounted(() {
// // // // //         // Always update the search query state.
// // // // //         _searchQuery = newSearchQuery;
// // // // //       });
// // // // //     }

// // // // //     if ((_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null) {
// // // // //         _fetchVenuesForFilterOrSearch(newSearchQuery: _searchQuery);
// // // // //     } else {
// // // // //         // If we are clearing all filters/search, fetch the primary data.
// // // // //         _fetchPrimaryVenueData();
// // // // //     }

// // // // //     // Unfocus on web if a new search was submitted
// // // // //     if (kIsWeb && queryChanged) {
// // // // //       FocusScope.of(context).unfocus();
// // // // //     }
// // // // //   }

// // // // //   Future<void> _showLogoutConfirmationDialog(BuildContext context) async {
// // // // //       if (!context.mounted) return;
// // // // //       return showDialog<void>(context: context, barrierDismissible: false, builder: (BuildContext dialogContext) {
// // // // //           return AlertDialog(title: const Text('Confirm Logout'), content: const SingleChildScrollView(child: ListBody(children: <Widget>[Text('Are you sure you want to sign out?')])),
// // // // //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
// // // // //             actions: <Widget>[
// // // // //               TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
// // // // //               TextButton(child: const Text('Logout', style: TextStyle(color: Colors.red)), onPressed: () async {
// // // // //                   Navigator.of(dialogContext).pop(); try { await _authService.signOut();
// // // // //                    } catch (e) {
// // // // //                     debugPrint("Error during sign out: $e"); if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error signing out: ${e.toString()}'), backgroundColor: Colors.redAccent, behavior: SnackBarBehavior.floating, margin: const EdgeInsets.all(10)));
// // // // //                   }},), ],); },);
// // // // //     }

// // // // //   void _navigateToVenueDetail(Map<String, dynamic> venue) {
// // // // //     if (!context.mounted) return;
// // // // //     Navigator.push(context, MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venue['id'] as String, initialVenueData: venue))).then((_) {
// // // // //     });
// // // // //   }

// // // // //   void _openSearchMobile() async {
// // // // //      if (!context.mounted) return;
// // // // //      final String? submittedQuery = await showSearch<String?>(
// // // // //         context: context,
// // // // //         delegate: VenueSearchDelegate(
// // // // //             firestoreService: _firestoreService,
// // // // //             initialCityFilter: _selectedCityFilter,
// // // // //         )
// // // // //     );
// // // // //     if (submittedQuery != null && submittedQuery.isNotEmpty) {
// // // // //         _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
// // // // //     }
// // // // //   }

// // // // //   Future<void> _openCitySelectionScreen() async {
// // // // //     if (!mounted) return;
// // // // //     final String? newSelectedCityName = await Navigator.push<String?>(
// // // // //       context,
// // // // //       MaterialPageRoute(
// // // // //         builder: (context) => CitySelectionScreen(currentSelectedCity: _selectedCityFilter),
// // // // //       ),
// // // // //     );

// // // // //     if (mounted) {
// // // // //       if (newSelectedCityName != _selectedCityFilter) {
// // // // //         setStateIfMounted(() {
// // // // //           _selectedCityFilter = newSelectedCityName; 
// // // // //           _updateSelectedCityIconFromFilter(); 
// // // // //         });
// // // // //         _onFilterOrSearchChanged(); 
// // // // //       } else {
// // // // //         IconData currentExpectedIcon = Icons.location_city_outlined; 
// // // // //         if (_selectedCityFilter == null) {
// // // // //             currentExpectedIcon = Icons.my_location;
// // // // //         } else {
// // // // //             try {
// // // // //                 final cityInfo = kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
// // // // //                 currentExpectedIcon = cityInfo.icon;
// // // // //             } catch (e) {
// // // // //                 debugPrint("Error re-validating icon for city '$_selectedCityFilter': $e. Using fallback.");
// // // // //             }
// // // // //         }
// // // // //         if (_selectedCityIcon != currentExpectedIcon) {
// // // // //             setStateIfMounted(() {
// // // // //               _selectedCityIcon = currentExpectedIcon;
// // // // //             });
// // // // //         }
// // // // //       }
// // // // //     }
// // // // //   }

// // // // //   @override
// // // // //   Widget build(BuildContext context) {
// // // // //     final theme = Theme.of(context);
// // // // //     final appBarBackgroundColor = theme.appBarTheme.backgroundColor ?? theme.primaryColor;
// // // // //     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ?? theme.appBarTheme.iconTheme?.color ?? (kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white);
// // // // //     final bool isLoggedIn = _currentUser != null;

// // // // //     return Scaffold(
// // // // //       appBar: AppBar(
// // // // //         automaticallyImplyLeading: false,
// // // // //         title: kIsWeb ? _buildWebAppBarTitle(context) : _buildMobileAppBarTitle(context, theme),
// // // // //         actions: kIsWeb ? _buildWebAppBarActions(context, isLoggedIn, actionsIconColor) : _buildMobileAppBarActions(context, isLoggedIn, actionsIconColor),
// // // // //         backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
// // // // //         elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
// // // // //         iconTheme: theme.iconTheme.copyWith(color: kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white),
// // // // //         actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
// // // // //         titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ?? TextStyle(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white, fontSize: 20, fontWeight: FontWeight.w500),
// // // // //       ),
// // // // //       floatingActionButton: FloatingActionButton.extended(
// // // // //         onPressed: () {
// // // // //           Navigator.push(
// // // // //             context,
// // // // //             MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
// // // // //           ).then((result) {
// // // // //             if (result == true && mounted) {
// // // // //               _handleRefresh();
// // // // //               ScaffoldMessenger.of(context).showSnackBar(
// // // // //                 const SnackBar(content: Text("Venue list updated."), backgroundColor: Colors.blueAccent),
// // // // //               );
// // // // //             }
// // // // //           });
// // // // //         },
// // // // //         icon: const Icon(Icons.add_location_alt_outlined),
// // // // //         label: const Text("Add Venue"),
// // // // //         tooltip: 'Add New Venue',
// // // // //       ),
// // // // //       floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
// // // // //       body: _buildBodyContent(),
// // // // //     );
// // // // //   }

// // // // //   Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
// // // // //     final titleStyle = theme.appBarTheme.titleTextStyle ?? theme.primaryTextTheme.titleLarge ?? const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
// // // // //     final currentUser = _currentUser;
// // // // //     return Row(children: [
// // // // //         if (currentUser != null)
// // // // //           GestureDetector(
// // // // //             onTap: () {
// // // // //               if (!context.mounted) return;
// // // // //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // //                   .then((_) { if (mounted) _fetchUserNameAndPic(); });
// // // // //             },
// // // // //             child: Tooltip(
// // // // //               message: "My Profile",
// // // // //               child: Padding(
// // // // //                 padding: const EdgeInsets.only(right: 10.0),
// // // // //                 child: CircleAvatar(
// // // // //                   radius: 18,
// // // // //                   backgroundColor: Colors.white24,
// // // // //                   backgroundImage: _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty ? NetworkImage(_userProfilePicUrl!) : null,
// // // // //                   child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty ? Icon(Icons.person_outline, size: 20, color: Colors.white.withOpacity(0.8)) : null
// // // // //                 )
// // // // //               ),
// // // // //             ),
// // // // //           ),
// // // // //         if (_isLoadingName && currentUser != null)
// // // // //           const Padding(
// // // // //             padding: EdgeInsets.only(left: 6.0),
// // // // //             child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(Colors.white70)))
// // // // //           )
// // // // //         else if (_userName != null && currentUser != null)
// // // // //           Expanded(
// // // // //             child: Padding(
// // // // //                padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
// // // // //               child: Text(
// // // // //                 'Hi, ${_userName!.split(' ')[0]}!',
// // // // //                 style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
// // // // //                 overflow: TextOverflow.ellipsis
// // // // //               )
// // // // //             )
// // // // //           )
// // // // //         else
// // // // //           Text('MM Associates', style: titleStyle),
// // // // //       ]
// // // // //     );
// // // // //   }
  
// // // // //   List<Widget> _buildMobileAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // // //     final String cityNameText = _selectedCityFilter ?? 'Near Me';
// // // // //     final double textSize = 10.0; 

// // // // //     return [
// // // // //       IconButton(
// // // // //         icon: Icon(Icons.search_outlined, color: iconColor),
// // // // //         tooltip: 'Search Venues',
// // // // //         onPressed: _openSearchMobile,
// // // // //         padding: const EdgeInsets.symmetric(horizontal: 8),
// // // // //         constraints: const BoxConstraints(),
// // // // //       ),
// // // // //       Tooltip( 
// // // // //         message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // // //         child: IconButton(
// // // // //           icon: Column(
// // // // //             mainAxisAlignment: MainAxisAlignment.center,
// // // // //             mainAxisSize: MainAxisSize.min,
// // // // //             children: [
// // // // //               Icon(
// // // // //                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // // //                 color: iconColor,
// // // // //                 size: 24,
// // // // //               ),
// // // // //               const SizedBox(height: 2), 
// // // // //               Text(
// // // // //                 cityNameText,
// // // // //                 style: TextStyle(
// // // // //                   color: iconColor,
// // // // //                   fontSize: textSize,
// // // // //                   fontWeight: FontWeight.w500,
// // // // //                 ),
// // // // //                 overflow: TextOverflow.ellipsis,
// // // // //                 maxLines: 1,
// // // // //               ),
// // // // //             ],
// // // // //           ),
// // // // //           onPressed: _openCitySelectionScreen,
// // // // //           padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0),
// // // // //           constraints: const BoxConstraints(),
// // // // //         ),
// // // // //       ),
// // // // //       if (isLoggedIn)
// // // // //         IconButton(
// // // // //           icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // // //           tooltip: 'My Profile',
// // // // //           onPressed: () {
// // // // //             if (!context.mounted) return;
// // // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // //                 .then((_) {
// // // // //               if (mounted) _fetchUserNameAndPic();
// // // // //             });
// // // // //           },
// // // // //           padding: const EdgeInsets.symmetric(horizontal: 8),
// // // // //           constraints: const BoxConstraints(),
// // // // //         ),
// // // // //     ];
// // // // //   }

// // // // //   Widget _buildWebAppBarTitle(BuildContext context) {
// // // // //     final theme = Theme.of(context);
// // // // //     final currentUser = _currentUser;
// // // // //     double screenWidth = MediaQuery.of(context).size.width;
// // // // //     double leadingWidth = 150 + (_userName != null ? 100 : 0);
// // // // //     double searchWidthFraction = 0.4;
// // // // //     double minSearchWidth = 200;
// // // // //     double maxSearchWidth = 500;
// // // // //     double actionsWidth = 80 + (_currentUser != null ? 120 : 0);
// // // // //     double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
// // // // //     double calculatedSearchWidth = (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);
// // // // //     double spacerFlexFactor = (availableWidth > calculatedSearchWidth + 40)
// // // // //         ? (availableWidth - calculatedSearchWidth) / 2 / availableWidth
// // // // //         : 0.05;
// // // // //     int searchFlex = (searchWidthFraction * 100).toInt();
// // // // //     int spacerFlex = (spacerFlexFactor * 100).toInt().clamp(5, 50);

// // // // //     return Row(children: [
// // // // //       Text('MM Associates', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
// // // // //       const SizedBox(width: 24),
// // // // //       if (_isLoadingName && currentUser != null)
// // // // //         const Padding(padding: EdgeInsets.only(right: 16.0), child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))
// // // // //       else if (_userName != null && currentUser != null)
// // // // //         Padding(
// // // // //           padding: const EdgeInsets.only(right: 16.0),
// // // // //           child: Text('Hi, ${_userName!.split(' ')[0]}!', style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: theme.textTheme.bodyLarge?.color), overflow: TextOverflow.ellipsis)
// // // // //         ),
// // // // //       Spacer(flex: spacerFlex),
// // // // //       Expanded(
// // // // //         flex: searchFlex,
// // // // //         child: Container(
// // // // //           constraints: BoxConstraints(maxWidth: maxSearchWidth),
// // // // //           child: WebSearchBar(
// // // // //             key: ValueKey(_searchQuery), // Helps re-render if needed, though props handle state
// // // // //             initialValue: _searchQuery ?? '',
// // // // //             cityFilter: _selectedCityFilter,
// // // // //             firestoreService: _firestoreService,
// // // // //             onSearchSubmitted: (query) {
// // // // //               if (query.trim().isNotEmpty) {
// // // // //                 _onFilterOrSearchChanged(explicitSearchQuery: query.trim());
// // // // //               }
// // // // //             },
// // // // //             onSuggestionSelected: (suggestionName) {
// // // // //               _onFilterOrSearchChanged(explicitSearchQuery: suggestionName);
// // // // //             },
// // // // //             onClear: () {
// // // // //               _onFilterOrSearchChanged(explicitSearchQuery: null);
// // // // //             },
// // // // //           ),
// // // // //         ),
// // // // //       ),
// // // // //       Spacer(flex: spacerFlex),
// // // // //     ]);
// // // // //   }

// // // // //   List<Widget> _buildWebAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // // //     final String cityNameText = _selectedCityFilter ?? 'Near Me';
// // // // //     final double textSize = 10.0;

// // // // //     return [
// // // // //       Tooltip(
// // // // //         message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // // //         child: IconButton(
// // // // //           icon: Column(
// // // // //             mainAxisAlignment: MainAxisAlignment.center,
// // // // //             mainAxisSize: MainAxisSize.min,
// // // // //             children: [
// // // // //               Icon(
// // // // //                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // // //                 color: iconColor,
// // // // //                 size: 24,
// // // // //               ),
// // // // //               const SizedBox(height: 2),
// // // // //               Text(
// // // // //                 cityNameText,
// // // // //                 style: TextStyle(
// // // // //                   color: iconColor,
// // // // //                   fontSize: textSize,
// // // // //                   fontWeight: FontWeight.w500,
// // // // //                 ),
// // // // //                 overflow: TextOverflow.ellipsis,
// // // // //                 maxLines: 1,
// // // // //               ),
// // // // //             ],
// // // // //           ),
// // // // //           onPressed: _openCitySelectionScreen,
// // // // //           padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
// // // // //           constraints: const BoxConstraints(),
// // // // //         ),
// // // // //       ),
// // // // //       if (isLoggedIn)
// // // // //         Tooltip(
// // // // //           message: 'My Profile',
// // // // //           child: IconButton(
// // // // //             icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // // //             onPressed: () {
// // // // //               if (!context.mounted) return;
// // // // //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // // //                   .then((_) {
// // // // //                 if (mounted) _fetchUserNameAndPic();
// // // // //               });
// // // // //             },
// // // // //             padding: const EdgeInsets.symmetric(horizontal: 16),
// // // // //             constraints: const BoxConstraints(),
// // // // //           ),
// // // // //         ),
// // // // //       const SizedBox(width: 8)
// // // // //     ];
// // // // //   }

// // // // //   Widget _buildQuickSportFilters() {
// // // // //     if (_quickSportFilters.isEmpty) return const SizedBox.shrink();
// // // // //     final theme = Theme.of(context);
// // // // //     return Container(
// // // // //       height: 55,
// // // // //       color: theme.cardColor,
// // // // //       child: ListView.separated(
// // // // //         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
// // // // //         scrollDirection: Axis.horizontal,
// // // // //         itemCount: _quickSportFilters.length + 1,
// // // // //         separatorBuilder: (context, index) => const SizedBox(width: 10),
// // // // //         itemBuilder: (context, index) {
// // // // //           if (index == 0) {
// // // // //             final bool isSelected = _selectedSportFilter == null;
// // // // //             return ChoiceChip(
// // // // //               label: const Text('All Sports'),
// // // // //               selected: isSelected,
// // // // //               onSelected: (bool nowSelected) {
// // // // //                 if (nowSelected && _selectedSportFilter != null) {
// // // // //                     setStateIfMounted(() => _selectedSportFilter = null);
// // // // //                     _onFilterOrSearchChanged();
// // // // //                 }
// // // // //               },
// // // // //               selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// // // // //               backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// // // // //               labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// // // // //               shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// // // // //               padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// // // // //               visualDensity: VisualDensity.compact,
// // // // //                showCheckmark: false,
// // // // //             );
// // // // //           }
// // // // //           final sport = _quickSportFilters[index - 1];
// // // // //           final bool isSelected = _selectedSportFilter == sport;
// // // // //           return ChoiceChip(
// // // // //             label: Text(sport),
// // // // //             selected: isSelected,
// // // // //             onSelected: (bool isNowSelected) {
// // // // //               String? newFilterValue = isNowSelected ? sport : null;
// // // // //               if (_selectedSportFilter != newFilterValue) {
// // // // //                 setStateIfMounted(() { _selectedSportFilter = newFilterValue; });
// // // // //                 _onFilterOrSearchChanged();
// // // // //               }
// // // // //             },
// // // // //             selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// // // // //             backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// // // // //             labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// // // // //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// // // // //             padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// // // // //             visualDensity: VisualDensity.compact,
// // // // //             showCheckmark: false,
// // // // //           );
// // // // //         },
// // // // //       ),
// // // // //     );
// // // // //   }

// // // // //   Widget _buildSectionHeader(BuildContext context, String title) {
// // // // //     return Padding(padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
// // // // //       child: Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
// // // // //   }

// // // // //   Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg, String emptyMsg, {bool isNearbySection = false}) {
// // // // //      if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
// // // // //      if (errorMsg != null) return Center(child: Padding(padding: const EdgeInsets.all(20), child: Text(errorMsg, textAlign: TextAlign.center, style: const TextStyle(color: Colors.red, fontSize: 16))));
// // // // //      if (venues.isEmpty) return Center(child: Padding(padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0), child: Text(emptyMsg, textAlign: TextAlign.center, style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

// // // // //      return GridView.builder(
// // // // //        shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// // // // //        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
// // // // //        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
// // // // //            maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
// // // // //            mainAxisSpacing: 16.0,
// // // // //            crossAxisSpacing: 16.0,
// // // // //            childAspectRatio: 0.70
// // // // //         ),
// // // // //        itemCount: venues.length,
// // // // //        itemBuilder: (context, index) {
// // // // //          final venue = venues[index];
// // // // //          final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
// // // // //          return _buildVenueGridCard(venue, isFavorite: isFavorite);
// // // // //        },
// // // // //      );
// // // // //    }

// // // // //   Widget _buildBodyContent() {
// // // // //      return Column(children: [
// // // // //          _buildQuickSportFilters(),
// // // // //          Expanded(
// // // // //            child: RefreshIndicator(
// // // // //              onRefresh: _handleRefresh,
// // // // //              child: ListView(
// // // // //                padding: EdgeInsets.zero,
// // // // //                children: [
// // // // //                  if (_isSearchingOrFiltering) ...[
// // // // //                    _buildSectionHeader(context,
// // // // //                         _searchQuery != null && _searchQuery!.isNotEmpty
// // // // //                             ? "Results for \"$_searchQuery\""
// // // // //                             : (_selectedCityFilter != null
// // // // //                                 ? "Venues in $_selectedCityFilter"
// // // // //                                 : (_selectedSportFilter != null ? "Venues for $_selectedSportFilter" : "Filtered Venues")
// // // // //                             )
// // // // //                     ),
// // // // //                    _buildVenueList(_filteredVenues, _isLoadingFilteredVenues, _filteredVenueFetchError, "No venues found for your selection.", isNearbySection: false),
// // // // //                  ] else ...[
// // // // //                    if (_currentPosition != null || _isLoadingNearbyVenues)
// // // // //                        _buildSectionHeader(context, "Venues Near You"),
// // // // //                    _buildVenueList(_nearbyVenues, _isLoadingNearbyVenues, _nearbyVenueFetchError, "No venues found nearby. Try exploring other cities or check location permissions.", isNearbySection: true),

// // // // //                    const SizedBox(height: 16),
// // // // //                    _buildSectionHeader(context, "Explore Venues"),
// // // // //                    _buildVenueList(_exploreVenues, _isLoadingExploreVenues, _exploreVenueFetchError, "No venues to explore at the moment.", isNearbySection: false),
// // // // //                   ],
// // // // //                  const SizedBox(height: 80),
// // // // //                ],
// // // // //              ),
// // // // //            ),
// // // // //          ),
// // // // //        ]
// // // // //      );
// // // // //   }

// // // // //   Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
// // // // //     return Shimmer.fromColors(baseColor: Colors.grey[350]!, highlightColor: Colors.grey[200]!,
// // // // //       child: GridView.builder(
// // // // //         shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// // // // //         padding: const EdgeInsets.all(16.0),
// // // // //         gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0, mainAxisSpacing: 16.0, crossAxisSpacing: 16.0, childAspectRatio: 0.70),
// // // // //         itemCount: itemCount, itemBuilder: (context, index) => _buildVenueShimmerCard())
// // // // //       );
// // // // //   }
// // // // //   Widget _buildVenueShimmerCard() {
// // // // //     return Card(
// // // // //       margin: EdgeInsets.zero, elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), clipBehavior: Clip.antiAlias,
// // // // //       child: Column(children: [
// // // // //         Container(height: 130, width: double.infinity, color: Colors.white),
// // // // //         Expanded(child: Padding(padding: const EdgeInsets.all(10.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
// // // // //           Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
// // // // //             Container(width: double.infinity, height: 18.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// // // // //             Container(width: MediaQuery.of(context).size.width * 0.3, height: 14.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// // // // //             Container(width: MediaQuery.of(context).size.width * 0.2, height: 12.0, color: Colors.white)]),
// // // // //           Container(width: double.infinity, height: 12.0, color: Colors.white)
// // // // //           ])))
// // // // //       ]));
// // // // //   }

// // // // //   Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite}) {
// // // // //       final String venueId = venue['id'] as String? ?? '';
// // // // //       return _VenueCardWidget(
// // // // //         key: ValueKey(venueId),
// // // // //         venue: venue,
// // // // //         isFavorite: isFavorite,
// // // // //         onTapCard: () => _navigateToVenueDetail(venue),
// // // // //         onTapFavorite: () => _toggleFavorite(venueId, isFavorite, venue),
// // // // //       );
// // // // //     }

// // // // //   Future<void> _toggleFavorite(String venueId, bool currentIsFavorite, Map<String, dynamic> venue) async {
// // // // //     if (!mounted) return;
// // // // //     final currentUser = _currentUser;
// // // // //     if (currentUser == null) {
// // // // //       ScaffoldMessenger.of(context).showSnackBar(
// // // // //         const SnackBar(content: Text("Please log in to manage favorites."), behavior: SnackBarBehavior.floating, margin: EdgeInsets.all(10)),
// // // // //       );
// // // // //       return;
// // // // //     }
// // // // //     if (venueId.isEmpty) return;

// // // // //     try {
// // // // //       if (!currentIsFavorite) {
// // // // //         await _userService.addFavorite(venueId);
// // // // //       } else {
// // // // //         await _userService.removeFavorite(venueId);
// // // // //       }
// // // // //     } catch (e) {
// // // // //       debugPrint("Error toggling favorite: $e");
// // // // //       if (mounted) {
// // // // //         ScaffoldMessenger.of(context).showSnackBar(
// // // // //           SnackBar(content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"), backgroundColor: Colors.redAccent, behavior: SnackBarBehavior.floating, margin: const EdgeInsets.all(10)),
// // // // //         );
// // // // //       }
// // // // //     }
// // // // //   }

// // // // // } 

// // // // // class _VenueCardWidget extends StatefulWidget {
// // // // //   final Map<String, dynamic> venue;
// // // // //   final bool isFavorite;
// // // // //   final VoidCallback onTapCard;
// // // // //   final Future<void> Function() onTapFavorite;

// // // // //   const _VenueCardWidget({
// // // // //     required Key key,
// // // // //     required this.venue,
// // // // //     required this.isFavorite,
// // // // //     required this.onTapCard,
// // // // //     required this.onTapFavorite,
// // // // //   }) : super(key: key);

// // // // //   @override
// // // // //   _VenueCardWidgetState createState() => _VenueCardWidgetState();
// // // // // }

// // // // // class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
// // // // //   late AnimationController _favoriteAnimationController;
// // // // //   late Animation<double> _favoriteScaleAnimation;

// // // // //   @override
// // // // //   void initState() {
// // // // //     super.initState();
// // // // //     _favoriteAnimationController = AnimationController(
// // // // //       duration: const Duration(milliseconds: 300),
// // // // //       vsync: this,
// // // // //     );
// // // // //     _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
// // // // //       CurvedAnimation(parent: _favoriteAnimationController, curve: Curves.elasticOut, reverseCurve: Curves.easeInCubic),
// // // // //     );
// // // // //   }

// // // // //   @override
// // // // //   void didUpdateWidget(_VenueCardWidget oldWidget) {
// // // // //     super.didUpdateWidget(oldWidget);
// // // // //     if (widget.isFavorite != oldWidget.isFavorite && mounted) {
// // // // //       if (widget.isFavorite) {
// // // // //         _favoriteAnimationController.forward(from: 0.0).catchError((e) {
// // // // //           if (e is! TickerCanceled) { debugPrint("Error playing fav add animation: $e"); }
// // // // //         });
// // // // //       } else {
// // // // //          _favoriteAnimationController.reverse().catchError((e) {
// // // // //              if (e is! TickerCanceled) { debugPrint("Error reversing fav remove animation: $e"); }
// // // // //          });
// // // // //       }
// // // // //     }
// // // // //   }

// // // // //   @override
// // // // //   void dispose() {
// // // // //     _favoriteAnimationController.dispose();
// // // // //     super.dispose();
// // // // //   }

// // // // //   @override
// // // // //   Widget build(BuildContext context) {
// // // // //     final ThemeData theme = Theme.of(context);
// // // // //     final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
// // // // //     final dynamic sportRaw = widget.venue['sportType'];
// // // // //     final String sport = (sportRaw is String) ? sportRaw : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
// // // // //     final String? imageUrl = widget.venue['imageUrl'] as String?;
// // // // //     final String city = widget.venue['city'] as String? ?? '';
// // // // //     final String venueId = widget.venue['id'] as String? ?? '';
// // // // //     final double? distance = widget.venue['distance'] as double?;
// // // // //     final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
// // // // //     final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

// // // // //     return MouseRegion(
// // // // //       cursor: SystemMouseCursors.click,
// // // // //       child: Card(
// // // // //         margin: EdgeInsets.zero,
// // // // //         elevation: 3,
// // // // //         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
// // // // //         clipBehavior: Clip.antiAlias,
// // // // //         child: Column(
// // // // //           crossAxisAlignment: CrossAxisAlignment.start,
// // // // //           children: [
// // // // //             SizedBox(
// // // // //               height: 130,
// // // // //               width: double.infinity,
// // // // //               child: Stack(
// // // // //                 children: [
// // // // //                   Positioned.fill(
// // // // //                     child: InkWell(
// // // // //                       onTap: widget.onTapCard,
// // // // //                       child: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// // // // //                           ? Hero(
// // // // //                               tag: 'venue_image_$venueId',
// // // // //                               child: Image.network(
// // // // //                                 imageUrl, height: 130, width: double.infinity, fit: BoxFit.cover,
// // // // //                                 loadingBuilder: (context, child, loadingProgress) =>
// // // // //                                     (loadingProgress == null) ? child : Container(height: 130, color: Colors.grey[200], child: Center(child: CircularProgressIndicator(strokeWidth: 2, value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null))),
// // // // //                                 errorBuilder: (context, error, stackTrace) =>
// // // // //                                     Container(height: 130, color: Colors.grey[200], child: Center(child: Icon(Icons.broken_image_outlined, color: Colors.grey[400], size: 40))),
// // // // //                               ),
// // // // //                             )
// // // // //                           : Container(height: 130, color: theme.primaryColor.withOpacity(0.08), child: Center(child: Icon(Icons.sports_soccer_outlined, size: 50, color: theme.primaryColor.withOpacity(0.7)))),
// // // // //                     ),
// // // // //                   ),
// // // // //                   Positioned(
// // // // //                     top: 6, right: 6,
// // // // //                     child: Material(
// // // // //                       color: Colors.black.withOpacity(0.45), shape: const CircleBorder(),
// // // // //                       child: InkWell(
// // // // //                         borderRadius: BorderRadius.circular(20),
// // // // //                         onTap: widget.onTapFavorite,
// // // // //                         child: Padding(
// // // // //                           padding: const EdgeInsets.all(7.0),
// // // // //                           child: ScaleTransition(
// // // // //                             scale: _favoriteScaleAnimation,
// // // // //                             child: Icon(
// // // // //                               widget.isFavorite ? Icons.favorite_rounded : Icons.favorite_border_rounded,
// // // // //                               color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
// // // // //                               size: 22,
// // // // //                             ),
// // // // //                           ),
// // // // //                         ),
// // // // //                       ),
// // // // //                     ),
// // // // //                   ),
// // // // //                   if (distance != null)
// // // // //                     Positioned(
// // // // //                       bottom: 6, left: 6,
// // // // //                       child: Container(
// // // // //                         padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
// // // // //                         decoration: BoxDecoration(color: Colors.black.withOpacity(0.6), borderRadius: BorderRadius.circular(4)),
// // // // //                         child: Text('${distance.toStringAsFixed(1)} km', style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.w500)),
// // // // //                       ),
// // // // //                     ),
// // // // //                 ],
// // // // //               ),
// // // // //             ),
// // // // //             Expanded(
// // // // //               child: InkWell(
// // // // //                 onTap: widget.onTapCard,
// // // // //                 child: Padding(
// // // // //                   padding: const EdgeInsets.all(10.0),
// // // // //                   child: Column(
// // // // //                     crossAxisAlignment: CrossAxisAlignment.start,
// // // // //                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
// // // // //                     children: [
// // // // //                       Column(
// // // // //                         crossAxisAlignment: CrossAxisAlignment.start,
// // // // //                         mainAxisSize: MainAxisSize.min,
// // // // //                         children: [
// // // // //                           Text(name, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 2, overflow: TextOverflow.ellipsis),
// // // // //                           const SizedBox(height: 4),
// // // // //                           Row(children: [
// // // // //                             Icon(Icons.sports_kabaddi_outlined, size: 14, color: theme.colorScheme.secondary),
// // // // //                             const SizedBox(width: 4),
// // // // //                             Expanded(child: Text(sport, style: theme.textTheme.bodyMedium?.copyWith(color: Colors.grey[800], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// // // // //                           ]),
// // // // //                           if (reviewCount > 0)
// // // // //                             Padding(
// // // // //                                padding: const EdgeInsets.only(top: 5.0),
// // // // //                                child: Row(children: [
// // // // //                                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// // // // //                                 const SizedBox(width: 4),
// // // // //                                 Text(averageRating.toStringAsFixed(1), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
// // // // //                                 const SizedBox(width: 4),
// // // // //                                 Text("($reviewCount reviews)", style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
// // // // //                               ]),
// // // // //                              ),
// // // // //                         ],
// // // // //                       ),
// // // // //                       Row(
// // // // //                         children: [
// // // // //                           Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
// // // // //                           const SizedBox(width: 4),
// // // // //                           Expanded(child: Text(city, style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[700], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// // // // //                         ],
// // // // //                       ),
// // // // //                     ],
// // // // //                   ),
// // // // //                 ),
// // // // //               ),
// // // // //             ),
// // // // //           ],
// // // // //         ),
// // // // //       ),
// // // // //     );
// // // // //   }
// // // // // }

// // // // //---------search component seperated from homescree, plus added admin realted things-----------
// // // // // lib/features/home/screens/home_screen.dart
// // // // // I am providing the full updated code for this file for clarity.

// // // // import 'package:flutter/material.dart';
// // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // import 'package:geolocator/geolocator.dart';
// // // // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // // // import 'package:mm_associates/features/home/screens/venue_form.dart';
// // // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // // import 'package:mm_associates/features/user/services/user_service.dart';
// // // // import 'package:mm_associates/core/services/location_service.dart';
// // // // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // // // import 'venue_detail_screen.dart';
// // // // import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
// // // // import 'dart:async';
// // // // import 'package:shimmer/shimmer.dart';
// // // // import 'city_selection_screen.dart' show CitySelectionScreen, CityInfo, kAppAllCities;
// // // // import 'package:mm_associates/features/home/widgets/home_search_components.dart';

// // // // class HomeScreen extends StatefulWidget {
// // // //   /// Controls the visibility of the "Add Venue" Floating Action Button.
// // // //   final bool showAddVenueButton;

// // // //   const HomeScreen({
// // // //     super.key,
// // // //     required this.showAddVenueButton,
// // // //   });

// // // //   @override
// // // //   State<HomeScreen> createState() => _HomeScreenState();
// // // // }

// // // // class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
// // // //   final AuthService _authService = AuthService();
// // // //   final FirestoreService _firestoreService = FirestoreService();
// // // //   final LocationService _locationService = LocationService();
// // // //   final UserService _userService = UserService();

// // // //   // Search and Filter State
// // // //   String? _searchQuery;
// // // //   String? _selectedCityFilter;
// // // //   IconData? _selectedCityIcon;
// // // //   String? _selectedSportFilter;

// // // //   // User State
// // // //   User? _currentUser;
// // // //   String? _userName;
// // // //   String? _userProfilePicUrl;
// // // //   bool _isLoadingName = true;

// // // //   // Venue Data State
// // // //   List<Map<String, dynamic>> _filteredVenues = [];
// // // //   bool _isLoadingFilteredVenues = true;
// // // //   String? _filteredVenueFetchError;

// // // //   List<Map<String, dynamic>> _nearbyVenues = [];
// // // //   bool _isLoadingNearbyVenues = true;
// // // //   String? _nearbyVenueFetchError;

// // // //   List<Map<String, dynamic>> _exploreVenues = [];
// // // //   bool _isLoadingExploreVenues = true;
// // // //   String? _exploreVenueFetchError;

// // // //   // Location State
// // // //   Position? _currentPosition;
// // // //   bool _isFetchingLocation = false;
// // // //   String? _locationStatusMessage;

// // // //   // Favorite Venues State
// // // //   List<String> _favoriteVenueIds = [];
// // // //   bool _isLoadingFavorites = true;
// // // //   Stream<List<String>>? _favoritesStream;
// // // //   StreamSubscription<List<String>>? _favoritesSubscription;

// // // //   // UI Helper data
// // // //   final List<String> _supportedCities = ['Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'];
// // // //   final List<String> _quickSportFilters = ['Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'];

// // // //   // Getter to determine if we are in a search/filter mode
// // // //   bool get _isSearchingOrFiltering => (_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null;

// // // //   @override
// // // //   void initState() {
// // // //     super.initState();
// // // //     _currentUser = FirebaseAuth.instance.currentUser;
// // // //     _initializeScreen();
// // // //     _setupFavoritesStream();
// // // //     _updateSelectedCityIconFromFilter();
// // // //   }

// // // //   @override
// // // //   void dispose() {
// // // //     _favoritesSubscription?.cancel();
// // // //     super.dispose();
// // // //   }

// // // //   void setStateIfMounted(VoidCallback fn) {
// // // //     if (mounted) setState(fn);
// // // //   }

// // // //   void _updateSelectedCityIconFromFilter() {
// // // //     if (_selectedCityFilter == null) {
// // // //       _selectedCityIcon = Icons.my_location;
// // // //     } else {
// // // //       try {
// // // //         final cityInfo = kAppAllCities.firstWhere(
// // // //           (city) => city.name == _selectedCityFilter,
// // // //         );
// // // //         _selectedCityIcon = cityInfo.icon;
// // // //       } catch (e) {
// // // //         _selectedCityIcon = Icons.location_city_outlined;
// // // //         debugPrint("HomeScreen initState: Selected city '$_selectedCityFilter' not found in kAppAllCities. Using fallback icon. Error: $e");
// // // //       }
// // // //     }
// // // //   }
  
// // // //   Future<void> _initializeScreen() async {
// // // //     await _fetchUserNameAndPic();
// // // //     await _fetchPrimaryVenueData();
// // // //   }

// // // //   Future<void> _fetchPrimaryVenueData() async {
// // // //     if (!mounted) return;
// // // //     setStateIfMounted(() {
// // // //       _isFetchingLocation = true; _isLoadingNearbyVenues = true; _isLoadingExploreVenues = true;
// // // //       _locationStatusMessage = 'Fetching your location...';
// // // //       _nearbyVenues = []; _exploreVenues = [];
// // // //       _nearbyVenueFetchError = null; _exploreVenueFetchError = null;
// // // //     });
// // // //     _currentPosition = await _locationService.getCurrentLocation();
// // // //     if (!mounted) return;
// // // //     setStateIfMounted(() {
// // // //       _isFetchingLocation = false;
// // // //       _locationStatusMessage = _currentPosition != null ? 'Location acquired.' : 'Could not get location.';
// // // //     });
// // // //     await Future.wait([_fetchNearbyVenuesScoped(), _fetchExploreVenuesFromOtherCities()]);
// // // //   }

// // // //   void _setupFavoritesStream() {
// // // //     _favoritesSubscription?.cancel();
// // // //     if (_currentUser != null) {
// // // //         _favoritesStream = _userService.getFavoriteVenueIdsStream();
// // // //         _favoritesSubscription = _favoritesStream?.listen(
// // // //           (favoriteIds) {
// // // //             if (mounted) {
// // // //               final newIdsSet = favoriteIds.toSet();
// // // //               final currentIdsSet = _favoriteVenueIds.toSet();
// // // //               if (newIdsSet.difference(currentIdsSet).isNotEmpty || currentIdsSet.difference(newIdsSet).isNotEmpty) {
// // // //                 setStateIfMounted(() {
// // // //                   _favoriteVenueIds = favoriteIds;
// // // //                 });
// // // //               }
// // // //             }
// // // //           },
// // // //           onError: (error) {
// // // //             debugPrint("Error in favorites stream: $error");
// // // //              if (mounted) {
// // // //                 ScaffoldMessenger.of(context).showSnackBar(
// // // //                     const SnackBar(content: Text("Could not update favorites."),
// // // //                     backgroundColor: Colors.orangeAccent,
// // // //                     behavior: SnackBarBehavior.floating)
// // // //                 );
// // // //              }
// // // //           }
// // // //         );
// // // //         if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);
// // // //     } else {
// // // //       if (mounted) {
// // // //          setStateIfMounted(() {
// // // //            _favoriteVenueIds = [];
// // // //            _isLoadingFavorites = false;
// // // //            _favoritesStream = null;
// // // //            _favoritesSubscription = null;
// // // //          });
// // // //       }
// // // //     }
// // // //   }

// // // //   @override
// // // //   void didChangeDependencies() {
// // // //     super.didChangeDependencies();
// // // //     final currentAuthUser = FirebaseAuth.instance.currentUser;
// // // //     if (currentAuthUser != _currentUser) {
// // // //       _currentUser = currentAuthUser;
// // // //       _initializeScreen();
// // // //       _setupFavoritesStream();
// // // //       if (mounted) {
// // // //         setStateIfMounted(() {
// // // //           _updateSelectedCityIconFromFilter();
// // // //         });
// // // //       }
// // // //     }
// // // //   }

// // // //   Future<void> _fetchVenuesForFilterOrSearch({String? newSearchQuery}) async {
// // // //     if (!mounted) return;
// // // //     setStateIfMounted(() {
// // // //       _isLoadingFilteredVenues = true;
// // // //       _filteredVenueFetchError = null;
// // // //       _filteredVenues = [];
// // // //     });

// // // //     try {
// // // //       debugPrint("Fetching FILTERED/SEARCH venues: City: $_selectedCityFilter, Sport: $_selectedSportFilter, Search: $newSearchQuery, Location: $_currentPosition");
// // // //       final venuesData = await _firestoreService.getVenues(
// // // //         userLocation: _currentPosition,
// // // //         radiusInKm: _selectedCityFilter != null ? null : (_currentPosition != null ? 50.0 : null),
// // // //         cityFilter: _selectedCityFilter,
// // // //         searchQuery: newSearchQuery,
// // // //         sportFilter: _selectedSportFilter,
// // // //       );
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() {
// // // //           _filteredVenues = venuesData;
// // // //         });
// // // //     } catch (e) {
// // // //       debugPrint("Error fetching filtered/search venues: $e");
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() => _filteredVenueFetchError = "Could not load venues: ${e.toString().replaceFirst('Exception: ', '')}");
// // // //     } finally {
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() => _isLoadingFilteredVenues = false);
// // // //     }
// // // //   }

// // // //   Future<void> _fetchNearbyVenuesScoped() async {
// // // //     if (!mounted) return;
// // // //     if (_currentPosition == null) {
// // // //       if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = false; _nearbyVenueFetchError = "Location not available."; _nearbyVenues = []; });
// // // //       return;
// // // //     }
// // // //     if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = true; _nearbyVenueFetchError = null; _nearbyVenues = []; });
// // // //     try {
// // // //       final venuesData = await _firestoreService.getVenues(userLocation: _currentPosition, radiusInKm: 25.0);
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() {
// // // //         _nearbyVenues = venuesData;
// // // //       });
// // // //     } catch (e) {
// // // //       debugPrint("Error fetching nearby venues: $e");
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() => _nearbyVenueFetchError = "Could not load nearby venues.");
// // // //     } finally {
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() => _isLoadingNearbyVenues = false);
// // // //     }
// // // //   }

// // // //   Future<void> _fetchExploreVenuesFromOtherCities() async {
// // // //     if (!mounted) return;
// // // //     setStateIfMounted(() { _isLoadingExploreVenues = true; _exploreVenueFetchError = null; _exploreVenues = [];});
// // // //     List<Map<String, dynamic>> allExploreVenues = [];
// // // //     try {
// // // //       for (String city in _supportedCities) {
// // // //         final cityVenues = await _firestoreService.getVenues(cityFilter: city, userLocation: _currentPosition, limit: 5);
// // // //         allExploreVenues.addAll(cityVenues);
// // // //         if (!mounted) return;
// // // //       }
// // // //       final uniqueExploreVenues = allExploreVenues.fold<Map<String, Map<String, dynamic>>>({}, (map, venue) {
// // // //           final String? venueId = venue['id'] as String?;
// // // //           if (venueId != null) map[venueId] = venue;
// // // //           return map;
// // // //         }).values.toList();

// // // //       if (_currentPosition != null) {
// // // //         uniqueExploreVenues.sort((a, b) {
// // // //           final distA = a['distance'] as double?; final distB = b['distance'] as double?;
// // // //           if (distA != null && distB != null) return distA.compareTo(distB);
// // // //           if (distA != null) return -1;
// // // //           if (distB != null) return 1;
// // // //           return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
// // // //         });
// // // //       } else {
// // // //          uniqueExploreVenues.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
// // // //       }
// // // //       if(!mounted) return;
// // // //       setStateIfMounted(() {
// // // //         _exploreVenues = uniqueExploreVenues.take(15).toList();
// // // //       });
// // // //     } catch (e) {
// // // //       debugPrint("Error fetching explore venues: $e");
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() => _exploreVenueFetchError = "Could not load explore venues.");
// // // //     } finally {
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() => _isLoadingExploreVenues = false);
// // // //     }
// // // //   }

// // // //   Future<void> _fetchUserNameAndPic() async {
// // // //     _setLoadingName(true); final currentUser = _currentUser;
// // // //     if (currentUser == null) { if(mounted) _updateUserNameAndPic('Guest', null); _setLoadingName(false); return; }
// // // //     try {
// // // //       final userData = await _userService.getUserProfileData();
// // // //       if (!mounted) return;
// // // //       final fetchedName = userData?['name'] as String? ?? currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // // //       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
// // // //       _updateUserNameAndPic(fetchedName, fetchedPicUrl);
// // // //     } catch (e) {
// // // //       debugPrint("Error fetching user name/pic via UserService: $e"); if (!mounted) return;
// // // //       final fallbackName = currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // // //       _updateUserNameAndPic(fallbackName, null);
// // // //     } finally { if(mounted) _setLoadingName(false); }
// // // //   }

// // // //   void _setLoadingName(bool isLoading) => {if(mounted) setStateIfMounted(() => _isLoadingName = isLoading)};
// // // //   void _updateUserNameAndPic(String name, String? picUrl) => {if(mounted) setStateIfMounted(() { _userName = name; _userProfilePicUrl = picUrl; })};

// // // //   Future<void> _handleRefresh() async {
// // // //     if(mounted) {
// // // //       setStateIfMounted(() {
// // // //           _searchQuery = null;
// // // //           _selectedSportFilter = null;
// // // //       });
// // // //     }
// // // //     _onFilterOrSearchChanged();
// // // //   }

// // // //   void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
// // // //     final newSearchQuery = explicitSearchQuery ?? _searchQuery;
// // // //     bool queryChanged = _searchQuery != newSearchQuery;

// // // //     if (mounted) {
// // // //       setStateIfMounted(() {
// // // //         _searchQuery = newSearchQuery;
// // // //       });
// // // //     }

// // // //     if ((_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null) {
// // // //         _fetchVenuesForFilterOrSearch(newSearchQuery: _searchQuery);
// // // //     } else {
// // // //         _fetchPrimaryVenueData();
// // // //     }

// // // //     if (kIsWeb && queryChanged) {
// // // //       FocusScope.of(context).unfocus();
// // // //     }
// // // //   }

// // // //   Future<void> _showLogoutConfirmationDialog(BuildContext context) async {
// // // //       if (!context.mounted) return;
// // // //       return showDialog<void>(context: context, barrierDismissible: false, builder: (BuildContext dialogContext) {
// // // //           return AlertDialog(title: const Text('Confirm Logout'), content: const SingleChildScrollView(child: ListBody(children: <Widget>[Text('Are you sure you want to sign out?')])),
// // // //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
// // // //             actions: <Widget>[
// // // //               TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
// // // //               TextButton(child: const Text('Logout', style: TextStyle(color: Colors.red)), onPressed: () async {
// // // //                   Navigator.of(dialogContext).pop(); try { await _authService.signOut();
// // // //                    } catch (e) {
// // // //                     debugPrint("Error during sign out: $e"); if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error signing out: ${e.toString()}'), backgroundColor: Colors.redAccent, behavior: SnackBarBehavior.floating, margin: const EdgeInsets.all(10)));
// // // //                   }},), ],); },);
// // // //     }

// // // //   void _navigateToVenueDetail(Map<String, dynamic> venue) {
// // // //     if (!context.mounted) return;
// // // //     Navigator.push(context, MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venue['id'] as String, initialVenueData: venue))).then((_) {
// // // //     });
// // // //   }

// // // //   void _openSearchMobile() async {
// // // //      if (!context.mounted) return;
// // // //      final String? submittedQuery = await showSearch<String?>(
// // // //         context: context,
// // // //         delegate: VenueSearchDelegate(
// // // //             firestoreService: _firestoreService,
// // // //             initialCityFilter: _selectedCityFilter,
// // // //         )
// // // //     );
// // // //     if (submittedQuery != null && submittedQuery.isNotEmpty) {
// // // //         _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
// // // //     }
// // // //   }

// // // //   Future<void> _openCitySelectionScreen() async {
// // // //     if (!mounted) return;
// // // //     final String? newSelectedCityName = await Navigator.push<String?>(
// // // //       context,
// // // //       MaterialPageRoute(
// // // //         builder: (context) => CitySelectionScreen(currentSelectedCity: _selectedCityFilter),
// // // //       ),
// // // //     );

// // // //     if (mounted) {
// // // //       if (newSelectedCityName != _selectedCityFilter) {
// // // //         setStateIfMounted(() {
// // // //           _selectedCityFilter = newSelectedCityName; 
// // // //           _updateSelectedCityIconFromFilter(); 
// // // //         });
// // // //         _onFilterOrSearchChanged(); 
// // // //       } else {
// // // //         IconData currentExpectedIcon = Icons.location_city_outlined; 
// // // //         if (_selectedCityFilter == null) {
// // // //             currentExpectedIcon = Icons.my_location;
// // // //         } else {
// // // //             try {
// // // //                 final cityInfo = kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
// // // //                 currentExpectedIcon = cityInfo.icon;
// // // //             } catch (e) {
// // // //                 debugPrint("Error re-validating icon for city '$_selectedCityFilter': $e. Using fallback.");
// // // //             }
// // // //         }
// // // //         if (_selectedCityIcon != currentExpectedIcon) {
// // // //             setStateIfMounted(() {
// // // //               _selectedCityIcon = currentExpectedIcon;
// // // //             });
// // // //         }
// // // //       }
// // // //     }
// // // //   }

// // // //   @override
// // // //   Widget build(BuildContext context) {
// // // //     final theme = Theme.of(context);
// // // //     final appBarBackgroundColor = theme.appBarTheme.backgroundColor ?? theme.primaryColor;
// // // //     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ?? theme.appBarTheme.iconTheme?.color ?? (kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white);
// // // //     final bool isLoggedIn = _currentUser != null;

// // // //     return Scaffold(
// // // //       appBar: AppBar(
// // // //         automaticallyImplyLeading: false,
// // // //         title: kIsWeb ? _buildWebAppBarTitle(context) : _buildMobileAppBarTitle(context, theme),
// // // //         actions: kIsWeb ? _buildWebAppBarActions(context, isLoggedIn, actionsIconColor) : _buildMobileAppBarActions(context, isLoggedIn, actionsIconColor),
// // // //         backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
// // // //         elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
// // // //         iconTheme: theme.iconTheme.copyWith(color: kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white),
// // // //         actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
// // // //         titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ?? TextStyle(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white, fontSize: 20, fontWeight: FontWeight.w500),
// // // //       ),
// // // //       // *** THE ONLY CHANGE IN THIS WIDGET IS HERE ***
// // // //       floatingActionButton: widget.showAddVenueButton
// // // //           ? FloatingActionButton.extended(
// // // //               onPressed: () {
// // // //                 Navigator.push(
// // // //                   context,
// // // //                   MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
// // // //                 ).then((result) {
// // // //                   if (result == true && mounted) {
// // // //                     _handleRefresh();
// // // //                     ScaffoldMessenger.of(context).showSnackBar(
// // // //                       const SnackBar(content: Text("Venue list updated."), backgroundColor: Colors.blueAccent),
// // // //                     );
// // // //                   }
// // // //                 });
// // // //               },
// // // //               icon: const Icon(Icons.add_location_alt_outlined),
// // // //               label: const Text("Add Venue"),
// // // //               tooltip: 'Add New Venue',
// // // //             )
// // // //           : null, // If false, hide the button
// // // //       floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
// // // //       body: _buildBodyContent(),
// // // //     );
// // // //   }

// // // //   // ... (All other UI build methods remain exactly the same)
// // // //   // _buildMobileAppBarTitle, _buildMobileAppBarActions, _buildWebAppBarTitle, etc.
// // // //   // ... Paste all the build methods from your previous code here, unchanged ...
  
// // // //   Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
// // // //     final titleStyle = theme.appBarTheme.titleTextStyle ?? theme.primaryTextTheme.titleLarge ?? const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
// // // //     final currentUser = _currentUser;
// // // //     return Row(children: [
// // // //         if (currentUser != null)
// // // //           GestureDetector(
// // // //             onTap: () {
// // // //               if (!context.mounted) return;
// // // //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // //                   .then((_) { if (mounted) _fetchUserNameAndPic(); });
// // // //             },
// // // //             child: Tooltip(
// // // //               message: "My Profile",
// // // //               child: Padding(
// // // //                 padding: const EdgeInsets.only(right: 10.0),
// // // //                 child: CircleAvatar(
// // // //                   radius: 18,
// // // //                   backgroundColor: Colors.white24,
// // // //                   backgroundImage: _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty ? NetworkImage(_userProfilePicUrl!) : null,
// // // //                   child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty ? Icon(Icons.person_outline, size: 20, color: Colors.white.withOpacity(0.8)) : null
// // // //                 )
// // // //               ),
// // // //             ),
// // // //           ),
// // // //         if (_isLoadingName && currentUser != null)
// // // //           const Padding(
// // // //             padding: EdgeInsets.only(left: 6.0),
// // // //             child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(Colors.white70)))
// // // //           )
// // // //         else if (_userName != null && currentUser != null)
// // // //           Expanded(
// // // //             child: Padding(
// // // //                padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
// // // //               child: Text(
// // // //                 'Hi, ${_userName!.split(' ')[0]}!',
// // // //                 style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
// // // //                 overflow: TextOverflow.ellipsis
// // // //               )
// // // //             )
// // // //           )
// // // //         else
// // // //           Text('MM Associates', style: titleStyle),
// // // //       ]
// // // //     );
// // // //   }
  
// // // //   List<Widget> _buildMobileAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // //     final String cityNameText = _selectedCityFilter ?? 'Near Me';
// // // //     final double textSize = 10.0; 

// // // //     return [
// // // //       IconButton(
// // // //         icon: Icon(Icons.search_outlined, color: iconColor),
// // // //         tooltip: 'Search Venues',
// // // //         onPressed: _openSearchMobile,
// // // //         padding: const EdgeInsets.symmetric(horizontal: 8),
// // // //         constraints: const BoxConstraints(),
// // // //       ),
// // // //       Tooltip( 
// // // //         message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // //         child: IconButton(
// // // //           icon: Column(
// // // //             mainAxisAlignment: MainAxisAlignment.center,
// // // //             mainAxisSize: MainAxisSize.min,
// // // //             children: [
// // // //               Icon(
// // // //                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // //                 color: iconColor,
// // // //                 size: 24,
// // // //               ),
// // // //               const SizedBox(height: 2), 
// // // //               Text(
// // // //                 cityNameText,
// // // //                 style: TextStyle(
// // // //                   color: iconColor,
// // // //                   fontSize: textSize,
// // // //                   fontWeight: FontWeight.w500,
// // // //                 ),
// // // //                 overflow: TextOverflow.ellipsis,
// // // //                 maxLines: 1,
// // // //               ),
// // // //             ],
// // // //           ),
// // // //           onPressed: _openCitySelectionScreen,
// // // //           padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0),
// // // //           constraints: const BoxConstraints(),
// // // //         ),
// // // //       ),
// // // //       if (isLoggedIn)
// // // //         IconButton(
// // // //           icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // //           tooltip: 'My Profile',
// // // //           onPressed: () {
// // // //             if (!context.mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // //                 .then((_) {
// // // //               if (mounted) _fetchUserNameAndPic();
// // // //             });
// // // //           },
// // // //           padding: const EdgeInsets.symmetric(horizontal: 8),
// // // //           constraints: const BoxConstraints(),
// // // //         ),
// // // //     ];
// // // //   }

// // // //   Widget _buildWebAppBarTitle(BuildContext context) {
// // // //     final theme = Theme.of(context);
// // // //     final currentUser = _currentUser;
// // // //     double screenWidth = MediaQuery.of(context).size.width;
// // // //     double leadingWidth = 150 + (_userName != null ? 100 : 0);
// // // //     double searchWidthFraction = 0.4;
// // // //     double minSearchWidth = 200;
// // // //     double maxSearchWidth = 500;
// // // //     double actionsWidth = 80 + (_currentUser != null ? 120 : 0);
// // // //     double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
// // // //     double calculatedSearchWidth = (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);
// // // //     double spacerFlexFactor = (availableWidth > calculatedSearchWidth + 40)
// // // //         ? (availableWidth - calculatedSearchWidth) / 2 / availableWidth
// // // //         : 0.05;
// // // //     int searchFlex = (searchWidthFraction * 100).toInt();
// // // //     int spacerFlex = (spacerFlexFactor * 100).toInt().clamp(5, 50);

// // // //     return Row(children: [
// // // //       Text('MM Associates', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
// // // //       const SizedBox(width: 24),
// // // //       if (_isLoadingName && currentUser != null)
// // // //         const Padding(padding: EdgeInsets.only(right: 16.0), child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))
// // // //       else if (_userName != null && currentUser != null)
// // // //         Padding(
// // // //           padding: const EdgeInsets.only(right: 16.0),
// // // //           child: Text('Hi, ${_userName!.split(' ')[0]}!', style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: theme.textTheme.bodyLarge?.color), overflow: TextOverflow.ellipsis)
// // // //         ),
// // // //       Spacer(flex: spacerFlex),
// // // //       Expanded(
// // // //         flex: searchFlex,
// // // //         child: Container(
// // // //           constraints: BoxConstraints(maxWidth: maxSearchWidth),
// // // //           child: WebSearchBar(
// // // //             key: ValueKey(_searchQuery),
// // // //             initialValue: _searchQuery ?? '',
// // // //             cityFilter: _selectedCityFilter,
// // // //             firestoreService: _firestoreService,
// // // //             onSearchSubmitted: (query) {
// // // //               if (query.trim().isNotEmpty) {
// // // //                 _onFilterOrSearchChanged(explicitSearchQuery: query.trim());
// // // //               }
// // // //             },
// // // //             onSuggestionSelected: (suggestionName) {
// // // //               _onFilterOrSearchChanged(explicitSearchQuery: suggestionName);
// // // //             },
// // // //             onClear: () {
// // // //               _onFilterOrSearchChanged(explicitSearchQuery: null);
// // // //             },
// // // //           ),
// // // //         ),
// // // //       ),
// // // //       Spacer(flex: spacerFlex),
// // // //     ]);
// // // //   }

// // // //   List<Widget> _buildWebAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// // // //     final String cityNameText = _selectedCityFilter ?? 'Near Me';
// // // //     final double textSize = 10.0;

// // // //     return [
// // // //       Tooltip(
// // // //         message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// // // //         child: IconButton(
// // // //           icon: Column(
// // // //             mainAxisAlignment: MainAxisAlignment.center,
// // // //             mainAxisSize: MainAxisSize.min,
// // // //             children: [
// // // //               Icon(
// // // //                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// // // //                 color: iconColor,
// // // //                 size: 24,
// // // //               ),
// // // //               const SizedBox(height: 2),
// // // //               Text(
// // // //                 cityNameText,
// // // //                 style: TextStyle(
// // // //                   color: iconColor,
// // // //                   fontSize: textSize,
// // // //                   fontWeight: FontWeight.w500,
// // // //                 ),
// // // //                 overflow: TextOverflow.ellipsis,
// // // //                 maxLines: 1,
// // // //               ),
// // // //             ],
// // // //           ),
// // // //           onPressed: _openCitySelectionScreen,
// // // //           padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
// // // //           constraints: const BoxConstraints(),
// // // //         ),
// // // //       ),
// // // //       if (isLoggedIn)
// // // //         Tooltip(
// // // //           message: 'My Profile',
// // // //           child: IconButton(
// // // //             icon: Icon(Icons.person_outline_rounded, color: iconColor),
// // // //             onPressed: () {
// // // //               if (!context.mounted) return;
// // // //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// // // //                   .then((_) {
// // // //                 if (mounted) _fetchUserNameAndPic();
// // // //               });
// // // //             },
// // // //             padding: const EdgeInsets.symmetric(horizontal: 16),
// // // //             constraints: const BoxConstraints(),
// // // //           ),
// // // //         ),
// // // //       const SizedBox(width: 8)
// // // //     ];
// // // //   }

// // // //   Widget _buildQuickSportFilters() {
// // // //     if (_quickSportFilters.isEmpty) return const SizedBox.shrink();
// // // //     final theme = Theme.of(context);
// // // //     return Container(
// // // //       height: 55,
// // // //       color: theme.cardColor,
// // // //       child: ListView.separated(
// // // //         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
// // // //         scrollDirection: Axis.horizontal,
// // // //         itemCount: _quickSportFilters.length + 1,
// // // //         separatorBuilder: (context, index) => const SizedBox(width: 10),
// // // //         itemBuilder: (context, index) {
// // // //           if (index == 0) {
// // // //             final bool isSelected = _selectedSportFilter == null;
// // // //             return ChoiceChip(
// // // //               label: const Text('All Sports'),
// // // //               selected: isSelected,
// // // //               onSelected: (bool nowSelected) {
// // // //                 if (nowSelected && _selectedSportFilter != null) {
// // // //                     setStateIfMounted(() => _selectedSportFilter = null);
// // // //                     _onFilterOrSearchChanged();
// // // //                 }
// // // //               },
// // // //               selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// // // //               backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// // // //               labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// // // //               shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// // // //               padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// // // //               visualDensity: VisualDensity.compact,
// // // //                showCheckmark: false,
// // // //             );
// // // //           }
// // // //           final sport = _quickSportFilters[index - 1];
// // // //           final bool isSelected = _selectedSportFilter == sport;
// // // //           return ChoiceChip(
// // // //             label: Text(sport),
// // // //             selected: isSelected,
// // // //             onSelected: (bool isNowSelected) {
// // // //               String? newFilterValue = isNowSelected ? sport : null;
// // // //               if (_selectedSportFilter != newFilterValue) {
// // // //                 setStateIfMounted(() { _selectedSportFilter = newFilterValue; });
// // // //                 _onFilterOrSearchChanged();
// // // //               }
// // // //             },
// // // //             selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// // // //             backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// // // //             labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// // // //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// // // //             padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// // // //             visualDensity: VisualDensity.compact,
// // // //             showCheckmark: false,
// // // //           );
// // // //         },
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildSectionHeader(BuildContext context, String title) {
// // // //     return Padding(padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
// // // //       child: Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
// // // //   }

// // // //   Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg, String emptyMsg, {bool isNearbySection = false}) {
// // // //      if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
// // // //      if (errorMsg != null) return Center(child: Padding(padding: const EdgeInsets.all(20), child: Text(errorMsg, textAlign: TextAlign.center, style: const TextStyle(color: Colors.red, fontSize: 16))));
// // // //      if (venues.isEmpty) return Center(child: Padding(padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0), child: Text(emptyMsg, textAlign: TextAlign.center, style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

// // // //      return GridView.builder(
// // // //        shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// // // //        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
// // // //        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
// // // //            maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
// // // //            mainAxisSpacing: 16.0,
// // // //            crossAxisSpacing: 16.0,
// // // //            childAspectRatio: 0.70
// // // //         ),
// // // //        itemCount: venues.length,
// // // //        itemBuilder: (context, index) {
// // // //          final venue = venues[index];
// // // //          final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
// // // //          return _buildVenueGridCard(venue, isFavorite: isFavorite);
// // // //        },
// // // //      );
// // // //    }

// // // //   Widget _buildBodyContent() {
// // // //      return Column(children: [
// // // //          _buildQuickSportFilters(),
// // // //          Expanded(
// // // //            child: RefreshIndicator(
// // // //              onRefresh: _handleRefresh,
// // // //              child: ListView(
// // // //                padding: EdgeInsets.zero,
// // // //                children: [
// // // //                  if (_isSearchingOrFiltering) ...[
// // // //                    _buildSectionHeader(context,
// // // //                         _searchQuery != null && _searchQuery!.isNotEmpty
// // // //                             ? "Results for \"$_searchQuery\""
// // // //                             : (_selectedCityFilter != null
// // // //                                 ? "Venues in $_selectedCityFilter"
// // // //                                 : (_selectedSportFilter != null ? "Venues for $_selectedSportFilter" : "Filtered Venues")
// // // //                             )
// // // //                     ),
// // // //                    _buildVenueList(_filteredVenues, _isLoadingFilteredVenues, _filteredVenueFetchError, "No venues found for your selection.", isNearbySection: false),
// // // //                  ] else ...[
// // // //                    if (_currentPosition != null || _isLoadingNearbyVenues)
// // // //                        _buildSectionHeader(context, "Venues Near You"),
// // // //                    _buildVenueList(_nearbyVenues, _isLoadingNearbyVenues, _nearbyVenueFetchError, "No venues found nearby. Try exploring other cities or check location permissions.", isNearbySection: true),

// // // //                    const SizedBox(height: 16),
// // // //                    _buildSectionHeader(context, "Explore Venues"),
// // // //                    _buildVenueList(_exploreVenues, _isLoadingExploreVenues, _exploreVenueFetchError, "No venues to explore at the moment.", isNearbySection: false),
// // // //                   ],
// // // //                  const SizedBox(height: 80),
// // // //                ],
// // // //              ),
// // // //            ),
// // // //          ),
// // // //        ]
// // // //      );
// // // //   }

// // // //   Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
// // // //     return Shimmer.fromColors(baseColor: Colors.grey[350]!, highlightColor: Colors.grey[200]!,
// // // //       child: GridView.builder(
// // // //         shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// // // //         padding: const EdgeInsets.all(16.0),
// // // //         gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0, mainAxisSpacing: 16.0, crossAxisSpacing: 16.0, childAspectRatio: 0.70),
// // // //         itemCount: itemCount, itemBuilder: (context, index) => _buildVenueShimmerCard())
// // // //       );
// // // //   }
// // // //   Widget _buildVenueShimmerCard() {
// // // //     return Card(
// // // //       margin: EdgeInsets.zero, elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), clipBehavior: Clip.antiAlias,
// // // //       child: Column(children: [
// // // //         Container(height: 130, width: double.infinity, color: Colors.white),
// // // //         Expanded(child: Padding(padding: const EdgeInsets.all(10.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
// // // //           Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
// // // //             Container(width: double.infinity, height: 18.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// // // //             Container(width: MediaQuery.of(context).size.width * 0.3, height: 14.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// // // //             Container(width: MediaQuery.of(context).size.width * 0.2, height: 12.0, color: Colors.white)]),
// // // //           Container(width: double.infinity, height: 12.0, color: Colors.white)
// // // //           ])))
// // // //       ]));
// // // //   }

// // // //   Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite}) {
// // // //       final String venueId = venue['id'] as String? ?? '';
// // // //       return _VenueCardWidget(
// // // //         key: ValueKey(venueId),
// // // //         venue: venue,
// // // //         isFavorite: isFavorite,
// // // //         onTapCard: () => _navigateToVenueDetail(venue),
// // // //         onTapFavorite: () => _toggleFavorite(venueId, isFavorite, venue),
// // // //       );
// // // //     }

// // // //   Future<void> _toggleFavorite(String venueId, bool currentIsFavorite, Map<String, dynamic> venue) async {
// // // //     if (!mounted) return;
// // // //     final currentUser = _currentUser;
// // // //     if (currentUser == null) {
// // // //       ScaffoldMessenger.of(context).showSnackBar(
// // // //         const SnackBar(content: Text("Please log in to manage favorites."), behavior: SnackBarBehavior.floating, margin: EdgeInsets.all(10)),
// // // //       );
// // // //       return;
// // // //     }
// // // //     if (venueId.isEmpty) return;

// // // //     try {
// // // //       if (!currentIsFavorite) {
// // // //         await _userService.addFavorite(venueId);
// // // //       } else {
// // // //         await _userService.removeFavorite(venueId);
// // // //       }
// // // //     } catch (e) {
// // // //       debugPrint("Error toggling favorite: $e");
// // // //       if (mounted) {
// // // //         ScaffoldMessenger.of(context).showSnackBar(
// // // //           SnackBar(content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"), backgroundColor: Colors.redAccent, behavior: SnackBarBehavior.floating, margin: const EdgeInsets.all(10)),
// // // //         );
// // // //       }
// // // //     }
// // // //   }
// // // // }

// // // // class _VenueCardWidget extends StatefulWidget {
// // // //   final Map<String, dynamic> venue;
// // // //   final bool isFavorite;
// // // //   final VoidCallback onTapCard;
// // // //   final Future<void> Function() onTapFavorite;

// // // //   const _VenueCardWidget({
// // // //     required Key key,
// // // //     required this.venue,
// // // //     required this.isFavorite,
// // // //     required this.onTapCard,
// // // //     required this.onTapFavorite,
// // // //   }) : super(key: key);

// // // //   @override
// // // //   _VenueCardWidgetState createState() => _VenueCardWidgetState();
// // // // }

// // // // class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
// // // //   late AnimationController _favoriteAnimationController;
// // // //   late Animation<double> _favoriteScaleAnimation;

// // // //   @override
// // // //   void initState() {
// // // //     super.initState();
// // // //     _favoriteAnimationController = AnimationController(
// // // //       duration: const Duration(milliseconds: 300),
// // // //       vsync: this,
// // // //     );
// // // //     _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
// // // //       CurvedAnimation(parent: _favoriteAnimationController, curve: Curves.elasticOut, reverseCurve: Curves.easeInCubic),
// // // //     );
// // // //   }

// // // //   @override
// // // //   void didUpdateWidget(_VenueCardWidget oldWidget) {
// // // //     super.didUpdateWidget(oldWidget);
// // // //     if (widget.isFavorite != oldWidget.isFavorite && mounted) {
// // // //       if (widget.isFavorite) {
// // // //         _favoriteAnimationController.forward(from: 0.0).catchError((e) {
// // // //           if (e is! TickerCanceled) { debugPrint("Error playing fav add animation: $e"); }
// // // //         });
// // // //       } else {
// // // //          _favoriteAnimationController.reverse().catchError((e) {
// // // //              if (e is! TickerCanceled) { debugPrint("Error reversing fav remove animation: $e"); }
// // // //          });
// // // //       }
// // // //     }
// // // //   }

// // // //   @override
// // // //   void dispose() {
// // // //     _favoriteAnimationController.dispose();
// // // //     super.dispose();
// // // //   }

// // // //   @override
// // // //   Widget build(BuildContext context) {
// // // //     final ThemeData theme = Theme.of(context);
// // // //     final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
// // // //     final dynamic sportRaw = widget.venue['sportType'];
// // // //     final String sport = (sportRaw is String) ? sportRaw : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
// // // //     final String? imageUrl = widget.venue['imageUrl'] as String?;
// // // //     final String city = widget.venue['city'] as String? ?? '';
// // // //     final String venueId = widget.venue['id'] as String? ?? '';
// // // //     final double? distance = widget.venue['distance'] as double?;
// // // //     final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
// // // //     final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

// // // //     return MouseRegion(
// // // //       cursor: SystemMouseCursors.click,
// // // //       child: Card(
// // // //         margin: EdgeInsets.zero,
// // // //         elevation: 3,
// // // //         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
// // // //         clipBehavior: Clip.antiAlias,
// // // //         child: Column(
// // // //           crossAxisAlignment: CrossAxisAlignment.start,
// // // //           children: [
// // // //             SizedBox(
// // // //               height: 130,
// // // //               width: double.infinity,
// // // //               child: Stack(
// // // //                 children: [
// // // //                   Positioned.fill(
// // // //                     child: InkWell(
// // // //                       onTap: widget.onTapCard,
// // // //                       child: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// // // //                           ? Hero(
// // // //                               tag: 'venue_image_$venueId',
// // // //                               child: Image.network(
// // // //                                 imageUrl, height: 130, width: double.infinity, fit: BoxFit.cover,
// // // //                                 loadingBuilder: (context, child, loadingProgress) =>
// // // //                                     (loadingProgress == null) ? child : Container(height: 130, color: Colors.grey[200], child: Center(child: CircularProgressIndicator(strokeWidth: 2, value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null))),
// // // //                                 errorBuilder: (context, error, stackTrace) =>
// // // //                                     Container(height: 130, color: Colors.grey[200], child: Center(child: Icon(Icons.broken_image_outlined, color: Colors.grey[400], size: 40))),
// // // //                               ),
// // // //                             )
// // // //                           : Container(height: 130, color: theme.primaryColor.withOpacity(0.08), child: Center(child: Icon(Icons.sports_soccer_outlined, size: 50, color: theme.primaryColor.withOpacity(0.7)))),
// // // //                     ),
// // // //                   ),
// // // //                   Positioned(
// // // //                     top: 6, right: 6,
// // // //                     child: Material(
// // // //                       color: Colors.black.withOpacity(0.45), shape: const CircleBorder(),
// // // //                       child: InkWell(
// // // //                         borderRadius: BorderRadius.circular(20),
// // // //                         onTap: widget.onTapFavorite,
// // // //                         child: Padding(
// // // //                           padding: const EdgeInsets.all(7.0),
// // // //                           child: ScaleTransition(
// // // //                             scale: _favoriteScaleAnimation,
// // // //                             child: Icon(
// // // //                               widget.isFavorite ? Icons.favorite_rounded : Icons.favorite_border_rounded,
// // // //                               color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
// // // //                               size: 22,
// // // //                             ),
// // // //                           ),
// // // //                         ),
// // // //                       ),
// // // //                     ),
// // // //                   ),
// // // //                   if (distance != null)
// // // //                     Positioned(
// // // //                       bottom: 6, left: 6,
// // // //                       child: Container(
// // // //                         padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
// // // //                         decoration: BoxDecoration(color: Colors.black.withOpacity(0.6), borderRadius: BorderRadius.circular(4)),
// // // //                         child: Text('${distance.toStringAsFixed(1)} km', style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.w500)),
// // // //                       ),
// // // //                     ),
// // // //                 ],
// // // //               ),
// // // //             ),
// // // //             Expanded(
// // // //               child: InkWell(
// // // //                 onTap: widget.onTapCard,
// // // //                 child: Padding(
// // // //                   padding: const EdgeInsets.all(10.0),
// // // //                   child: Column(
// // // //                     crossAxisAlignment: CrossAxisAlignment.start,
// // // //                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
// // // //                     children: [
// // // //                       Column(
// // // //                         crossAxisAlignment: CrossAxisAlignment.start,
// // // //                         mainAxisSize: MainAxisSize.min,
// // // //                         children: [
// // // //                           Text(name, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 2, overflow: TextOverflow.ellipsis),
// // // //                           const SizedBox(height: 4),
// // // //                           Row(children: [
// // // //                             Icon(Icons.sports_kabaddi_outlined, size: 14, color: theme.colorScheme.secondary),
// // // //                             const SizedBox(width: 4),
// // // //                             Expanded(child: Text(sport, style: theme.textTheme.bodyMedium?.copyWith(color: Colors.grey[800], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// // // //                           ]),
// // // //                           if (reviewCount > 0)
// // // //                             Padding(
// // // //                                padding: const EdgeInsets.only(top: 5.0),
// // // //                                child: Row(children: [
// // // //                                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// // // //                                 const SizedBox(width: 4),
// // // //                                 Text(averageRating.toStringAsFixed(1), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
// // // //                                 const SizedBox(width: 4),
// // // //                                 Text("($reviewCount reviews)", style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
// // // //                               ]),
// // // //                              ),
// // // //                         ],
// // // //                       ),
// // // //                       Row(
// // // //                         children: [
// // // //                           Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
// // // //                           const SizedBox(width: 4),
// // // //                           Expanded(child: Text(city, style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[700], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// // // //                         ],
// // // //                       ),
// // // //                     ],
// // // //                   ),
// // // //                 ),
// // // //               ),
// // // //             ),
// // // //           ],
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }
// // // // }

// // // //-----------search issue resolved------------------
// // import 'package:flutter/material.dart';
// // import 'package:firebase_auth/firebase_auth.dart';
// // import 'package:geolocator/geolocator.dart';
// // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // import 'package:mm_associates/features/home/screens/venue_form.dart';
// // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // import 'package:mm_associates/features/user/services/user_service.dart';
// // import 'package:mm_associates/core/services/location_service.dart';
// // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // import 'venue_detail_screen.dart';
// // import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
// // import 'dart:async';
// // import 'package:shimmer/shimmer.dart';
// // import 'city_selection_screen.dart' show CitySelectionScreen, CityInfo, kAppAllCities;
// // import 'package:mm_associates/features/home/widgets/home_search_components.dart';

// // class HomeScreen extends StatefulWidget {
// //   final bool showAddVenueButton;

// //   const HomeScreen({
// //     super.key,
// //     required this.showAddVenueButton,
// //   });

// //   @override
// //   State<HomeScreen> createState() => _HomeScreenState();
// // }

// // class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
// //   final AuthService _authService = AuthService();
// //   final FirestoreService _firestoreService = FirestoreService();
// //   final LocationService _locationService = LocationService();
// //   final UserService _userService = UserService();

// //   // --- State Variables ---
// //   String? _searchQuery;
// //   String? _selectedCityFilter;
// //   IconData? _selectedCityIcon;
// //   String? _selectedSportFilter;

// //   User? _currentUser;
// //   String? _userName;
// //   String? _userProfilePicUrl;
// //   bool _isLoadingName = true;

// //   List<Map<String, dynamic>> _filteredVenues = [];
// //   bool _isLoadingFilteredVenues = true;
// //   String? _filteredVenueFetchError;

// //   List<Map<String, dynamic>> _nearbyVenues = [];
// //   bool _isLoadingNearbyVenues = true;
// //   String? _nearbyVenueFetchError;

// //   List<Map<String, dynamic>> _exploreVenues = [];
// //   bool _isLoadingExploreVenues = true;
// //   String? _exploreVenueFetchError;

// //   Position? _currentPosition;
// //   bool _isFetchingLocation = false;
// //   String? _locationStatusMessage;

// //   // Favorites State
// //   List<String> _favoriteVenueIds = [];
// //   bool _isLoadingFavorites = true;
// //   Stream<List<String>>? _favoritesStream;
// //   StreamSubscription<List<String>>? _favoritesSubscription;

// //   final List<String> _supportedCities = ['Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'];
// //   final List<String> _quickSportFilters = ['Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'];

// //   bool get _isSearchingOrFiltering => (_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null;

// //   @override
// //   void initState() {
// //     super.initState();
// //     _currentUser = FirebaseAuth.instance.currentUser;
// //     _initializeScreen();
// //     _setupFavoritesStream();
// //     _updateSelectedCityIconFromFilter();
// //   }

// //   @override
// //   void dispose() {
// //     _favoritesSubscription?.cancel();
// //     super.dispose();
// //   }

// //   void setStateIfMounted(VoidCallback fn) {
// //     if (mounted) setState(fn);
// //   }

// //   // --- Core Logic & Data Fetching ---

// //   Future<void> _initializeScreen() async {
// //     await _fetchUserNameAndPic();
// //     await _fetchPrimaryVenueData();
// //   }

// //   /// **[CORRECTED & SIMPLIFIED]** This is the single, central function to handle any change
// //   /// that requires a data refresh (search, city filter, sport filter).
// //   void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
// //     if (!mounted) return;

// //     // A state change has occurred (e.g., sport filter selected, city changed, or search submitted).
// //     // First, update the search query state if a new one was provided.
// //     setState(() {
// //       _searchQuery = (explicitSearchQuery?.trim().isEmpty ?? true) ? null : explicitSearchQuery!.trim();
// //     });

// //     // Now, based on the *updated* state, decide which view to fetch data for.
// //     // The `_isSearchingOrFiltering` getter will now be accurate.
// //     if (_isSearchingOrFiltering) {
// //       // If any filter or search query exists, fetch the filtered results.
// //       _fetchVenuesForFilterOrSearch();
// //     } else {
// //       // If all filters and the search query are clear, fetch the default view.
// //       // This path is now correctly taken when the last filter is removed or search is cleared.
// //       _fetchPrimaryVenueData();
// //     }
// //   }

// //   /// Fetches venues for the filtered/search view.
// //   Future<void> _fetchVenuesForFilterOrSearch() async {
// //     if (!mounted) return;
// //     setStateIfMounted(() {
// //       _isLoadingFilteredVenues = true;
// //       _filteredVenueFetchError = null;
// //       _filteredVenues = [];
// //     });

// //     try {
// //       debugPrint("Fetching FILTERED/SEARCH venues: City: $_selectedCityFilter, Sport: $_selectedSportFilter, Search: $_searchQuery");
// //       final venuesData = await _firestoreService.getVenues(
// //         userLocation: _currentPosition,
// //         radiusInKm: _selectedCityFilter != null ? null : (_currentPosition != null ? 50.0 : null),
// //         cityFilter: _selectedCityFilter,
// //         searchQuery: _searchQuery,
// //         sportFilter: _selectedSportFilter,
// //       );
// //       if (!mounted) return;
// //       setStateIfMounted(() {
// //         _filteredVenues = venuesData;
// //       });
// //     } catch (e) {
// //       debugPrint("Error fetching filtered/search venues: $e");
// //       if (!mounted) return;
// //       setStateIfMounted(() => _filteredVenueFetchError = "Could not load venues: ${e.toString().replaceFirst('Exception: ', '')}");
// //     } finally {
// //       if (!mounted) return;
// //       setStateIfMounted(() => _isLoadingFilteredVenues = false);
// //     }
// //   }

// //   /// Fetches venues for the default home screen view (Nearby and Explore).
// //   Future<void> _fetchPrimaryVenueData() async {
// //     if (!mounted) return;
// //     setStateIfMounted(() {
// //       _isFetchingLocation = true;
// //       _isLoadingNearbyVenues = true;
// //       _isLoadingExploreVenues = true;
// //       _locationStatusMessage = 'Fetching your location...';
// //       _nearbyVenues = [];
// //       _exploreVenues = [];
// //       _nearbyVenueFetchError = null;
// //       _exploreVenueFetchError = null;
// //     });
    
// //     _currentPosition = await _locationService.getCurrentLocation();
    
// //     if (!mounted) return;
    
// //     setStateIfMounted(() {
// //       _isFetchingLocation = false;
// //       _locationStatusMessage = _currentPosition != null ? 'Location acquired.' : 'Could not get location.';
// //     });

// //     // Fetch both lists in parallel and update the state when they complete.
// //     await Future.wait([
// //       _fetchNearbyVenuesScoped(),
// //       _fetchExploreVenuesFromOtherCities(),
// //     ]);
// //   }

// //   Future<void> _handleRefresh() async {
// //     if (mounted) {
// //       // Reset filters and search query
// //       setState(() {
// //         _searchQuery = null;
// //         _selectedSportFilter = null;
// //         // NOTE: We don't clear the city filter on pull-to-refresh, which is standard UX.
// //       });
// //       // Trigger a fetch with the new (potentially cleared) state.
// //       _onFilterOrSearchChanged();
// //     }
// //   }
  
// //   // --- The rest of the file remains the same ---
// //   // --- All helper methods and build methods are unchanged ---

// //   void _updateSelectedCityIconFromFilter() {
// //     if (_selectedCityFilter == null) {
// //       _selectedCityIcon = Icons.my_location;
// //     } else {
// //       try {
// //         final cityInfo = kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
// //         _selectedCityIcon = cityInfo.icon;
// //       } catch (e) {
// //         _selectedCityIcon = Icons.location_city_outlined;
// //       }
// //     }
// //   }

// //   void _setupFavoritesStream() {
// //     _favoritesSubscription?.cancel();
// //     if (_currentUser != null) {
// //         _favoritesStream = _userService.getFavoriteVenueIdsStream();
// //         _favoritesSubscription = _favoritesStream?.listen(
// //           (favoriteIds) {
// //             if (mounted) {
// //               final newIdsSet = favoriteIds.toSet();
// //               final currentIdsSet = _favoriteVenueIds.toSet();
// //               if (newIdsSet.difference(currentIdsSet).isNotEmpty || currentIdsSet.difference(newIdsSet).isNotEmpty) {
// //                 setStateIfMounted(() => _favoriteVenueIds = favoriteIds);
// //               }
// //             }
// //           },
// //           onError: (error) { debugPrint("Error in favorites stream: $error"); }
// //         );
// //         if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);
// //     } else {
// //       if (mounted) {
// //          setStateIfMounted(() { _favoriteVenueIds = []; _isLoadingFavorites = false; _favoritesStream = null; _favoritesSubscription = null; });
// //       }
// //     }
// //   }

// //   @override
// //   void didChangeDependencies() {
// //     super.didChangeDependencies();
// //     final currentAuthUser = FirebaseAuth.instance.currentUser;
// //     if (currentAuthUser != _currentUser) {
// //       _currentUser = currentAuthUser;
// //       _initializeScreen();
// //       _setupFavoritesStream();
// //       if (mounted) setStateIfMounted(_updateSelectedCityIconFromFilter);
// //     }
// //   }

// //   Future<void> _fetchNearbyVenuesScoped() async {
// //     if (!mounted) return;
// //     if (_currentPosition == null) {
// //       if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = false; _nearbyVenueFetchError = "Location not available."; _nearbyVenues = []; });
// //       return;
// //     }
// //     if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = true; _nearbyVenueFetchError = null; _nearbyVenues = []; });
// //     try {
// //       final venuesData = await _firestoreService.getVenues(userLocation: _currentPosition, radiusInKm: 25.0);
// //       if (!mounted) return;
// //       setStateIfMounted(() => _nearbyVenues = venuesData);
// //     } catch (e) {
// //       if (!mounted) return;
// //       setStateIfMounted(() => _nearbyVenueFetchError = "Could not load nearby venues.");
// //     } finally {
// //       if (!mounted) return;
// //       setStateIfMounted(() => _isLoadingNearbyVenues = false);
// //     }
// //   }

// //   Future<void> _fetchExploreVenuesFromOtherCities() async {
// //     if (!mounted) return;
// //     setStateIfMounted(() { _isLoadingExploreVenues = true; _exploreVenueFetchError = null; _exploreVenues = [];});
// //     List<Map<String, dynamic>> allExploreVenues = [];
// //     try {
// //       for (String city in _supportedCities) {
// //         final cityVenues = await _firestoreService.getVenues(cityFilter: city, userLocation: _currentPosition, limit: 5);
// //         allExploreVenues.addAll(cityVenues);
// //         if (!mounted) return;
// //       }
// //       final uniqueExploreVenues = allExploreVenues.fold<Map<String, Map<String, dynamic>>>({}, (map, venue) {
// //           final String? venueId = venue['id'] as String?;
// //           if (venueId != null) map[venueId] = venue;
// //           return map;
// //         }).values.toList();

// //       if (_currentPosition != null) {
// //         uniqueExploreVenues.sort((a, b) {
// //           final distA = a['distance'] as double?; final distB = b['distance'] as double?;
// //           if (distA != null && distB != null) return distA.compareTo(distB);
// //           if (distA != null) return -1;
// //           if (distB != null) return 1;
// //           return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
// //         });
// //       } else {
// //          uniqueExploreVenues.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
// //       }
// //       if(!mounted) return;
// //       setStateIfMounted(() => _exploreVenues = uniqueExploreVenues.take(15).toList());
// //     } catch (e) {
// //       if (!mounted) return;
// //       setStateIfMounted(() => _exploreVenueFetchError = "Could not load explore venues.");
// //     } finally {
// //       if (!mounted) return;
// //       setStateIfMounted(() => _isLoadingExploreVenues = false);
// //     }
// //   }

// //   Future<void> _fetchUserNameAndPic() async {
// //     if (!mounted) return;
// //     _setLoadingName(true); final currentUser = _currentUser;
// //     if (currentUser == null) { if(mounted) _updateUserNameAndPic('Guest', null); _setLoadingName(false); return; }
// //     try {
// //       final userData = await _userService.getUserProfileData();
// //       if (!mounted) return;
// //       final fetchedName = userData?['name'] as String? ?? currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// //       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
// //       _updateUserNameAndPic(fetchedName, fetchedPicUrl);
// //     } catch (e) {
// //       if (!mounted) return;
// //       final fallbackName = currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// //       _updateUserNameAndPic(fallbackName, null);
// //     } finally { if(mounted) _setLoadingName(false); }
// //   }

// //   void _setLoadingName(bool isLoading) => {if(mounted) setStateIfMounted(() => _isLoadingName = isLoading)};
// //   void _updateUserNameAndPic(String name, String? picUrl) => {if(mounted) setStateIfMounted(() { _userName = name; _userProfilePicUrl = picUrl; })};

// //   void _navigateToVenueDetail(Map<String, dynamic> venue) {
// //     if (!context.mounted) return;
// //     Navigator.push(context, MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venue['id'] as String, initialVenueData: venue)));
// //   }

// //   void _openSearchMobile() async {
// //      if (!context.mounted) return;
// //      final String? submittedQuery = await showSearch<String?>(
// //         context: context,
// //         delegate: VenueSearchDelegate(
// //             firestoreService: _firestoreService,
// //             initialCityFilter: _selectedCityFilter,
// //         )
// //     );
// //     _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
// //   }

// //   Future<void> _openCitySelectionScreen() async {
// //     if (!context.mounted) return;
// //     final String? newSelectedCityName = await Navigator.push<String?>(
// //       context,
// //       MaterialPageRoute(builder: (context) => CitySelectionScreen(currentSelectedCity: _selectedCityFilter)),
// //     );

// //     if (mounted && newSelectedCityName != _selectedCityFilter) {
// //       setStateIfMounted(() {
// //         _selectedCityFilter = newSelectedCityName; 
// //         _updateSelectedCityIconFromFilter(); 
// //       });
// //       _onFilterOrSearchChanged(); 
// //     }
// //   }
  
// //   @override
// //   Widget build(BuildContext context) {
// //     final theme = Theme.of(context);
// //     final appBarBackgroundColor = theme.appBarTheme.backgroundColor ?? theme.primaryColor;
// //     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ?? theme.appBarTheme.iconTheme?.color ?? (kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white);
// //     final bool isLoggedIn = _currentUser != null;

// //     return Scaffold(
// //       appBar: AppBar(
// //         automaticallyImplyLeading: false,
// //         title: kIsWeb ? _buildWebAppBarTitle(context) : _buildMobileAppBarTitle(context, theme),
// //         actions: kIsWeb ? _buildWebAppBarActions(context, isLoggedIn, actionsIconColor) : _buildMobileAppBarActions(context, isLoggedIn, actionsIconColor),
// //         backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
// //         elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
// //         iconTheme: theme.iconTheme.copyWith(color: kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white),
// //         actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
// //         titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ?? TextStyle(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white, fontSize: 20, fontWeight: FontWeight.w500),
// //       ),
// //       floatingActionButton: widget.showAddVenueButton
// //           ? FloatingActionButton.extended(
// //               onPressed: () {
// //                 Navigator.push(
// //                   context,
// //                   MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
// //                 ).then((result) {
// //                   if (result == true && mounted) {
// //                     _handleRefresh();
// //                     ScaffoldMessenger.of(context).showSnackBar(
// //                       const SnackBar(content: Text("Venue list updated."), backgroundColor: Colors.blueAccent),
// //                     );
// //                   }
// //                 });
// //               },
// //               icon: const Icon(Icons.add_location_alt_outlined),
// //               label: const Text("Add Venue"),
// //               tooltip: 'Add New Venue',
// //             )
// //           : null,
// //       floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
// //       body: _buildBodyContent(),
// //     );
// //   }

// //   Widget _buildWebAppBarTitle(BuildContext context) {
// //     final theme = Theme.of(context);
// //     final currentUser = _currentUser;
// //     double screenWidth = MediaQuery.of(context).size.width;
// //     double leadingWidth = 150 + (_userName != null ? 100 : 0);
// //     double searchWidthFraction = 0.4;
// //     double minSearchWidth = 200;
// //     double maxSearchWidth = 500;
// //     double actionsWidth = 80 + (_currentUser != null ? 120 : 0);
// //     double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
// //     double calculatedSearchWidth = (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);
// //     double spacerFlexFactor = (availableWidth > calculatedSearchWidth + 40)
// //         ? (availableWidth - calculatedSearchWidth) / 2 / availableWidth
// //         : 0.05;
// //     int searchFlex = (searchWidthFraction * 100).toInt();
// //     int spacerFlex = (spacerFlexFactor * 100).toInt().clamp(5, 50);

// //     return Row(children: [
// //       Text('MM Associates', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
// //       const SizedBox(width: 24),
// //       if (_isLoadingName && currentUser != null)
// //         const Padding(padding: EdgeInsets.only(right: 16.0), child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))
// //       else if (_userName != null && currentUser != null)
// //         Padding(
// //           padding: const EdgeInsets.only(right: 16.0),
// //           child: Text('Hi, ${_userName!.split(' ')[0]}!', style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: theme.textTheme.bodyLarge?.color), overflow: TextOverflow.ellipsis)
// //         ),
// //       Spacer(flex: spacerFlex),
// //       Expanded(
// //         flex: searchFlex,
// //         child: Container(
// //           constraints: BoxConstraints(maxWidth: maxSearchWidth),
// //           child: WebSearchBar(
// //             key: ValueKey(_searchQuery ?? 'initial'),
// //             initialValue: _searchQuery ?? '',
// //             cityFilter: _selectedCityFilter,
// //             firestoreService: _firestoreService,
// //             onSearchSubmitted: (query) {
// //               _onFilterOrSearchChanged(explicitSearchQuery: query);
// //             },
// //             onSuggestionSelected: (suggestionName) {
// //               _onFilterOrSearchChanged(explicitSearchQuery: suggestionName);
// //             },
// //             onClear: () {
// //               _onFilterOrSearchChanged(explicitSearchQuery: null);
// //             },
// //           ),
// //         ),
// //       ),
// //       Spacer(flex: spacerFlex),
// //     ]);
// //   }
  
// //   List<Widget> _buildMobileAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// //     final String cityNameText = _selectedCityFilter ?? 'Near Me';
// //     final double textSize = 10.0; 

// //     return [
// //       IconButton(
// //         icon: Icon(Icons.search_outlined, color: iconColor),
// //         tooltip: 'Search Venues',
// //         onPressed: _openSearchMobile,
// //         padding: const EdgeInsets.symmetric(horizontal: 8),
// //         constraints: const BoxConstraints(),
// //       ),
// //       Tooltip( 
// //         message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// //         child: IconButton(
// //           icon: Column(
// //             mainAxisAlignment: MainAxisAlignment.center,
// //             mainAxisSize: MainAxisSize.min,
// //             children: [
// //               Icon(
// //                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// //                 color: iconColor,
// //                 size: 24,
// //               ),
// //               const SizedBox(height: 2), 
// //               Text(
// //                 cityNameText,
// //                 style: TextStyle(
// //                   color: iconColor,
// //                   fontSize: textSize,
// //                   fontWeight: FontWeight.w500,
// //                 ),
// //                 overflow: TextOverflow.ellipsis,
// //                 maxLines: 1,
// //               ),
// //             ],
// //           ),
// //           onPressed: _openCitySelectionScreen,
// //           padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0),
// //           constraints: const BoxConstraints(),
// //         ),
// //       ),
// //       if (isLoggedIn)
// //         IconButton(
// //           icon: Icon(Icons.person_outline_rounded, color: iconColor),
// //           tooltip: 'My Profile',
// //           onPressed: () {
// //             if (!context.mounted) return;
// //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// //                 .then((_) {
// //               if (mounted) _fetchUserNameAndPic();
// //             });
// //           },
// //           padding: const EdgeInsets.symmetric(horizontal: 8),
// //           constraints: const BoxConstraints(),
// //         ),
// //     ];
// //   }
  
// //   Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
// //     final titleStyle = theme.appBarTheme.titleTextStyle ?? theme.primaryTextTheme.titleLarge ?? const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
// //     final currentUser = _currentUser;
// //     return Row(children: [
// //         if (currentUser != null)
// //           GestureDetector(
// //             onTap: () {
// //               if (!context.mounted) return;
// //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// //                   .then((_) { if (mounted) _fetchUserNameAndPic(); });
// //             },
// //             child: Tooltip(
// //               message: "My Profile",
// //               child: Padding(
// //                 padding: const EdgeInsets.only(right: 10.0),
// //                 child: CircleAvatar(
// //                   radius: 18,
// //                   backgroundColor: Colors.white24,
// //                   backgroundImage: _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty ? NetworkImage(_userProfilePicUrl!) : null,
// //                   child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty ? Icon(Icons.person_outline, size: 20, color: Colors.white.withOpacity(0.8)) : null
// //                 )
// //               ),
// //             ),
// //           ),
// //         if (_isLoadingName && currentUser != null)
// //           const Padding(
// //             padding: EdgeInsets.only(left: 6.0),
// //             child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(Colors.white70)))
// //           )
// //         else if (_userName != null && currentUser != null)
// //           Expanded(
// //             child: Padding(
// //                padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
// //               child: Text(
// //                 'Hi, ${_userName!.split(' ')[0]}!',
// //                 style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
// //                 overflow: TextOverflow.ellipsis
// //               )
// //             )
// //           )
// //         else
// //           Text('MM Associates', style: titleStyle),
// //       ]
// //     );
// //   }

// //   List<Widget> _buildWebAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
// //     final String cityNameText = _selectedCityFilter ?? 'Near Me';
// //     final double textSize = 10.0;

// //     return [
// //       Tooltip(
// //         message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
// //         child: IconButton(
// //           icon: Column(
// //             mainAxisAlignment: MainAxisAlignment.center,
// //             mainAxisSize: MainAxisSize.min,
// //             children: [
// //               Icon(
// //                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
// //                 color: iconColor,
// //                 size: 24,
// //               ),
// //               const SizedBox(height: 2),
// //               Text(
// //                 cityNameText,
// //                 style: TextStyle(
// //                   color: iconColor,
// //                   fontSize: textSize,
// //                   fontWeight: FontWeight.w500,
// //                 ),
// //                 overflow: TextOverflow.ellipsis,
// //                 maxLines: 1,
// //               ),
// //             ],
// //           ),
// //           onPressed: _openCitySelectionScreen,
// //           padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 4.0),
// //           constraints: const BoxConstraints(),
// //         ),
// //       ),
// //       if (isLoggedIn)
// //         Tooltip(
// //           message: 'My Profile',
// //           child: IconButton(
// //             icon: Icon(Icons.person_outline_rounded, color: iconColor),
// //             onPressed: () {
// //               if (!context.mounted) return;
// //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
// //                   .then((_) {
// //                 if (mounted) _fetchUserNameAndPic();
// //               });
// //             },
// //             padding: const EdgeInsets.symmetric(horizontal: 16),
// //             constraints: const BoxConstraints(),
// //           ),
// //         ),
// //       const SizedBox(width: 8)
// //     ];
// //   }

// //   Widget _buildQuickSportFilters() {
// //     final theme = Theme.of(context);
// //     return Container(
// //       height: 55,
// //       color: theme.cardColor,
// //       child: ListView.separated(
// //         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
// //         scrollDirection: Axis.horizontal,
// //         itemCount: _quickSportFilters.length + 1,
// //         separatorBuilder: (context, index) => const SizedBox(width: 10),
// //         itemBuilder: (context, index) {
// //           if (index == 0) {
// //             final bool isSelected = _selectedSportFilter == null;
// //             return ChoiceChip(
// //               label: const Text('All Sports'),
// //               selected: isSelected,
// //               onSelected: (bool nowSelected) {
// //                 if (nowSelected && _selectedSportFilter != null) {
// //                     setStateIfMounted(() => _selectedSportFilter = null);
// //                     _onFilterOrSearchChanged();
// //                 }
// //               },
// //               selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// //               backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// //               labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// //               shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// //               padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// //               visualDensity: VisualDensity.compact,
// //                showCheckmark: false,
// //             );
// //           }
// //           final sport = _quickSportFilters[index - 1];
// //           final bool isSelected = _selectedSportFilter == sport;
// //           return ChoiceChip(
// //             label: Text(sport),
// //             selected: isSelected,
// //             onSelected: (bool isNowSelected) {
// //               final newFilter = isNowSelected ? sport : null;
// //               if (_selectedSportFilter != newFilter) {
// //                 setStateIfMounted(() => _selectedSportFilter = newFilter);
// //                 _onFilterOrSearchChanged();
// //               }
// //             },
// //             selectedColor: theme.colorScheme.primary.withOpacity(0.2),
// //             backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
// //             labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
// //             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
// //             padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
// //             visualDensity: VisualDensity.compact,
// //             showCheckmark: false,
// //           );
// //         },
// //       ),
// //     );
// //   }

// //   Widget _buildBodyContent() {
// //      return Column(children: [
// //          _buildQuickSportFilters(),
// //          Expanded(
// //            child: RefreshIndicator(
// //              onRefresh: _handleRefresh,
// //              child: ListView(
// //                padding: EdgeInsets.zero,
// //                children: [
// //                  if (_isSearchingOrFiltering) ...[
// //                    _buildSectionHeader(context,
// //                         _searchQuery != null && _searchQuery!.isNotEmpty
// //                             ? "Results for \"$_searchQuery\""
// //                             : (_selectedCityFilter != null
// //                                 ? "Venues in $_selectedCityFilter"
// //                                 : (_selectedSportFilter != null ? "Venues for $_selectedSportFilter" : "Filtered Venues")
// //                             )
// //                     ),
// //                    _buildVenueList(_filteredVenues, _isLoadingFilteredVenues, _filteredVenueFetchError, "No venues found for your selection.", isNearbySection: false),
// //                  ] else ...[
// //                    if (_currentPosition != null || _isLoadingNearbyVenues)
// //                        _buildSectionHeader(context, "Venues Near You"),
// //                    _buildVenueList(_nearbyVenues, _isLoadingNearbyVenues, _nearbyVenueFetchError, "No venues found nearby. Try exploring other cities.", isNearbySection: true),
// //                    const SizedBox(height: 16),
// //                    _buildSectionHeader(context, "Explore Venues"),
// //                    _buildVenueList(_exploreVenues, _isLoadingExploreVenues, _exploreVenueFetchError, "No venues to explore at the moment.", isNearbySection: false),
// //                   ],
// //                  const SizedBox(height: 80),
// //                ],
// //              ),
// //            ),
// //          ),
// //        ]
// //      );
// //   }
  
// //   Widget _buildSectionHeader(BuildContext context, String title) {
// //     return Padding(padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
// //       child: Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
// //   }

// //   Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg, String emptyMsg, {bool isNearbySection = false}) {
// //      if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
// //      if (errorMsg != null) return Center(child: Padding(padding: const EdgeInsets.all(20), child: Text(errorMsg, textAlign: TextAlign.center, style: const TextStyle(color: Colors.red, fontSize: 16))));
// //      if (venues.isEmpty) return Center(child: Padding(padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0), child: Text(emptyMsg, textAlign: TextAlign.center, style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

// //      return GridView.builder(
// //        shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// //        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
// //        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
// //            maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
// //            mainAxisSpacing: 16.0,
// //            crossAxisSpacing: 16.0,
// //            childAspectRatio: 0.70
// //         ),
// //        itemCount: venues.length,
// //        itemBuilder: (context, index) {
// //          final venue = venues[index];
// //          final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
// //          return _buildVenueGridCard(venue, isFavorite: isFavorite);
// //        },
// //      );
// //    }

// //   Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
// //     return Shimmer.fromColors(baseColor: Colors.grey[350]!, highlightColor: Colors.grey[200]!,
// //       child: GridView.builder(
// //         shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
// //         padding: const EdgeInsets.all(16.0),
// //         gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0, mainAxisSpacing: 16.0, crossAxisSpacing: 16.0, childAspectRatio: 0.70),
// //         itemCount: itemCount, itemBuilder: (context, index) => _buildVenueShimmerCard())
// //       );
// //   }
// //   Widget _buildVenueShimmerCard() {
// //     return Card(
// //       margin: EdgeInsets.zero, elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), clipBehavior: Clip.antiAlias,
// //       child: Column(children: [
// //         Container(height: 130, width: double.infinity, color: Colors.white),
// //         Expanded(child: Padding(padding: const EdgeInsets.all(10.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
// //           Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
// //             Container(width: double.infinity, height: 18.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// //             Container(width: MediaQuery.of(context).size.width * 0.3, height: 14.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
// //             Container(width: MediaQuery.of(context).size.width * 0.2, height: 12.0, color: Colors.white)]),
// //           Container(width: double.infinity, height: 12.0, color: Colors.white)
// //           ])))
// //       ]));
// //   }

// //   Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite}) {
// //       final String venueId = venue['id'] as String? ?? '';
// //       return _VenueCardWidget(
// //         key: ValueKey(venueId),
// //         venue: venue,
// //         isFavorite: isFavorite,
// //         onTapCard: () => _navigateToVenueDetail(venue),
// //         onTapFavorite: () => _toggleFavorite(venueId, isFavorite),
// //       );
// //     }

// //   Future<void> _toggleFavorite(String venueId, bool currentIsFavorite) async {
// //     if (!mounted) return;
// //     final currentUser = _currentUser;
// //     if (currentUser == null) {
// //       ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Please log in to manage favorites.")));
// //       return;
// //     }
// //     if (venueId.isEmpty) return;
// //     try {
// //       if (!currentIsFavorite) {
// //         await _userService.addFavorite(venueId);
// //       } else {
// //         await _userService.removeFavorite(venueId);
// //       }
// //     } catch (e) {
// //       if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error updating favorites: ${e.toString()}")));
// //     }
// //   }
// // }

// // class _VenueCardWidget extends StatefulWidget {
// //   final Map<String, dynamic> venue;
// //   final bool isFavorite;
// //   final VoidCallback onTapCard;
// //   final Future<void> Function() onTapFavorite;

// //   const _VenueCardWidget({
// //     required Key key,
// //     required this.venue,
// //     required this.isFavorite,
// //     required this.onTapCard,
// //     required this.onTapFavorite,
// //   }) : super(key: key);

// //   @override
// //   _VenueCardWidgetState createState() => _VenueCardWidgetState();
// // }

// // class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
// //   late AnimationController _favoriteAnimationController;
// //   late Animation<double> _favoriteScaleAnimation;

// //   @override
// //   void initState() {
// //     super.initState();
// //     _favoriteAnimationController = AnimationController(
// //       duration: const Duration(milliseconds: 300),
// //       vsync: this,
// //     );
// //     _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
// //       CurvedAnimation(parent: _favoriteAnimationController, curve: Curves.elasticOut, reverseCurve: Curves.easeInCubic),
// //     );
// //   }

// //   @override
// //   void didUpdateWidget(_VenueCardWidget oldWidget) {
// //     super.didUpdateWidget(oldWidget);
// //     if (widget.isFavorite != oldWidget.isFavorite && mounted) {
// //       if (widget.isFavorite) {
// //         _favoriteAnimationController.forward(from: 0.0).catchError((e) { if (e is! TickerCanceled) debugPrint("Error playing fav animation: $e"); });
// //       } else {
// //          _favoriteAnimationController.reverse().catchError((e) { if (e is! TickerCanceled) debugPrint("Error reversing fav animation: $e"); });
// //       }
// //     }
// //   }

// //   @override
// //   void dispose() {
// //     _favoriteAnimationController.dispose();
// //     super.dispose();
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final ThemeData theme = Theme.of(context);
// //     final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
// //     final dynamic sportRaw = widget.venue['sportType'];
// //     final String sport = (sportRaw is String) ? sportRaw : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
// //     final String? imageUrl = widget.venue['imageUrl'] as String?;
// //     final String city = widget.venue['city'] as String? ?? '';
// //     final String venueId = widget.venue['id'] as String? ?? '';
// //     final double? distance = widget.venue['distance'] as double?;
// //     final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
// //     final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

// //     return MouseRegion(
// //       cursor: SystemMouseCursors.click,
// //       child: Card(
// //         margin: EdgeInsets.zero,
// //         elevation: 3,
// //         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
// //         clipBehavior: Clip.antiAlias,
// //         child: Column(
// //           crossAxisAlignment: CrossAxisAlignment.start,
// //           children: [
// //             SizedBox(
// //               height: 130,
// //               width: double.infinity,
// //               child: Stack(
// //                 children: [
// //                   Positioned.fill(
// //                     child: InkWell(
// //                       onTap: widget.onTapCard,
// //                       child: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// //                           ? Hero(
// //                               tag: 'venue_image_$venueId',
// //                               child: Image.network(
// //                                 imageUrl, height: 130, width: double.infinity, fit: BoxFit.cover,
// //                                 loadingBuilder: (context, child, loadingProgress) => (loadingProgress == null) ? child : Container(height: 130, color: Colors.grey[200], child: Center(child: CircularProgressIndicator(strokeWidth: 2, value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null))),
// //                                 errorBuilder: (context, error, stackTrace) => Container(height: 130, color: Colors.grey[200], child: Center(child: Icon(Icons.broken_image_outlined, color: Colors.grey[400], size: 40))),
// //                               ),
// //                             )
// //                           : Container(height: 130, color: theme.primaryColor.withOpacity(0.08), child: Center(child: Icon(Icons.sports_soccer_outlined, size: 50, color: theme.primaryColor.withOpacity(0.7)))),
// //                     ),
// //                   ),
// //                   Positioned(
// //                     top: 6, right: 6,
// //                     child: Material(
// //                       color: Colors.black.withOpacity(0.45), shape: const CircleBorder(),
// //                       child: InkWell(
// //                         borderRadius: BorderRadius.circular(20),
// //                         onTap: widget.onTapFavorite,
// //                         child: Padding(
// //                           padding: const EdgeInsets.all(7.0),
// //                           child: ScaleTransition(
// //                             scale: _favoriteScaleAnimation,
// //                             child: Icon(
// //                               widget.isFavorite ? Icons.favorite_rounded : Icons.favorite_border_rounded,
// //                               color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
// //                               size: 22,
// //                             ),
// //                           ),
// //                         ),
// //                       ),
// //                     ),
// //                   ),
// //                   if (distance != null)
// //                     Positioned(
// //                       bottom: 6, left: 6,
// //                       child: Container(
// //                         padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
// //                         decoration: BoxDecoration(color: Colors.black.withOpacity(0.6), borderRadius: BorderRadius.circular(4)),
// //                         child: Text('${distance.toStringAsFixed(1)} km', style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.w500)),
// //                       ),
// //                     ),
// //                 ],
// //               ),
// //             ),
// //             Expanded(
// //               child: InkWell(
// //                 onTap: widget.onTapCard,
// //                 child: Padding(
// //                   padding: const EdgeInsets.all(10.0),
// //                   child: Column(
// //                     crossAxisAlignment: CrossAxisAlignment.start,
// //                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
// //                     children: [
// //                       Column(
// //                         crossAxisAlignment: CrossAxisAlignment.start,
// //                         mainAxisSize: MainAxisSize.min,
// //                         children: [
// //                           Text(name, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 2, overflow: TextOverflow.ellipsis),
// //                           const SizedBox(height: 4),
// //                           Row(children: [
// //                             Icon(Icons.sports_kabaddi_outlined, size: 14, color: theme.colorScheme.secondary),
// //                             const SizedBox(width: 4),
// //                             Expanded(child: Text(sport, style: theme.textTheme.bodyMedium?.copyWith(color: Colors.grey[800], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// //                           ]),
// //                           if (reviewCount > 0)
// //                             Padding(
// //                                padding: const EdgeInsets.only(top: 5.0),
// //                                child: Row(children: [
// //                                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// //                                 const SizedBox(width: 4),
// //                                 Text(averageRating.toStringAsFixed(1), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
// //                                 const SizedBox(width: 4),
// //                                 Text("($reviewCount reviews)", style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
// //                               ]),
// //                              ),
// //                         ],
// //                       ),
// //                       Row(
// //                         children: [
// //                           Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
// //                           const SizedBox(width: 4),
// //                           Expanded(child: Text(city, style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[700], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
// //                         ],
// //                       ),
// //                     ],
// //                   ),
// //                 ),
// //               ),
// //             ),
// //           ],
// //         ),
// //       ),
// //     );
// //   }
// // }

// //icons alignemnet-----
// import 'package:flutter/material.dart';
// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:geolocator/geolocator.dart';
// import 'package:mm_associates/features/data/services/firestore_service.dart';
// import 'package:mm_associates/features/home/screens/venue_form.dart';
// import 'package:mm_associates/features/auth/services/auth_service.dart';
// import 'package:mm_associates/features/user/services/user_service.dart';
// import 'package:mm_associates/core/services/location_service.dart';
// import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// import 'venue_detail_screen.dart';
// import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
// import 'dart:async';
// import 'package:shimmer/shimmer.dart';
// import 'city_selection_screen.dart' show CitySelectionScreen, CityInfo, kAppAllCities;
// import 'package:mm_associates/features/home/widgets/home_search_components.dart';

// class HomeScreen extends StatefulWidget {
//   final bool showAddVenueButton;

//   const HomeScreen({
//     super.key,
//     required this.showAddVenueButton,
//   });

//   @override
//   State<HomeScreen> createState() => _HomeScreenState();
// }

// class _HomeScreenState extends State<HomeScreen> with TickerProviderStateMixin {
//   final AuthService _authService = AuthService();
//   final FirestoreService _firestoreService = FirestoreService();
//   final LocationService _locationService = LocationService();
//   final UserService _userService = UserService();

//   // --- State Variables ---
//   String? _searchQuery;
//   String? _selectedCityFilter;
//   IconData? _selectedCityIcon;
//   String? _selectedSportFilter;

//   User? _currentUser;
//   String? _userName;
//   String? _userProfilePicUrl;
//   bool _isLoadingName = true;

//   List<Map<String, dynamic>> _filteredVenues = [];
//   bool _isLoadingFilteredVenues = true;
//   String? _filteredVenueFetchError;

//   List<Map<String, dynamic>> _nearbyVenues = [];
//   bool _isLoadingNearbyVenues = true;
//   String? _nearbyVenueFetchError;

//   List<Map<String, dynamic>> _exploreVenues = [];
//   bool _isLoadingExploreVenues = true;
//   String? _exploreVenueFetchError;

//   Position? _currentPosition;
//   bool _isFetchingLocation = false;
//   String? _locationStatusMessage;

//   // Favorites State
//   List<String> _favoriteVenueIds = [];
//   bool _isLoadingFavorites = true;
//   Stream<List<String>>? _favoritesStream;
//   StreamSubscription<List<String>>? _favoritesSubscription;

//   final List<String> _supportedCities = ['Mumbai', 'Delhi', 'Bangalore', 'Pune', 'Hyderabad', 'Chennai', 'Kolkata'];
//   final List<String> _quickSportFilters = ['Cricket', 'Football', 'Badminton', 'Basketball', 'Tennis'];

//   bool get _isSearchingOrFiltering => (_searchQuery != null && _searchQuery!.isNotEmpty) || _selectedCityFilter != null || _selectedSportFilter != null;

//   @override
//   void initState() {
//     super.initState();
//     _currentUser = FirebaseAuth.instance.currentUser;
//     _initializeScreen();
//     _setupFavoritesStream();
//     _updateSelectedCityIconFromFilter();
//   }

//   @override
//   void dispose() {
//     _favoritesSubscription?.cancel();
//     super.dispose();
//   }

//   void setStateIfMounted(VoidCallback fn) {
//     if (mounted) setState(fn);
//   }

//   // --- Core Logic & Data Fetching ---

//   Future<void> _initializeScreen() async {
//     await _fetchUserNameAndPic();
//     await _fetchPrimaryVenueData();
//   }

//   void _onFilterOrSearchChanged({String? explicitSearchQuery}) {
//     if (!mounted) return;

//     setState(() {
//       _searchQuery = (explicitSearchQuery?.trim().isEmpty ?? true) ? null : explicitSearchQuery!.trim();
//     });

//     if (_isSearchingOrFiltering) {
//       _fetchVenuesForFilterOrSearch();
//     } else {
//       _fetchPrimaryVenueData();
//     }
//   }

//   Future<void> _fetchVenuesForFilterOrSearch() async {
//     if (!mounted) return;
//     setStateIfMounted(() {
//       _isLoadingFilteredVenues = true;
//       _filteredVenueFetchError = null;
//       _filteredVenues = [];
//     });

//     try {
//       final venuesData = await _firestoreService.getVenues(
//         userLocation: _currentPosition,
//         radiusInKm: _selectedCityFilter != null ? null : (_currentPosition != null ? 50.0 : null),
//         cityFilter: _selectedCityFilter,
//         searchQuery: _searchQuery,
//         sportFilter: _selectedSportFilter,
//       );
//       if (!mounted) return;
//       setStateIfMounted(() {
//         _filteredVenues = venuesData;
//       });
//     } catch (e) {
//       debugPrint("Error fetching filtered/search venues: $e");
//       if (!mounted) return;
//       setStateIfMounted(() => _filteredVenueFetchError = "Could not load venues: ${e.toString().replaceFirst('Exception: ', '')}");
//     } finally {
//       if (!mounted) return;
//       setStateIfMounted(() => _isLoadingFilteredVenues = false);
//     }
//   }

//   Future<void> _fetchPrimaryVenueData() async {
//     if (!mounted) return;
//     setStateIfMounted(() {
//       _isFetchingLocation = true;
//       _isLoadingNearbyVenues = true;
//       _isLoadingExploreVenues = true;
//       _locationStatusMessage = 'Fetching your location...';
//       _nearbyVenues = [];
//       _exploreVenues = [];
//       _nearbyVenueFetchError = null;
//       _exploreVenueFetchError = null;
//     });
    
//     _currentPosition = await _locationService.getCurrentLocation();
    
//     if (!mounted) return;
    
//     setStateIfMounted(() {
//       _isFetchingLocation = false;
//       _locationStatusMessage = _currentPosition != null ? 'Location acquired.' : 'Could not get location.';
//     });

//     await Future.wait([
//       _fetchNearbyVenuesScoped(),
//       _fetchExploreVenuesFromOtherCities(),
//     ]);
//   }

//   Future<void> _handleRefresh() async {
//     if (mounted) {
//       setState(() {
//         _searchQuery = null;
//         _selectedSportFilter = null;
//       });
//       _onFilterOrSearchChanged();
//     }
//   }

//   void _updateSelectedCityIconFromFilter() {
//     if (_selectedCityFilter == null) {
//       _selectedCityIcon = Icons.my_location;
//     } else {
//       try {
//         final cityInfo = kAppAllCities.firstWhere((city) => city.name == _selectedCityFilter);
//         _selectedCityIcon = cityInfo.icon;
//       } catch (e) {
//         _selectedCityIcon = Icons.location_city_outlined;
//       }
//     }
//   }

//   void _setupFavoritesStream() {
//     _favoritesSubscription?.cancel();
//     if (_currentUser != null) {
//         _favoritesStream = _userService.getFavoriteVenueIdsStream();
//         _favoritesSubscription = _favoritesStream?.listen(
//           (favoriteIds) {
//             if (mounted) {
//               final newIdsSet = favoriteIds.toSet();
//               final currentIdsSet = _favoriteVenueIds.toSet();
//               if (newIdsSet.difference(currentIdsSet).isNotEmpty || currentIdsSet.difference(newIdsSet).isNotEmpty) {
//                 setStateIfMounted(() => _favoriteVenueIds = favoriteIds);
//               }
//             }
//           },
//           onError: (error) { debugPrint("Error in favorites stream: $error"); }
//         );
//         if (mounted) setStateIfMounted(() => _isLoadingFavorites = false);
//     } else {
//       if (mounted) {
//          setStateIfMounted(() { _favoriteVenueIds = []; _isLoadingFavorites = false; _favoritesStream = null; _favoritesSubscription = null; });
//       }
//     }
//   }

//   @override
//   void didChangeDependencies() {
//     super.didChangeDependencies();
//     final currentAuthUser = FirebaseAuth.instance.currentUser;
//     if (currentAuthUser != _currentUser) {
//       _currentUser = currentAuthUser;
//       _initializeScreen();
//       _setupFavoritesStream();
//       if (mounted) setStateIfMounted(_updateSelectedCityIconFromFilter);
//     }
//   }

//   Future<void> _fetchNearbyVenuesScoped() async {
//     if (!mounted) return;
//     if (_currentPosition == null) {
//       if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = false; _nearbyVenueFetchError = "Location not available."; _nearbyVenues = []; });
//       return;
//     }
//     if(mounted) setStateIfMounted(() { _isLoadingNearbyVenues = true; _nearbyVenueFetchError = null; _nearbyVenues = []; });
//     try {
//       final venuesData = await _firestoreService.getVenues(userLocation: _currentPosition, radiusInKm: 25.0);
//       if (!mounted) return;
//       setStateIfMounted(() => _nearbyVenues = venuesData);
//     } catch (e) {
//       if (!mounted) return;
//       setStateIfMounted(() => _nearbyVenueFetchError = "Could not load nearby venues.");
//     } finally {
//       if (!mounted) return;
//       setStateIfMounted(() => _isLoadingNearbyVenues = false);
//     }
//   }

//   Future<void> _fetchExploreVenuesFromOtherCities() async {
//     if (!mounted) return;
//     setStateIfMounted(() { _isLoadingExploreVenues = true; _exploreVenueFetchError = null; _exploreVenues = [];});
//     List<Map<String, dynamic>> allExploreVenues = [];
//     try {
//       for (String city in _supportedCities) {
//         final cityVenues = await _firestoreService.getVenues(cityFilter: city, userLocation: _currentPosition, limit: 5);
//         allExploreVenues.addAll(cityVenues);
//         if (!mounted) return;
//       }
//       final uniqueExploreVenues = allExploreVenues.fold<Map<String, Map<String, dynamic>>>({}, (map, venue) {
//           final String? venueId = venue['id'] as String?;
//           if (venueId != null) map[venueId] = venue;
//           return map;
//         }).values.toList();

//       if (_currentPosition != null) {
//         uniqueExploreVenues.sort((a, b) {
//           final distA = a['distance'] as double?; final distB = b['distance'] as double?;
//           if (distA != null && distB != null) return distA.compareTo(distB);
//           if (distA != null) return -1;
//           if (distB != null) return 1;
//           return (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? '');
//         });
//       } else {
//          uniqueExploreVenues.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
//       }
//       if(!mounted) return;
//       setStateIfMounted(() => _exploreVenues = uniqueExploreVenues.take(15).toList());
//     } catch (e) {
//       if (!mounted) return;
//       setStateIfMounted(() => _exploreVenueFetchError = "Could not load explore venues.");
//     } finally {
//       if (!mounted) return;
//       setStateIfMounted(() => _isLoadingExploreVenues = false);
//     }
//   }

//   Future<void> _fetchUserNameAndPic() async {
//     if (!mounted) return;
//     _setLoadingName(true); final currentUser = _currentUser;
//     if (currentUser == null) { if(mounted) _updateUserNameAndPic('Guest', null); _setLoadingName(false); return; }
//     try {
//       final userData = await _userService.getUserProfileData();
//       if (!mounted) return;
//       final fetchedName = userData?['name'] as String? ?? currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
//       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
//       _updateUserNameAndPic(fetchedName, fetchedPicUrl);
//     } catch (e) {
//       if (!mounted) return;
//       final fallbackName = currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
//       _updateUserNameAndPic(fallbackName, null);
//     } finally { if(mounted) _setLoadingName(false); }
//   }

//   void _setLoadingName(bool isLoading) => {if(mounted) setStateIfMounted(() => _isLoadingName = isLoading)};
//   void _updateUserNameAndPic(String name, String? picUrl) => {if(mounted) setStateIfMounted(() { _userName = name; _userProfilePicUrl = picUrl; })};

//   void _navigateToVenueDetail(Map<String, dynamic> venue) {
//     if (!context.mounted) return;
//     Navigator.push(context, MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venue['id'] as String, initialVenueData: venue)));
//   }

//   void _openSearchMobile() async {
//      if (!context.mounted) return;
//      final String? submittedQuery = await showSearch<String?>(
//         context: context,
//         delegate: VenueSearchDelegate(
//             firestoreService: _firestoreService,
//             initialCityFilter: _selectedCityFilter,
//         )
//     );
//     _onFilterOrSearchChanged(explicitSearchQuery: submittedQuery);
//   }

//   Future<void> _openCitySelectionScreen() async {
//     if (!context.mounted) return;
//     final String? newSelectedCityName = await Navigator.push<String?>(
//       context,
//       MaterialPageRoute(builder: (context) => CitySelectionScreen(currentSelectedCity: _selectedCityFilter)),
//     );

//     if (mounted && newSelectedCityName != _selectedCityFilter) {
//       setStateIfMounted(() {
//         _selectedCityFilter = newSelectedCityName; 
//         _updateSelectedCityIconFromFilter(); 
//       });
//       _onFilterOrSearchChanged(); 
//     }
//   }
  
//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     final appBarBackgroundColor = theme.appBarTheme.backgroundColor ?? theme.primaryColor;
//     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ?? theme.appBarTheme.iconTheme?.color ?? (kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white);
//     final bool isLoggedIn = _currentUser != null;

//     return Scaffold(
//       appBar: AppBar(
//         // ----- THE KEY FIX: INCREASING THE APP BAR HEIGHT -----
//         toolbarHeight: 70.0, // This gives enough room for the translated widget
//         automaticallyImplyLeading: false,
//         title: kIsWeb ? _buildWebAppBarTitle(context) : _buildMobileAppBarTitle(context, theme),
//         actions: _buildAppBarActions(context, isLoggedIn, actionsIconColor),
//         backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
//         elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
//         iconTheme: theme.iconTheme.copyWith(color: kIsWeb ? (theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : Colors.white),
//         actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
//         titleTextStyle: theme.appBarTheme.titleTextStyle?.copyWith(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ?? TextStyle(color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white, fontSize: 20, fontWeight: FontWeight.w500),
//       ),
//       floatingActionButton: widget.showAddVenueButton
//           ? FloatingActionButton.extended(
//               onPressed: () {
//                 Navigator.push(
//                   context,
//                   MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
//                 ).then((result) {
//                   if (result == true && mounted) {
//                     _handleRefresh();
//                     ScaffoldMessenger.of(context).showSnackBar(
//                       const SnackBar(content: Text("Venue list updated."), backgroundColor: Colors.blueAccent),
//                     );
//                   }
//                 });
//               },
//               icon: const Icon(Icons.add_location_alt_outlined),
//               label: const Text("Add Venue"),
//               tooltip: 'Add New Venue',
//             )
//           : null,
//       floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
//       body: _buildBodyContent(),
//     );
//   }

//   Widget _buildWebAppBarTitle(BuildContext context) {
//     final theme = Theme.of(context);
//     final currentUser = _currentUser;
//     final bool isLoggedIn = _currentUser != null; 
    
//     double screenWidth = MediaQuery.of(context).size.width;
//     double leadingWidth = 150 + (_userName != null ? 100 : 0);
//     double searchWidthFraction = 0.4;
//     double minSearchWidth = 200;
//     double maxSearchWidth = 500;
//     double actionsWidth = kIsWeb ? (isLoggedIn ? 200 : 100) : (isLoggedIn ? 150 : 80);
//     double availableWidth = screenWidth - leadingWidth - actionsWidth - 32;
//     double calculatedSearchWidth = (availableWidth * searchWidthFraction).clamp(minSearchWidth, maxSearchWidth);

//     return Row(children: [
//       Text('MM Associates', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
//       const SizedBox(width: 24),
//       if (_isLoadingName && currentUser != null)
//         const Padding(padding: EdgeInsets.only(right: 16.0), child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))
//       else if (_userName != null && currentUser != null)
//         Padding(
//           padding: const EdgeInsets.only(right: 16.0),
//           child: Text('Hi, ${_userName!.split(' ')[0]}!', style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: theme.textTheme.bodyLarge?.color), overflow: TextOverflow.ellipsis)
//         ),
//       const Spacer(),
//       SizedBox(
//         width: calculatedSearchWidth,
//         child: WebSearchBar(
//           key: ValueKey(_searchQuery ?? 'initial'),
//           initialValue: _searchQuery ?? '',
//           cityFilter: _selectedCityFilter,
//           firestoreService: _firestoreService,
//           onSearchSubmitted: (query) => _onFilterOrSearchChanged(explicitSearchQuery: query),
//           onSuggestionSelected: (suggestionName) => _onFilterOrSearchChanged(explicitSearchQuery: suggestionName),
//           onClear: () => _onFilterOrSearchChanged(explicitSearchQuery: null),
//         ),
//       ),
//       const Spacer(),
//     ]);
//   }
  
//   Widget _buildMobileAppBarTitle(BuildContext context, ThemeData theme) {
//     final titleStyle = theme.appBarTheme.titleTextStyle ?? theme.primaryTextTheme.titleLarge ?? const TextStyle(fontSize: 20, color: Colors.white, fontWeight: FontWeight.w500);
//     final currentUser = _currentUser;
//     return Row(children: [
//         if (currentUser != null)
//           GestureDetector(
//             onTap: () {
//               if (!context.mounted) return;
//               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
//                   .then((_) { if (mounted) _fetchUserNameAndPic(); });
//             },
//             child: Tooltip(
//               message: "My Profile",
//               child: Padding(
//                 padding: const EdgeInsets.only(right: 10.0),
//                 child: CircleAvatar(
//                   radius: 18,
//                   backgroundColor: Colors.white24,
//                   backgroundImage: _userProfilePicUrl != null && _userProfilePicUrl!.isNotEmpty ? NetworkImage(_userProfilePicUrl!) : null,
//                   child: _userProfilePicUrl == null || _userProfilePicUrl!.isEmpty ? Icon(Icons.person_outline, size: 20, color: Colors.white.withOpacity(0.8)) : null
//                 )
//               ),
//             ),
//           ),
//         if (_isLoadingName && currentUser != null)
//           const Padding(
//             padding: EdgeInsets.only(left: 6.0),
//             child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(Colors.white70)))
//           )
//         else if (_userName != null && currentUser != null)
//           Expanded(
//             child: Padding(
//                padding: EdgeInsets.only(left: currentUser != null ? 0 : 8.0),
//               child: Text(
//                 'Hi, ${_userName!.split(' ')[0]}!',
//                 style: titleStyle.copyWith(fontSize: 18, fontWeight: FontWeight.w500),
//                 overflow: TextOverflow.ellipsis
//               )
//             )
//           )
//         else
//           Text('MM Associates', style: titleStyle),
//       ]
//     );
//   }

//   List<Widget> _buildAppBarActions(BuildContext context, bool isLoggedIn, Color iconColor) {
//     final String cityNameText = _selectedCityFilter ?? 'Near Me';
//     const double textSize = 10.0;

//     final locationButton = Tooltip(
//       message: _selectedCityFilter == null ? 'Filter: Near Me' : 'Filter: $_selectedCityFilter',
//       child: Transform.translate(
//         offset: const Offset(0, 9.0), // Pushes just this widget down
//         child: TextButton(
//           onPressed: _openCitySelectionScreen,
//           style: TextButton.styleFrom(
//             padding: const EdgeInsets.symmetric(horizontal: 4),
//             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
//             foregroundColor: iconColor,
//           ),
//           child: Column(
//             mainAxisSize: MainAxisSize.min,
//             children: [
//               Icon(
//                 _selectedCityIcon ?? (_selectedCityFilter == null ? Icons.my_location : Icons.location_city_outlined),
//                 size: 24,
//               ),
//               const SizedBox(height: 2),
//               Text(
//                 cityNameText,
//                 style: TextStyle(fontSize: textSize, fontWeight: FontWeight.w500),
//                 overflow: TextOverflow.ellipsis,
//               ),
//             ],
//           ),
//         ),
//       ),
//     );

//     final profileButton = isLoggedIn ? IconButton(
//       icon: Icon(Icons.person_outline_rounded, color: iconColor),
//       tooltip: 'My Profile',
//       onPressed: () {
//         if (!context.mounted) return;
//         Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()))
//             .then((_) => {if (mounted) _fetchUserNameAndPic()});
//       },
//     ) : null;

//     return [
//       Row(
//         crossAxisAlignment: CrossAxisAlignment.center,
//         children: kIsWeb 
//         ? [ // Web Layout
//             locationButton,
//             if (profileButton != null) const SizedBox(width: 8),
//             if (profileButton != null) profileButton,
//             const SizedBox(width: 8),
//         ] 
//         : [ // Mobile Layout
//             IconButton(
//               icon: Icon(Icons.search_outlined, color: iconColor),
//               tooltip: 'Search Venues',
//               onPressed: _openSearchMobile,
//             ),
//             locationButton,
//             if (profileButton != null) profileButton,
//             if (profileButton == null) const SizedBox(width: 8), 
//         ],
//       )
//     ];
//   }


//   Widget _buildQuickSportFilters() {
//     final theme = Theme.of(context);
//     return Container(
//       height: 55,
//       color: theme.cardColor,
//       child: ListView.separated(
//         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
//         scrollDirection: Axis.horizontal,
//         itemCount: _quickSportFilters.length + 1,
//         separatorBuilder: (context, index) => const SizedBox(width: 10),
//         itemBuilder: (context, index) {
//           if (index == 0) {
//             final bool isSelected = _selectedSportFilter == null;
//             return ChoiceChip(
//               label: const Text('All Sports'),
//               selected: isSelected,
//               onSelected: (bool nowSelected) {
//                 if (nowSelected && _selectedSportFilter != null) {
//                     setStateIfMounted(() => _selectedSportFilter = null);
//                     _onFilterOrSearchChanged();
//                 }
//               },
//               selectedColor: theme.colorScheme.primary.withOpacity(0.2),
//               backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
//               labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
//               shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
//               padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
//               visualDensity: VisualDensity.compact,
//                showCheckmark: false,
//             );
//           }
//           final sport = _quickSportFilters[index - 1];
//           final bool isSelected = _selectedSportFilter == sport;
//           return ChoiceChip(
//             label: Text(sport),
//             selected: isSelected,
//             onSelected: (bool isNowSelected) {
//               final newFilter = isNowSelected ? sport : null;
//               if (_selectedSportFilter != newFilter) {
//                 setStateIfMounted(() => _selectedSportFilter = newFilter);
//                 _onFilterOrSearchChanged();
//               }
//             },
//             selectedColor: theme.colorScheme.primary.withOpacity(0.2),
//             backgroundColor: theme.chipTheme.backgroundColor ?? theme.colorScheme.surfaceContainerLow,
//             labelStyle: TextStyle(color: isSelected ? theme.colorScheme.primary : theme.textTheme.bodyMedium?.color, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal, fontSize: 13),
//             shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20), side: BorderSide(color: isSelected ? theme.colorScheme.primary.withOpacity(0.5) : Colors.grey.shade300)),
//             padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
//             visualDensity: VisualDensity.compact,
//             showCheckmark: false,
//           );
//         },
//       ),
//     );
//   }

//   Widget _buildBodyContent() {
//      return Column(children: [
//          _buildQuickSportFilters(),
//          Expanded(
//            child: RefreshIndicator(
//              onRefresh: _handleRefresh,
//              child: ListView(
//                padding: EdgeInsets.zero,
//                children: [
//                  if (_isSearchingOrFiltering) ...[
//                    _buildSectionHeader(context,
//                         _searchQuery != null && _searchQuery!.isNotEmpty
//                             ? "Results for \"$_searchQuery\""
//                             : (_selectedCityFilter != null
//                                 ? "Venues in $_selectedCityFilter"
//                                 : (_selectedSportFilter != null ? "Venues for $_selectedSportFilter" : "Filtered Venues")
//                             )
//                     ),
//                    _buildVenueList(_filteredVenues, _isLoadingFilteredVenues, _filteredVenueFetchError, "No venues found for your selection.", isNearbySection: false),
//                  ] else ...[
//                    if (_currentPosition != null || _isLoadingNearbyVenues)
//                        _buildSectionHeader(context, "Venues Near You"),
//                    _buildVenueList(_nearbyVenues, _isLoadingNearbyVenues, _nearbyVenueFetchError, "No venues found nearby. Try exploring other cities.", isNearbySection: true),
//                    const SizedBox(height: 16),
//                    _buildSectionHeader(context, "Explore Venues"),
//                    _buildVenueList(_exploreVenues, _isLoadingExploreVenues, _exploreVenueFetchError, "No venues to explore at the moment.", isNearbySection: false),
//                   ],
//                  const SizedBox(height: 80),
//                ],
//              ),
//            ),
//          ),
//        ]
//      );
//   }
  
//   Widget _buildSectionHeader(BuildContext context, String title) {
//     return Padding(padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 20.0, bottom: 8.0),
//       child: Text(title, style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600)));
//   }

//   Widget _buildVenueList(List<Map<String, dynamic>> venues, bool isLoading, String? errorMsg, String emptyMsg, {bool isNearbySection = false}) {
//      if (isLoading) return _buildShimmerLoadingGrid(itemCount: isNearbySection ? 3 : 6);
//      if (errorMsg != null) return Center(child: Padding(padding: const EdgeInsets.all(20), child: Text(errorMsg, textAlign: TextAlign.center, style: const TextStyle(color: Colors.red, fontSize: 16))));
//      if (venues.isEmpty) return Center(child: Padding(padding: const EdgeInsets.symmetric(vertical: 40.0, horizontal: 20.0), child: Text(emptyMsg, textAlign: TextAlign.center, style: TextStyle(fontSize: 16, color: Colors.grey[600]))));

//      return GridView.builder(
//        shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
//        padding: const EdgeInsets.only(left: 16.0, right: 16.0, top: 8.0, bottom: 16.0),
//        gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
//            maxCrossAxisExtent: kIsWeb ? 280.0 : 240.0,
//            mainAxisSpacing: 16.0,
//            crossAxisSpacing: 16.0,
//            childAspectRatio: 0.70
//         ),
//        itemCount: venues.length,
//        itemBuilder: (context, index) {
//          final venue = venues[index];
//          final bool isFavorite = !_isLoadingFavorites && _favoriteVenueIds.contains(venue['id']);
//          return _buildVenueGridCard(venue, isFavorite: isFavorite);
//        },
//      );
//    }

//   Widget _buildShimmerLoadingGrid({int itemCount = 6}) {
//     return Shimmer.fromColors(baseColor: Colors.grey[350]!, highlightColor: Colors.grey[200]!,
//       child: GridView.builder(
//         shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
//         padding: const EdgeInsets.all(16.0),
//         gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(maxCrossAxisExtent: kIsWeb ? 280.0 : 230.0, mainAxisSpacing: 16.0, crossAxisSpacing: 16.0, childAspectRatio: 0.70),
//         itemCount: itemCount, itemBuilder: (context, index) => _buildVenueShimmerCard())
//       );
//   }
//   Widget _buildVenueShimmerCard() {
//     return Card(
//       margin: EdgeInsets.zero, elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), clipBehavior: Clip.antiAlias,
//       child: Column(children: [
//         Container(height: 130, width: double.infinity, color: Colors.white),
//         Expanded(child: Padding(padding: const EdgeInsets.all(10.0), child: Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
//           Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
//             Container(width: double.infinity, height: 18.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
//             Container(width: MediaQuery.of(context).size.width * 0.3, height: 14.0, color: Colors.white, margin: const EdgeInsets.only(bottom: 6)),
//             Container(width: MediaQuery.of(context).size.width * 0.2, height: 12.0, color: Colors.white)]),
//           Container(width: double.infinity, height: 12.0, color: Colors.white)
//           ])))
//       ]));
//   }

//   Widget _buildVenueGridCard(Map<String, dynamic> venue, {required bool isFavorite}) {
//       final String venueId = venue['id'] as String? ?? '';
//       return _VenueCardWidget(
//         key: ValueKey(venueId),
//         venue: venue,
//         isFavorite: isFavorite,
//         onTapCard: () => _navigateToVenueDetail(venue),
//         onTapFavorite: () => _toggleFavorite(venueId, isFavorite),
//       );
//     }

//   Future<void> _toggleFavorite(String venueId, bool currentIsFavorite) async {
//     if (!mounted) return;
//     final currentUser = _currentUser;
//     if (currentUser == null) {
//       ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Please log in to manage favorites.")));
//       return;
//     }
//     if (venueId.isEmpty) return;
//     try {
//       if (!currentIsFavorite) {
//         await _userService.addFavorite(venueId);
//       } else {
//         await _userService.removeFavorite(venueId);
//       }
//     } catch (e) {
//       if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Error updating favorites: ${e.toString()}")));
//     }
//   }
// }

// class _VenueCardWidget extends StatefulWidget {
//   final Map<String, dynamic> venue;
//   final bool isFavorite;
//   final VoidCallback onTapCard;
//   final Future<void> Function() onTapFavorite;

//   const _VenueCardWidget({
//     required Key key,
//     required this.venue,
//     required this.isFavorite,
//     required this.onTapCard,
//     required this.onTapFavorite,
//   }) : super(key: key);

//   @override
//   _VenueCardWidgetState createState() => _VenueCardWidgetState();
// }

// class _VenueCardWidgetState extends State<_VenueCardWidget> with SingleTickerProviderStateMixin {
//   late AnimationController _favoriteAnimationController;
//   late Animation<double> _favoriteScaleAnimation;

//   @override
//   void initState() {
//     super.initState();
//     _favoriteAnimationController = AnimationController(
//       duration: const Duration(milliseconds: 300),
//       vsync: this,
//     );
//     _favoriteScaleAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
//       CurvedAnimation(parent: _favoriteAnimationController, curve: Curves.elasticOut, reverseCurve: Curves.easeInCubic),
//     );
//   }

//   @override
//   void didUpdateWidget(_VenueCardWidget oldWidget) {
//     super.didUpdateWidget(oldWidget);
//     if (widget.isFavorite != oldWidget.isFavorite && mounted) {
//       if (widget.isFavorite) {
//         _favoriteAnimationController.forward(from: 0.0).catchError((e) { if (e is! TickerCanceled) debugPrint("Error playing fav animation: $e"); });
//       } else {
//          _favoriteAnimationController.reverse().catchError((e) { if (e is! TickerCanceled) debugPrint("Error reversing fav animation: $e"); });
//       }
//     }
//   }

//   @override
//   void dispose() {
//     _favoriteAnimationController.dispose();
//     super.dispose();
//   }

//   @override
//   Widget build(BuildContext context) {
//     final ThemeData theme = Theme.of(context);
//     final String name = widget.venue['name'] as String? ?? 'Unnamed Venue';
//     final dynamic sportRaw = widget.venue['sportType'];
//     final String sport = (sportRaw is String) ? sportRaw : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');
//     final String? imageUrl = widget.venue['imageUrl'] as String?;
//     final String city = widget.venue['city'] as String? ?? '';
//     final String venueId = widget.venue['id'] as String? ?? '';
//     final double? distance = widget.venue['distance'] as double?;
//     final double averageRating = (widget.venue['averageRating'] as num?)?.toDouble() ?? 0.0;
//     final int reviewCount = (widget.venue['reviewCount'] as num?)?.toInt() ?? 0;

//     return MouseRegion(
//       cursor: SystemMouseCursors.click,
//       child: Card(
//         margin: EdgeInsets.zero,
//         elevation: 3,
//         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
//         clipBehavior: Clip.antiAlias,
//         child: Column(
//           crossAxisAlignment: CrossAxisAlignment.start,
//           children: [
//             SizedBox(
//               height: 130,
//               width: double.infinity,
//               child: Stack(
//                 children: [
//                   Positioned.fill(
//                     child: InkWell(
//                       onTap: widget.onTapCard,
//                       child: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
//                           ? Hero(
//                               tag: 'venue_image_$venueId',
//                               child: Image.network(
//                                 imageUrl, height: 130, width: double.infinity, fit: BoxFit.cover,
//                                 loadingBuilder: (context, child, loadingProgress) => (loadingProgress == null) ? child : Container(height: 130, color: Colors.grey[200], child: Center(child: CircularProgressIndicator(strokeWidth: 2, value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null))),
//                                 errorBuilder: (context, error, stackTrace) => Container(height: 130, color: Colors.grey[200], child: Center(child: Icon(Icons.broken_image_outlined, color: Colors.grey[400], size: 40))),
//                               ),
//                             )
//                           : Container(height: 130, color: theme.primaryColor.withOpacity(0.08), child: Center(child: Icon(Icons.sports_soccer_outlined, size: 50, color: theme.primaryColor.withOpacity(0.7)))),
//                     ),
//                   ),
//                   Positioned(
//                     top: 6, right: 6,
//                     child: Material(
//                       color: Colors.black.withOpacity(0.45), shape: const CircleBorder(),
//                       child: InkWell(
//                         borderRadius: BorderRadius.circular(20),
//                         onTap: widget.onTapFavorite,
//                         child: Padding(
//                           padding: const EdgeInsets.all(7.0),
//                           child: ScaleTransition(
//                             scale: _favoriteScaleAnimation,
//                             child: Icon(
//                               widget.isFavorite ? Icons.favorite_rounded : Icons.favorite_border_rounded,
//                               color: widget.isFavorite ? Colors.pinkAccent[100] : Colors.white,
//                               size: 22,
//                             ),
//                           ),
//                         ),
//                       ),
//                     ),
//                   ),
//                   if (distance != null)
//                     Positioned(
//                       bottom: 6, left: 6,
//                       child: Container(
//                         padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
//                         decoration: BoxDecoration(color: Colors.black.withOpacity(0.6), borderRadius: BorderRadius.circular(4)),
//                         child: Text('${distance.toStringAsFixed(1)} km', style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.w500)),
//                       ),
//                     ),
//                 ],
//               ),
//             ),
//             Expanded(
//               child: InkWell(
//                 onTap: widget.onTapCard,
//                 child: Padding(
//                   padding: const EdgeInsets.all(10.0),
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.start,
//                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                     children: [
//                       Column(
//                         crossAxisAlignment: CrossAxisAlignment.start,
//                         mainAxisSize: MainAxisSize.min,
//                         children: [
//                           Text(name, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 2, overflow: TextOverflow.ellipsis),
//                           const SizedBox(height: 4),
//                           Row(children: [
//                             Icon(Icons.sports_kabaddi_outlined, size: 14, color: theme.colorScheme.secondary),
//                             const SizedBox(width: 4),
//                             Expanded(child: Text(sport, style: theme.textTheme.bodyMedium?.copyWith(color: Colors.grey[800], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
//                           ]),
//                           if (reviewCount > 0)
//                             Padding(
//                                padding: const EdgeInsets.only(top: 5.0),
//                                child: Row(children: [
//                                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
//                                 const SizedBox(width: 4),
//                                 Text(averageRating.toStringAsFixed(1), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12.5)),
//                                 const SizedBox(width: 4),
//                                 Text("($reviewCount reviews)", style: TextStyle(fontSize: 11.5, color: Colors.grey[600])),
//                               ]),
//                              ),
//                         ],
//                       ),
//                       Row(
//                         children: [
//                           Icon(Icons.location_on_outlined, size: 14, color: Colors.grey[600]),
//                           const SizedBox(width: 4),
//                           Expanded(child: Text(city, style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[700], fontSize: 12), maxLines: 1, overflow: TextOverflow.ellipsis)),
//                         ],
//                       ),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }


===== features\home\screens\venue_detail_screen copy.dart =====

// // // lib/features/home/screens/venue_detail_screen.dart

// // import 'package:flutter/material.dart';
// // import 'package:cloud_firestore/cloud_firestore.dart';
// // import 'package:google_maps_flutter/google_maps_flutter.dart';
// // import 'package:mm_associates/features/bookings/screens/venue_availability_screen.dart';
// // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // import 'package:mm_associates/features/user/services/user_service.dart';
// // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // import 'package:mm_associates/features/reviews/widgets/add_review_dialog.dart';
// // import 'package:mm_associates/features/reviews/widgets/review_list_item.dart';
// // import 'package:url_launcher/url_launcher.dart';
// // import 'package:flutter_rating_bar/flutter_rating_bar.dart';
// // import 'package:share_plus/share_plus.dart';

// // class VenueDetailScreen extends StatefulWidget {
// //   final String venueId;
// //   final Map<String, dynamic>? initialVenueData;

// //   const VenueDetailScreen({
// //     super.key,
// //     required this.venueId,
// //     this.initialVenueData,
// //   });

// //   @override
// //   State<VenueDetailScreen> createState() => _VenueDetailScreenState();
// // }

// // class _VenueDetailScreenState extends State<VenueDetailScreen> {
// //   final FirestoreService _firestoreService = FirestoreService();
// //   final UserService _userService = UserService();
// //   final AuthService _authService = AuthService();

// //   Map<String, dynamic>? _venueData;
// //   bool _isLoadingDetails = true;
// //   String? _errorMessage;
// //   GoogleMapController? _mapController;
// //   Set<Marker> _markers = {};

// //   List<Map<String, dynamic>> _reviews = [];
// //   bool _isLoadingReviews = true;
// //   bool _isFavorite = false;
// //   bool _isLoadingFavorite = true;
// //   double _averageRating = 0.0;
// //   int _reviewCount = 0;

// //   @override
// //   void initState() {
// //     super.initState();
// //     _applyInitialData();
// //     _fetchAllDetails();
// //   }

// //   void _applyInitialData() {
// //     // Use initial data if provided for a faster first paint
// //     if (widget.initialVenueData != null && widget.initialVenueData!.isNotEmpty) {
// //       _venueData = widget.initialVenueData;
// //       // Pre-fill rating and review counts if available in initial data
// //       _averageRating =
// //           (widget.initialVenueData!['averageRating'] as num?)?.toDouble() ??
// //               0.0;
// //       _reviewCount =
// //           (widget.initialVenueData!['reviewCount'] as num?)?.toInt() ?? 0;
// //       _isLoadingDetails = false; // Already have some data
// //       _setupMapMarker(); // Setup map with initial data if possible
// //     } else {
// //       _isLoadingDetails = true; // No initial data, need to fetch everything
// //     }
// //   }

// //   @override
// //   void dispose() {
// //     _mapController?.dispose();
// //     super.dispose();
// //   }

// //   // Fetches venue details, reviews, and favorite status concurrently
// //   Future<void> _fetchAllDetails() async {
// //     if (!mounted) return;
// //     setState(() {
// //       // Set specific loading states
// //       if (_venueData == null) _isLoadingDetails = true; // Full load if no data yet
// //       _isLoadingReviews = true;
// //       _isLoadingFavorite = true; // Need to check fav status even if details exist
// //       _errorMessage = null; // Clear previous errors
// //     });

// //     try {
// //       // Fetch data in parallel for efficiency
// //       final results = await Future.wait([
// //         _firestoreService.getVenueDetails(widget.venueId),
// //         _firestoreService.getReviewsForVenue(widget.venueId, limit: 50), // Fetch up to 50 reviews
// //         // Only check favorite status if user is logged in
// //         _authService.getCurrentUser() != null
// //             ? _userService.isVenueFavorite(widget.venueId)
// //             : Future.value(false), // Default to not favorite if logged out
// //       ]);

// //       // Process results
// //       final venueDetailsData = results[0] as Map<String, dynamic>?;
// //       final reviewsData = results[1] as List<Map<String, dynamic>>;
// //       final isFavoriteData = results[2] as bool;

// //       // Update state only if the widget is still mounted
// //       if (mounted) {
// //         if (venueDetailsData != null) {
// //           setState(() {
// //             _venueData = venueDetailsData; // Overwrite initial data with latest
// //             _reviews = reviewsData;
// //             _isFavorite = isFavoriteData;
// //             _calculateAverageRating(); // Recalculate rating based on fetched reviews
// //             _isLoadingDetails = false; // All main details are loaded
// //             _isLoadingReviews = false; // Reviews loaded
// //             _isLoadingFavorite = false; // Favorite status loaded
// //             _errorMessage = null; // Clear any previous errors
// //             _setupMapMarker(); // Update map markers with fetched location
// //           });
// //         } else {
// //           // Venue not found or other fetch error for details
// //           setState(() {
// //             _isLoadingDetails = false; // Stop loading
// //             _isLoadingReviews = false;
// //             _isLoadingFavorite = false;
// //             _errorMessage = 'Venue details not found.'; // Specific error message
// //           });
// //         }
// //       }
// //     } catch (e) {
// //       debugPrint("Error fetching venue details/reviews/fav status: $e");
// //       if (mounted) {
// //          // Handle error differently based on whether we had initial data
// //          if (_venueData == null) { // If initial load failed completely
// //              setState(() {
// //                  _isLoadingDetails = false;
// //                  _isLoadingReviews = false;
// //                  _isLoadingFavorite = false;
// //                  _errorMessage = 'Failed to load venue details. Please try again.';
// //              });
// //          } else { // If refresh failed but we have old data, show less intrusive error
// //              ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// //                  content: Text(
// //                    "Could not refresh all details: ${e.toString().replaceFirst("Exception: ", "")}",
// //                     maxLines: 2, overflow: TextOverflow.ellipsis,
// //                  ),
// //                  backgroundColor: Colors.orangeAccent,
// //               ));
// //              // Stop loading indicators but keep showing stale data
// //              setState(() {
// //                 _isLoadingReviews = false;
// //                 _isLoadingFavorite = false;
// //               });
// //            }
// //         }
// //     }
// //   }

// //   // Calculates average rating based on the fetched _reviews list
// //   void _calculateAverageRating() {
// //     if (!mounted) return;
// //     if (_reviews.isEmpty) {
// //       // Set rating/count to 0 if there are no reviews
// //       setState(() {
// //         _averageRating = 0.0;
// //         _reviewCount = 0;
// //       });
// //       return;
// //     }
// //     double totalRating = 0;
// //     // Sum up ratings from all fetched reviews
// //     for (var review in _reviews) {
// //       totalRating += (review['rating'] as num?)?.toDouble() ?? 0.0;
// //     }
// //     setState(() {
// //       _reviewCount = _reviews.length; // Update review count
// //       // Calculate average and round to one decimal place
// //       _averageRating = (totalRating / _reviewCount * 10).round() / 10;
// //     });
// //   }

// //   // Sets up the marker for the Google Map based on _venueData
// //   void _setupMapMarker() {
// //     if (_venueData == null || !mounted) return;

// //     final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
// //     final String name = _venueData!['name'] as String? ?? 'Venue Location';
// //     final String address = _venueData!['address'] as String? ?? '';

// //     if (geoPoint != null) {
// //       final marker = Marker(
// //         markerId: MarkerId(widget.venueId), // Use venue ID for marker ID
// //         position: LatLng(geoPoint.latitude, geoPoint.longitude),
// //         infoWindow: InfoWindow(title: name, snippet: address), // Show info on tap
// //       );
// //       // Update the state to display the marker
// //       setState(() {
// //         _markers = {marker};
// //       });

// //       // If map is already created, animate camera to the new marker
// //       _mapController?.animateCamera(
// //         CameraUpdate.newLatLngZoom(
// //             LatLng(geoPoint.latitude, geoPoint.longitude), 14.5), // Zoom level 14.5
// //       );
// //     } else {
// //        // If no location data, clear existing markers
// //       setState(() {
// //         _markers = {};
// //       });
// //     }
// //   }

// //   // Callback when the Google Map is created
// //   void _onMapCreated(GoogleMapController controller) {
// //      if (!mounted) return;
// //     _mapController = controller; // Store the controller
// //     _setupMapMarker(); // Setup markers now that the map is ready
// //   }

// //   // Utility function to launch external URLs (website, phone)
// //   Future<void> _launchUrl(String urlString) async {
// //      if (!mounted) return; // Check if widget is still active
// //      final Uri url = Uri.parse(urlString); // Parse the string into a Uri
// //      try {
// //         bool canLaunch = await canLaunchUrl(url); // Check if the URL can be launched
// //         if (canLaunch) {
// //            // Launch the URL using the preferred external application mode
// //            if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
// //              throw 'Could not launch $urlString'; // Throw error if launch fails
// //            }
// //         } else {
// //            throw 'Could not launch $urlString'; // Throw error if system can't handle the URL scheme
// //          }
// //      } catch (e) {
// //         debugPrint("Error launching URL: $e");
// //         if (mounted) // Show error message to the user
// //          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// //              content: Text('Could not open link: ${e.toString().replaceFirst("Exception: ", "")}'),
// //              backgroundColor: Colors.redAccent));
// //      }
// //    }

// //   // Toggles the favorite status of the venue for the logged-in user
// //   Future<void> _toggleFavorite() async {
// //      // Check if user is logged in
// //      if (_authService.getCurrentUser() == null) {
// //         if (!mounted) return;
// //        ScaffoldMessenger.of(context).showSnackBar(
// //            const SnackBar(content: Text("Please log in to manage favorites.")));
// //        return;
// //      }
// //       // Prevent multiple taps while processing
// //      if (_isLoadingFavorite || !mounted) return;

// //      setState(() => _isLoadingFavorite = true); // Show loading indicator on button
// //      final originalFavStatus = _isFavorite; // Store original state for rollback on error

// //      try {
// //        // Call the appropriate UserService method based on current status
// //        if (_isFavorite) {
// //          await _userService.removeFavorite(widget.venueId);
// //        } else {
// //          await _userService.addFavorite(widget.venueId);
// //        }

// //        // Update UI only after successful Firestore operation
// //        if (mounted) {
// //          setState(() {
// //            _isFavorite = !_isFavorite; // Toggle the favorite state visually
// //            // Show confirmation message
// //             ScaffoldMessenger.of(context).showSnackBar(
// //                SnackBar(
// //                    content: Text(_isFavorite ? "Added to Favorites" : "Removed from Favorites"),
// //                    duration: const Duration(seconds: 2) // Short duration for confirmation
// //                ),
// //             );
// //          });
// //        }
// //      } catch (e) {
// //        debugPrint("Error toggling favorite: $e");
// //        // Rollback UI change if there was an error
// //         if (mounted) {
// //           setState(() {
// //               _isFavorite = originalFavStatus; // Revert visual state
// //           });
// //          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// //              content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"),
// //              backgroundColor: Colors.redAccent)); // Show error message
// //        }
// //      } finally {
// //         // Ensure loading indicator is removed regardless of success/failure
// //        if (mounted) setState(() => _isLoadingFavorite = false);
// //      }
// //    }

// //   // Shows the dialog for adding a new review
// //   void _showAddReviewDialog() {
// //      // Check if user is logged in
// //      if (_authService.getCurrentUser() == null) {
// //         if (!mounted) return;
// //        ScaffoldMessenger.of(context).showSnackBar(
// //            const SnackBar(content: Text("Please log in to write a review.")));
// //        return;
// //      }
// //       // Ensure venue data is loaded before allowing review
// //      if (_venueData == null) return;

// //      showDialog<bool>(
// //        context: context,
// //        barrierDismissible: false, // Prevent closing by tapping outside
// //        builder: (BuildContext context) {
// //           // Use the dedicated AddReviewDialog widget
// //          return AddReviewDialog(venueId: widget.venueId);
// //        },
// //      ).then((success) {
// //         // After the dialog is closed, check if review was successfully added
// //        if (success == true && mounted) {
// //          // If successful, re-fetch all details to update the review list and average rating
// //          _fetchAllDetails();
// //        }
// //      });
// //    }

// //   // Shares venue details using the share_plus package
// //   Future<void> _shareVenue() async {
// //       // Ensure venue data is loaded
// //       if (_venueData == null) {
// //          if (!mounted) return;
// //          ScaffoldMessenger.of(context)
// //              .showSnackBar(const SnackBar(content: Text("Venue data not loaded yet.")));
// //          return;
// //       }

// //       // Extract data to share
// //       final String name = _venueData!['name'] as String? ?? 'This Venue';
// //       final String address = _venueData!['address'] as String? ?? '';
// //       final String city = _venueData!['city'] as String? ?? '';
// //       final String? website = _venueData!['website'] as String?;

// //       // Construct the share text
// //       final String locationInfo = [address, city].where((s) => s.isNotEmpty).join(', ');
// //       String shareText = 'Check out this venue: $name';
// //       if (locationInfo.isNotEmpty) {
// //          shareText += '\nLocated at: $locationInfo';
// //       }
// //       if (website != null && website.isNotEmpty) {
// //            final uri = Uri.tryParse(website);
// //            if (uri != null && uri.isAbsolute) { // Simple validation for absolute URL
// //               shareText += '\nWebsite: $website';
// //            }
// //       }
// //       // TODO: Consider adding a dynamic link to your app here if configured

// //       try {
// //          // Find the render box of the context to position the share sheet on iPad
// //          final RenderBox? box = context.findRenderObject() as RenderBox?;
// //          // Use the share_plus package to initiate sharing
// //          await Share.share(
// //            shareText, // The text content to share
// //            subject: 'Venue Recommendation: $name', // Optional subject, mainly for email
// //             // Provides positioning reference for iPad share popovers
// //            sharePositionOrigin: box != null ? box.localToGlobal(Offset.zero) & box.size : null
// //         );
// //       } catch (e) {
// //         debugPrint("Error sharing: $e");
// //          if (mounted) {
// //              ScaffoldMessenger.of(context)
// //                  .showSnackBar(const SnackBar(content: Text("Could not open share options.")));
// //          }
// //       }
// //     }

// //   // Navigates to the Venue Availability Screen
// //   void _navigateToBookingScreen() {
// //       // Ensure venue data is loaded
// //       if (_venueData == null) return;
// //       // Ensure user is logged in
// //       if (_authService.getCurrentUser() == null) {
// //          if (!mounted) return;
// //          ScaffoldMessenger.of(context).showSnackBar(
// //            const SnackBar(content: Text("Please log in to book a venue.")),
// //          );
// //          return;
// //       }

// //       // Extract booking-related info, providing safe defaults
// //       final bool bookingEnabled = _venueData!['bookingEnabled'] as bool? ?? false;
// //        final int slotDuration = (_venueData!['slotDurationMinutes'] as num?)?.toInt() ?? 60; // Default to 60 min
// //       final Map<String, dynamic>? operatingHours = _venueData!['operatingHours'] as Map<String, dynamic>?; // Can be null

// //       // Check if booking is enabled and hours are configured
// //       if (!bookingEnabled) {
// //          if (!mounted) return;
// //          ScaffoldMessenger.of(context).showSnackBar(
// //            const SnackBar(content: Text("Bookings are not enabled for this venue.")),
// //          );
// //          return;
// //       }
// //        if (operatingHours == null || operatingHours.isEmpty) {
// //            if (!mounted) return;
// //            ScaffoldMessenger.of(context).showSnackBar(
// //             const SnackBar(content: Text("Booking hours are not set up for this venue.")),
// //            );
// //            return;
// //        }

// //       // Navigate to the availability screen, passing required parameters
// //       Navigator.push(
// //         context,
// //         MaterialPageRoute(
// //           builder: (context) => VenueAvailabilityScreen(
// //              venueId: widget.venueId, // Current venue ID
// //              venueName: _venueData!['name'] as String? ?? 'Venue', // Venue name for display
// //              operatingHours: operatingHours, // Pass the operating hours map
// //              slotDurationMinutes: slotDuration, // Pass slot duration
// //            ),
// //          ),
// //        );
// //    }


// //   @override
// //   Widget build(BuildContext context) {
// //      String appBarTitle = 'Loading...'; // Default title while loading
// //      // Determine if content can be shown based on loading state and data presence
// //      final bool canShowContent = !_isLoadingDetails && _venueData != null;

// //      // Set AppBar title based on state
// //      if (canShowContent) {
// //        appBarTitle = _venueData!['name'] as String? ?? 'Venue Details';
// //      } else if (_errorMessage != null && _venueData == null) { // Show error title only if initial load failed
// //        appBarTitle = 'Error Loading Venue';
// //      }

// //      // Determine if the Book Now button should be shown
// //      final bool showBookButton = canShowContent && (_venueData!['bookingEnabled'] as bool? ?? false);

// //      return Scaffold(
// //        appBar: AppBar(
// //          title: Text(appBarTitle, overflow: TextOverflow.ellipsis), // Prevent long titles overflowing
// //          actions: [
// //            // Share button - only shown when content is ready
// //            if (canShowContent)
// //              IconButton(
// //                icon: const Icon(Icons.share_outlined),
// //                tooltip: 'Share Venue',
// //                onPressed: _shareVenue,
// //              ),
// //             // Favorite button - shown if content is ready and user is logged in
// //            if (canShowContent && _authService.getCurrentUser() != null)
// //              IconButton(
// //                icon: _isLoadingFavorite // Show spinner while loading fav status
// //                    ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
// //                    : Icon( // Show filled or bordered heart based on state
// //                        _isFavorite ? Icons.favorite : Icons.favorite_border,
// //                        color: _isFavorite ? Colors.redAccent[100] : null, // Light red when favorited
// //                        semanticLabel: _isFavorite ? 'Remove from favorites' : 'Add to favorites',
// //                      ),
// //                tooltip: _isFavorite ? 'Remove from Favorites' : 'Add to Favorites',
// //                onPressed: _toggleFavorite, // Action to toggle favorite
// //              ),
// //          ],
// //        ),
// //         // Use RefreshIndicator for pull-to-refresh functionality
// //        body: RefreshIndicator(
// //            onRefresh: _fetchAllDetails, // Call fetch function on refresh
// //            child: _buildBody(canShowContent), // Build the main body content
// //         ),
// //         // Display Floating Action Button for booking if enabled and loaded
// //         floatingActionButton: showBookButton
// //             ? FloatingActionButton.extended(
// //                 onPressed: _navigateToBookingScreen, // Navigate to booking screen
// //                 icon: const Icon(Icons.calendar_today_outlined),
// //                 label: const Text('Check Availability & Book'),
// //                 tooltip: 'Check Availability & Book',
// //                )
// //             : null, // Show no FAB if booking isn't enabled/loaded
// //           // Position FAB based on whether booking is enabled to avoid overlap with potential review button
// //        floatingActionButtonLocation: showBookButton ? FloatingActionButtonLocation.centerFloat : FloatingActionButtonLocation.endFloat,
// //      );
// //    }

// //    // Builds the main content body of the screen
// //   Widget _buildBody(bool canShowContent) {
// //      // Show loading indicator if details are loading and no initial data exists
// //      if (_isLoadingDetails && _venueData == null) {
// //        return const Center(child: CircularProgressIndicator());
// //      }
// //       // Show error message if the initial load failed completely
// //      if (_errorMessage != null && _venueData == null) {
// //         return Center(
// //           child: Padding(
// //             padding: const EdgeInsets.all(16.0),
// //             child: Column(
// //                mainAxisAlignment: MainAxisAlignment.center,
// //                children: [
// //                   const Icon(Icons.error_outline, color: Colors.red, size: 50),
// //                   const SizedBox(height: 10),
// //                   Text(_errorMessage!, style: TextStyle(color: Colors.red[700], fontSize: 16), textAlign: TextAlign.center),
// //                   const SizedBox(height: 10),
// //                    ElevatedButton.icon( // Add a retry button
// //                       icon: const Icon(Icons.refresh),
// //                       label: const Text("Try Again"),
// //                       onPressed: _fetchAllDetails,
// //                    ),
// //                 ],
// //              ),
// //            ),
// //         );
// //       }
// //      // Fallback if data somehow becomes null after initial check (shouldn't usually happen)
// //      if (!canShowContent || _venueData == null) {
// //        return const Center(child: Text('Venue data not available.'));
// //      }


// //      // --- Extract data safely now that _venueData is guaranteed non-null ---
// //      final String name = _venueData!['name'] as String? ?? 'Unnamed Venue';
// //      final String description = _venueData!['description'] as String? ?? 'No description provided.';
// //      final String address = _venueData!['address'] as String? ?? 'Address not available';
// //      final String city = _venueData!['city'] as String? ?? 'Unknown City';
// //      final String country = _venueData!['country'] as String? ?? 'Unknown Country';
// //      final dynamic sportRaw = _venueData!['sportType'];
// //      final String? imageUrl = _venueData!['imageUrl'] as String?;
// //      final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
// //      final String? phoneNumber = _venueData!['phoneNumber'] as String?;
// //      final String? website = _venueData!['website'] as String?;
// //      final String? openingHours = _venueData!['openingHours'] as String?;
// //      final List<String> facilities = (_venueData!['facilities'] as List<dynamic>?)
// //              ?.cast<String>() // Ensure elements are Strings
// //              .where((f) => f.isNotEmpty) // Filter out empty strings if any
// //              .toList() ?? []; // Default to empty list if null
// //      final bool bookingEnabled = _venueData!['bookingEnabled'] as bool? ?? false;

// //      // Process sport types list into a display string
// //      String sport = 'Various Sports'; // Default value
// //      if (sportRaw is String && sportRaw.isNotEmpty) {
// //          sport = sportRaw; // Use directly if it's a non-empty string
// //      } else if (sportRaw is List && sportRaw.isNotEmpty) {
// //          sport = sportRaw.whereType<String>().where((s) => s.isNotEmpty).join(', '); // Join non-empty strings
// //          if (sport.isEmpty) sport = 'Various Sports'; // Fallback if list had only empty strings
// //       }
// //       // Combine address parts into a single display string
// //      final String fullAddress = [address, city, country].where((s) => s.isNotEmpty).join(', ');


// //      // Build the scrollable column layout
// //      return SingleChildScrollView(
// //        padding: const EdgeInsets.only(bottom: 90), // Padding at the bottom to avoid overlap with FAB
// //        child: Column(
// //          crossAxisAlignment: CrossAxisAlignment.start, // Align content to the start
// //          children: [
// //            // --- Venue Image Section ---
// //             // Display image if available and valid URL, using Hero animation
// //            if (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// //              Hero(
// //                tag: 'venue_image_${widget.venueId}', // Unique tag for animation
// //                child: Image.network(
// //                  imageUrl,
// //                  height: 250, // Fixed height for the image
// //                  width: double.infinity, // Take full width
// //                  fit: BoxFit.cover, // Cover the area, cropping if necessary
// //                  errorBuilder: (context, error, stackTrace) => Container( // Placeholder on error
// //                      height: 250, color: Colors.grey[200],
// //                      child: const Center(child: Icon(Icons.broken_image_outlined, size: 50, color: Colors.grey))),
// //                  loadingBuilder: (context, child, loadingProgress) { // Show loading indicator
// //                    if (loadingProgress == null) return child; // Image loaded
// //                    return Container(
// //                        height: 250, color: Colors.grey[100],
// //                        child: Center(child: CircularProgressIndicator(
// //                                strokeWidth: 2,
// //                                value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null // Show progress % if possible
// //                            )));
// //                    },
// //                ),
// //              )
// //            else // Fallback placeholder if no valid image URL
// //              Container(
// //                  height: 250,
// //                  color: Theme.of(context).primaryColor.withOpacity(0.1), // Use theme color with opacity
// //                  child: Center(child: Icon(Icons.sports_rounded, size: 80, color: Theme.of(context).primaryColor.withOpacity(0.6)))),


// //            // --- Main Content Area with Padding ---
// //             Padding(
// //               padding: const EdgeInsets.symmetric(horizontal: 16.0).copyWith(top: 16.0), // Add horizontal and top padding
// //               child: Column(
// //                  crossAxisAlignment: CrossAxisAlignment.start,
// //                  children: [
// //                     // Venue Name
// //                     Text(name, style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
// //                     const SizedBox(height: 12), // Spacing

// //                     // --- Average Rating Display ---
// //                      Row(
// //                        children: [
// //                          // Show rating bar if rating is > 0
// //                           if (_averageRating > 0)
// //                            IgnorePointer( // Make the bar non-interactive
// //                              child: RatingBar.builder(
// //                                 initialRating: _averageRating,
// //                                 minRating: 1, // Minimum rating value
// //                                 direction: Axis.horizontal,
// //                                 allowHalfRating: true, // Allow showing half stars
// //                                 itemCount: 5, // Number of stars
// //                                 itemSize: 22.0, // Size of the stars
// //                                 itemPadding: const EdgeInsets.symmetric(horizontal: 0.0), // No horizontal padding between stars
// //                                 itemBuilder: (context, _) => const Icon(Icons.star, color: Colors.amber), // Star icon
// //                                 onRatingUpdate: (rating) {}, // Callback not used for display
// //                               ),
// //                            )
// //                           // Show "No reviews yet" if loaded and rating is 0
// //                          else if (!_isLoadingReviews) // Only show if reviews have been checked
// //                             const Text("No reviews yet", style: TextStyle(color: Colors.grey)),

// //                          // Display numerical rating and count if available
// //                           if (_averageRating > 0)
// //                            Padding(
// //                              padding: const EdgeInsets.only(left: 8.0),
// //                              child: Text(
// //                                // Format average rating to one decimal place, show review count
// //                                '${_averageRating.toStringAsFixed(1)} ($_reviewCount review${_reviewCount != 1 ? 's' : ''})',
// //                                style: TextStyle(fontSize: 15, color: Colors.grey[700]),
// //                              ),
// //                            ),
// //                          // Show a small spinner while reviews are initially loading if count is 0
// //                          if (_isLoadingReviews && _reviewCount == 0)
// //                            const Padding(
// //                              padding: EdgeInsets.only(left: 8.0),
// //                              child: SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 1.5)),
// //                            ),
// //                        ],
// //                      ),
// //                     const SizedBox(height: 12), // Spacing

// //                     // --- Detailed Info Rows ---
// //                      _buildInfoRow(context, Icons.location_on_outlined, fullAddress), // Display combined address
// //                      _buildInfoRow(context, Icons.fitness_center, sport, iconColor: Colors.deepPurple[300]), // Display sports
// //                      // Conditionally display Phone number if available, make tappable
// //                      if (phoneNumber != null && phoneNumber.isNotEmpty)
// //                         _buildInfoRow(context, Icons.phone_outlined, phoneNumber, onTap: () => _launchUrl('tel:$phoneNumber')),
// //                      // Conditionally display Website if available and valid, make tappable
// //                      if (website != null && website.isNotEmpty)
// //                          _buildInfoRow(context, Icons.language_outlined, website, onTap: () => _launchUrl(website)),
// //                       // Conditionally display Opening Hours if available
// //                      if (openingHours != null && openingHours.isNotEmpty)
// //                          _buildInfoRow(context, Icons.access_time_outlined, openingHours),

// //                     // --- Description Section ---
// //                     Text('Description', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)), // Section title
// //                     const SizedBox(height: 6), // Spacing
// //                      // Display description or fallback text
// //                      Text(
// //                         description.isEmpty ? 'No description available.' : description,
// //                         style: const TextStyle(fontSize: 15, height: 1.4), // Style for readability
// //                        ),

// //                     // --- Facilities Section ---
// //                     // Only show section if facilities list is not empty
// //                     if (facilities.isNotEmpty) ...[
// //                         const SizedBox(height: 16), // Spacing before section
// //                         Text('Facilities', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)), // Section title
// //                         const SizedBox(height: 8), // Spacing
// //                          // Use Wrap to display facility chips, handling overflow
// //                          Wrap(
// //                            spacing: 8.0, // Horizontal spacing between chips
// //                            runSpacing: 4.0, // Vertical spacing between lines of chips
// //                            children: facilities.map((facility) => Chip(
// //                                   label: Text(facility),
// //                                   avatar: _getFacilityIcon(facility), // Add relevant icon if available
// //                                   padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4), // Chip padding
// //                                   labelStyle: const TextStyle(fontSize: 13), // Style for chip text
// //                                )).toList(), // Convert mapped chips to a list
// //                           )
// //                       ]

// //                   ],
// //               ),
// //            ), // End Main Content Padding


// //           // --- Reviews Section ---
// //           // --- Reviews Section Separator and Title/Button Row ---
// // const Divider(height: 30, thickness: 1, indent: 16, endIndent: 16),
// // Padding(
// //     padding: const EdgeInsets.symmetric(horizontal: 16.0).copyWith(bottom: 4), // Reduce bottom padding if needed
// //     child: Row( // Use Row to place title and button side-by-side
// //        mainAxisAlignment: MainAxisAlignment.spaceBetween, // Push items to ends
// //        crossAxisAlignment: CrossAxisAlignment.center, // Align items vertically
// //        children: [
// //           // Section Title (Takes available space)
// //           Flexible( // Use Flexible so Title doesn't overflow if button is wide
// //             child: Text(
// //                'Reviews (${_reviewCount})',
// //                style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
// //                 overflow: TextOverflow.ellipsis, // Prevent overflow if title is very long
// //               ),
// //            ),

// //           // Write Review Button (Only show if user is logged in)
// //            if (_authService.getCurrentUser() != null) // Check if logged in
// //               TextButton.icon(
// //                  onPressed: _showAddReviewDialog, // Call your existing dialog function
// //                  icon: const Icon(Icons.edit_note_outlined, size: 18),
// //                  label: const Text("Write"),
// //                  style: TextButton.styleFrom(
// //                    // Optional: customize padding, color etc.
// //                     padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
// //                     // foregroundColor: Theme.of(context).primaryColor,
// //                    visualDensity: VisualDensity.compact, // Makes button a bit smaller
// //                  ),
// //                ),
// //         ],
// //      ),
// //  ),
// //  _buildReviewsList(), // The actual list of reviews// Build the list of reviews


// //           // --- Map Section ---
// //           const Divider(height: 40, thickness: 1, indent: 16, endIndent: 16), // Separator line
// //            Padding(
// //                padding: const EdgeInsets.symmetric(horizontal: 16.0),
// //               child: Text('Location on Map', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)), // Section title
// //            ),
// //            const SizedBox(height: 10), // Spacing
// //             // Conditionally display Google Map if location data exists
// //            if (geoPoint != null)
// //              Container(
// //                height: 250, // Fixed height for the map container
// //                margin: const EdgeInsets.symmetric(horizontal: 16.0), // Margin around map
// //                clipBehavior: Clip.antiAlias, // Clip map to rounded corners
// //                decoration: BoxDecoration(
// //                    borderRadius: BorderRadius.circular(8), // Rounded corners
// //                    border: Border.all(color: Colors.grey[300]!) // Subtle border
// //                ),
// //                child: GoogleMap(
// //                  onMapCreated: _onMapCreated, // Callback when map is ready
// //                  initialCameraPosition: CameraPosition( // Initial camera view
// //                     target: LatLng(geoPoint.latitude, geoPoint.longitude), // Center on venue
// //                     zoom: 14.5, // Zoom level
// //                    ),
// //                  markers: _markers, // Set of markers to display (just the one for the venue)
// //                  zoomControlsEnabled: true, // Show zoom buttons
// //                  mapType: MapType.normal, // Standard map type
// //                 ),
// //              )
// //            else // Display message if map location is not available
// //              const Padding(
// //                padding: EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
// //                child: Center(child: Text('Map location not available for this venue.', style: TextStyle(color: Colors.grey))),
// //              ),


// //            const SizedBox(height: 20), // Final spacing at the bottom

// //           ],
// //        ),
// //      );
// //    }

// //   // Helper widget to build consistently styled info rows (Icon + Text)
// //   Widget _buildInfoRow(BuildContext context, IconData icon, String text, {Color? iconColor, VoidCallback? onTap}) {
// //       final color = iconColor ?? Colors.grey[700]; // Default icon color
// //       final style = TextStyle(fontSize: 15, color: Colors.grey[800], height: 1.3); // Text style
// //       // Row containing the icon and text
// //       Widget content = Row(
// //          crossAxisAlignment: CrossAxisAlignment.start, // Align items to the top
// //          children: [
// //             Padding(
// //                padding: const EdgeInsets.only(top: 2.0, right: 10.0), // Align icon nicely with text
// //                child: Icon(icon, size: 20, color: color), // Icon display
// //              ),
// //              Expanded(child: Text(text, style: style)), // Text, expands to fill space
// //           ],
// //         );
// //      // Wrap with InkWell for tappable feedback if onTap is provided
// //      return Padding(
// //        padding: const EdgeInsets.symmetric(vertical: 6.0), // Vertical spacing for the row
// //        child: onTap != null
// //            ? InkWell(
// //                onTap: onTap, // Action to perform on tap
// //                borderRadius: BorderRadius.circular(4), // Feedback shape
// //                child: Padding(padding: const EdgeInsets.symmetric(vertical: 4.0), child: content)) // Inner padding for tap area
// //            : content, // Return row directly if not tappable
// //       );
// //    }

// //    // Helper widget to build the list of reviews
// //   Widget _buildReviewsList() {
// //       // Show loading indicator while reviews are loading
// //       if (_isLoadingReviews) {
// //         // Use a less intrusive loading indicator for refreshes
// //          return const Padding(padding: EdgeInsets.symmetric(vertical: 30.0), child: Center(child: Text("Loading reviews...", style: TextStyle(color: Colors.grey))));
// //       }
// //       // Show message if no reviews are available
// //       if (_reviews.isEmpty) {
// //          return const Padding(
// //            padding: EdgeInsets.symmetric(vertical: 30.0, horizontal: 16.0),
// //             child: Center(child: Text("Be the first to write a review!", style: TextStyle(color: Colors.grey, fontSize: 16))),
// //           );
// //        }
// //       // Build the list using ListView.separated for dividers between items
// //       return ListView.separated(
// //          shrinkWrap: true, // Prevent unbounded height in Column
// //          physics: const NeverScrollableScrollPhysics(), // Disable ListView's own scrolling
// //          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0), // Padding around the list
// //          itemCount: _reviews.length, // Number of reviews
// //          itemBuilder: (context, index) {
// //            // Build each list item using the ReviewListItem widget
// //            return ReviewListItem(reviewData: _reviews[index]);
// //          },
// //          separatorBuilder: (context, index) => const Divider(height: 1), // Add divider between reviews
// //        );
// //    }

// //   // Helper to get an icon based on facility name (case-insensitive)
// //   Widget? _getFacilityIcon(String facilityName) {
// //       // Map of facility names (lowercase) to icons
// //      final Map<String, IconData> facilityIcons = {
// //        'parking': Icons.local_parking,
// //        'car parking': Icons.local_parking,
// //        'wifi': Icons.wifi,
// //        'wi-fi': Icons.wifi,
// //        'showers': Icons.shower,
// //        'lockers': Icons.lock_outline,
// //        'equipment rental': Icons.build_outlined,
// //        'rental': Icons.build_outlined,
// //        'first aid': Icons.medical_services_outlined,
// //        'refreshments': Icons.fastfood_outlined,
// //        'cafe': Icons.local_cafe_outlined,
// //        'food': Icons.restaurant_outlined,
// //        'changing rooms': Icons.checkroom_outlined,
// //        'changing room': Icons.checkroom_outlined,
// //        'washroom': Icons.wc_outlined,
// //        'restroom': Icons.wc_outlined,
// //        'toilets': Icons.wc_outlined,
// //        'wheelchair accessible': Icons.accessible_forward,
// //      };

// //      String lowerCaseFacility = facilityName.toLowerCase().trim(); // Normalize input
// //      IconData? iconData = facilityIcons[lowerCaseFacility]; // Lookup icon

// //      // Return Icon widget if found, otherwise null
// //      if (iconData != null) {
// //          return Icon(iconData, size: 16, color: Colors.grey[700]);
// //      }
// //      return null;
// //    }

// // } // End of _VenueDetailScreenState class


// import 'package:flutter/material.dart';
// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:google_maps_flutter/google_maps_flutter.dart';
// import 'package:mm_associates/features/bookings/screens/venue_availability_screen.dart';
// import 'package:mm_associates/features/data/services/firestore_service.dart';
// import 'package:mm_associates/features/home/widgets/full_screen_image_viewer.dart';
// import 'package:mm_associates/features/user/services/user_service.dart';
// import 'package:mm_associates/features/auth/services/auth_service.dart';
// import 'package:mm_associates/features/reviews/widgets/add_review_dialog.dart';
// import 'package:mm_associates/features/reviews/widgets/review_list_item.dart';
// import 'package:url_launcher/url_launcher.dart';
// import 'package:flutter_rating_bar/flutter_rating_bar.dart';
// import 'package:share_plus/share_plus.dart';

// // Import the new fullscreen image viewer

// class VenueDetailScreen extends StatefulWidget {
//   final String venueId;
//   final Map<String, dynamic>? initialVenueData;

//   const VenueDetailScreen({
//     super.key,
//     required this.venueId,
//     this.initialVenueData,
//   });

//   @override
//   State<VenueDetailScreen> createState() => _VenueDetailScreenState();
// }

// class _VenueDetailScreenState extends State<VenueDetailScreen> {
//   final FirestoreService _firestoreService = FirestoreService();
//   final UserService _userService = UserService();
//   final AuthService _authService = AuthService();

//   Map<String, dynamic>? _venueData;
//   bool _isLoadingDetails = true;
//   String? _errorMessage;
//   GoogleMapController? _mapController;
//   Set<Marker> _markers = {};

//   List<Map<String, dynamic>> _reviews = [];
//   bool _isLoadingReviews = true;
//   bool _isFavorite = false;
//   bool _isLoadingFavorite = true;
//   double _averageRating = 0.0;
//   int _reviewCount = 0;

//   @override
//   void initState() {
//     super.initState();
//     _applyInitialData();
//     _fetchAllDetails();
//   }

//   void _applyInitialData() {
//     if (widget.initialVenueData != null && widget.initialVenueData!.isNotEmpty) {
//       _venueData = widget.initialVenueData;
//       _averageRating =
//           (widget.initialVenueData!['averageRating'] as num?)?.toDouble() ??
//               0.0;
//       _reviewCount =
//           (widget.initialVenueData!['reviewCount'] as num?)?.toInt() ?? 0;
//       _isLoadingDetails = false;
//       _setupMapMarker();
//     } else {
//       _isLoadingDetails = true;
//     }
//   }

//   @override
//   void dispose() {
//     _mapController?.dispose();
//     super.dispose();
//   }

//   Future<void> _fetchAllDetails() async {
//     if (!mounted) return;
//     setState(() {
//       if (_venueData == null) _isLoadingDetails = true;
//       _isLoadingReviews = true;
//       _isLoadingFavorite = true;
//       _errorMessage = null;
//     });

//     try {
//       final results = await Future.wait([
//         _firestoreService.getVenueDetails(widget.venueId),
//         _firestoreService.getReviewsForVenue(widget.venueId, limit: 50),
//         _authService.getCurrentUser() != null
//             ? _userService.isVenueFavorite(widget.venueId)
//             : Future.value(false),
//       ]);

//       final venueDetailsData = results[0] as Map<String, dynamic>?;
//       final reviewsData = results[1] as List<Map<String, dynamic>>;
//       final isFavoriteData = results[2] as bool;

//       if (mounted) {
//         if (venueDetailsData != null) {
//           setState(() {
//             _venueData = venueDetailsData;
//             _reviews = reviewsData;
//             _isFavorite = isFavoriteData;
//             _calculateAverageRating();
//             _isLoadingDetails = false;
//             _isLoadingReviews = false;
//             _isLoadingFavorite = false;
//             _errorMessage = null;
//             _setupMapMarker();
//           });
//         } else {
//           setState(() {
//             _isLoadingDetails = false;
//             _isLoadingReviews = false;
//             _isLoadingFavorite = false;
//             _errorMessage = 'Venue details not found.';
//           });
//         }
//       }
//     } catch (e) {
//       debugPrint("Error fetching venue details/reviews/fav status: $e");
//       if (mounted) {
//          if (_venueData == null) {
//              setState(() {
//                  _isLoadingDetails = false;
//                  _isLoadingReviews = false;
//                  _isLoadingFavorite = false;
//                  _errorMessage = 'Failed to load venue details. Please try again.';
//              });
//          } else {
//              ScaffoldMessenger.of(context).showSnackBar(SnackBar(
//                  content: Text(
//                    "Could not refresh all details: ${e.toString().replaceFirst("Exception: ", "")}",
//                     maxLines: 2, overflow: TextOverflow.ellipsis,
//                  ),
//                  backgroundColor: Colors.orangeAccent,
//               ));
//              setState(() {
//                 _isLoadingReviews = false;
//                 _isLoadingFavorite = false;
//               });
//            }
//         }
//     }
//   }

//   void _calculateAverageRating() {
//     if (!mounted) return;
//     if (_reviews.isEmpty) {
//       setState(() {
//         _averageRating = 0.0;
//         _reviewCount = 0;
//       });
//       return;
//     }
//     double totalRating = 0;
//     for (var review in _reviews) {
//       totalRating += (review['rating'] as num?)?.toDouble() ?? 0.0;
//     }
//     setState(() {
//       _reviewCount = _reviews.length;
//       _averageRating = (totalRating / _reviewCount * 10).round() / 10;
//     });
//   }

//   void _setupMapMarker() {
//     if (_venueData == null || !mounted) return;

//     final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
//     final String name = _venueData!['name'] as String? ?? 'Venue Location';
//     final String address = _venueData!['address'] as String? ?? '';

//     if (geoPoint != null) {
//       final marker = Marker(
//         markerId: MarkerId(widget.venueId),
//         position: LatLng(geoPoint.latitude, geoPoint.longitude),
//         infoWindow: InfoWindow(title: name, snippet: address),
//       );
//       setState(() {
//         _markers = {marker};
//       });

//       _mapController?.animateCamera(
//         CameraUpdate.newLatLngZoom(
//             LatLng(geoPoint.latitude, geoPoint.longitude), 14.5),
//       );
//     } else {
//       setState(() {
//         _markers = {};
//       });
//     }
//   }

//   void _onMapCreated(GoogleMapController controller) {
//      if (!mounted) return;
//     _mapController = controller;
//     _setupMapMarker();
//   }

//   Future<void> _launchUrl(String urlString) async {
//      if (!mounted) return;
//      final Uri url = Uri.parse(urlString);
//      try {
//         bool canLaunch = await canLaunchUrl(url);
//         if (canLaunch) {
//            if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
//              throw 'Could not launch $urlString';
//            }
//         } else {
//            throw 'Could not launch $urlString';
//          }
//      } catch (e) {
//         debugPrint("Error launching URL: $e");
//         if (mounted)
//          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
//              content: Text('Could not open link: ${e.toString().replaceFirst("Exception: ", "")}'),
//              backgroundColor: Colors.redAccent));
//      }
//    }

//   Future<void> _toggleFavorite() async {
//      if (_authService.getCurrentUser() == null) {
//         if (!mounted) return;
//        ScaffoldMessenger.of(context).showSnackBar(
//            const SnackBar(content: Text("Please log in to manage favorites.")));
//        return;
//      }
//      if (_isLoadingFavorite || !mounted) return;

//      setState(() => _isLoadingFavorite = true);
//      final originalFavStatus = _isFavorite;

//      try {
//        if (_isFavorite) {
//          await _userService.removeFavorite(widget.venueId);
//        } else {
//          await _userService.addFavorite(widget.venueId);
//        }
//        if (mounted) {
//          setState(() {
//            _isFavorite = !_isFavorite;
//             ScaffoldMessenger.of(context).showSnackBar(
//                SnackBar(
//                    content: Text(_isFavorite ? "Added to Favorites" : "Removed from Favorites"),
//                    duration: const Duration(seconds: 2)
//                ),
//             );
//          });
//        }
//      } catch (e) {
//        debugPrint("Error toggling favorite: $e");
//         if (mounted) {
//           setState(() {
//               _isFavorite = originalFavStatus;
//           });
//          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
//              content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"),
//              backgroundColor: Colors.redAccent));
//        }
//      } finally {
//        if (mounted) setState(() => _isLoadingFavorite = false);
//      }
//    }

//   void _showAddReviewDialog() {
//      if (_authService.getCurrentUser() == null) {
//         if (!mounted) return;
//        ScaffoldMessenger.of(context).showSnackBar(
//            const SnackBar(content: Text("Please log in to write a review.")));
//        return;
//      }
//      if (_venueData == null) return;

//      showDialog<bool>(
//        context: context,
//        barrierDismissible: false,
//        builder: (BuildContext context) {
//          return AddReviewDialog(venueId: widget.venueId);
//        },
//      ).then((success) {
//        if (success == true && mounted) {
//          _fetchAllDetails();
//        }
//      });
//    }

//   Future<void> _shareVenue() async {
//       if (_venueData == null) {
//          if (!mounted) return;
//          ScaffoldMessenger.of(context)
//              .showSnackBar(const SnackBar(content: Text("Venue data not loaded yet.")));
//          return;
//       }

//       final String name = _venueData!['name'] as String? ?? 'This Venue';
//       final String address = _venueData!['address'] as String? ?? '';
//       final String city = _venueData!['city'] as String? ?? '';
//       final String? website = _venueData!['website'] as String?;
//       final String? googleMapsUrl = _venueData!['googleMapsUrl'] as String?; // Get Google Maps URL


//       final String locationInfo = [address, city].where((s) => s.isNotEmpty).join(', ');
//       String shareText = 'Check out this venue: $name';
//       if (locationInfo.isNotEmpty) {
//          shareText += '\nLocated at: $locationInfo';
//       }

//       // Prefer Google Maps link if available for sharing location
//       if (googleMapsUrl != null && googleMapsUrl.isNotEmpty && Uri.tryParse(googleMapsUrl)?.isAbsolute == true) {
//         shareText += '\nFind it on Google Maps: $googleMapsUrl';
//       } else if (website != null && website.isNotEmpty) {
//            final uri = Uri.tryParse(website);
//            if (uri != null && uri.isAbsolute) {
//               shareText += '\nWebsite: $website';
//            }
//       }

//       try {
//          final RenderBox? box = context.findRenderObject() as RenderBox?;
//          await Share.share(
//            shareText,
//            subject: 'Venue Recommendation: $name',
//            sharePositionOrigin: box != null ? box.localToGlobal(Offset.zero) & box.size : null
//         );
//       } catch (e) {
//         debugPrint("Error sharing: $e");
//          if (mounted) {
//              ScaffoldMessenger.of(context)
//                  .showSnackBar(const SnackBar(content: Text("Could not open share options.")));
//          }
//       }
//     }

//   void _navigateToBookingScreen() {
//       if (_venueData == null) return;
//       if (_authService.getCurrentUser() == null) {
//          if (!mounted) return;
//          ScaffoldMessenger.of(context).showSnackBar(
//            const SnackBar(content: Text("Please log in to book a venue.")),
//          );
//          return;
//       }

//       final bool bookingEnabled = _venueData!['bookingEnabled'] as bool? ?? false;
//        final int slotDuration = (_venueData!['slotDurationMinutes'] as num?)?.toInt() ?? 60;
//       final Map<String, dynamic>? operatingHours = _venueData!['operatingHours'] as Map<String, dynamic>?;

//       if (!bookingEnabled) {
//          if (!mounted) return;
//          ScaffoldMessenger.of(context).showSnackBar(
//            const SnackBar(content: Text("Bookings are not enabled for this venue.")),
//          );
//          return;
//       }
//        if (operatingHours == null || operatingHours.isEmpty) {
//            if (!mounted) return;
//            ScaffoldMessenger.of(context).showSnackBar(
//             const SnackBar(content: Text("Booking hours are not set up for this venue.")),
//            );
//            return;
//        }
//       Navigator.push(
//         context,
//         MaterialPageRoute(
//           builder: (context) => VenueAvailabilityScreen(
//              venueId: widget.venueId,
//              venueName: _venueData!['name'] as String? ?? 'Venue',
//              operatingHours: operatingHours,
//              slotDurationMinutes: slotDuration,
//            ),
//          ),
//        );
//    }


//   @override
//   Widget build(BuildContext context) {
//      String appBarTitle = 'Loading...';
//      final bool canShowContent = !_isLoadingDetails && _venueData != null;

//      if (canShowContent) {
//        appBarTitle = _venueData!['name'] as String? ?? 'Venue Details';
//      } else if (_errorMessage != null && _venueData == null) {
//        appBarTitle = 'Error Loading Venue';
//      }

//      final bool showBookButton = canShowContent && (_venueData!['bookingEnabled'] as bool? ?? false);

//      return Scaffold(
//        appBar: AppBar(
//          title: Text(appBarTitle, overflow: TextOverflow.ellipsis),
//          actions: [
//            if (canShowContent)
//              IconButton(
//                icon: const Icon(Icons.share_outlined),
//                tooltip: 'Share Venue',
//                onPressed: _shareVenue,
//              ),
//            if (canShowContent && _authService.getCurrentUser() != null)
//              IconButton(
//                icon: _isLoadingFavorite
//                    ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
//                    : Icon(
//                        _isFavorite ? Icons.favorite : Icons.favorite_border,
//                        color: _isFavorite ? Colors.redAccent[100] : null,
//                        semanticLabel: _isFavorite ? 'Remove from favorites' : 'Add to favorites',
//                      ),
//                tooltip: _isFavorite ? 'Remove from Favorites' : 'Add to Favorites',
//                onPressed: _toggleFavorite,
//              ),
//          ],
//        ),
//        body: RefreshIndicator(
//            onRefresh: _fetchAllDetails,
//            child: _buildBody(canShowContent),
//         ),
//         floatingActionButton: showBookButton
//             ? FloatingActionButton.extended(
//                 onPressed: _navigateToBookingScreen,
//                 icon: const Icon(Icons.calendar_today_outlined),
//                 label: const Text('Check Availability & Book'),
//                 tooltip: 'Check Availability & Book',
//                )
//             : null,
//        floatingActionButtonLocation: showBookButton ? FloatingActionButtonLocation.centerFloat : FloatingActionButtonLocation.endFloat,
//      );
//    }

//   Widget _buildBody(bool canShowContent) {
//      if (_isLoadingDetails && _venueData == null) {
//        return const Center(child: CircularProgressIndicator());
//      }
//      if (_errorMessage != null && _venueData == null) {
//         return Center(
//           child: Padding(
//             padding: const EdgeInsets.all(16.0),
//             child: Column(
//                mainAxisAlignment: MainAxisAlignment.center,
//                children: [
//                   const Icon(Icons.error_outline, color: Colors.red, size: 50),
//                   const SizedBox(height: 10),
//                   Text(_errorMessage!, style: TextStyle(color: Colors.red[700], fontSize: 16), textAlign: TextAlign.center),
//                   const SizedBox(height: 10),
//                    ElevatedButton.icon(
//                       icon: const Icon(Icons.refresh),
//                       label: const Text("Try Again"),
//                       onPressed: _fetchAllDetails,
//                    ),
//                 ],
//              ),
//            ),
//         );
//       }
//      if (!canShowContent || _venueData == null) {
//        return const Center(child: Text('Venue data not available.'));
//      }

//      final String name = _venueData!['name'] as String? ?? 'Unnamed Venue';
//      final String description = _venueData!['description'] as String? ?? 'No description provided.';
//      final String address = _venueData!['address'] as String? ?? 'Address not available';
//      final String city = _venueData!['city'] as String? ?? 'Unknown City';
//      final String country = _venueData!['country'] as String? ?? 'Unknown Country';
//      final dynamic sportRaw = _venueData!['sportType'];
//      final String? imageUrl = _venueData!['imageUrl'] as String?;
//      final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
//      final String? phoneNumber = _venueData!['phoneNumber'] as String?;
//      final String? website = _venueData!['website'] as String?;
//      final Map<String, dynamic>? operatingHoursMap = _venueData!['operatingHours'] as Map<String, dynamic>?; // Use this for passing to booking screen
//      final List<String> facilities = (_venueData!['facilities'] as List<dynamic>?)
//              ?.cast<String>()
//              .where((f) => f.isNotEmpty)
//              .toList() ?? [];
//     //  final bool bookingEnabled = _venueData!['bookingEnabled'] as bool? ?? false;
//      final String? googleMapsUrl = _venueData!['googleMapsUrl'] as String?; // <<<< GET googleMapsUrl


//      String sport = 'Various Sports';
//      if (sportRaw is String && sportRaw.isNotEmpty) {
//          sport = sportRaw;
//      } else if (sportRaw is List && sportRaw.isNotEmpty) {
//          sport = sportRaw.whereType<String>().where((s) => s.isNotEmpty).join(', ');
//          if (sport.isEmpty) sport = 'Various Sports';
//       }
//      final String fullAddress = [address, city, country].where((s) => s.isNotEmpty).join(', ');
//       String openingHoursDisplay = "Not specified"; // Default for display
//         if (operatingHoursMap != null) {
//           final weekday = operatingHoursMap['weekday'];
//           if (weekday != null && weekday['start'] != null && weekday['end'] != null) {
//             if (weekday['start'].isNotEmpty || weekday['end'].isNotEmpty) {
//                openingHoursDisplay = "Weekdays: ${weekday['start']} - ${weekday['end']}";
//              }
//            }
//           // You could add more complex logic here to format Saturday/Sunday hours too
//          }

//      return SingleChildScrollView(
//        padding: const EdgeInsets.only(bottom: 90),
//        child: Column(
//          crossAxisAlignment: CrossAxisAlignment.start,
//          children: [
//            if (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
//              GestureDetector( // <<<< WRAPPED WITH GESTUREDETECTOR
//                onTap: () {
//                  Navigator.push(context, MaterialPageRoute(builder: (_) {
//                    return FullScreenImageViewer(imageUrl: imageUrl, heroTag: 'venue_image_${widget.venueId}');
//                  }));
//                },
//                child: Hero(
//                  tag: 'venue_image_${widget.venueId}',
//                  child: Image.network(
//                    imageUrl,
//                    height: 250,
//                    width: double.infinity,
//                    fit: BoxFit.cover,
//                    errorBuilder: (context, error, stackTrace) => Container(
//                        height: 250, color: Colors.grey[200],
//                        child: const Center(child: Icon(Icons.broken_image_outlined, size: 50, color: Colors.grey))),
//                    loadingBuilder: (context, child, loadingProgress) {
//                      if (loadingProgress == null) return child;
//                      return Container(
//                          height: 250, color: Colors.grey[100],
//                          child: Center(child: CircularProgressIndicator(
//                                  strokeWidth: 2,
//                                  value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null
//                              )));
//                      },
//                  ),
//                ),
//              )
//            else
//              Container(
//                  height: 250,
//                  color: Theme.of(context).primaryColor.withOpacity(0.1),
//                  child: Center(child: Icon(Icons.sports_rounded, size: 80, color: Theme.of(context).primaryColor.withOpacity(0.6)))),

//             Padding(
//               padding: const EdgeInsets.symmetric(horizontal: 16.0).copyWith(top: 16.0),
//               child: Column(
//                  crossAxisAlignment: CrossAxisAlignment.start,
//                  children: [
//                     Text(name, style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
//                     const SizedBox(height: 12),
//                      Row(
//                        children: [
//                           if (_averageRating > 0)
//                            IgnorePointer(
//                              child: RatingBar.builder(
//                                 initialRating: _averageRating,
//                                 minRating: 1,
//                                 direction: Axis.horizontal,
//                                 allowHalfRating: true,
//                                 itemCount: 5,
//                                 itemSize: 22.0,
//                                 itemPadding: const EdgeInsets.symmetric(horizontal: 0.0),
//                                 itemBuilder: (context, _) => const Icon(Icons.star, color: Colors.amber),
//                                 onRatingUpdate: (rating) {},
//                               ),
//                            )
//                          else if (!_isLoadingReviews)
//                             const Text("No reviews yet", style: TextStyle(color: Colors.grey)),
//                           if (_averageRating > 0)
//                            Padding(
//                              padding: const EdgeInsets.only(left: 8.0),
//                              child: Text(
//                                '${_averageRating.toStringAsFixed(1)} ($_reviewCount review${_reviewCount != 1 ? 's' : ''})',
//                                style: TextStyle(fontSize: 15, color: Colors.grey[700]),
//                              ),
//                            ),
//                          if (_isLoadingReviews && _reviewCount == 0)
//                            const Padding(
//                              padding: EdgeInsets.only(left: 8.0),
//                              child: SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 1.5)),
//                            ),
//                        ],
//                      ),
//                     const SizedBox(height: 12),
//                      _buildInfoRow(context, Icons.location_on_outlined, fullAddress),
//                      _buildInfoRow(context, Icons.fitness_center, sport, iconColor: Colors.deepPurple[300]),
//                      if (phoneNumber != null && phoneNumber.isNotEmpty)
//                         _buildInfoRow(context, Icons.phone_outlined, phoneNumber, onTap: () => _launchUrl('tel:$phoneNumber')),
//                      if (website != null && website.isNotEmpty)
//                          _buildInfoRow(context, Icons.language_outlined, website, onTap: () => _launchUrl(website)),
//                     _buildInfoRow(context, Icons.access_time_outlined, openingHoursDisplay),


//                     Text('Description', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
//                     const SizedBox(height: 6),
//                      Text(
//                         description.isEmpty ? 'No description available.' : description,
//                         style: const TextStyle(fontSize: 15, height: 1.4),
//                        ),
//                     if (facilities.isNotEmpty) ...[
//                         const SizedBox(height: 16),
//                         Text('Facilities', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
//                         const SizedBox(height: 8),
//                          Wrap(
//                            spacing: 8.0,
//                            runSpacing: 4.0,
//                            children: facilities.map((facility) => Chip(
//                                   label: Text(facility),
//                                   avatar: _getFacilityIcon(facility),
//                                   padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
//                                   labelStyle: const TextStyle(fontSize: 13),
//                                )).toList(),
//                           )
//                       ]
//                   ],
//               ),
//            ),


//         const Divider(height: 30, thickness: 1, indent: 16, endIndent: 16),
//         Padding(
//             padding: const EdgeInsets.symmetric(horizontal: 16.0).copyWith(bottom: 4),
//             child: Row(
//                mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                crossAxisAlignment: CrossAxisAlignment.center,
//                children: [
//                   Flexible(
//                     child: Text(
//                        'Reviews ($_reviewCount)',
//                        style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
//                         overflow: TextOverflow.ellipsis,
//                       ),
//                    ),
//                    if (_authService.getCurrentUser() != null)
//                       TextButton.icon(
//                          onPressed: _showAddReviewDialog,
//                          icon: const Icon(Icons.edit_note_outlined, size: 18),
//                          label: const Text("Write"),
//                          style: TextButton.styleFrom(
//                             padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
//                            visualDensity: VisualDensity.compact,
//                          ),
//                        ),
//                 ],
//              ),
//          ),
//         _buildReviewsList(),


//           const Divider(height: 40, thickness: 1, indent: 16, endIndent: 16),
//            Padding(
//                padding: const EdgeInsets.symmetric(horizontal: 16.0),
//               child: Text('Location on Map', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
//            ),
//            const SizedBox(height: 5),
//            if (googleMapsUrl != null && googleMapsUrl.isNotEmpty && Uri.tryParse(googleMapsUrl)?.isAbsolute == true)
//              Padding(
//                padding: const EdgeInsets.only(top: 12.0, left: 16.0, right: 16.0, bottom: 10.0),
//                child: Center(
//                  child: OutlinedButton.icon(
//                    icon: const Icon(Icons.open_in_new_outlined, size: 18),
//                    label: const Text('Open in Google Maps'),
//                    onPressed: () => _launchUrl(googleMapsUrl),
//                    style: OutlinedButton.styleFrom(
//                      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
//                      // side: BorderSide(color: Theme.of(context).primaryColor),
//                    ),
//                  ),
//                ),
//              ),
//            const SizedBox(height: 20),
//           ],
//        ),
//      );
//    }

//   Widget _buildInfoRow(BuildContext context, IconData icon, String text, {Color? iconColor, VoidCallback? onTap}) {
//       final color = iconColor ?? Colors.grey[700];
//       final style = TextStyle(fontSize: 15, color: Colors.grey[800], height: 1.3);
//       Widget content = Row(
//          crossAxisAlignment: CrossAxisAlignment.start,
//          children: [
//             Padding(
//                padding: const EdgeInsets.only(top: 2.0, right: 10.0),
//                child: Icon(icon, size: 20, color: color),
//              ),
//              Expanded(child: Text(text, style: style)),
//           ],
//         );
//      return Padding(
//        padding: const EdgeInsets.symmetric(vertical: 6.0),
//        child: onTap != null
//            ? InkWell(
//                onTap: onTap,
//                borderRadius: BorderRadius.circular(4),
//                child: Padding(padding: const EdgeInsets.symmetric(vertical: 4.0), child: content))
//            : content,
//       );
//    }

//   Widget _buildReviewsList() {
//       if (_isLoadingReviews) {
//          return const Padding(padding: EdgeInsets.symmetric(vertical: 30.0), child: Center(child: Text("Loading reviews...", style: TextStyle(color: Colors.grey))));
//       }
//       if (_reviews.isEmpty) {
//          return const Padding(
//            padding: EdgeInsets.symmetric(vertical: 30.0, horizontal: 16.0),
//             child: Center(child: Text("Be the first to write a review!", style: TextStyle(color: Colors.grey, fontSize: 16))),
//           );
//        }
//       return ListView.separated(
//          shrinkWrap: true,
//          physics: const NeverScrollableScrollPhysics(),
//          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
//          itemCount: _reviews.length,
//          itemBuilder: (context, index) {
//            return ReviewListItem(reviewData: _reviews[index]);
//          },
//          separatorBuilder: (context, index) => const Divider(height: 1),
//        );
//    }

//   Widget? _getFacilityIcon(String facilityName) {
//      final Map<String, IconData> facilityIcons = {
//        'parking': Icons.local_parking,
//        'car parking': Icons.local_parking,
//        'wifi': Icons.wifi,
//        'wi-fi': Icons.wifi,
//        'showers': Icons.shower,
//        'lockers': Icons.lock_outline,
//        'equipment rental': Icons.build_outlined,
//        'rental': Icons.build_outlined,
//        'first aid': Icons.medical_services_outlined,
//        'refreshments': Icons.fastfood_outlined,
//        'cafe': Icons.local_cafe_outlined,
//        'food': Icons.restaurant_outlined,
//        'changing rooms': Icons.checkroom_outlined,
//        'changing room': Icons.checkroom_outlined,
//        'washroom': Icons.wc_outlined,
//        'restroom': Icons.wc_outlined,
//        'toilets': Icons.wc_outlined,
//        'wheelchair accessible': Icons.accessible_forward,
//      };

//      String lowerCaseFacility = facilityName.toLowerCase().trim();
//      IconData? iconData = facilityIcons[lowerCaseFacility];

//      if (iconData != null) {
//          return Icon(iconData, size: 16, color: Colors.grey[700]);
//      }
//      return null;
//    }
// }

// lib/features/home/screens/venue_detail_screen.dart

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:mm_associates/features/bookings/screens/venue_availability_screen.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';
// Ensure this path is correct for your project structure
import 'package:mm_associates/features/home/widgets/full_screen_image_viewer.dart';
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:mm_associates/features/reviews/widgets/add_review_dialog.dart';
import 'package:mm_associates/features/reviews/widgets/review_list_item.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:flutter_rating_bar/flutter_rating_bar.dart';
import 'package:share_plus/share_plus.dart';


class VenueDetailScreen extends StatefulWidget {
  final String venueId;
  final Map<String, dynamic>? initialVenueData;

  const VenueDetailScreen({
    super.key,
    required this.venueId,
    this.initialVenueData,
  });

  @override
  State<VenueDetailScreen> createState() => _VenueDetailScreenState();
}

class _VenueDetailScreenState extends State<VenueDetailScreen> {
  final FirestoreService _firestoreService = FirestoreService();
  final UserService _userService = UserService();
  final AuthService _authService = AuthService();

  Map<String, dynamic>? _venueData;
  bool _isLoadingDetails = true;
  String? _errorMessage;
  GoogleMapController? _mapController;
  Set<Marker> _markers = {};

  List<Map<String, dynamic>> _reviews = [];
  bool _isLoadingReviews = true;
  bool _isFavorite = false;
  bool _isLoadingFavorite = true;
  double _averageRating = 0.0;
  int _reviewCount = 0;

  @override
  void initState() {
    super.initState();
    _applyInitialData();
    _fetchAllDetails();
  }

  void _applyInitialData() {
    if (widget.initialVenueData != null && widget.initialVenueData!.isNotEmpty) {
      _venueData = widget.initialVenueData;
      _averageRating =
          (widget.initialVenueData!['averageRating'] as num?)?.toDouble() ??
              0.0;
      _reviewCount =
          (widget.initialVenueData!['reviewCount'] as num?)?.toInt() ?? 0;
      _isLoadingDetails = false;
      _setupMapMarker();
    } else {
      _isLoadingDetails = true;
    }
  }

  @override
  void dispose() {
    _mapController?.dispose();
    super.dispose();
  }

  Future<void> _fetchAllDetails() async {
    if (!mounted) return;
    setState(() {
      if (_venueData == null) _isLoadingDetails = true;
      _isLoadingReviews = true;
      _isLoadingFavorite = true;
      _errorMessage = null;
    });

    try {
      final results = await Future.wait([
        _firestoreService.getVenueDetails(widget.venueId),
        _firestoreService.getReviewsForVenue(widget.venueId, limit: 50),
        _authService.getCurrentUser() != null
            ? _userService.isVenueFavorite(widget.venueId)
            : Future.value(false),
      ]);

      final venueDetailsData = results[0] as Map<String, dynamic>?;
      final reviewsData = results[1] as List<Map<String, dynamic>>;
      final isFavoriteData = results[2] as bool;

      if (mounted) {
        if (venueDetailsData != null) {
          setState(() {
            _venueData = venueDetailsData;
            _reviews = reviewsData;
            _isFavorite = isFavoriteData;
            _calculateAverageRating();
            _isLoadingDetails = false;
            _isLoadingReviews = false;
            _isLoadingFavorite = false;
            _errorMessage = null;
            _setupMapMarker();
          });
        } else {
          setState(() {
            _isLoadingDetails = false;
            _isLoadingReviews = false;
            _isLoadingFavorite = false;
            _errorMessage = 'Venue details not found.';
          });
        }
      }
    } catch (e) {
      debugPrint("Error fetching venue details/reviews/fav status: $e");
      if (mounted) {
         if (_venueData == null) {
             setState(() {
                 _isLoadingDetails = false;
                 _isLoadingReviews = false;
                 _isLoadingFavorite = false;
                 _errorMessage = 'Failed to load venue details. Please try again.';
             });
         } else {
             ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                 content: Text(
                   "Could not refresh all details: ${e.toString().replaceFirst("Exception: ", "")}",
                    maxLines: 2, overflow: TextOverflow.ellipsis,
                 ),
                 backgroundColor: Colors.orangeAccent,
              ));
             setState(() {
                _isLoadingReviews = false;
                _isLoadingFavorite = false;
              });
           }
        }
    }
  }

  void _calculateAverageRating() {
    if (!mounted) return;
    if (_reviews.isEmpty) {
      setState(() {
        _averageRating = 0.0;
        _reviewCount = 0;
      });
      return;
    }
    double totalRating = 0;
    for (var review in _reviews) {
      totalRating += (review['rating'] as num?)?.toDouble() ?? 0.0;
    }
    setState(() {
      _reviewCount = _reviews.length;
      _averageRating = (totalRating / _reviewCount * 10).round() / 10;
    });
  }

  void _setupMapMarker() {
    if (_venueData == null || !mounted) return;

    final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
    final String name = _venueData!['name'] as String? ?? 'Venue Location';
    final String address = _venueData!['address'] as String? ?? '';

    if (geoPoint != null) {
      final marker = Marker(
        markerId: MarkerId(widget.venueId),
        position: LatLng(geoPoint.latitude, geoPoint.longitude),
        infoWindow: InfoWindow(title: name, snippet: address),
      );
      setState(() {
        _markers = {marker};
      });

      _mapController?.animateCamera(
        CameraUpdate.newLatLngZoom(
            LatLng(geoPoint.latitude, geoPoint.longitude), 14.5),
      );
    } else {
      setState(() {
        _markers = {};
      });
    }
  }

  void _onMapCreated(GoogleMapController controller) {
     if (!mounted) return;
    _mapController = controller;
    _setupMapMarker();
  }

  Future<void> _launchUrl(String urlString) async {
     if (!mounted) return;
     final Uri url = Uri.parse(urlString);
     try {
        bool canLaunch = await canLaunchUrl(url);
        if (canLaunch) {
           if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
             throw 'Could not launch $urlString';
           }
        } else {
           throw 'Could not launch $urlString';
         }
     } catch (e) {
        debugPrint("Error launching URL: $e");
        if (mounted)
         ScaffoldMessenger.of(context).showSnackBar(SnackBar(
             content: Text('Could not open link: ${e.toString().replaceFirst("Exception: ", "")}'),
             backgroundColor: Colors.redAccent));
     }
   }

  Future<void> _toggleFavorite() async {
     if (_authService.getCurrentUser() == null) {
        if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Please log in to manage favorites.")));
       return;
     }
     if (_isLoadingFavorite || !mounted) return;

     setState(() => _isLoadingFavorite = true);
     final originalFavStatus = _isFavorite;

     try {
       if (_isFavorite) {
         await _userService.removeFavorite(widget.venueId);
       } else {
         await _userService.addFavorite(widget.venueId);
       }
       if (mounted) {
         setState(() {
           _isFavorite = !_isFavorite;
            ScaffoldMessenger.of(context).showSnackBar(
               SnackBar(
                   content: Text(_isFavorite ? "Added to Favorites" : "Removed from Favorites"),
                   duration: const Duration(seconds: 2)
               ),
            );
         });
       }
     } catch (e) {
       debugPrint("Error toggling favorite: $e");
        if (mounted) {
          setState(() {
              _isFavorite = originalFavStatus;
          });
         ScaffoldMessenger.of(context).showSnackBar(SnackBar(
             content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"),
             backgroundColor: Colors.redAccent));
       }
     } finally {
       if (mounted) setState(() => _isLoadingFavorite = false);
     }
   }

  void _showAddReviewDialog() {
     if (_authService.getCurrentUser() == null) {
        if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Please log in to write a review.")));
       return;
     }
     if (_venueData == null) return;

     showDialog<bool>(
       context: context,
       barrierDismissible: false,
       builder: (BuildContext context) {
         return AddReviewDialog(venueId: widget.venueId);
       },
     ).then((success) {
       if (success == true && mounted) {
         _fetchAllDetails();
       }
     });
   }

  Future<void> _shareVenue() async {
      if (_venueData == null) {
         if (!mounted) return;
         ScaffoldMessenger.of(context)
             .showSnackBar(const SnackBar(content: Text("Venue data not loaded yet.")));
         return;
      }

      final String name = _venueData!['name'] as String? ?? 'This Venue';
      final String address = _venueData!['address'] as String? ?? '';
      final String city = _venueData!['city'] as String? ?? '';
      final String? website = _venueData!['website'] as String?;
      final String? googleMapsUrl = _venueData!['googleMapsUrl'] as String?;


      final String locationInfo = [address, city].where((s) => s.isNotEmpty).join(', ');
      String shareText = 'Check out this venue: $name';
      if (locationInfo.isNotEmpty) {
         shareText += '\nLocated at: $locationInfo';
      }

      if (googleMapsUrl != null && googleMapsUrl.isNotEmpty && Uri.tryParse(googleMapsUrl)?.isAbsolute == true) {
        shareText += '\nFind it on Google Maps: $googleMapsUrl';
      } else if (website != null && website.isNotEmpty) {
           final uri = Uri.tryParse(website);
           if (uri != null && uri.isAbsolute) {
              shareText += '\nWebsite: $website';
           }
      }

      try {
         final RenderBox? box = context.findRenderObject() as RenderBox?;
         await Share.share(
           shareText,
           subject: 'Venue Recommendation: $name',
           sharePositionOrigin: box != null ? box.localToGlobal(Offset.zero) & box.size : null
        );
      } catch (e) {
        debugPrint("Error sharing: $e");
         if (mounted) {
             ScaffoldMessenger.of(context)
                 .showSnackBar(const SnackBar(content: Text("Could not open share options.")));
         }
      }
    }

  void _navigateToBookingScreen() {
      if (_venueData == null) return;
      if (_authService.getCurrentUser() == null) {
         if (!mounted) return;
         ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Please log in to book a venue.")),
         );
         return;
      }

      final bool bookingEnabled = _venueData!['bookingEnabled'] as bool? ?? false;
       final int slotDuration = (_venueData!['slotDurationMinutes'] as num?)?.toInt() ?? 60;
      final Map<String, dynamic>? operatingHours = _venueData!['operatingHours'] as Map<String, dynamic>?;

      if (!bookingEnabled) {
         if (!mounted) return;
         ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Bookings are not enabled for this venue.")),
         );
         return;
      }
       if (operatingHours == null || operatingHours.isEmpty) {
           if (!mounted) return;
           ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("Booking hours are not set up for this venue.")),
           );
           return;
       }
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => VenueAvailabilityScreen(
             venueId: widget.venueId,
             venueName: _venueData!['name'] as String? ?? 'Venue',
             operatingHours: operatingHours,
             slotDurationMinutes: slotDuration,
           ),
         ),
       );
   }


  @override
  Widget build(BuildContext context) {
     String appBarTitle = 'Loading...';
     final bool canShowContent = !_isLoadingDetails && _venueData != null;

     if (canShowContent) {
       appBarTitle = _venueData!['name'] as String? ?? 'Venue Details';
     } else if (_errorMessage != null && _venueData == null) {
       appBarTitle = 'Error Loading Venue';
     }

     final bool showBookButton = canShowContent && (_venueData!['bookingEnabled'] as bool? ?? false);

     return Scaffold(
       appBar: AppBar(
         title: Text(appBarTitle, overflow: TextOverflow.ellipsis),
         actions: [
           if (canShowContent)
             IconButton(
               icon: const Icon(Icons.share_outlined),
               tooltip: 'Share Venue',
               onPressed: _shareVenue,
             ),
           if (canShowContent && _authService.getCurrentUser() != null)
             IconButton(
               icon: _isLoadingFavorite
                   ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                   : Icon(
                       _isFavorite ? Icons.favorite : Icons.favorite_border,
                       color: _isFavorite ? Colors.redAccent[100] : null,
                       semanticLabel: _isFavorite ? 'Remove from favorites' : 'Add to favorites',
                     ),
               tooltip: _isFavorite ? 'Remove from Favorites' : 'Add to Favorites',
               onPressed: _toggleFavorite,
             ),
         ],
       ),
       body: RefreshIndicator(
           onRefresh: _fetchAllDetails,
           child: _buildBody(canShowContent),
        ),
        floatingActionButton: showBookButton
            ? FloatingActionButton.extended(
                onPressed: _navigateToBookingScreen,
                icon: const Icon(Icons.calendar_today_outlined),
                label: const Text('Check Availability & Book'),
                tooltip: 'Check Availability & Book',
               )
            : null,
       floatingActionButtonLocation: showBookButton ? FloatingActionButtonLocation.centerFloat : FloatingActionButtonLocation.endFloat,
     );
   }

  Widget _buildBody(bool canShowContent) {
     if (_isLoadingDetails && _venueData == null) {
       return const Center(child: CircularProgressIndicator());
     }
     if (_errorMessage != null && _venueData == null) {
        return Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
                  const Icon(Icons.error_outline, color: Colors.red, size: 50),
                  const SizedBox(height: 10),
                  Text(_errorMessage!, style: TextStyle(color: Colors.red[700], fontSize: 16), textAlign: TextAlign.center),
                  const SizedBox(height: 10),
                   ElevatedButton.icon(
                      icon: const Icon(Icons.refresh),
                      label: const Text("Try Again"),
                      onPressed: _fetchAllDetails,
                   ),
                ],
             ),
           ),
        );
      }
     if (!canShowContent || _venueData == null) {
       return const Center(child: Text('Venue data not available.'));
     }

     final String name = _venueData!['name'] as String? ?? 'Unnamed Venue';
     final String description = _venueData!['description'] as String? ?? 'No description provided.';
     final String address = _venueData!['address'] as String? ?? 'Address not available';
     final String city = _venueData!['city'] as String? ?? 'Unknown City';
     final String country = _venueData!['country'] as String? ?? 'Unknown Country';
     final dynamic sportRaw = _venueData!['sportType'];
     final String? imageUrl = _venueData!['imageUrl'] as String?;
     final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
     final String? phoneNumber = _venueData!['phoneNumber'] as String?;
     final String? website = _venueData!['website'] as String?;
     final Map<String, dynamic>? operatingHoursMap = _venueData!['operatingHours'] as Map<String, dynamic>?;
     final List<String> facilities = (_venueData!['facilities'] as List<dynamic>?)
             ?.cast<String>()
             .where((f) => f.isNotEmpty)
             .toList() ?? [];
     final String? googleMapsUrl = _venueData!['googleMapsUrl'] as String?;


     String sport = 'Various Sports';
     if (sportRaw is String && sportRaw.isNotEmpty) {
         sport = sportRaw;
     } else if (sportRaw is List && sportRaw.isNotEmpty) {
         sport = sportRaw.whereType<String>().where((s) => s.isNotEmpty).join(', ');
         if (sport.isEmpty) sport = 'Various Sports';
      }
     final String fullAddress = [address, city, country].where((s) => s.isNotEmpty).join(', ');

    // --- MODIFIED: Operating Hours Display Logic ---
    String formatDayHours(Map<String, dynamic>? dayHours, String dayPrefix) {
      if (dayHours != null) {
        final String start = dayHours['start'] as String? ?? '';
        final String end = dayHours['end'] as String? ?? '';
        if (start.isNotEmpty && end.isNotEmpty) {
          return '$dayPrefix: $start - $end';
        }
      }
      return '$dayPrefix: N/A';
    }

    List<String> hoursParts = [];
    if (operatingHoursMap != null) {
      hoursParts.add(formatDayHours(operatingHoursMap['weekday'] as Map<String, dynamic>?, 'Mon-Fri'));
      hoursParts.add(formatDayHours(operatingHoursMap['saturday'] as Map<String, dynamic>?, 'Sat'));
      hoursParts.add(formatDayHours(operatingHoursMap['sunday'] as Map<String, dynamic>?, 'Sun'));
    }
    final String openingHoursDisplay = hoursParts.isNotEmpty ? hoursParts.join(', ') : "Not specified";
    // --- END MODIFIED: Operating Hours Display Logic ---

     return SingleChildScrollView(
       padding: const EdgeInsets.only(bottom: 90),
       child: Column(
         crossAxisAlignment: CrossAxisAlignment.start,
         children: [
           if (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
             GestureDetector(
               onTap: () {
                 Navigator.push(context, MaterialPageRoute(builder: (_) {
                   return FullScreenImageViewer(imageUrl: imageUrl, heroTag: 'venue_image_${widget.venueId}');
                 }));
               },
               child: Hero(
                 tag: 'venue_image_${widget.venueId}',
                 child: Image.network(
                   imageUrl,
                   height: 250, // Keep as is for banner consistency
                   width: double.infinity,
                   fit: BoxFit.cover,
                   // --- MODIFIED: Image Quality Settings ---
                   filterQuality: FilterQuality.medium, // Improved filter quality
                   cacheWidth: (MediaQuery.of(context).size.width * MediaQuery.of(context).devicePixelRatio).round(), // Hint for better cache resolution width
                   cacheHeight: (250 * MediaQuery.of(context).devicePixelRatio).round(), // Hint for better cache resolution height (250 is the display height)
                   // --- END MODIFIED ---
                   errorBuilder: (context, error, stackTrace) => Container(
                       height: 250, color: Colors.grey[200],
                       child: const Center(child: Icon(Icons.broken_image_outlined, size: 50, color: Colors.grey))),
                   loadingBuilder: (context, child, loadingProgress) {
                     if (loadingProgress == null) return child;
                     return Container(
                         height: 250, color: Colors.grey[100],
                         child: Center(child: CircularProgressIndicator(
                                 strokeWidth: 2,
                                 value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null
                             )));
                     },
                 ),
               ),
             )
           else
             Container(
                 height: 250,
                 color: Theme.of(context).primaryColor.withOpacity(0.1),
                 child: Center(child: Icon(Icons.sports_rounded, size: 80, color: Theme.of(context).primaryColor.withOpacity(0.6)))),

            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0).copyWith(top: 16.0),
              child: Column(
                 crossAxisAlignment: CrossAxisAlignment.start,
                 children: [
                    Text(name, style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
                    const SizedBox(height: 12),
                     Row(
                       children: [
                          if (_averageRating > 0)
                           IgnorePointer(
                             child: RatingBar.builder(
                                initialRating: _averageRating,
                                minRating: 1,
                                direction: Axis.horizontal,
                                allowHalfRating: true,
                                itemCount: 5,
                                itemSize: 22.0,
                                itemPadding: const EdgeInsets.symmetric(horizontal: 0.0),
                                itemBuilder: (context, _) => const Icon(Icons.star, color: Colors.amber),
                                onRatingUpdate: (rating) {},
                              ),
                           )
                         else if (!_isLoadingReviews)
                            const Text("No reviews yet", style: TextStyle(color: Colors.grey)),
                          if (_averageRating > 0)
                           Padding(
                             padding: const EdgeInsets.only(left: 8.0),
                             child: Text(
                               '${_averageRating.toStringAsFixed(1)} ($_reviewCount review${_reviewCount != 1 ? 's' : ''})',
                               style: TextStyle(fontSize: 15, color: Colors.grey[700]),
                             ),
                           ),
                         if (_isLoadingReviews && _reviewCount == 0)
                           const Padding(
                             padding: EdgeInsets.only(left: 8.0),
                             child: SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 1.5)),
                           ),
                       ],
                     ),
                    const SizedBox(height: 12),
                     _buildInfoRow(context, Icons.location_on_outlined, fullAddress),
                     _buildInfoRow(context, Icons.fitness_center, sport, iconColor: Colors.deepPurple[300]),
                     if (phoneNumber != null && phoneNumber.isNotEmpty)
                        _buildInfoRow(context, Icons.phone_outlined, phoneNumber, onTap: () => _launchUrl('tel:$phoneNumber')),
                     if (website != null && website.isNotEmpty)
                         _buildInfoRow(context, Icons.language_outlined, website, onTap: () => _launchUrl(website)),
                    _buildInfoRow(context, Icons.access_time_outlined, openingHoursDisplay), // Using the new combined display string


                    Text('Description', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
                    const SizedBox(height: 6),
                     Text(
                        description.isEmpty ? 'No description available.' : description,
                        style: const TextStyle(fontSize: 15, height: 1.4),
                       ),
                    if (facilities.isNotEmpty) ...[
                        const SizedBox(height: 16),
                        Text('Facilities', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
                        const SizedBox(height: 8),
                         Wrap(
                           spacing: 8.0,
                           runSpacing: 4.0,
                           children: facilities.map((facility) => Chip(
                                  label: Text(facility),
                                  avatar: _getFacilityIcon(facility),
                                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                  labelStyle: const TextStyle(fontSize: 13),
                               )).toList(),
                          )
                      ]
                  ],
              ),
           ),


        const Divider(height: 30, thickness: 1, indent: 16, endIndent: 16),
        Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0).copyWith(bottom: 4),
            child: Row(
               mainAxisAlignment: MainAxisAlignment.spaceBetween,
               crossAxisAlignment: CrossAxisAlignment.center,
               children: [
                  Flexible(
                    child: Text(
                       'Reviews ($_reviewCount)',
                       style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
                        overflow: TextOverflow.ellipsis,
                      ),
                   ),
                   if (_authService.getCurrentUser() != null)
                      TextButton.icon(
                         onPressed: _showAddReviewDialog,
                         icon: const Icon(Icons.edit_note_outlined, size: 18),
                         label: const Text("Write"),
                         style: TextButton.styleFrom(
                            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                           visualDensity: VisualDensity.compact,
                         ),
                       ),
                ],
             ),
         ),
        _buildReviewsList(),


          const Divider(height: 40, thickness: 1, indent: 16, endIndent: 16),
           Padding(
               padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text('Location on Map', style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
           ),
           const SizedBox(height: 1), 
           if (googleMapsUrl != null && googleMapsUrl.isNotEmpty && Uri.tryParse(googleMapsUrl)?.isAbsolute == true)
             Padding(
               padding: const EdgeInsets.fromLTRB(16.0, 12.0, 16.0, 10.0), // Symmetric padding is fine
               child: Center( // Button already centered, Center widget is okay.
                 child: OutlinedButton.icon(
                   icon: const Icon(Icons.open_in_new_outlined, size: 18),
                   label: const Text('Open in Google Maps'),
                   onPressed: () => _launchUrl(googleMapsUrl),
                   style: OutlinedButton.styleFrom(
                     padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                   ),
                 ),
               ),
             ),
           const SizedBox(height: 20),
          ],
       ),
     );
   }

  Widget _buildInfoRow(BuildContext context, IconData icon, String text, {Color? iconColor, VoidCallback? onTap}) {
      final color = iconColor ?? Colors.grey[700];
      final style = TextStyle(fontSize: 15, color: Colors.grey[800], height: 1.3);
      Widget content = Row(
         crossAxisAlignment: CrossAxisAlignment.start,
         children: [
            Padding(
               padding: const EdgeInsets.only(top: 2.0, right: 10.0),
               child: Icon(icon, size: 20, color: color),
             ),
             Expanded(child: Text(text, style: style)),
          ],
        );
     return Padding(
       padding: const EdgeInsets.symmetric(vertical: 6.0),
       child: onTap != null
           ? InkWell(
               onTap: onTap,
               borderRadius: BorderRadius.circular(4),
               child: Padding(padding: const EdgeInsets.symmetric(vertical: 4.0), child: content))
           : content,
      );
   }

  Widget _buildReviewsList() {
      if (_isLoadingReviews) {
         return const Padding(padding: EdgeInsets.symmetric(vertical: 30.0), child: Center(child: Text("Loading reviews...", style: TextStyle(color: Colors.grey))));
      }
      if (_reviews.isEmpty) {
         return const Padding(
           padding: EdgeInsets.symmetric(vertical: 30.0, horizontal: 16.0),
            child: Center(child: Text("Be the first to write a review!", style: TextStyle(color: Colors.grey, fontSize: 16))),
          );
       }
      return ListView.separated(
         shrinkWrap: true,
         physics: const NeverScrollableScrollPhysics(),
         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
         itemCount: _reviews.length,
         itemBuilder: (context, index) {
           return ReviewListItem(reviewData: _reviews[index]);
         },
         separatorBuilder: (context, index) => const Divider(height: 1),
       );
   }

  Widget? _getFacilityIcon(String facilityName) {
     final Map<String, IconData> facilityIcons = {
       'parking': Icons.local_parking,
       'car parking': Icons.local_parking,
       'wifi': Icons.wifi,
       'wi-fi': Icons.wifi,
       'showers': Icons.shower,
       'lockers': Icons.lock_outline,
       'equipment rental': Icons.build_outlined,
       'rental': Icons.build_outlined,
       'first aid': Icons.medical_services_outlined,
       'refreshments': Icons.fastfood_outlined,
       'cafe': Icons.local_cafe_outlined,
       'food': Icons.restaurant_outlined,
       'changing rooms': Icons.checkroom_outlined,
       'changing room': Icons.checkroom_outlined,
       'washroom': Icons.wc_outlined,
       'restroom': Icons.wc_outlined,
       'toilets': Icons.wc_outlined,
       'wheelchair accessible': Icons.accessible_forward,
     };

     String lowerCaseFacility = facilityName.toLowerCase().trim();
     IconData? iconData = facilityIcons[lowerCaseFacility];

     if (iconData != null) {
         return Icon(iconData, size: 16, color: Colors.grey[700]);
     }
     return null;
   }
}


===== features\home\screens\venue_detail_screen.dart =====

// features/home/screens/venue_detail_screen.dart

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:mm_associates/features/bookings/screens/venue_availability_screen.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:mm_associates/features/home/widgets/full_screen_image_viewer.dart';
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:mm_associates/features/reviews/widgets/add_review_dialog.dart';
import 'package:mm_associates/features/reviews/widgets/review_list_item.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:flutter_rating_bar/flutter_rating_bar.dart';
import 'package:share_plus/share_plus.dart';


class VenueDetailScreen extends StatefulWidget {
  final String venueId;
  final Map<String, dynamic>? initialVenueData;
  // <<< MODIFIED: Added heroTagContext to receive the section identifier >>>
  final String heroTagContext; 

  const VenueDetailScreen({
    super.key,
    required this.venueId,
    this.initialVenueData,
    required this.heroTagContext, // <<< MODIFIED: Made it required
  });

  @override
  State<VenueDetailScreen> createState() => _VenueDetailScreenState();
}

class _VenueDetailScreenState extends State<VenueDetailScreen> {
  // ... All the state variables and methods are exactly the same as before ...
  // ... The only change is in the build method where the Hero tag is constructed ...
  final FirestoreService _firestoreService = FirestoreService();
  final UserService _userService = UserService();
  final AuthService _authService = AuthService();

  Map<String, dynamic>? _venueData;
  bool _isLoadingDetails = true;
  String? _errorMessage;
  GoogleMapController? _mapController;
  Set<Marker> _markers = {};

  List<Map<String, dynamic>> _reviews = [];
  bool _isLoadingReviews = true;
  bool _isFavorite = false;
  bool _isLoadingFavorite = true;
  double _averageRating = 0.0;
  int _reviewCount = 0;

  @override
  void initState() {
    super.initState();
    _applyInitialData();
    _fetchAllDetails();
  }

  void _applyInitialData() {
    if (widget.initialVenueData != null && widget.initialVenueData!.isNotEmpty) {
      _venueData = widget.initialVenueData;
      _averageRating =
          (widget.initialVenueData!['averageRating'] as num?)?.toDouble() ??
              0.0;
      _reviewCount =
          (widget.initialVenueData!['reviewCount'] as num?)?.toInt() ?? 0;
      _isLoadingDetails = false;
      _setupMapMarker();
    } else {
      _isLoadingDetails = true;
    }
  }

  @override
  void dispose() {
    _mapController?.dispose();
    super.dispose();
  }

  Future<void> _fetchAllDetails() async {
    if (!mounted) return;
    setState(() {
      if (_venueData == null) _isLoadingDetails = true;
      _isLoadingReviews = true;
      _isLoadingFavorite = true;
      _errorMessage = null;
    });

    try {
      final results = await Future.wait([
        _firestoreService.getVenueDetails(widget.venueId),
        _firestoreService.getReviewsForVenue(widget.venueId, limit: 50),
        _authService.getCurrentUser() != null
            ? _userService.isVenueFavorite(widget.venueId)
            : Future.value(false),
      ]);

      final venueDetailsData = results[0] as Map<String, dynamic>?;
      final reviewsData = results[1] as List<Map<String, dynamic>>;
      final isFavoriteData = results[2] as bool;

      if (mounted) {
        if (venueDetailsData != null) {
          setState(() {
            _venueData = venueDetailsData;
            _reviews = reviewsData;
            _isFavorite = isFavoriteData;
            _calculateAverageRating();
            _isLoadingDetails = false;
            _isLoadingReviews = false;
            _isLoadingFavorite = false;
            _errorMessage = null;
            _setupMapMarker();
          });
        } else {
          setState(() {
            _isLoadingDetails = false;
            _isLoadingReviews = false;
            _isLoadingFavorite = false;
            _errorMessage = 'Venue details not found.';
          });
        }
      }
    } catch (e) {
      debugPrint("Error fetching venue details/reviews/fav status: $e");
      if (mounted) {
         if (_venueData == null) {
             setState(() {
                 _isLoadingDetails = false;
                 _isLoadingReviews = false;
                 _isLoadingFavorite = false;
                 _errorMessage = 'Failed to load venue details. Please try again.';
             });
         } else {
             ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                 content: Text(
                   "Could not refresh all details: ${e.toString().replaceFirst("Exception: ", "")}",
                    maxLines: 2, overflow: TextOverflow.ellipsis,
                 ),
                 backgroundColor: Colors.orangeAccent,
              ));
             setState(() {
                _isLoadingReviews = false;
                _isLoadingFavorite = false;
              });
           }
        }
    }
  }

  void _calculateAverageRating() {
    if (!mounted) return;
    if (_reviews.isEmpty) {
      setState(() {
        _averageRating = 0.0;
        _reviewCount = 0;
      });
      return;
    }
    double totalRating = 0;
    for (var review in _reviews) {
      totalRating += (review['rating'] as num?)?.toDouble() ?? 0.0;
    }
    setState(() {
      _reviewCount = _reviews.length;
      _averageRating = (totalRating / _reviewCount * 10).round() / 10;
    });
  }

  void _setupMapMarker() {
    if (_venueData == null || !mounted) return;

    final GeoPoint? geoPoint = _venueData!['location'] as GeoPoint?;
    final String name = _venueData!['name'] as String? ?? 'Venue Location';
    final String address = _venueData!['address'] as String? ?? '';

    if (geoPoint != null) {
      final marker = Marker(
        markerId: MarkerId(widget.venueId),
        position: LatLng(geoPoint.latitude, geoPoint.longitude),
        infoWindow: InfoWindow(title: name, snippet: address),
      );
      setState(() {
        _markers = {marker};
      });

      _mapController?.animateCamera(
        CameraUpdate.newLatLngZoom(
            LatLng(geoPoint.latitude, geoPoint.longitude), 14.5),
      );
    } else {
      setState(() {
        _markers = {};
      });
    }
  }

  void _onMapCreated(GoogleMapController controller) {
     if (!mounted) return;
    _mapController = controller;
    _setupMapMarker();
  }

  Future<void> _launchUrl(String urlString) async {
     if (!mounted) return;
     final Uri url = Uri.parse(urlString);
     try {
        bool canLaunch = await canLaunchUrl(url);
        if (canLaunch) {
           if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
             throw 'Could not launch $urlString';
           }
        } else {
           throw 'Could not launch $urlString';
         }
     } catch (e) {
        debugPrint("Error launching URL: $e");
        if (mounted)
         ScaffoldMessenger.of(context).showSnackBar(SnackBar(
             content: Text('Could not open link: ${e.toString().replaceFirst("Exception: ", "")}'),
             backgroundColor: Colors.redAccent));
     }
   }

  Future<void> _toggleFavorite() async {
     if (_authService.getCurrentUser() == null) {
        if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Please log in to manage favorites.")));
       return;
     }
     if (_isLoadingFavorite || !mounted) return;

     setState(() => _isLoadingFavorite = true);
     final originalFavStatus = _isFavorite;

     try {
       if (_isFavorite) {
         await _userService.removeFavorite(widget.venueId);
       } else {
         await _userService.addFavorite(widget.venueId);
       }
       if (mounted) {
         setState(() {
           _isFavorite = !_isFavorite;
            ScaffoldMessenger.of(context).showSnackBar(
               SnackBar(
                   content: Text(_isFavorite ? "Added to Favorites" : "Removed from Favorites"),
                   duration: const Duration(seconds: 2)
               ),
            );
         });
       }
     } catch (e) {
       debugPrint("Error toggling favorite: $e");
        if (mounted) {
          setState(() {
              _isFavorite = originalFavStatus;
          });
         ScaffoldMessenger.of(context).showSnackBar(SnackBar(
             content: Text("Error updating favorites: ${e.toString().replaceFirst("Exception: ", "")}"),
             backgroundColor: Colors.redAccent));
       }
     } finally {
       if (mounted) setState(() => _isLoadingFavorite = false);
     }
   }

  void _showAddReviewDialog() {
     if (_authService.getCurrentUser() == null) {
        if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Please log in to write a review.")));
       return;
     }
     if (_venueData == null) return;

     showDialog<bool>(
       context: context,
       barrierDismissible: false,
       builder: (BuildContext context) {
         return AddReviewDialog(venueId: widget.venueId);
       },
     ).then((success) {
       if (success == true && mounted) {
         _fetchAllDetails();
       }
     });
   }

  Future<void> _shareVenue() async {
      if (_venueData == null) {
         if (!mounted) return;
         ScaffoldMessenger.of(context)
             .showSnackBar(const SnackBar(content: Text("Venue data not loaded yet.")));
         return;
      }

      final String name = _venueData!['name'] as String? ?? 'This Venue';
      final String address = _venueData!['address'] as String? ?? '';
      final String city = _venueData!['city'] as String? ?? '';
      final String? website = _venueData!['website'] as String?;
      final String? googleMapsUrl = _venueData!['googleMapsUrl'] as String?;

      final String locationInfo = [address, city].where((s) => s.isNotEmpty).join(', ');
      String shareText = 'Check out this venue: $name';
      if (locationInfo.isNotEmpty) {
         shareText += '\nLocated at: $locationInfo';
      }

      if (googleMapsUrl != null && googleMapsUrl.isNotEmpty && Uri.tryParse(googleMapsUrl)?.isAbsolute == true) {
        shareText += '\nFind it on Google Maps: $googleMapsUrl';
      } else if (website != null && website.isNotEmpty) {
           final uri = Uri.tryParse(website);
           if (uri != null && uri.isAbsolute) {
              shareText += '\nWebsite: $website';
           }
      }

      try {
         final RenderBox? box = context.findRenderObject() as RenderBox?;
         await Share.share(
           shareText,
           subject: 'Venue Recommendation: $name',
           sharePositionOrigin: box != null ? box.localToGlobal(Offset.zero) & box.size : null
        );
      } catch (e) {
        debugPrint("Error sharing: $e");
         if (mounted) {
             ScaffoldMessenger.of(context)
                 .showSnackBar(const SnackBar(content: Text("Could not open share options.")));
         }
      }
    }

  void _navigateToBookingScreen() {
      if (_venueData == null) return;
      if (_authService.getCurrentUser() == null) {
         if (!mounted) return;
         ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Please log in to book a venue.")),
         );
         return;
      }

      final bool bookingEnabled = _venueData!['bookingEnabled'] as bool? ?? false;
       final int slotDuration = (_venueData!['slotDurationMinutes'] as num?)?.toInt() ?? 60;
      final Map<String, dynamic>? operatingHours = _venueData!['operatingHours'] as Map<String, dynamic>?;

      if (!bookingEnabled) {
         if (!mounted) return;
         ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text("Bookings are not enabled for this venue.")),
         );
         return;
      }
       if (operatingHours == null || operatingHours.isEmpty) {
           if (!mounted) return;
           ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("Booking hours are not set up for this venue.")),
           );
           return;
       }
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => VenueAvailabilityScreen(
             venueId: widget.venueId,
             venueName: _venueData!['name'] as String? ?? 'Venue',
             operatingHours: operatingHours,
             slotDurationMinutes: slotDuration,
           ),
         ),
       );
   }

  @override
  Widget build(BuildContext context) {
    String appBarTitle = 'Loading...';
    final bool canShowContent = !_isLoadingDetails && _venueData != null;

    if (canShowContent) {
      appBarTitle = _venueData!['name'] as String? ?? 'Venue Details';
    } else if (_errorMessage != null && _venueData == null) {
      appBarTitle = 'Error Loading Venue';
    }

    final bool showBookButton = canShowContent && (_venueData!['bookingEnabled'] as bool? ?? false);

    return Scaffold(
      appBar: AppBar(
        title: Text(appBarTitle, overflow: TextOverflow.ellipsis),
        actions: [
          if (canShowContent)
            IconButton(
              icon: const Icon(Icons.share_outlined),
              tooltip: 'Share Venue',
              onPressed: _shareVenue,
            ),
          if (canShowContent && _authService.getCurrentUser() != null)
            IconButton(
              icon: _isLoadingFavorite
                  ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                  : Icon(
                      _isFavorite ? Icons.favorite : Icons.favorite_border,
                      color: _isFavorite ? Colors.redAccent[100] : null,
                      semanticLabel: _isFavorite ? 'Remove from favorites' : 'Add to favorites',
                    ),
              tooltip: _isFavorite ? 'Remove from Favorites' : 'Add to Favorites',
              onPressed: _toggleFavorite,
            ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: _fetchAllDetails,
        child: _buildBody(canShowContent),
      ),
      floatingActionButton: showBookButton
          ? FloatingActionButton.extended(
              onPressed: _navigateToBookingScreen,
              icon: const Icon(Icons.calendar_today_outlined),
              label: const Text('Check Availability & Book'),
              tooltip: 'Check Availability & Book',
            )
          : null,
      floatingActionButtonLocation: showBookButton ? FloatingActionButtonLocation.centerFloat : FloatingActionButtonLocation.endFloat,
    );
  }

  Widget _buildBody(bool canShowContent) {
    if (_isLoadingDetails && _venueData == null) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_errorMessage != null && _venueData == null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, color: Colors.red, size: 50),
              const SizedBox(height: 10),
              Text(_errorMessage!, style: TextStyle(color: Colors.red[700], fontSize: 16), textAlign: TextAlign.center),
              const SizedBox(height: 10),
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh),
                label: const Text("Try Again"),
                onPressed: _fetchAllDetails,
              ),
            ],
          ),
        ),
      );
    }
    if (!canShowContent || _venueData == null) {
      return const Center(child: Text('Venue data not available.'));
    }

    final String name = _venueData!['name'] as String? ?? 'Unnamed Venue';
    final String description =
        _venueData!['description'] as String? ?? 'No description provided.';
    final String address = _venueData!['address'] as String? ?? 'Address not available';
    final String city = _venueData!['city'] as String? ?? 'Unknown City';
    final String country = _venueData!['country'] as String? ?? 'Unknown Country';
    final dynamic sportRaw = _venueData!['sportType'];
    final String? imageUrl = _venueData!['imageUrl'] as String?;
    final String? phoneNumber = _venueData!['phoneNumber'] as String?;
    final String? website = _venueData!['website'] as String?;
    final Map<String, dynamic>? operatingHoursMap =
        _venueData!['operatingHours'] as Map<String, dynamic>?;
    final List<String> facilities = (_venueData!['facilities'] as List<dynamic>?)
            ?.cast<String>()
            .where((f) => f.isNotEmpty)
            .toList() ??
        [];
    final String? googleMapsUrl = _venueData!['googleMapsUrl'] as String?;

    String sport = 'Various Sports';
    if (sportRaw is String && sportRaw.isNotEmpty) {
      sport = sportRaw;
    } else if (sportRaw is List && sportRaw.isNotEmpty) {
      sport = sportRaw.whereType<String>().where((s) => s.isNotEmpty).join(', ');
      if (sport.isEmpty) sport = 'Various Sports';
    }
    final String fullAddress = [address, city, country].where((s) => s.isNotEmpty).join(', ');
    
    String formatDayHours(Map<String, dynamic>? dayHours, String dayPrefix) {
      if (dayHours != null) {
        final String start = dayHours['start'] as String? ?? '';
        final String end = dayHours['end'] as String? ?? '';
        if (start.isNotEmpty && end.isNotEmpty) {
          return '$dayPrefix: $start - $end';
        }
      }
      return '$dayPrefix: N/A';
    }

    List<String> hoursParts = [];
    if (operatingHoursMap != null) {
      hoursParts.add(
          formatDayHours(operatingHoursMap['weekday'] as Map<String, dynamic>?, 'Mon-Fri'));
      hoursParts.add(formatDayHours(
          operatingHoursMap['saturday'] as Map<String, dynamic>?, 'Sat'));
      hoursParts.add(formatDayHours(
          operatingHoursMap['sunday'] as Map<String, dynamic>?, 'Sun'));
    }
    final String openingHoursDisplay =
        hoursParts.isNotEmpty ? hoursParts.join(', ') : "Not specified";

    return SingleChildScrollView(
      padding: const EdgeInsets.only(bottom: 90),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
            GestureDetector(
              onTap: () {
                // <<< MODIFIED: Create unique hero tag for full screen view >>>
                final heroTag = '${widget.heroTagContext}_venue_image_${widget.venueId}';
                Navigator.push(context, MaterialPageRoute(builder: (_) {
                  return FullScreenImageViewer(imageUrl: imageUrl, heroTag: heroTag);
                }));
              },
              child: Hero(
                // <<< MODIFIED: Construct Hero tag with the context >>>
                tag: '${widget.heroTagContext}_venue_image_${widget.venueId}',
                child: Image.network(
                  imageUrl,
                  height: 250,
                  width: double.infinity,
                  fit: BoxFit.cover,
                  filterQuality: FilterQuality.medium,
                  cacheWidth: (MediaQuery.of(context).size.width * MediaQuery.of(context).devicePixelRatio).round(),
                  cacheHeight: (250 * MediaQuery.of(context).devicePixelRatio).round(),
                  errorBuilder: (context, error, stackTrace) => Container(
                      height: 250,
                      color: Colors.grey[200],
                      child: const Center(
                          child: Icon(Icons.broken_image_outlined,
                              size: 50, color: Colors.grey))),
                  loadingBuilder: (context, child, loadingProgress) {
                    if (loadingProgress == null) return child;
                    return Container(
                        height: 250,
                        color: Colors.grey[100],
                        child: Center(
                            child: CircularProgressIndicator(
                                strokeWidth: 2,
                                value: loadingProgress.expectedTotalBytes != null
                                    ? loadingProgress.cumulativeBytesLoaded /
                                        loadingProgress.expectedTotalBytes!
                                    : null)));
                  },
                ),
              ),
            )
          else
            Container(
                height: 250,
                color: Theme.of(context).primaryColor.withOpacity(0.1),
                child: Center(
                    child: Icon(Icons.sports_rounded,
                        size: 80,
                        color:
                            Theme.of(context).primaryColor.withOpacity(0.6)))),
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0).copyWith(top: 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(name,
                    style: Theme.of(context)
                        .textTheme
                        .headlineSmall
                        ?.copyWith(fontWeight: FontWeight.bold)),
                const SizedBox(height: 12),
                Row(
                  children: [
                    if (_averageRating > 0)
                      IgnorePointer(
                        child: RatingBar.builder(
                          initialRating: _averageRating,
                          minRating: 1,
                          direction: Axis.horizontal,
                          allowHalfRating: true,
                          itemCount: 5,
                          itemSize: 22.0,
                          itemPadding:
                              const EdgeInsets.symmetric(horizontal: 0.0),
                          itemBuilder: (context, _) =>
                              const Icon(Icons.star, color: Colors.amber),
                          onRatingUpdate: (rating) {},
                        ),
                      )
                    else if (!_isLoadingReviews)
                      const Text("No reviews yet",
                          style: TextStyle(color: Colors.grey)),
                    if (_averageRating > 0)
                      Padding(
                        padding: const EdgeInsets.only(left: 8.0),
                        child: Text(
                          '${_averageRating.toStringAsFixed(1)} ($_reviewCount review${_reviewCount != 1 ? 's' : ''})',
                          style:
                              TextStyle(fontSize: 15, color: Colors.grey[700]),
                        ),
                      ),
                    if (_isLoadingReviews && _reviewCount == 0)
                      const Padding(
                        padding: EdgeInsets.only(left: 8.0),
                        child: SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 1.5)),
                      ),
                  ],
                ),
                const SizedBox(height: 12),
                _buildInfoRow(context, Icons.location_on_outlined, fullAddress),
                _buildInfoRow(context, Icons.fitness_center, sport,
                    iconColor: Colors.deepPurple[300]),
                if (phoneNumber != null && phoneNumber.isNotEmpty)
                  _buildInfoRow(context, Icons.phone_outlined, phoneNumber,
                      onTap: () => _launchUrl('tel:$phoneNumber')),
                if (website != null && website.isNotEmpty)
                  _buildInfoRow(context, Icons.language_outlined, website,
                      onTap: () => _launchUrl(website)),
                _buildInfoRow(context, Icons.access_time_outlined,
                    openingHoursDisplay),
                Text('Description',
                    style: Theme.of(context)
                        .textTheme
                        .titleMedium
                        ?.copyWith(fontWeight: FontWeight.w600)),
                const SizedBox(height: 6),
                Text(
                  description.isEmpty
                      ? 'No description available.'
                      : description,
                  style: const TextStyle(fontSize: 15, height: 1.4),
                ),
                if (facilities.isNotEmpty) ...[
                  const SizedBox(height: 16),
                  Text('Facilities',
                      style: Theme.of(context)
                          .textTheme
                          .titleMedium
                          ?.copyWith(fontWeight: FontWeight.w600)),
                  const SizedBox(height: 8),
                  Wrap(
                    spacing: 8.0,
                    runSpacing: 4.0,
                    children: facilities
                        .map((facility) => Chip(
                              label: Text(facility),
                              avatar: _getFacilityIcon(facility),
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8, vertical: 4),
                              labelStyle: const TextStyle(fontSize: 13),
                            ))
                        .toList(),
                  )
                ]
              ],
            ),
          ),
          const Divider(height: 30, thickness: 1, indent: 16, endIndent: 16),
          Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0).copyWith(bottom: 4),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Flexible(
                  child: Text(
                    'Reviews ($_reviewCount)',
                    style: Theme.of(context)
                        .textTheme
                        .titleMedium
                        ?.copyWith(fontWeight: FontWeight.w600),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                if (_authService.getCurrentUser() != null)
                  TextButton.icon(
                    onPressed: _showAddReviewDialog,
                    icon: const Icon(Icons.edit_note_outlined, size: 18),
                    label: const Text("Write"),
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 10, vertical: 6),
                      visualDensity: VisualDensity.compact,
                    ),
                  ),
              ],
            ),
          ),
          _buildReviewsList(),
          const Divider(height: 40, thickness: 1, indent: 16, endIndent: 16),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text('Location on Map',
                style: Theme.of(context)
                    .textTheme
                    .titleMedium
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
          const SizedBox(height: 5),
          if (googleMapsUrl != null &&
              googleMapsUrl.isNotEmpty &&
              Uri.tryParse(googleMapsUrl)?.isAbsolute == true)
            Padding(
              padding:
                  const EdgeInsets.only(top: 12.0, left: 16.0, right: 16.0, bottom: 10.0),
              child: Center(
                child: OutlinedButton.icon(
                  icon: const Icon(Icons.open_in_new_outlined, size: 18),
                  label: const Text('Open in Google Maps'),
                  onPressed: () => _launchUrl(googleMapsUrl),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 20, vertical: 12),
                  ),
                ),
              ),
            ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }

  Widget _buildInfoRow(BuildContext context, IconData icon, String text,
      {Color? iconColor, VoidCallback? onTap}) {
    final color = iconColor ?? Colors.grey[700];
    final style = TextStyle(fontSize: 15, color: Colors.grey[800], height: 1.3);
    Widget content = Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(top: 2.0, right: 10.0),
          child: Icon(icon, size: 20, color: color),
        ),
        Expanded(child: Text(text, style: style)),
      ],
    );
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: onTap != null
          ? InkWell(
              onTap: onTap,
              borderRadius: BorderRadius.circular(4),
              child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: 4.0),
                  child: content))
          : content,
    );
  }

  Widget _buildReviewsList() {
    if (_isLoadingReviews) {
      return const Padding(
          padding: EdgeInsets.symmetric(vertical: 30.0),
          child: Center(
              child: Text("Loading reviews...",
                  style: TextStyle(color: Colors.grey))));
    }
    if (_reviews.isEmpty) {
      return const Padding(
        padding: EdgeInsets.symmetric(vertical: 30.0, horizontal: 16.0),
        child: Center(
            child: Text("Be the first to write a review!",
                style: TextStyle(color: Colors.grey, fontSize: 16))),
      );
    }
    return ListView.separated(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      itemCount: _reviews.length,
      itemBuilder: (context, index) {
        return ReviewListItem(reviewData: _reviews[index]);
      },
      separatorBuilder: (context, index) => const Divider(height: 1),
    );
  }

  Widget? _getFacilityIcon(String facilityName) {
    final Map<String, IconData> facilityIcons = {
      'parking': Icons.local_parking,
      'car parking': Icons.local_parking,
      'wifi': Icons.wifi,
      'wi-fi': Icons.wifi,
      'showers': Icons.shower,
      'lockers': Icons.lock_outline,
      'equipment rental': Icons.build_outlined,
      'rental': Icons.build_outlined,
      'first aid': Icons.medical_services_outlined,
      'refreshments': Icons.fastfood_outlined,
      'cafe': Icons.local_cafe_outlined,
      'food': Icons.restaurant_outlined,
      'changing rooms': Icons.checkroom_outlined,
      'changing room': Icons.checkroom_outlined,
      'washroom': Icons.wc_outlined,
      'restroom': Icons.wc_outlined,
      'toilets': Icons.wc_outlined,
      'wheelchair accessible': Icons.accessible_forward,
    };

    String lowerCaseFacility = facilityName.toLowerCase().trim();
    IconData? iconData = facilityIcons[lowerCaseFacility];

    if (iconData != null) {
      return Icon(iconData, size: 16, color: Colors.grey[700]);
    }
    return null;
  }
}


===== features\home\screens\venue_form copy.dart =====

// // // // // // // // // import 'dart:async';
// // // // // // // // // import 'dart:io'; // For File, used for non-web image preview

// // // // // // // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // // // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // // // // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // // // // // // // import 'package:flutter/material.dart';
// // // // // // // // // import 'package:geolocator/geolocator.dart';
// // // // // // // // // import 'package:image_picker/image_picker.dart';

// // // // // // // // // import '../../../../core/services/geocoding_service.dart';
// // // // // // // // // import '../../../../core/services/image_upload_service.dart'; // Your updated ImageUploadService
// // // // // // // // // import '../../../../core/services/location_service.dart';
// // // // // // // // // import '../../../../features/data/services/firestore_service.dart';

// // // // // // // // // class AddVenueFormScreen extends StatefulWidget {
// // // // // // // // //   final String? venueIdToEdit;
// // // // // // // // //   final Map<String, dynamic>? initialData;

// // // // // // // // //   const AddVenueFormScreen({
// // // // // // // // //     super.key,
// // // // // // // // //     this.venueIdToEdit,
// // // // // // // // //     this.initialData,
// // // // // // // // //   });

// // // // // // // // //   @override
// // // // // // // // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // // // // // // // }

// // // // // // // // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // // // // // // // //   final _formKey = GlobalKey<FormState>();
// // // // // // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // // // // // //   final LocationService _locationService = LocationService();
// // // // // // // // //   final LocationIQService _geocodingService = LocationIQService();
// // // // // // // // //   final FirebaseAuth _auth = FirebaseAuth.instance;

// // // // // // // // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // // // // // // // //   final ImagePicker _picker = ImagePicker();

// // // // // // // // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics'; // <<<< YOUR VENUE IMAGE PRESET

// // // // // // // // //   // Controllers
// // // // // // // // //   final _nameController = TextEditingController();
// // // // // // // // //   final _sportsController = TextEditingController();
// // // // // // // // //   final _descriptionController = TextEditingController();
// // // // // // // // //   final _imageUrlController = TextEditingController();
// // // // // // // // //   final _addressController = TextEditingController();
// // // // // // // // //   final _cityController = TextEditingController();
// // // // // // // // //   final _countryController = TextEditingController();
// // // // // // // // //   final _weekdayStartController = TextEditingController();
// // // // // // // // //   final _weekdayEndController = TextEditingController();
// // // // // // // // //   final _saturdayStartController = TextEditingController();
// // // // // // // // //   final _saturdayEndController = TextEditingController();
// // // // // // // // //   final _sundayStartController = TextEditingController();
// // // // // // // // //   final _sundayEndController = TextEditingController();
// // // // // // // // //   final _phoneController = TextEditingController();
// // // // // // // // //   final _websiteController = TextEditingController();
// // // // // // // // //   final _emailController = TextEditingController();
// // // // // // // // //   final _facilitiesController = TextEditingController();

// // // // // // // // //   // State variables
// // // // // // // // //   bool _isActive = true;
// // // // // // // // //   bool _bookingEnabled = true;
// // // // // // // // //   bool _isLoading = false;
// // // // // // // // //   bool _isFetchingLocation = false;
// // // // // // // // //   bool _isGeocoding = false;
// // // // // // // // //   GeoPoint? _selectedLocation;
// // // // // // // // //   String? _locationStatusMessage;

// // // // // // // // //   Timer? _venueNameDebouncer;
// // // // // // // // //   bool _isCheckingVenueName = false;
// // // // // // // // //   bool _venueNameIsAvailable = true;
// // // // // // // // //   String? _venueNameErrorText;
// // // // // // // // //   String? _initialVenueNameLowercase;

// // // // // // // // //   XFile? _selectedImageFile;
// // // // // // // // //   bool _isUploadingImage = false;
// // // // // // // // //   String? _imageErrorText; // For displaying image validation error

// // // // // // // // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // // // // // // // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // // // // // // // //   @override
// // // // // // // // //   void initState() {
// // // // // // // // //     super.initState();
// // // // // // // // //     if (_isEditMode && widget.initialData != null) {
// // // // // // // // //       _prefillFormData(widget.initialData!);
// // // // // // // // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // // // // // // // //     }
// // // // // // // // //     _nameController.addListener(_onNameChanged);
// // // // // // // // //   }

// // // // // // // // //   void _prefillFormData(Map<String, dynamic> data) {
// // // // // // // // //     _nameController.text = data['name'] ?? '';
// // // // // // // // //     _sportsController.text = (data['sportType'] as List<dynamic>?)?.join(', ') ?? '';
// // // // // // // // //     _descriptionController.text = data['description'] ?? '';
// // // // // // // // //     _addressController.text = data['address'] ?? '';
// // // // // // // // //     _cityController.text = data['city'] ?? '';
// // // // // // // // //     _countryController.text = data['country'] ?? '';
// // // // // // // // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // // // // // // // //     _isActive = data['isActive'] ?? true;
// // // // // // // // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // // // // // // // //     _phoneController.text = data['phoneNumber'] ?? '';
// // // // // // // // //     _websiteController.text = data['website'] ?? '';
// // // // // // // // //     _emailController.text = data['email'] ?? '';
// // // // // // // // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';

// // // // // // // // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // // // // // // // //     if (initialLocation != null) {
// // // // // // // // //       _selectedLocation = initialLocation;
// // // // // // // // //       _locationStatusMessage =
// // // // // // // // //           'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // // // // // // // //     }

// // // // // // // // //     if (data['operatingHours'] is Map) {
// // // // // // // // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // // // // // // // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // // // // // // // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // // // // // // // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // // // // // // // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // // // // // // // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // // // // // // // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   @override
// // // // // // // // //   void dispose() {
// // // // // // // // //     _nameController.removeListener(_onNameChanged);
// // // // // // // // //     _nameController.dispose();
// // // // // // // // //     _venueNameDebouncer?.cancel();
// // // // // // // // //     _sportsController.dispose();
// // // // // // // // //     _descriptionController.dispose();
// // // // // // // // //     _imageUrlController.dispose();
// // // // // // // // //     _addressController.dispose();
// // // // // // // // //     _cityController.dispose();
// // // // // // // // //     _countryController.dispose();
// // // // // // // // //     _weekdayStartController.dispose();
// // // // // // // // //     _weekdayEndController.dispose();
// // // // // // // // //     _saturdayStartController.dispose();
// // // // // // // // //     _saturdayEndController.dispose();
// // // // // // // // //     _sundayStartController.dispose();
// // // // // // // // //     _sundayEndController.dispose();
// // // // // // // // //     _phoneController.dispose();
// // // // // // // // //     _websiteController.dispose();
// // // // // // // // //     _emailController.dispose();
// // // // // // // // //     _facilitiesController.dispose();
// // // // // // // // //     super.dispose();
// // // // // // // // //   }

// // // // // // // // //   void _onNameChanged() {
// // // // // // // // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // // // // // // // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // // // // // // // //       final name = _nameController.text.trim();
// // // // // // // // //       if (name.isNotEmpty) {
// // // // // // // // //         _checkVenueNameUniqueness(name);
// // // // // // // // //       } else {
// // // // // // // // //         setState(() {
// // // // // // // // //           _isCheckingVenueName = false;
// // // // // // // // //           _venueNameIsAvailable = true;
// // // // // // // // //           _venueNameErrorText = null;
// // // // // // // // //         });
// // // // // // // // //       }
// // // // // // // // //     });
// // // // // // // // //   }

// // // // // // // // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // // // // // // // //     if (!mounted) return;
// // // // // // // // //     setState(() {
// // // // // // // // //       _isCheckingVenueName = true;
// // // // // // // // //       _venueNameIsAvailable = true;
// // // // // // // // //       _venueNameErrorText = null;
// // // // // // // // //     });
// // // // // // // // //     final nameLower = name.toLowerCase();
// // // // // // // // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // // // // // // // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // // // // // // // //       return;
// // // // // // // // //     }
// // // // // // // // //     try {
// // // // // // // // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // // // // // // // //       if (!mounted) return;
// // // // // // // // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // // // // // // // //     } catch (e) {
// // // // // // // // //       if (!mounted) return;
// // // // // // // // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // // // // // // // //       debugPrint("Error checking venue name: $e");
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // // // // // // // //     TimeOfDay? initialTime;
// // // // // // // // //     if (controller.text.isNotEmpty) {
// // // // // // // // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // // // // // // // //     }
// // // // // // // // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // // // // // // // //     if (picked != null) {
// // // // // // // // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // // // // // // // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   Future<void> _fetchAndSetCurrentLocation() async {
// // // // // // // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // // // // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // // // // // // // //     final Position? p = await _locationService.getCurrentLocation();
// // // // // // // // //     if (!mounted) return;
// // // // // // // // //     if (p != null) {
// // // // // // // // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // // // // // // // //       _showSnackBar('Location fetched!', isError: false);
// // // // // // // // //     } else {
// // // // // // // // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // // // // // // // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   Future<void> _geocodeAddress() async {
// // // // // // // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // // // // //     FocusScope.of(context).unfocus();
// // // // // // // // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // // // // // // // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // // // // // // // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // // // // // // // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // // // // // // // //     try {
// // // // // // // // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // // // // // // // //       if (!mounted) return;
// // // // // // // // //       if (r != null) {
// // // // // // // // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // // // // // // // //         _showSnackBar('Location found!', isError: false);
// // // // // // // // //       } else {
// // // // // // // // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // // // // // // // //         _showSnackBar('Address lookup failed.', isError: true);
// // // // // // // // //       }
// // // // // // // // //     } catch (e) {
// // // // // // // // //       if (!mounted) return;
// // // // // // // // //       String err = e.toString().replaceFirst('Exception: ', '');
// // // // // // // // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // // // // // // // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   Future<void> _pickAndUploadImage() async {
// // // // // // // // //     if (_isUploadingImage) return;
// // // // // // // // //     setState(() { _imageErrorText = null; }); // Clear previous image error

// // // // // // // // //     try {
// // // // // // // // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // // // // // // // //       if (pickedFile == null) return;

// // // // // // // // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // // // // // // // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10); // Moderate duration for upload

// // // // // // // // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // // // // // // // //         pickedFile,
// // // // // // // // //         uploadPreset: _venueImageUploadPreset,
// // // // // // // // //         folder: 'venue_images',
// // // // // // // // //       );

// // // // // // // // //       if (!mounted) return;

// // // // // // // // //       if (uploadedUrl != null) {
// // // // // // // // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // // // // // // // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // // // // // // // //       } else {
// // // // // // // // //         throw Exception("Cloudinary returned a null URL.");
// // // // // // // // //       }
// // // // // // // // //     } catch (e) {
// // // // // // // // //       if (!mounted) return;
// // // // // // // // //       setState(() { _isUploadingImage = false; /* Optionally: _selectedImageFile = null; */ });
// // // // // // // // //       debugPrint("Image pick/upload error: $e");
// // // // // // // // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   void _clearImage() {
// // // // // // // // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // // // // // // // //     _showSnackBar('Image removed.', isError: false);
// // // // // // // // //   }

// // // // // // // // //   Future<void> _submitForm() async {
// // // // // // // // //     setState(() { _imageErrorText = null; }); // Clear image error on submit attempt

// // // // // // // // //     if (_isLoading || _isUploadingImage) {
// // // // // // // // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // // // // // // // //     }
// // // // // // // // //     if (_isCheckingVenueName) {
// // // // // // // // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // // // // // // // //     }
// // // // // // // // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // // // // // // // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // // // // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // // // // // // // //     }

// // // // // // // // //     // --- MODIFIED: Validate image presence ---
// // // // // // // // //     bool isFormValid = _formKey.currentState!.validate();
// // // // // // // // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;

// // // // // // // // //     if (!isImagePresent) {
// // // // // // // // //         setState(() {
// // // // // // // // //             _imageErrorText = 'Venue image is required.';
// // // // // // // // //             // Optionally, scroll to the image section or shake it
// // // // // // // // //         });
// // // // // // // // //     }
    
// // // // // // // // //     if (isFormValid && isImagePresent) {
// // // // // // // // //       setState(() { _isLoading = true; });

// // // // // // // // //       if (!_isEditMode && _selectedLocation == null) {
// // // // // // // // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // // // // // // // //         setState(() { _isLoading = false; }); return;
// // // // // // // // //       }

// // // // // // // // //       try {
// // // // // // // // //         List<String> sportTypes = _sportsController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();
// // // // // // // // //         if (sportTypes.isEmpty) sportTypes.add(_sportsController.text.trim().isNotEmpty ? _sportsController.text.trim() : 'General');
// // // // // // // // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // // // // // // // //         Set<String> keywords = {};
// // // // // // // // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // // // // // // // //         addWordsToKeywordsSet(_nameController.text.trim());
// // // // // // // // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // // // // // // // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // // // // // // // //         List<String> searchKeywordsList = keywords.toList();

// // // // // // // // //         Map<String, dynamic> venueData = {
// // // // // // // // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // // // // // // // //           'sportType': sportTypes, 'description': _descriptionController.text.trim(),
// // // // // // // // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // // // // // // // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // // // // // // // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // // // // // // // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // // // // // // // //           'searchKeywords': searchKeywordsList, 'operatingHours': {
// // // // // // // // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // // // // // // // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // // // // // // // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // // // // // // // //           },
// // // // // // // // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // // // // // // // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // // // // // // // //         };

// // // // // // // // //         if (_isEditMode) {
// // // // // // // // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // // // // // // // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // // // // // // // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // // // // // // // //           _showSnackBar('Venue updated!', isError: false);
// // // // // // // // //         } else {
// // // // // // // // //           await _firestoreService.addVenue(venueData);
// // // // // // // // //           _showSnackBar('Venue added!', isError: false);
// // // // // // // // //         }
// // // // // // // // //         if (mounted) Navigator.pop(context, true);
// // // // // // // // //       } catch (e) {
// // // // // // // // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // // // // // // // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // // // // //       } finally {
// // // // // // // // //         if (mounted) setState(() { _isLoading = false; });
// // // // // // // // //       }
// // // // // // // // //     } else {
// // // // // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // // // // // // // //       if (!isImagePresent && isFormValid) { // If only image is missing but rest of form is valid
// // // // // // // // //          _showSnackBar('Please upload a venue image.', isError: true);
// // // // // // // // //       } else {
// // // // // // // // //          _showSnackBar('Please fix errors in the form.', isError: true);
// // // // // // // // //       }
// // // // // // // // //     }
// // // // // // // // //   }

// // // // // // // // //   // --- MODIFIED: Snackbar duration ---
// // // // // // // // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) { // Default duration 3 seconds
// // // // // // // // //     if (!mounted) return;
// // // // // // // // //     ScaffoldMessenger.of(context).removeCurrentSnackBar(); // Remove previous snackbar
// // // // // // // // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // // // // // // // //       content: Text(message),
// // // // // // // // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // // // // // // // //       behavior: SnackBarBehavior.floating,
// // // // // // // // //       margin: const EdgeInsets.all(10),
// // // // // // // // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds), // Specific for upload message
// // // // // // // // //     ));
// // // // // // // // //   }

// // // // // // // // //   // --- MODIFIED: Image Upload Section Widget ---
// // // // // // // // //   Widget _buildImageUploadSection() {
// // // // // // // // //     Widget imagePreview;
// // // // // // // // //     // --- MODIFIED: Define fixed size for the preview area ---
// // // // // // // // //     const double previewSize = 150.0;

// // // // // // // // //     if (_isUploadingImage && _selectedImageFile == null) {
// // // // // // // // //       imagePreview = const Center(child: CircularProgressIndicator());
// // // // // // // // //     } else if (_selectedImageFile != null) {
// // // // // // // // //       imagePreview = kIsWeb
// // // // // // // // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // // // // // // // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // // // // // // // //     } else if (_imageUrlController.text.isNotEmpty) {
// // // // // // // // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // // // // // // // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // // // // // // // //         loadingBuilder: (context, child, loadingProgress) {
// // // // // // // // //           if (loadingProgress == null) return child;
// // // // // // // // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // // // // // // // //         },
// // // // // // // // //       );
// // // // // // // // //     } else { // Placeholder
// // // // // // // // //       // --- MODIFIED: Smaller placeholder icon ---
// // // // // // // // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // // // // // // // //     }

// // // // // // // // //     return Column(
// // // // // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // // // // //       children: [
// // // // // // // // //         // Removed centered image container, the parent column will center the children if needed
// // // // // // // // //         // using `mainAxisAlignment: MainAxisAlignment.center` on a Row or similar.
// // // // // // // // //         // For this form, keeping it aligned with other fields (start) is likely better.

// // // // // // // // //         Center( // Center the preview box and button
// // // // // // // // //           child: Column(
// // // // // // // // //             children: [
// // // // // // // // //               GestureDetector(
// // // // // // // // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // // // // // // // //                 child: Container(
// // // // // // // // //                   // --- MODIFIED: Fixed square size ---
// // // // // // // // //                   height: previewSize,
// // // // // // // // //                   width: previewSize,
// // // // // // // // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // // // // // // // //                   decoration: BoxDecoration(
// // // // // // // // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // // // // // // // //                     border: Border.all(
// // // // // // // // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // // // // // // // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // // // // // // // //                     ),
// // // // // // // // //                     borderRadius: BorderRadius.circular(8.0),
// // // // // // // // //                   ),
// // // // // // // // //                   child: ClipRRect(
// // // // // // // // //                     borderRadius: BorderRadius.circular(7.0), // slightly less for content
// // // // // // // // //                     child: Stack(
// // // // // // // // //                       fit: StackFit.expand,
// // // // // // // // //                       children: [
// // // // // // // // //                         imagePreview,
// // // // // // // // //                         if (_isUploadingImage)
// // // // // // // // //                           Container(
// // // // // // // // //                             color: Colors.black.withOpacity(0.4),
// // // // // // // // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // // // // // // // //                           ),
// // // // // // // // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // // // // // // // //                           Positioned(
// // // // // // // // //                             top: 4,
// // // // // // // // //                             right: 4,
// // // // // // // // //                             child: Material(
// // // // // // // // //                               color: Colors.black54,
// // // // // // // // //                               shape: const CircleBorder(),
// // // // // // // // //                               child: InkWell(
// // // // // // // // //                                 customBorder: const CircleBorder(),
// // // // // // // // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // // // // // // // //                                 child: const Padding(
// // // // // // // // //                                   padding: EdgeInsets.all(6.0),
// // // // // // // // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // // // // // // // //                                 ),
// // // // // // // // //                               ),
// // // // // // // // //                             ),
// // // // // // // // //                           ),
// // // // // // // // //                       ],
// // // // // // // // //                     ),
// // // // // // // // //                   ),
// // // // // // // // //                 ),
// // // // // // // // //               ),
// // // // // // // // //               if (!_isUploadingImage)
// // // // // // // // //                 OutlinedButton.icon(
// // // // // // // // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // // // // // // // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // // // // // // // //                   onPressed: _pickAndUploadImage,
// // // // // // // // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // // // // // // // //                 ),
// // // // // // // // //             ],
// // // // // // // // //           ),
// // // // // // // // //         ),
// // // // // // // // //         if (_isUploadingImage)
// // // // // // // // //           Center(
// // // // // // // // //             child: Padding(
// // // // // // // // //               padding: const EdgeInsets.only(top: 10.0), // Add some space for the text
// // // // // // // // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // // // // // // // //             ),
// // // // // // // // //           ),
// // // // // // // // //         // --- MODIFIED: Display image error text if image is mandatory ---
// // // // // // // // //         if (_imageErrorText != null)
// // // // // // // // //             Padding(
// // // // // // // // //                 padding: const EdgeInsets.only(top: 8.0),
// // // // // // // // //                 child: Center( // Center the error text
// // // // // // // // //                   child: Text(
// // // // // // // // //                     _imageErrorText!,
// // // // // // // // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // // // // //                     textAlign: TextAlign.center,
// // // // // // // // //                   ),
// // // // // // // // //                 ),
// // // // // // // // //             ),
// // // // // // // // //         // Hidden TextFormField (can be removed if no form key validation is needed for the URL directly)
// // // // // // // // //         Visibility(
// // // // // // // // //           visible: false, maintainState: true,
// // // // // // // // //           child: TextFormField(
// // // // // // // // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // // // // // // // //             // validator: (value) { // This validator will now mostly be for internal checks as user won't type URL
// // // // // // // // //             //   if ((value == null || value.isEmpty) && _selectedImageFile == null) {
// // // // // // // // //             //     return 'Venue image is required.'; // This error would show under the (hidden) field
// // // // // // // // //             //   }
// // // // // // // // //             //   return null;
// // // // // // // // //             // },
// // // // // // // // //           ),
// // // // // // // // //         ),
// // // // // // // // //       ],
// // // // // // // // //     );
// // // // // // // // //   }

// // // // // // // // //   @override
// // // // // // // // //   Widget build(BuildContext context) {
// // // // // // // // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // // // // // // // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // // // // // // // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;

// // // // // // // // //     Widget nameSuffixIcon;
// // // // // // // // //     if (_isCheckingVenueName) {
// // // // // // // // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // // // // // // // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // // // // // // // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // // // // // // // //     } else {
// // // // // // // // //       nameSuffixIcon = const SizedBox.shrink();
// // // // // // // // //     }

// // // // // // // // //     return Scaffold(
// // // // // // // // //       appBar: AppBar(title: Text(_isEditMode ? 'Edit Venue' : 'Add New Venue')),
// // // // // // // // //       body: SingleChildScrollView(
// // // // // // // // //         child: GestureDetector(
// // // // // // // // //           onTap: () => FocusScope.of(context).unfocus(),
// // // // // // // // //           child: Padding(
// // // // // // // // //             padding: const EdgeInsets.all(16.0),
// // // // // // // // //             child: Form(
// // // // // // // // //               key: _formKey,
// // // // // // // // //               autovalidateMode: _autovalidateMode,
// // // // // // // // //               child: AbsorbPointer(
// // // // // // // // //                 absorbing: anyOperationInProgress,
// // // // // // // // //                 child: Opacity(
// // // // // // // // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // // // // // // // //                   child: Column(
// // // // // // // // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // // // // // // // //                     children: [
// // // // // // // // //                       _buildSectionHeader("Core Details"),
// // // // // // // // //                       TextFormField(
// // // // // // // // //                         controller: _nameController,
// // // // // // // // //                         decoration: InputDecoration(
// // // // // // // // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // // // // // // // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // // // // // // // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // // // // // // // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // // // // // // // //                                      ? _venueNameErrorText : null,
// // // // // // // // //                         ),
// // // // // // // // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // // // // // // // //                         textCapitalization: TextCapitalization.words
// // // // // // // // //                       ),
// // // // // // // // //                       const SizedBox(height: 15),
// // // // // // // // //                       TextFormField(controller: _sportsController, decoration: const InputDecoration(labelText: 'Sports Offered*', hintText: 'Comma-separated', prefixIcon: Icon(Icons.fitness_center)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // // // // // // //                       const SizedBox(height: 15),
// // // // // // // // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // // // // // // // //                       const SizedBox(height: 20),

// // // // // // // // //                       // --- MODIFIED: Section header for mandatory image ---
// // // // // // // // //                       _buildSectionHeader("Venue Image*"),
// // // // // // // // //                       _buildImageUploadSection(),
// // // // // // // // //                       const SizedBox(height: 20),

// // // // // // // // //                       _buildSectionHeader("Address & Location*"),
// // // // // // // // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // // // // // // //                       const SizedBox(height: 15),
// // // // // // // // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // // // // // // // //                       const SizedBox(height: 15),
// // // // // // // // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // // // // // // // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),
// // // // // // // // //                       const SizedBox(height: 20),

// // // // // // // // //                       _buildSectionHeader("Operating Hours*"),
// // // // // // // // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // // // // // // // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // // // // // // // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // // // // // // // //                       _buildSectionHeader("Contact & Other Info"),
// // // // // // // // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // // // // // // // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // // // // // // // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // // // // // // // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // // // // // // // //                       _buildSectionHeader("Status & Settings"),
// // // // // // // // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // // // // // // // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // // // // // // // //                       Row(
// // // // // // // // //                         mainAxisAlignment: MainAxisAlignment.center,
// // // // // // // // //                         children: [
// // // // // // // // //                           SizedBox(
// // // // // // // // //                             width: 200,
// // // // // // // // //                             child: ElevatedButton.icon(
// // // // // // // // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // // // // // // // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // // // // // // // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // // // // // // // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // // // // // // // //                             ),
// // // // // // // // //                           ),
// // // // // // // // //                         ],
// // // // // // // // //                       ),
// // // // // // // // //                       const SizedBox(height: 20),
// // // // // // // // //                     ],
// // // // // // // // //                   ),
// // // // // // // // //                 ),
// // // // // // // // //               ),
// // // // // // // // //             ),
// // // // // // // // //           ),
// // // // // // // // //         ),
// // // // // // // // //       ),
// // // // // // // // //     );
// // // // // // // // //   }

// // // // // // // // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // // // // // // // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // // // // // // // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // // // // // // // //   }

// // // // // // // // //   Widget _buildSectionHeader(String title) {
// // // // // // // // //     return Padding(
// // // // // // // // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // // // // // // // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // // // // // // //     );
// // // // // // // // //   }

// // // // // // // // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // // // // // // // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // // // // // // // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // // // // // // // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // // // // // // // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // // // // // // // //     }
// // // // // // // // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // // // // // // // //     if (kIsWeb) {
// // // // // // // // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // // // // // // // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // // // // // // // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // // // // // // // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // // // // // // // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // // // // // // // //         final double totalAvailableWidth = constraints.maxWidth;
// // // // // // // // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // // // // // // // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // // // // // // // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // // // // // // // //         } else {
// // // // // // // // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // // // // // // // //         }
// // // // // // // // //       });
// // // // // // // // //     } else {
// // // // // // // // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // // // // // // // //     }
// // // // // // // // //   }
// // // // // // // // // }

// // // // // // // // import 'dart:async';
// // // // // // // // import 'dart:io'; // For File, used for non-web image preview

// // // // // // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // // // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // // // // // // import 'package:flutter/material.dart';
// // // // // // // // import 'package:geolocator/geolocator.dart';
// // // // // // // // import 'package:image_picker/image_picker.dart';
// // // // // // // // import 'package:url_launcher/url_launcher.dart';

// // // // // // // // import '../../../../core/services/geocoding_service.dart';
// // // // // // // // import '../../../../core/services/image_upload_service.dart';
// // // // // // // // import '../../../../core/services/location_service.dart';
// // // // // // // // import '../../../../features/data/services/firestore_service.dart';

// // // // // // // // class AddVenueFormScreen extends StatefulWidget {
// // // // // // // //   final String? venueIdToEdit;
// // // // // // // //   final Map<String, dynamic>? initialData;

// // // // // // // //   const AddVenueFormScreen({
// // // // // // // //     super.key,
// // // // // // // //     this.venueIdToEdit,
// // // // // // // //     this.initialData,
// // // // // // // //   });

// // // // // // // //   @override
// // // // // // // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // // // // // // }

// // // // // // // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // // // // // // //   final _formKey = GlobalKey<FormState>();
// // // // // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // // // // //   final LocationService _locationService = LocationService();
// // // // // // // //   final LocationIQService _geocodingService = LocationIQService();
// // // // // // // //   final FirebaseAuth _auth = FirebaseAuth.instance;

// // // // // // // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // // // // // // //   final ImagePicker _picker = ImagePicker();

// // // // // // // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// // // // // // // //   // Controllers
// // // // // // // //   final _nameController = TextEditingController();
// // // // // // // //   final _descriptionController = TextEditingController();
// // // // // // // //   final _imageUrlController = TextEditingController();
// // // // // // // //   final _addressController = TextEditingController();
// // // // // // // //   final _cityController = TextEditingController();
// // // // // // // //   final _countryController = TextEditingController();
// // // // // // // //   final _weekdayStartController = TextEditingController();
// // // // // // // //   final _weekdayEndController = TextEditingController();
// // // // // // // //   final _saturdayStartController = TextEditingController();
// // // // // // // //   final _saturdayEndController = TextEditingController();
// // // // // // // //   final _sundayStartController = TextEditingController();
// // // // // // // //   final _sundayEndController = TextEditingController();
// // // // // // // //   final _phoneController = TextEditingController();
// // // // // // // //   final _websiteController = TextEditingController();
// // // // // // // //   final _emailController = TextEditingController();
// // // // // // // //   final _facilitiesController = TextEditingController();
// // // // // // // //   final _googleMapsUrlController = TextEditingController();

// // // // // // // //   List<String> _selectedSports = [];
// // // // // // // //   final _sportInputController = TextEditingController();
// // // // // // // //   final _sportInputFocusNode = FocusNode();
// // // // // // // //   String? _sportsErrorText;

// // // // // // // //   bool _isActive = true;
// // // // // // // //   bool _bookingEnabled = true;
// // // // // // // //   bool _isLoading = false;
// // // // // // // //   bool _isFetchingLocation = false;
// // // // // // // //   bool _isGeocoding = false;
// // // // // // // //   GeoPoint? _selectedLocation;
// // // // // // // //   String? _locationStatusMessage;

// // // // // // // //   Timer? _venueNameDebouncer;
// // // // // // // //   bool _isCheckingVenueName = false;
// // // // // // // //   bool _venueNameIsAvailable = true;
// // // // // // // //   String? _venueNameErrorText;
// // // // // // // //   String? _initialVenueNameLowercase;

// // // // // // // //   XFile? _selectedImageFile;
// // // // // // // //   bool _isUploadingImage = false;
// // // // // // // //   String? _imageErrorText;

// // // // // // // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // // // // // // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // // // // // // //   @override
// // // // // // // //   void initState() {
// // // // // // // //     super.initState();
// // // // // // // //     if (_isEditMode && widget.initialData != null) {
// // // // // // // //       _prefillFormData(widget.initialData!);
// // // // // // // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // // // // // // //     }
// // // // // // // //     _nameController.addListener(_onNameChanged);
// // // // // // // //   }

// // // // // // // //   void _prefillFormData(Map<String, dynamic> data) {
// // // // // // // //     _nameController.text = data['name'] ?? '';
// // // // // // // //     _selectedSports = (data['sportType'] as List<dynamic>?)?.map((s) => s.toString().trim()).where((s) => s.isNotEmpty).toList() ?? [];
// // // // // // // //     _descriptionController.text = data['description'] ?? '';
// // // // // // // //     _addressController.text = data['address'] ?? '';
// // // // // // // //     _cityController.text = data['city'] ?? '';
// // // // // // // //     _countryController.text = data['country'] ?? '';
// // // // // // // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // // // // // // //     _isActive = data['isActive'] ?? true;
// // // // // // // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // // // // // // //     _phoneController.text = data['phoneNumber'] ?? '';
// // // // // // // //     _websiteController.text = data['website'] ?? '';
// // // // // // // //     _emailController.text = data['email'] ?? '';
// // // // // // // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// // // // // // // //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// // // // // // // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // // // // // // //     if (initialLocation != null) {
// // // // // // // //       _selectedLocation = initialLocation;
// // // // // // // //       _locationStatusMessage = 'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // // // // // // //     }

// // // // // // // //     if (data['operatingHours'] is Map) {
// // // // // // // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // // // // // // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // // // // // // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // // // // // // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // // // // // // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // // // // // // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // // // // // // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   @override
// // // // // // // //   void dispose() {
// // // // // // // //     _nameController.removeListener(_onNameChanged);
// // // // // // // //     _nameController.dispose();
// // // // // // // //     _venueNameDebouncer?.cancel();
// // // // // // // //     _sportInputController.dispose();
// // // // // // // //     _sportInputFocusNode.dispose();
// // // // // // // //     _descriptionController.dispose();
// // // // // // // //     _imageUrlController.dispose();
// // // // // // // //     _addressController.dispose();
// // // // // // // //     _cityController.dispose();
// // // // // // // //     _countryController.dispose();
// // // // // // // //     _weekdayStartController.dispose();
// // // // // // // //     _weekdayEndController.dispose();
// // // // // // // //     _saturdayStartController.dispose();
// // // // // // // //     _saturdayEndController.dispose();
// // // // // // // //     _sundayStartController.dispose();
// // // // // // // //     _sundayEndController.dispose();
// // // // // // // //     _phoneController.dispose();
// // // // // // // //     _websiteController.dispose();
// // // // // // // //     _emailController.dispose();
// // // // // // // //     _facilitiesController.dispose();
// // // // // // // //     _googleMapsUrlController.dispose();
// // // // // // // //     super.dispose();
// // // // // // // //   }

// // // // // // // //   void _addSportFromInput() {
// // // // // // // //     final sportName = _sportInputController.text.trim();
// // // // // // // //     if (sportName.isNotEmpty) {
// // // // // // // //       final capitalizedSportName = sportName
// // // // // // // //           .split(' ')
// // // // // // // //           .map((word) => word.isNotEmpty ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}' : '')
// // // // // // // //           .join(' ');

// // // // // // // //       if (!_selectedSports.any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// // // // // // // //         setState(() {
// // // // // // // //           _selectedSports.add(capitalizedSportName);
// // // // // // // //           _sportsErrorText = null;
// // // // // // // //         });
// // // // // // // //       }
// // // // // // // //       _sportInputController.clear();
// // // // // // // //       _sportInputFocusNode.requestFocus();
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   void _removeSport(String sportName) {
// // // // // // // //     setState(() {
// // // // // // // //       _selectedSports.remove(sportName);
// // // // // // // //       if (_selectedSports.isEmpty && _autovalidateMode == AutovalidateMode.onUserInteraction) {
// // // // // // // //         _sportsErrorText = 'At least one sport is required.';
// // // // // // // //       }
// // // // // // // //     });
// // // // // // // //   }


// // // // // // // //   void _onNameChanged() {
// // // // // // // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // // // // // // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // // // // // // //       final name = _nameController.text.trim();
// // // // // // // //       if (name.isNotEmpty) {
// // // // // // // //         _checkVenueNameUniqueness(name);
// // // // // // // //       } else {
// // // // // // // //         setState(() {
// // // // // // // //           _isCheckingVenueName = false;
// // // // // // // //           _venueNameIsAvailable = true;
// // // // // // // //           _venueNameErrorText = null;
// // // // // // // //         });
// // // // // // // //       }
// // // // // // // //     });
// // // // // // // //   }

// // // // // // // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // // // // // // //     if (!mounted) return;
// // // // // // // //     setState(() {
// // // // // // // //       _isCheckingVenueName = true;
// // // // // // // //       _venueNameIsAvailable = true;
// // // // // // // //       _venueNameErrorText = null;
// // // // // // // //     });
// // // // // // // //     final nameLower = name.toLowerCase();
// // // // // // // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // // // // // // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // // // // // // //       return;
// // // // // // // //     }
// // // // // // // //     try {
// // // // // // // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // // // // // // //       if (!mounted) return;
// // // // // // // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // // // // // // //     } catch (e) {
// // // // // // // //       if (!mounted) return;
// // // // // // // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // // // // // // //       debugPrint("Error checking venue name: $e");
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // // // // // // //     TimeOfDay? initialTime;
// // // // // // // //     if (controller.text.isNotEmpty) {
// // // // // // // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // // // // // // //     }
// // // // // // // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // // // // // // //     if (picked != null) {
// // // // // // // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // // // // // // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   Future<void> _fetchAndSetCurrentLocation() async {
// // // // // // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // // // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // // // // // // //     final Position? p = await _locationService.getCurrentLocation();
// // // // // // // //     if (!mounted) return;
// // // // // // // //     if (p != null) {
// // // // // // // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // // // // // // //       _showSnackBar('Location fetched!', isError: false);
// // // // // // // //     } else {
// // // // // // // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // // // // // // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   Future<void> _geocodeAddress() async {
// // // // // // // //      if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // // // //     FocusScope.of(context).unfocus();
// // // // // // // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // // // // // // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // // // // // // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // // // // // // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // // // // // // //     try {
// // // // // // // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // // // // // // //       if (!mounted) return;
// // // // // // // //       if (r != null) {
// // // // // // // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // // // // // // //         _showSnackBar('Location found!', isError: false);
// // // // // // // //       } else {
// // // // // // // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // // // // // // //         _showSnackBar('Address lookup failed.', isError: true);
// // // // // // // //       }
// // // // // // // //     } catch (e) {
// // // // // // // //       if (!mounted) return;
// // // // // // // //       String err = e.toString().replaceFirst('Exception: ', '');
// // // // // // // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // // // // // // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   Future<void> _launchGoogleMaps() async {
// // // // // // // //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// // // // // // // //     try {
// // // // // // // //       if (await canLaunchUrl(googleMapsUri)) {
// // // // // // // //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// // // // // // // //       } else {
// // // // // // // //         _showSnackBar('Could not open Google Maps. Please open it manually.', isError: true);
// // // // // // // //       }
// // // // // // // //     } catch (e) {
// // // // // // // //        _showSnackBar('Error opening Google Maps: $e', isError: true);
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   Future<void> _pickAndUploadImage() async {
// // // // // // // //      if (_isUploadingImage) return;
// // // // // // // //     setState(() { _imageErrorText = null; });

// // // // // // // //     try {
// // // // // // // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // // // // // // //       if (pickedFile == null) return;

// // // // // // // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // // // // // // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// // // // // // // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // // // // // // //         pickedFile,
// // // // // // // //         uploadPreset: _venueImageUploadPreset,
// // // // // // // //         folder: 'venue_images',
// // // // // // // //       );

// // // // // // // //       if (!mounted) return;

// // // // // // // //       if (uploadedUrl != null) {
// // // // // // // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // // // // // // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // // // // // // //       } else {
// // // // // // // //         throw Exception("Cloudinary returned a null URL.");
// // // // // // // //       }
// // // // // // // //     } catch (e) {
// // // // // // // //       if (!mounted) return;
// // // // // // // //       setState(() { _isUploadingImage = false; });
// // // // // // // //       debugPrint("Image pick/upload error: $e");
// // // // // // // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   void _clearImage() {
// // // // // // // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // // // // // // //     _showSnackBar('Image removed.', isError: false);
// // // // // // // //   }

// // // // // // // //   Future<void> _submitForm() async {
// // // // // // // //     setState(() {
// // // // // // // //       _imageErrorText = null;
// // // // // // // //       _sportsErrorText = null;
// // // // // // // //     });

// // // // // // // //     if (_isLoading || _isUploadingImage) {
// // // // // // // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // // // // // // //     }
// // // // // // // //     if (_isCheckingVenueName) {
// // // // // // // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // // // // // // //     }
// // // // // // // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // // // // // // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // // // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // // // // // // //     }

// // // // // // // //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// // // // // // // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// // // // // // // //     bool areSportsSelected = _selectedSports.isNotEmpty;

// // // // // // // //     if (!isImagePresent) {
// // // // // // // //         setState(() { _imageErrorText = 'Venue image is required.'; });
// // // // // // // //     }
// // // // // // // //     if (!areSportsSelected) {
// // // // // // // //         setState(() { _sportsErrorText = 'At least one sport is required.'; });
// // // // // // // //     }

// // // // // // // //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// // // // // // // //       setState(() { _isLoading = true; });

// // // // // // // //       if (!_isEditMode && _selectedLocation == null) {
// // // // // // // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // // // // // // //         setState(() { _isLoading = false; }); return;
// // // // // // // //       }

// // // // // // // //       try {
// // // // // // // //         List<String> sportTypes = List.from(_selectedSports);
// // // // // // // //         if (sportTypes.isEmpty) sportTypes.add('General');

// // // // // // // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // // // // // // //         Set<String> keywords = {};
// // // // // // // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // // // // // // //         addWordsToKeywordsSet(_nameController.text.trim());
// // // // // // // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // // // // // // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // // // // // // //         List<String> searchKeywordsList = keywords.toList();

// // // // // // // //         Map<String, dynamic> venueData = {
// // // // // // // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // // // // // // //           'sportType': sportTypes,
// // // // // // // //           'description': _descriptionController.text.trim(),
// // // // // // // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // // // // // // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // // // // // // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // // // // // // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // // // // // // //           'searchKeywords': searchKeywordsList,
// // // // // // // //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// // // // // // // //           'operatingHours': {
// // // // // // // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // // // // // // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // // // // // // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // // // // // // //           },
// // // // // // // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // // // // // // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // // // // // // //         };

// // // // // // // //         if (_isEditMode) {
// // // // // // // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // // // // // // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // // // // // // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // // // // // // //           _showSnackBar('Venue updated!', isError: false);
// // // // // // // //         } else {
// // // // // // // //           await _firestoreService.addVenue(venueData);
// // // // // // // //           _showSnackBar('Venue added!', isError: false);
// // // // // // // //         }
// // // // // // // //         if (mounted) Navigator.pop(context, true);
// // // // // // // //       } catch (e) {
// // // // // // // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // // // // // // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // // // //       } finally {
// // // // // // // //         if (mounted) setState(() { _isLoading = false; });
// // // // // // // //       }
// // // // // // // //     } else {
// // // // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // // // // // // //       String errorMessage = "Please fix errors in the form.";
// // // // // // // //       if (!isTextFormFieldsValid) { /* Errors shown by fields */ }
// // // // // // // //       else if (!isImagePresent && !areSportsSelected) {
// // // // // // // //           errorMessage = "Please upload a venue image and add at least one sport.";
// // // // // // // //       } else if (!isImagePresent) {
// // // // // // // //           errorMessage = "Please upload a venue image.";
// // // // // // // //       } else if (!areSportsSelected) {
// // // // // // // //           errorMessage = "Please add at least one sport.";
// // // // // // // //       }
// // // // // // // //       _showSnackBar(errorMessage, isError: true);
// // // // // // // //     }
// // // // // // // //   }

// // // // // // // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) {
// // // // // // // //     if (!mounted) return;
// // // // // // // //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// // // // // // // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // // // // // // //       content: Text(message),
// // // // // // // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // // // // // // //       behavior: SnackBarBehavior.floating,
// // // // // // // //       margin: const EdgeInsets.all(10),
// // // // // // // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// // // // // // // //     ));
// // // // // // // //   }

// // // // // // // //   Widget _buildImageUploadSection() {
// // // // // // // //     Widget imagePreview;
// // // // // // // //     const double previewSize = 150.0;

// // // // // // // //     if (_isUploadingImage && _selectedImageFile == null) {
// // // // // // // //       imagePreview = const Center(child: CircularProgressIndicator());
// // // // // // // //     } else if (_selectedImageFile != null) {
// // // // // // // //       imagePreview = kIsWeb
// // // // // // // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // // // // // // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // // // // // // //     } else if (_imageUrlController.text.isNotEmpty) {
// // // // // // // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // // // // // // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // // // // // // //         loadingBuilder: (context, child, loadingProgress) {
// // // // // // // //           if (loadingProgress == null) return child;
// // // // // // // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // // // // // // //         },
// // // // // // // //       );
// // // // // // // //     } else {
// // // // // // // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // // // // // // //     }

// // // // // // // //     return Column(
// // // // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // // // //       children: [
// // // // // // // //         Center(
// // // // // // // //           child: Column(
// // // // // // // //             children: [
// // // // // // // //               GestureDetector(
// // // // // // // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // // // // // // //                 child: Container(
// // // // // // // //                   height: previewSize,
// // // // // // // //                   width: previewSize,
// // // // // // // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // // // // // // //                   decoration: BoxDecoration(
// // // // // // // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // // // // // // //                     border: Border.all(
// // // // // // // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // // // // // // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // // // // // // //                     ),
// // // // // // // //                     borderRadius: BorderRadius.circular(8.0),
// // // // // // // //                   ),
// // // // // // // //                   child: ClipRRect(
// // // // // // // //                     borderRadius: BorderRadius.circular(7.0),
// // // // // // // //                     child: Stack(
// // // // // // // //                       fit: StackFit.expand,
// // // // // // // //                       children: [
// // // // // // // //                         imagePreview,
// // // // // // // //                         if (_isUploadingImage)
// // // // // // // //                           Container(
// // // // // // // //                             color: Colors.black.withOpacity(0.4),
// // // // // // // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // // // // // // //                           ),
// // // // // // // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // // // // // // //                           Positioned(
// // // // // // // //                             top: 4,
// // // // // // // //                             right: 4,
// // // // // // // //                             child: Material(
// // // // // // // //                               color: Colors.black54,
// // // // // // // //                               shape: const CircleBorder(),
// // // // // // // //                               child: InkWell(
// // // // // // // //                                 customBorder: const CircleBorder(),
// // // // // // // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // // // // // // //                                 child: const Padding(
// // // // // // // //                                   padding: EdgeInsets.all(6.0),
// // // // // // // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // // // // // // //                                 ),
// // // // // // // //                               ),
// // // // // // // //                             ),
// // // // // // // //                           ),
// // // // // // // //                       ],
// // // // // // // //                     ),
// // // // // // // //                   ),
// // // // // // // //                 ),
// // // // // // // //               ),
// // // // // // // //               if (!_isUploadingImage)
// // // // // // // //                 OutlinedButton.icon(
// // // // // // // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // // // // // // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // // // // // // //                   onPressed: _pickAndUploadImage,
// // // // // // // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // // // // // // //                 ),
// // // // // // // //             ],
// // // // // // // //           ),
// // // // // // // //         ),
// // // // // // // //         if (_isUploadingImage)
// // // // // // // //           Center(
// // // // // // // //             child: Padding(
// // // // // // // //               padding: const EdgeInsets.only(top: 10.0),
// // // // // // // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // // // // // // //             ),
// // // // // // // //           ),
// // // // // // // //         if (_imageErrorText != null)
// // // // // // // //             Padding(
// // // // // // // //                 padding: const EdgeInsets.only(top: 8.0),
// // // // // // // //                 child: Center(
// // // // // // // //                   child: Text(
// // // // // // // //                     _imageErrorText!,
// // // // // // // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // // // //                     textAlign: TextAlign.center,
// // // // // // // //                   ),
// // // // // // // //                 ),
// // // // // // // //             ),
// // // // // // // //         Visibility(
// // // // // // // //           visible: false, maintainState: true,
// // // // // // // //           child: TextFormField(
// // // // // // // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // // // // // // //           ),
// // // // // // // //         ),
// // // // // // // //       ],
// // // // // // // //     );
// // // // // // // //   }

// // // // // // // //   Widget _buildSportsInputSection() {
// // // // // // // //     return Column(
// // // // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // // // //       children: [
// // // // // // // //         // TextField for inputting sports
// // // // // // // //         TextFormField(
// // // // // // // //           controller: _sportInputController,
// // // // // // // //           focusNode: _sportInputFocusNode,
// // // // // // // //           textCapitalization: TextCapitalization.words,
// // // // // // // //           decoration: InputDecoration(
// // // // // // // //             // labelText: 'Sports Offered*', // <<<< REMOVED LABELTEXT
// // // // // // // //             hintText: 'Sports Offered* (Type & press Enter)', // <<<< UPDATED HINT TEXT
// // // // // // // //             prefixIcon: const Icon(Icons.fitness_center), // <<<< KEPT PREFIX ICON
// // // // // // // //             // Standard border and focused border styling
// // // // // // // //             border: OutlineInputBorder(
// // // // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline),
// // // // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // // // //             ),
// // // // // // // //             focusedBorder: OutlineInputBorder(
// // // // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).primaryColor, width: 1.5),
// // // // // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // // // // //             ),
// // // // // // // //              enabledBorder: OutlineInputBorder( // Added for consistency
// // // // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// // // // // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // // // // //             ),
// // // // // // // //             errorBorder: OutlineInputBorder(
// // // // // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // // // //             ),
// // // // // // // //             focusedErrorBorder: OutlineInputBorder(
// // // // // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // // // //             ),
// // // // // // // //           ),
// // // // // // // //           onFieldSubmitted: (_) => _addSportFromInput(),
// // // // // // // //         ),
// // // // // // // //         // Chips display area
// // // // // // // //         if (_selectedSports.isNotEmpty)
// // // // // // // //           Padding(
// // // // // // // //             padding: const EdgeInsets.only(top: 8.0),
// // // // // // // //             child: Container(
// // // // // // // //               width: double.infinity,
// // // // // // // //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// // // // // // // //               child: Wrap(
// // // // // // // //                 spacing: 8.0,
// // // // // // // //                 runSpacing: 4.0,
// // // // // // // //                 children: _selectedSports.map((sport) {
// // // // // // // //                   return InputChip(
// // // // // // // //                     label: Text(sport),
// // // // // // // //                     labelStyle: TextStyle(color: Theme.of(context).colorScheme.onSecondaryContainer),
// // // // // // // //                     backgroundColor: Theme.of(context).colorScheme.secondaryContainer.withOpacity(0.7),
// // // // // // // //                     deleteIconColor: Theme.of(context).colorScheme.onSecondaryContainer.withOpacity(0.7),
// // // // // // // //                     onDeleted: () => _removeSport(sport),
// // // // // // // //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// // // // // // // //                     padding: const EdgeInsets.all(6),
// // // // // // // //                   );
// // // // // // // //                 }).toList(),
// // // // // // // //               ),
// // // // // // // //             ),
// // // // // // // //           ),
// // // // // // // //         // Error message display
// // // // // // // //         if (_sportsErrorText != null)
// // // // // // // //           Padding(
// // // // // // // //             padding: const EdgeInsets.only(top: 8.0, left: 12.0), // Align error with TextFormField content padding if any
// // // // // // // //             child: Text(
// // // // // // // //               _sportsErrorText!,
// // // // // // // //               style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // // // //             ),
// // // // // // // //           ),
// // // // // // // //       ],
// // // // // // // //     );
// // // // // // // //   }


// // // // // // // //   @override
// // // // // // // //   Widget build(BuildContext context) {
// // // // // // // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // // // // // // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // // // // // // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;

// // // // // // // //     Widget nameSuffixIcon;
// // // // // // // //     if (_isCheckingVenueName) {
// // // // // // // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // // // // // // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // // // // // // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // // // // // // //     } else {
// // // // // // // //       nameSuffixIcon = const SizedBox.shrink();
// // // // // // // //     }

// // // // // // // //     return Scaffold(
// // // // // // // //       appBar: AppBar(title: Text(_isEditMode ? 'Edit Venue' : 'Add New Venue')),
// // // // // // // //       body: SingleChildScrollView(
// // // // // // // //         child: GestureDetector(
// // // // // // // //           onTap: () => FocusScope.of(context).unfocus(),
// // // // // // // //           child: Padding(
// // // // // // // //             padding: const EdgeInsets.all(16.0),
// // // // // // // //             child: Form(
// // // // // // // //               key: _formKey,
// // // // // // // //               autovalidateMode: _autovalidateMode,
// // // // // // // //               child: AbsorbPointer(
// // // // // // // //                 absorbing: anyOperationInProgress,
// // // // // // // //                 child: Opacity(
// // // // // // // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // // // // // // //                   child: Column(
// // // // // // // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // // // // // // //                     children: [
// // // // // // // //                       _buildSectionHeader("Core Details"),
// // // // // // // //                       TextFormField(
// // // // // // // //                         controller: _nameController,
// // // // // // // //                         decoration: InputDecoration(
// // // // // // // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // // // // // // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // // // // // // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // // // // // // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // // // // // // //                                      ? _venueNameErrorText : null,
// // // // // // // //                         ),
// // // // // // // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // // // // // // //                         textCapitalization: TextCapitalization.words
// // // // // // // //                       ),
// // // // // // // //                       const SizedBox(height: 15),

// // // // // // // //                       _buildSportsInputSection(),
// // // // // // // //                       const SizedBox(height: 15),

// // // // // // // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // // // // // // //                       const SizedBox(height: 20),

// // // // // // // //                       _buildSectionHeader("Venue Image*"),
// // // // // // // //                       _buildImageUploadSection(),
// // // // // // // //                       const SizedBox(height: 20),

// // // // // // // //                       _buildSectionHeader("Address & Location*"),
// // // // // // // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // // // // // //                       const SizedBox(height: 15),
// // // // // // // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // // // // // // //                       const SizedBox(height: 15),
// // // // // // // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // // // // // // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),

// // // // // // // //                       _buildSectionHeader("Venue on Google Maps*"),
// // // // // // // //                       Row(
// // // // // // // //                         children: [
// // // // // // // //                           Expanded(
// // // // // // // //                             child: OutlinedButton.icon(
// // // // // // // //                               icon: const Icon(Icons.map_outlined, size: 18),
// // // // // // // //                               label: const Text('Open Google Maps'),
// // // // // // // //                               onPressed: anyOperationInProgress ? null : _launchGoogleMaps,
// // // // // // // //                               style: OutlinedButton.styleFrom(
// // // // // // // //                                 padding: const EdgeInsets.symmetric(vertical: 12),
// // // // // // // //                               ),
// // // // // // // //                             ),
// // // // // // // //                           ),
// // // // // // // //                         ],
// // // // // // // //                       ),
// // // // // // // //                       const SizedBox(height: 10),
// // // // // // // //                       TextFormField(
// // // // // // // //                         controller: _googleMapsUrlController,
// // // // // // // //                         decoration: const InputDecoration(
// // // // // // // //                           labelText: 'Pasted Google Maps Link*',
// // // // // // // //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// // // // // // // //                           prefixIcon: Icon(Icons.link),
// // // // // // // //                         ),
// // // // // // // //                         validator: (value) {
// // // // // // // //                           if (value == null || value.trim().isEmpty) {
// // // // // // // //                             return 'Google Maps link is required.';
// // // // // // // //                           }
// // // // // // // //                           final trimmedValue = value.trim();
// // // // // // // //                           final uri = Uri.tryParse(trimmedValue);
// // // // // // // //                           if (uri == null || !uri.isAbsolute) {
// // // // // // // //                             return 'Please enter a valid URL.';
// // // // // // // //                           }
// // // // // // // //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// // // // // // // //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// // // // // // // //                               !lowerTrimmedValue.contains('google.') &&
// // // // // // // //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// // // // // // // //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// // // // // // // //                           }
// // // // // // // //                           return null;
// // // // // // // //                         },
// // // // // // // //                         keyboardType: TextInputType.url,
// // // // // // // //                       ),
// // // // // // // //                       Padding(
// // // // // // // //                         padding: const EdgeInsets.only(top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// // // // // // // //                         child: Text(
// // // // // // // //                           "1. Click 'Open Google Maps' above.\n"
// // // // // // // //                           "2. In Google Maps, find the exact venue.\n"
// // // // // // // //                           "3. Use the 'Share' option and 'Copy link'.\n"
// // // // // // // //                           "4. Paste the link in the field above.",
// // // // // // // //                           style: TextStyle(fontSize: 12.5, color: Theme.of(context).hintColor),
// // // // // // // //                           textAlign: TextAlign.start,
// // // // // // // //                         ),
// // // // // // // //                       ),
// // // // // // // //                       const SizedBox(height: 20),

// // // // // // // //                       _buildSectionHeader("Operating Hours*"),
// // // // // // // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // // // // // // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // // // // // // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // // // // // // //                       _buildSectionHeader("Contact & Other Info"),
// // // // // // // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // // // // // // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // // // // // // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // // // // // // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // // // // // // //                       _buildSectionHeader("Status & Settings"),
// // // // // // // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // // // // // // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // // // // // // //                       Row(
// // // // // // // //                         mainAxisAlignment: MainAxisAlignment.center,
// // // // // // // //                         children: [
// // // // // // // //                           SizedBox(
// // // // // // // //                             width: 200,
// // // // // // // //                             child: ElevatedButton.icon(
// // // // // // // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // // // // // // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // // // // // // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // // // // // // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // // // // // // //                             ),
// // // // // // // //                           ),
// // // // // // // //                         ],
// // // // // // // //                       ),
// // // // // // // //                       const SizedBox(height: 20),
// // // // // // // //                     ],
// // // // // // // //                   ),
// // // // // // // //                 ),
// // // // // // // //               ),
// // // // // // // //             ),
// // // // // // // //           ),
// // // // // // // //         ),
// // // // // // // //       ),
// // // // // // // //     );
// // // // // // // //   }

// // // // // // // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // // // // // // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // // // // // // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // // // // // // //   }

// // // // // // // //   Widget _buildSectionHeader(String title) {
// // // // // // // //      return Padding(
// // // // // // // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // // // // // // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // // // // // //     );
// // // // // // // //   }

// // // // // // // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // // // // // // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // // // // // // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // // // // // // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // // // // // // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // // // // // // //     }
// // // // // // // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // // // // // // //     if (kIsWeb) {
// // // // // // // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // // // // // // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // // // // // // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // // // // // // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // // // // // // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // // // // // // //         final double totalAvailableWidth = constraints.maxWidth;
// // // // // // // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // // // // // // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // // // // // // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // // // // // // //         } else {
// // // // // // // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // // // // // // //         }
// // // // // // // //       });
// // // // // // // //     } else {
// // // // // // // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // // // // // // //     }
// // // // // // // //   }
// // // // // // // // }

// // // // // // // import 'dart:async';
// // // // // // // import 'dart:io'; // For File, used for non-web image preview

// // // // // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // // // // // import 'package:flutter/material.dart';
// // // // // // // import 'package:geolocator/geolocator.dart';
// // // // // // // import 'package:image_picker/image_picker.dart';
// // // // // // // import 'package:url_launcher/url_launcher.dart';

// // // // // // // import '../../../../core/services/geocoding_service.dart';
// // // // // // // import '../../../../core/services/image_upload_service.dart';
// // // // // // // import '../../../../core/services/location_service.dart';
// // // // // // // import '../../../../features/data/services/firestore_service.dart';

// // // // // // // class AddVenueFormScreen extends StatefulWidget {
// // // // // // //   final String? venueIdToEdit;
// // // // // // //   final Map<String, dynamic>? initialData;

// // // // // // //   const AddVenueFormScreen({
// // // // // // //     super.key,
// // // // // // //     this.venueIdToEdit,
// // // // // // //     this.initialData,
// // // // // // //   });

// // // // // // //   @override
// // // // // // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // // // // // }

// // // // // // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // // // // // //   final _formKey = GlobalKey<FormState>();
// // // // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // // // //   final LocationService _locationService = LocationService();
// // // // // // //   final LocationIQService _geocodingService = LocationIQService();
// // // // // // //   final FirebaseAuth _auth = FirebaseAuth.instance;

// // // // // // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // // // // // //   final ImagePicker _picker = ImagePicker();

// // // // // // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// // // // // // //   // Controllers
// // // // // // //   final _nameController = TextEditingController();
// // // // // // //   final _descriptionController = TextEditingController();
// // // // // // //   final _imageUrlController = TextEditingController();
// // // // // // //   final _addressController = TextEditingController();
// // // // // // //   final _cityController = TextEditingController();
// // // // // // //   final _countryController = TextEditingController();
// // // // // // //   final _weekdayStartController = TextEditingController();
// // // // // // //   final _weekdayEndController = TextEditingController();
// // // // // // //   final _saturdayStartController = TextEditingController();
// // // // // // //   final _saturdayEndController = TextEditingController();
// // // // // // //   final _sundayStartController = TextEditingController();
// // // // // // //   final _sundayEndController = TextEditingController();
// // // // // // //   final _phoneController = TextEditingController();
// // // // // // //   final _websiteController = TextEditingController();
// // // // // // //   final _emailController = TextEditingController();
// // // // // // //   final _facilitiesController = TextEditingController();
// // // // // // //   final _googleMapsUrlController = TextEditingController();

// // // // // // //   List<String> _selectedSports = [];
// // // // // // //   final _sportInputController = TextEditingController();
// // // // // // //   final _sportInputFocusNode = FocusNode();
// // // // // // //   String? _sportsErrorText;

// // // // // // //   bool _isActive = true;
// // // // // // //   bool _bookingEnabled = true;
// // // // // // //   bool _isLoading = false;
// // // // // // //   bool _isFetchingLocation = false;
// // // // // // //   bool _isGeocoding = false;
// // // // // // //   GeoPoint? _selectedLocation;
// // // // // // //   String? _locationStatusMessage;

// // // // // // //   Timer? _venueNameDebouncer;
// // // // // // //   bool _isCheckingVenueName = false;
// // // // // // //   bool _venueNameIsAvailable = true;
// // // // // // //   String? _venueNameErrorText;
// // // // // // //   String? _initialVenueNameLowercase;

// // // // // // //   XFile? _selectedImageFile;
// // // // // // //   bool _isUploadingImage = false;
// // // // // // //   String? _imageErrorText;

// // // // // // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // // // // // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // // // // // //   @override
// // // // // // //   void initState() {
// // // // // // //     super.initState();
// // // // // // //     if (_isEditMode && widget.initialData != null) {
// // // // // // //       _prefillFormData(widget.initialData!);
// // // // // // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // // // // // //     }
// // // // // // //     _nameController.addListener(_onNameChanged);
// // // // // // //   }

// // // // // // //   void _prefillFormData(Map<String, dynamic> data) {
// // // // // // //     _nameController.text = data['name'] ?? '';
// // // // // // //     _selectedSports = (data['sportType'] as List<dynamic>?)?.map((s) => s.toString().trim()).where((s) => s.isNotEmpty).toList() ?? [];
// // // // // // //     _descriptionController.text = data['description'] ?? '';
// // // // // // //     _addressController.text = data['address'] ?? '';
// // // // // // //     _cityController.text = data['city'] ?? '';
// // // // // // //     _countryController.text = data['country'] ?? '';
// // // // // // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // // // // // //     _isActive = data['isActive'] ?? true;
// // // // // // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // // // // // //     _phoneController.text = data['phoneNumber'] ?? '';
// // // // // // //     _websiteController.text = data['website'] ?? '';
// // // // // // //     _emailController.text = data['email'] ?? '';
// // // // // // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// // // // // // //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// // // // // // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // // // // // //     if (initialLocation != null) {
// // // // // // //       _selectedLocation = initialLocation;
// // // // // // //       _locationStatusMessage = 'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // // // // // //     }

// // // // // // //     if (data['operatingHours'] is Map) {
// // // // // // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // // // // // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // // // // // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // // // // // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // // // // // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // // // // // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // // // // // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // // // // // //     }
// // // // // // //   }

// // // // // // //   @override
// // // // // // //   void dispose() {
// // // // // // //     _nameController.removeListener(_onNameChanged);
// // // // // // //     _nameController.dispose();
// // // // // // //     _venueNameDebouncer?.cancel();
// // // // // // //     _sportInputController.dispose();
// // // // // // //     _sportInputFocusNode.dispose();
// // // // // // //     _descriptionController.dispose();
// // // // // // //     _imageUrlController.dispose();
// // // // // // //     _addressController.dispose();
// // // // // // //     _cityController.dispose();
// // // // // // //     _countryController.dispose();
// // // // // // //     _weekdayStartController.dispose();
// // // // // // //     _weekdayEndController.dispose();
// // // // // // //     _saturdayStartController.dispose();
// // // // // // //     _saturdayEndController.dispose();
// // // // // // //     _sundayStartController.dispose();
// // // // // // //     _sundayEndController.dispose();
// // // // // // //     _phoneController.dispose();
// // // // // // //     _websiteController.dispose();
// // // // // // //     _emailController.dispose();
// // // // // // //     _facilitiesController.dispose();
// // // // // // //     _googleMapsUrlController.dispose();
// // // // // // //     super.dispose();
// // // // // // //   }

// // // // // // //   void _addSportFromInput() {
// // // // // // //     final sportName = _sportInputController.text.trim();
// // // // // // //     if (sportName.isNotEmpty) {
// // // // // // //       final capitalizedSportName = sportName
// // // // // // //           .split(' ')
// // // // // // //           .map((word) => word.isNotEmpty ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}' : '')
// // // // // // //           .join(' ');

// // // // // // //       if (!_selectedSports.any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// // // // // // //         setState(() {
// // // // // // //           _selectedSports.add(capitalizedSportName);
// // // // // // //           _sportsErrorText = null;
// // // // // // //         });
// // // // // // //       }
// // // // // // //       _sportInputController.clear();
// // // // // // //       _sportInputFocusNode.requestFocus();
// // // // // // //     }
// // // // // // //   }

// // // // // // //   void _removeSport(String sportName) {
// // // // // // //     setState(() {
// // // // // // //       _selectedSports.remove(sportName);
// // // // // // //       if (_selectedSports.isEmpty && _autovalidateMode == AutovalidateMode.onUserInteraction) {
// // // // // // //         _sportsErrorText = 'At least one sport is required.';
// // // // // // //       }
// // // // // // //     });
// // // // // // //   }


// // // // // // //   void _onNameChanged() {
// // // // // // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // // // // // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // // // // // //       final name = _nameController.text.trim();
// // // // // // //       if (name.isNotEmpty) {
// // // // // // //         _checkVenueNameUniqueness(name);
// // // // // // //       } else {
// // // // // // //         setState(() {
// // // // // // //           _isCheckingVenueName = false;
// // // // // // //           _venueNameIsAvailable = true;
// // // // // // //           _venueNameErrorText = null;
// // // // // // //         });
// // // // // // //       }
// // // // // // //     });
// // // // // // //   }

// // // // // // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // // // // // //     if (!mounted) return;
// // // // // // //     setState(() {
// // // // // // //       _isCheckingVenueName = true;
// // // // // // //       _venueNameIsAvailable = true;
// // // // // // //       _venueNameErrorText = null;
// // // // // // //     });
// // // // // // //     final nameLower = name.toLowerCase();
// // // // // // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // // // // // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // // // // // //       return;
// // // // // // //     }
// // // // // // //     try {
// // // // // // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // // // // // //       if (!mounted) return;
// // // // // // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // // // // // //     } catch (e) {
// // // // // // //       if (!mounted) return;
// // // // // // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // // // // // //       debugPrint("Error checking venue name: $e");
// // // // // // //     }
// // // // // // //   }

// // // // // // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // // // // // //     TimeOfDay? initialTime;
// // // // // // //     if (controller.text.isNotEmpty) {
// // // // // // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // // // // // //     }
// // // // // // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // // // // // //     if (picked != null) {
// // // // // // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // // // // // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // // // // // //     }
// // // // // // //   }

// // // // // // //   Future<void> _fetchAndSetCurrentLocation() async {
// // // // // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // // // // // //     final Position? p = await _locationService.getCurrentLocation();
// // // // // // //     if (!mounted) return;
// // // // // // //     if (p != null) {
// // // // // // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // // // // // //       _showSnackBar('Location fetched!', isError: false);
// // // // // // //     } else {
// // // // // // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // // // // // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // // // // // //     }
// // // // // // //   }

// // // // // // //   Future<void> _geocodeAddress() async {
// // // // // // //      if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // // //     FocusScope.of(context).unfocus();
// // // // // // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // // // // // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // // // // // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // // // // // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // // // // // //     try {
// // // // // // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // // // // // //       if (!mounted) return;
// // // // // // //       if (r != null) {
// // // // // // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // // // // // //         _showSnackBar('Location found!', isError: false);
// // // // // // //       } else {
// // // // // // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // // // // // //         _showSnackBar('Address lookup failed.', isError: true);
// // // // // // //       }
// // // // // // //     } catch (e) {
// // // // // // //       if (!mounted) return;
// // // // // // //       String err = e.toString().replaceFirst('Exception: ', '');
// // // // // // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // // // // // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // // // // // //     }
// // // // // // //   }

// // // // // // //   Future<void> _launchGoogleMaps() async {
// // // // // // //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// // // // // // //     try {
// // // // // // //       if (await canLaunchUrl(googleMapsUri)) {
// // // // // // //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// // // // // // //       } else {
// // // // // // //         _showSnackBar('Could not open Google Maps. Please open it manually.', isError: true);
// // // // // // //       }
// // // // // // //     } catch (e) {
// // // // // // //        _showSnackBar('Error opening Google Maps: $e', isError: true);
// // // // // // //     }
// // // // // // //   }

// // // // // // //   Future<void> _pickAndUploadImage() async {
// // // // // // //      if (_isUploadingImage) return;
// // // // // // //     setState(() { _imageErrorText = null; });

// // // // // // //     try {
// // // // // // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // // // // // //       if (pickedFile == null) return;

// // // // // // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // // // // // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// // // // // // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // // // // // //         pickedFile,
// // // // // // //         uploadPreset: _venueImageUploadPreset,
// // // // // // //         folder: 'venue_images',
// // // // // // //       );

// // // // // // //       if (!mounted) return;

// // // // // // //       if (uploadedUrl != null) {
// // // // // // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // // // // // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // // // // // //       } else {
// // // // // // //         throw Exception("Cloudinary returned a null URL.");
// // // // // // //       }
// // // // // // //     } catch (e) {
// // // // // // //       if (!mounted) return;
// // // // // // //       setState(() { _isUploadingImage = false; });
// // // // // // //       debugPrint("Image pick/upload error: $e");
// // // // // // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // // //     }
// // // // // // //   }

// // // // // // //   void _clearImage() {
// // // // // // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // // // // // //     _showSnackBar('Image removed.', isError: false);
// // // // // // //   }

// // // // // // //   Future<void> _submitForm() async {
// // // // // // //     setState(() {
// // // // // // //       _imageErrorText = null;
// // // // // // //       _sportsErrorText = null;
// // // // // // //     });

// // // // // // //     if (_isLoading || _isUploadingImage) {
// // // // // // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // // // // // //     }
// // // // // // //     if (_isCheckingVenueName) {
// // // // // // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // // // // // //     }
// // // // // // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // // // // // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // // // // // //     }

// // // // // // //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// // // // // // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// // // // // // //     bool areSportsSelected = _selectedSports.isNotEmpty;

// // // // // // //     if (!isImagePresent) {
// // // // // // //         setState(() { _imageErrorText = 'Venue image is required.'; });
// // // // // // //     }
// // // // // // //     if (!areSportsSelected) {
// // // // // // //         setState(() { _sportsErrorText = 'At least one sport is required.'; });
// // // // // // //     }

// // // // // // //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// // // // // // //       setState(() { _isLoading = true; });

// // // // // // //       if (!_isEditMode && _selectedLocation == null) {
// // // // // // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // // // // // //         setState(() { _isLoading = false; }); return;
// // // // // // //       }

// // // // // // //       try {
// // // // // // //         List<String> sportTypes = List.from(_selectedSports);
// // // // // // //         if (sportTypes.isEmpty) sportTypes.add('General');

// // // // // // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // // // // // //         Set<String> keywords = {};
// // // // // // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // // // // // //         addWordsToKeywordsSet(_nameController.text.trim());
// // // // // // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // // // // // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // // // // // //         List<String> searchKeywordsList = keywords.toList();

// // // // // // //         Map<String, dynamic> venueData = {
// // // // // // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // // // // // //           'sportType': sportTypes,
// // // // // // //           'description': _descriptionController.text.trim(),
// // // // // // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // // // // // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // // // // // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // // // // // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // // // // // //           'searchKeywords': searchKeywordsList,
// // // // // // //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// // // // // // //           'operatingHours': {
// // // // // // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // // // // // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // // // // // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // // // // // //           },
// // // // // // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // // // // // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // // // // // //         };

// // // // // // //         if (_isEditMode) {
// // // // // // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // // // // // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // // // // // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // // // // // //           _showSnackBar('Venue updated!', isError: false);
// // // // // // //         } else {
// // // // // // //           await _firestoreService.addVenue(venueData);
// // // // // // //           _showSnackBar('Venue added!', isError: false);
// // // // // // //         }
// // // // // // //         if (mounted) Navigator.pop(context, true);
// // // // // // //       } catch (e) {
// // // // // // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // // // // // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // // //       } finally {
// // // // // // //         if (mounted) setState(() { _isLoading = false; });
// // // // // // //       }
// // // // // // //     } else {
// // // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // // // // // //       String errorMessage = "Please fix errors in the form.";
// // // // // // //       if (!isTextFormFieldsValid) { /* Errors shown by fields */ }
// // // // // // //       else if (!isImagePresent && !areSportsSelected) {
// // // // // // //           errorMessage = "Please upload a venue image and add at least one sport.";
// // // // // // //       } else if (!isImagePresent) {
// // // // // // //           errorMessage = "Please upload a venue image.";
// // // // // // //       } else if (!areSportsSelected) {
// // // // // // //           errorMessage = "Please add at least one sport.";
// // // // // // //       }
// // // // // // //       _showSnackBar(errorMessage, isError: true);
// // // // // // //     }
// // // // // // //   }

// // // // // // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) {
// // // // // // //     if (!mounted) return;
// // // // // // //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// // // // // // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // // // // // //       content: Text(message),
// // // // // // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // // // // // //       behavior: SnackBarBehavior.floating,
// // // // // // //       margin: const EdgeInsets.all(10),
// // // // // // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// // // // // // //     ));
// // // // // // //   }

// // // // // // //   Widget _buildImageUploadSection() {
// // // // // // //     Widget imagePreview;
// // // // // // //     const double previewSize = 150.0;

// // // // // // //     if (_isUploadingImage && _selectedImageFile == null) {
// // // // // // //       imagePreview = const Center(child: CircularProgressIndicator());
// // // // // // //     } else if (_selectedImageFile != null) {
// // // // // // //       imagePreview = kIsWeb
// // // // // // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // // // // // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // // // // // //     } else if (_imageUrlController.text.isNotEmpty) {
// // // // // // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // // // // // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // // // // // //         loadingBuilder: (context, child, loadingProgress) {
// // // // // // //           if (loadingProgress == null) return child;
// // // // // // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // // // // // //         },
// // // // // // //       );
// // // // // // //     } else {
// // // // // // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // // // // // //     }

// // // // // // //     return Column(
// // // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // // //       children: [
// // // // // // //         Center(
// // // // // // //           child: Column(
// // // // // // //             children: [
// // // // // // //               GestureDetector(
// // // // // // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // // // // // //                 child: Container(
// // // // // // //                   height: previewSize,
// // // // // // //                   width: previewSize,
// // // // // // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // // // // // //                   decoration: BoxDecoration(
// // // // // // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // // // // // //                     border: Border.all(
// // // // // // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // // // // // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // // // // // //                     ),
// // // // // // //                     borderRadius: BorderRadius.circular(8.0),
// // // // // // //                   ),
// // // // // // //                   child: ClipRRect(
// // // // // // //                     borderRadius: BorderRadius.circular(7.0),
// // // // // // //                     child: Stack(
// // // // // // //                       fit: StackFit.expand,
// // // // // // //                       children: [
// // // // // // //                         imagePreview,
// // // // // // //                         if (_isUploadingImage)
// // // // // // //                           Container(
// // // // // // //                             color: Colors.black.withOpacity(0.4),
// // // // // // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // // // // // //                           ),
// // // // // // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // // // // // //                           Positioned(
// // // // // // //                             top: 4,
// // // // // // //                             right: 4,
// // // // // // //                             child: Material(
// // // // // // //                               color: Colors.black54,
// // // // // // //                               shape: const CircleBorder(),
// // // // // // //                               child: InkWell(
// // // // // // //                                 customBorder: const CircleBorder(),
// // // // // // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // // // // // //                                 child: const Padding(
// // // // // // //                                   padding: EdgeInsets.all(6.0),
// // // // // // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // // // // // //                                 ),
// // // // // // //                               ),
// // // // // // //                             ),
// // // // // // //                           ),
// // // // // // //                       ],
// // // // // // //                     ),
// // // // // // //                   ),
// // // // // // //                 ),
// // // // // // //               ),
// // // // // // //               if (!_isUploadingImage)
// // // // // // //                 OutlinedButton.icon(
// // // // // // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // // // // // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // // // // // //                   onPressed: _pickAndUploadImage,
// // // // // // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // // // // // //                 ),
// // // // // // //             ],
// // // // // // //           ),
// // // // // // //         ),
// // // // // // //         if (_isUploadingImage)
// // // // // // //           Center(
// // // // // // //             child: Padding(
// // // // // // //               padding: const EdgeInsets.only(top: 10.0),
// // // // // // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // // // // // //             ),
// // // // // // //           ),
// // // // // // //         if (_imageErrorText != null)
// // // // // // //             Padding(
// // // // // // //                 padding: const EdgeInsets.only(top: 8.0),
// // // // // // //                 child: Center(
// // // // // // //                   child: Text(
// // // // // // //                     _imageErrorText!,
// // // // // // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // // //                     textAlign: TextAlign.center,
// // // // // // //                   ),
// // // // // // //                 ),
// // // // // // //             ),
// // // // // // //         Visibility(
// // // // // // //           visible: false, maintainState: true,
// // // // // // //           child: TextFormField(
// // // // // // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // // // // // //           ),
// // // // // // //         ),
// // // // // // //       ],
// // // // // // //     );
// // // // // // //   }

// // // // // // //   Widget _buildSportsInputSection() {
// // // // // // //     return Column(
// // // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // // //       children: [
// // // // // // //         // TextField for inputting sports
// // // // // // //         TextFormField(
// // // // // // //           controller: _sportInputController,
// // // // // // //           focusNode: _sportInputFocusNode,
// // // // // // //           textCapitalization: TextCapitalization.words,
// // // // // // //           decoration: InputDecoration(
// // // // // // //             // labelText: 'Sports Offered*', // <<<< REMOVED LABELTEXT
// // // // // // //             hintText: 'Sports Offered* (Type & press Enter)', // <<<< UPDATED HINT TEXT
// // // // // // //             prefixIcon: const Icon(Icons.fitness_center), // <<<< KEPT PREFIX ICON
// // // // // // //             // Standard border and focused border styling
// // // // // // //             border: OutlineInputBorder(
// // // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline),
// // // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // // //             ),
// // // // // // //             focusedBorder: OutlineInputBorder(
// // // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).primaryColor, width: 1.5),
// // // // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // // // //             ),
// // // // // // //              enabledBorder: OutlineInputBorder( // Added for consistency
// // // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// // // // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // // // //             ),
// // // // // // //             errorBorder: OutlineInputBorder(
// // // // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // // //             ),
// // // // // // //             focusedErrorBorder: OutlineInputBorder(
// // // // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // // //             ),
// // // // // // //           ),
// // // // // // //           onFieldSubmitted: (_) => _addSportFromInput(),
// // // // // // //         ),
// // // // // // //         // Chips display area
// // // // // // //         if (_selectedSports.isNotEmpty)
// // // // // // //           Padding(
// // // // // // //             padding: const EdgeInsets.only(top: 8.0),
// // // // // // //             child: Container(
// // // // // // //               width: double.infinity,
// // // // // // //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// // // // // // //               child: Wrap(
// // // // // // //                 spacing: 8.0,
// // // // // // //                 runSpacing: 4.0,
// // // // // // //                 children: _selectedSports.map((sport) {
// // // // // // //                   return InputChip(
// // // // // // //                     label: Text(sport),
// // // // // // //                     labelStyle: TextStyle(color: Theme.of(context).colorScheme.onSecondaryContainer),
// // // // // // //                     backgroundColor: Theme.of(context).colorScheme.secondaryContainer.withOpacity(0.7),
// // // // // // //                     deleteIconColor: Theme.of(context).colorScheme.onSecondaryContainer.withOpacity(0.7),
// // // // // // //                     onDeleted: () => _removeSport(sport),
// // // // // // //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// // // // // // //                     padding: const EdgeInsets.all(6),
// // // // // // //                   );
// // // // // // //                 }).toList(),
// // // // // // //               ),
// // // // // // //             ),
// // // // // // //           ),
// // // // // // //         // Error message display
// // // // // // //         if (_sportsErrorText != null)
// // // // // // //           Padding(
// // // // // // //             padding: const EdgeInsets.only(top: 8.0, left: 12.0), // Align error with TextFormField content padding if any
// // // // // // //             child: Text(
// // // // // // //               _sportsErrorText!,
// // // // // // //               style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // // //             ),
// // // // // // //           ),
// // // // // // //       ],
// // // // // // //     );
// // // // // // //   }


// // // // // // //   @override
// // // // // // //   Widget build(BuildContext context) {
// // // // // // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // // // // // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // // // // // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;

// // // // // // //     Widget nameSuffixIcon;
// // // // // // //     if (_isCheckingVenueName) {
// // // // // // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // // // // // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // // // // // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // // // // // //     } else {
// // // // // // //       nameSuffixIcon = const SizedBox.shrink();
// // // // // // //     }

// // // // // // //     return Scaffold(
// // // // // // //       appBar: AppBar(title: Text(_isEditMode ? 'Edit Venue' : 'Add New Venue')),
// // // // // // //       body: SingleChildScrollView(
// // // // // // //         child: GestureDetector(
// // // // // // //           onTap: () => FocusScope.of(context).unfocus(),
// // // // // // //           child: Padding(
// // // // // // //             padding: const EdgeInsets.all(16.0),
// // // // // // //             child: Form(
// // // // // // //               key: _formKey,
// // // // // // //               autovalidateMode: _autovalidateMode,
// // // // // // //               child: AbsorbPointer(
// // // // // // //                 absorbing: anyOperationInProgress,
// // // // // // //                 child: Opacity(
// // // // // // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // // // // // //                   child: Column(
// // // // // // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // // // // // //                     children: [
// // // // // // //                       _buildSectionHeader("Core Details"),
// // // // // // //                       TextFormField(
// // // // // // //                         controller: _nameController,
// // // // // // //                         decoration: InputDecoration(
// // // // // // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // // // // // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // // // // // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // // // // // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // // // // // //                                      ? _venueNameErrorText : null,
// // // // // // //                         ),
// // // // // // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // // // // // //                         textCapitalization: TextCapitalization.words
// // // // // // //                       ),
// // // // // // //                       const SizedBox(height: 15),

// // // // // // //                       _buildSportsInputSection(),
// // // // // // //                       const SizedBox(height: 15),

// // // // // // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // // // // // //                       const SizedBox(height: 20),

// // // // // // //                       _buildSectionHeader("Venue Image*"),
// // // // // // //                       _buildImageUploadSection(),
// // // // // // //                       const SizedBox(height: 20),

// // // // // // //                       _buildSectionHeader("Address & Location*"),
// // // // // // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // // // // //                       const SizedBox(height: 15),
// // // // // // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // // // // // //                       const SizedBox(height: 15),
// // // // // // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // // // // // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),

// // // // // // //                       _buildSectionHeader("Venue on Google Maps*"),
// // // // // // //                       Row(
// // // // // // //                         children: [
// // // // // // //                           Expanded(
// // // // // // //                             child: OutlinedButton.icon(
// // // // // // //                               icon: const Icon(Icons.map_outlined, size: 18),
// // // // // // //                               label: const Text('Open Google Maps'),
// // // // // // //                               onPressed: anyOperationInProgress ? null : _launchGoogleMaps,
// // // // // // //                               style: OutlinedButton.styleFrom(
// // // // // // //                                 padding: const EdgeInsets.symmetric(vertical: 12),
// // // // // // //                               ),
// // // // // // //                             ),
// // // // // // //                           ),
// // // // // // //                         ],
// // // // // // //                       ),
// // // // // // //                       const SizedBox(height: 10),
// // // // // // //                       TextFormField(
// // // // // // //                         controller: _googleMapsUrlController,
// // // // // // //                         decoration: const InputDecoration(
// // // // // // //                           labelText: 'Pasted Google Maps Link*',
// // // // // // //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// // // // // // //                           prefixIcon: Icon(Icons.link),
// // // // // // //                         ),
// // // // // // //                         validator: (value) {
// // // // // // //                           if (value == null || value.trim().isEmpty) {
// // // // // // //                             return 'Google Maps link is required.';
// // // // // // //                           }
// // // // // // //                           final trimmedValue = value.trim();
// // // // // // //                           final uri = Uri.tryParse(trimmedValue);
// // // // // // //                           if (uri == null || !uri.isAbsolute) {
// // // // // // //                             return 'Please enter a valid URL.';
// // // // // // //                           }
// // // // // // //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// // // // // // //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// // // // // // //                               !lowerTrimmedValue.contains('google.') &&
// // // // // // //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// // // // // // //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// // // // // // //                           }
// // // // // // //                           return null;
// // // // // // //                         },
// // // // // // //                         keyboardType: TextInputType.url,
// // // // // // //                       ),
// // // // // // //                       Padding(
// // // // // // //                         padding: const EdgeInsets.only(top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// // // // // // //                         child: Text(
// // // // // // //                           "1. Click 'Open Google Maps' above.\n"
// // // // // // //                           "2. In Google Maps, find the exact venue.\n"
// // // // // // //                           "3. Use the 'Share' option and 'Copy link'.\n"
// // // // // // //                           "4. Paste the link in the field above.",
// // // // // // //                           style: TextStyle(fontSize: 12.5, color: Theme.of(context).hintColor),
// // // // // // //                           textAlign: TextAlign.start,
// // // // // // //                         ),
// // // // // // //                       ),
// // // // // // //                       const SizedBox(height: 20),

// // // // // // //                       _buildSectionHeader("Operating Hours*"),
// // // // // // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // // // // // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // // // // // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // // // // // //                       _buildSectionHeader("Contact & Other Info"),
// // // // // // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // // // // // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // // // // // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // // // // // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // // // // // //                       _buildSectionHeader("Status & Settings"),
// // // // // // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // // // // // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // // // // // //                       Row(
// // // // // // //                         mainAxisAlignment: MainAxisAlignment.center,
// // // // // // //                         children: [
// // // // // // //                           SizedBox(
// // // // // // //                             width: 200,
// // // // // // //                             child: ElevatedButton.icon(
// // // // // // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // // // // // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // // // // // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // // // // // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // // // // // //                             ),
// // // // // // //                           ),
// // // // // // //                         ],
// // // // // // //                       ),
// // // // // // //                       const SizedBox(height: 20),
// // // // // // //                     ],
// // // // // // //                   ),
// // // // // // //                 ),
// // // // // // //               ),
// // // // // // //             ),
// // // // // // //           ),
// // // // // // //         ),
// // // // // // //       ),
// // // // // // //     );
// // // // // // //   }

// // // // // // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // // // // // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // // // // // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // // // // // //   }

// // // // // // //   Widget _buildSectionHeader(String title) {
// // // // // // //      return Padding(
// // // // // // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // // // // // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // // // // //     );
// // // // // // //   }

// // // // // // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // // // // // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // // // // // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // // // // // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // // // // // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // // // // // //     }
// // // // // // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // // // // // //     if (kIsWeb) {
// // // // // // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // // // // // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // // // // // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // // // // // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // // // // // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // // // // // //         final double totalAvailableWidth = constraints.maxWidth;
// // // // // // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // // // // // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // // // // // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // // // // // //         } else {
// // // // // // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // // // // // //         }
// // // // // // //       });
// // // // // // //     } else {
// // // // // // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // // // // // //     }
// // // // // // //   }
// // // // // // // }

// // // // // // import 'dart:async';
// // // // // // import 'dart:io'; // For File, used for non-web image preview

// // // // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // // // // import 'package:flutter/material.dart';
// // // // // // import 'package:geolocator/geolocator.dart';
// // // // // // import 'package:image_picker/image_picker.dart';
// // // // // // import 'package:url_launcher/url_launcher.dart';

// // // // // // import '../../../../core/services/geocoding_service.dart';
// // // // // // import '../../../../core/services/image_upload_service.dart';
// // // // // // import '../../../../core/services/location_service.dart';
// // // // // // import '../../../../features/data/services/firestore_service.dart';

// // // // // // class AddVenueFormScreen extends StatefulWidget {
// // // // // //   final String? venueIdToEdit;
// // // // // //   final Map<String, dynamic>? initialData;

// // // // // //   const AddVenueFormScreen({
// // // // // //     super.key,
// // // // // //     this.venueIdToEdit,
// // // // // //     this.initialData,
// // // // // //   });

// // // // // //   @override
// // // // // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // // // // }

// // // // // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // // // // //   final _formKey = GlobalKey<FormState>();
// // // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // // //   final LocationService _locationService = LocationService();
// // // // // //   final LocationIQService _geocodingService = LocationIQService();
// // // // // //   final FirebaseAuth _auth = FirebaseAuth.instance;

// // // // // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // // // // //   final ImagePicker _picker = ImagePicker();

// // // // // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// // // // // //   // Controllers
// // // // // //   final _nameController = TextEditingController();
// // // // // //   final _descriptionController = TextEditingController();
// // // // // //   final _imageUrlController = TextEditingController();
// // // // // //   final _addressController = TextEditingController();
// // // // // //   final _cityController = TextEditingController();
// // // // // //   final _countryController = TextEditingController();
// // // // // //   final _weekdayStartController = TextEditingController();
// // // // // //   final _weekdayEndController = TextEditingController();
// // // // // //   final _saturdayStartController = TextEditingController();
// // // // // //   final _saturdayEndController = TextEditingController();
// // // // // //   final _sundayStartController = TextEditingController();
// // // // // //   final _sundayEndController = TextEditingController();
// // // // // //   final _phoneController = TextEditingController();
// // // // // //   final _websiteController = TextEditingController();
// // // // // //   final _emailController = TextEditingController();
// // // // // //   final _facilitiesController = TextEditingController();
// // // // // //   final _googleMapsUrlController = TextEditingController();

// // // // // //   List<String> _selectedSports = [];
// // // // // //   final _sportInputController = TextEditingController();
// // // // // //   final _sportInputFocusNode = FocusNode();
// // // // // //   String? _sportsErrorText;

// // // // // //   bool _isActive = true;
// // // // // //   bool _bookingEnabled = true;
// // // // // //   bool _isLoading = false;
// // // // // //   bool _isFetchingLocation = false;
// // // // // //   bool _isGeocoding = false;
// // // // // //   GeoPoint? _selectedLocation;
// // // // // //   String? _locationStatusMessage;

// // // // // //   Timer? _venueNameDebouncer;
// // // // // //   bool _isCheckingVenueName = false;
// // // // // //   bool _venueNameIsAvailable = true;
// // // // // //   String? _venueNameErrorText;
// // // // // //   String? _initialVenueNameLowercase;

// // // // // //   XFile? _selectedImageFile;
// // // // // //   bool _isUploadingImage = false;
// // // // // //   String? _imageErrorText;

// // // // // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // // // // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // // // // //   @override
// // // // // //   void initState() {
// // // // // //     super.initState();
// // // // // //     if (_isEditMode && widget.initialData != null) {
// // // // // //       _prefillFormData(widget.initialData!);
// // // // // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // // // // //     }
// // // // // //     _nameController.addListener(_onNameChanged);
// // // // // //   }

// // // // // //   void _prefillFormData(Map<String, dynamic> data) {
// // // // // //     _nameController.text = data['name'] ?? '';
// // // // // //     _selectedSports = (data['sportType'] as List<dynamic>?)?.map((s) => s.toString().trim()).where((s) => s.isNotEmpty).toList() ?? [];
// // // // // //     _descriptionController.text = data['description'] ?? '';
// // // // // //     _addressController.text = data['address'] ?? '';
// // // // // //     _cityController.text = data['city'] ?? '';
// // // // // //     _countryController.text = data['country'] ?? '';
// // // // // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // // // // //     _isActive = data['isActive'] ?? true;
// // // // // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // // // // //     _phoneController.text = data['phoneNumber'] ?? '';
// // // // // //     _websiteController.text = data['website'] ?? '';
// // // // // //     _emailController.text = data['email'] ?? '';
// // // // // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// // // // // //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// // // // // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // // // // //     if (initialLocation != null) {
// // // // // //       _selectedLocation = initialLocation;
// // // // // //       _locationStatusMessage = 'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // // // // //     }

// // // // // //     if (data['operatingHours'] is Map) {
// // // // // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // // // // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // // // // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // // // // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // // // // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // // // // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // // // // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // // // // //     }
// // // // // //   }

// // // // // //   @override
// // // // // //   void dispose() {
// // // // // //     _nameController.removeListener(_onNameChanged);
// // // // // //     _nameController.dispose();
// // // // // //     _venueNameDebouncer?.cancel();
// // // // // //     _sportInputController.dispose();
// // // // // //     _sportInputFocusNode.dispose();
// // // // // //     _descriptionController.dispose();
// // // // // //     _imageUrlController.dispose();
// // // // // //     _addressController.dispose();
// // // // // //     _cityController.dispose();
// // // // // //     _countryController.dispose();
// // // // // //     _weekdayStartController.dispose();
// // // // // //     _weekdayEndController.dispose();
// // // // // //     _saturdayStartController.dispose();
// // // // // //     _saturdayEndController.dispose();
// // // // // //     _sundayStartController.dispose();
// // // // // //     _sundayEndController.dispose();
// // // // // //     _phoneController.dispose();
// // // // // //     _websiteController.dispose();
// // // // // //     _emailController.dispose();
// // // // // //     _facilitiesController.dispose();
// // // // // //     _googleMapsUrlController.dispose();
// // // // // //     super.dispose();
// // // // // //   }

// // // // // //   void _addSportFromInput() {
// // // // // //     final sportName = _sportInputController.text.trim();
// // // // // //     if (sportName.isNotEmpty) {
// // // // // //       final capitalizedSportName = sportName
// // // // // //           .split(' ')
// // // // // //           .map((word) => word.isNotEmpty ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}' : '')
// // // // // //           .join(' ');

// // // // // //       if (!_selectedSports.any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// // // // // //         setState(() {
// // // // // //           _selectedSports.add(capitalizedSportName);
// // // // // //           _sportsErrorText = null;
// // // // // //         });
// // // // // //       }
// // // // // //       _sportInputController.clear();
// // // // // //       _sportInputFocusNode.requestFocus();
// // // // // //     }
// // // // // //   }

// // // // // //   void _removeSport(String sportName) {
// // // // // //     setState(() {
// // // // // //       _selectedSports.remove(sportName);
// // // // // //       if (_selectedSports.isEmpty && _autovalidateMode == AutovalidateMode.onUserInteraction) {
// // // // // //         _sportsErrorText = 'At least one sport is required.';
// // // // // //       }
// // // // // //     });
// // // // // //   }


// // // // // //   void _onNameChanged() {
// // // // // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // // // // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // // // // //       final name = _nameController.text.trim();
// // // // // //       if (name.isNotEmpty) {
// // // // // //         _checkVenueNameUniqueness(name);
// // // // // //       } else {
// // // // // //         setState(() {
// // // // // //           _isCheckingVenueName = false;
// // // // // //           _venueNameIsAvailable = true;
// // // // // //           _venueNameErrorText = null;
// // // // // //         });
// // // // // //       }
// // // // // //     });
// // // // // //   }

// // // // // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // // // // //     if (!mounted) return;
// // // // // //     setState(() {
// // // // // //       _isCheckingVenueName = true;
// // // // // //       _venueNameIsAvailable = true;
// // // // // //       _venueNameErrorText = null;
// // // // // //     });
// // // // // //     final nameLower = name.toLowerCase();
// // // // // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // // // // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // // // // //       return;
// // // // // //     }
// // // // // //     try {
// // // // // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // // // // //       if (!mounted) return;
// // // // // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // // // // //     } catch (e) {
// // // // // //       if (!mounted) return;
// // // // // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // // // // //       debugPrint("Error checking venue name: $e");
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // // // // //     TimeOfDay? initialTime;
// // // // // //     if (controller.text.isNotEmpty) {
// // // // // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // // // // //     }
// // // // // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // // // // //     if (picked != null) {
// // // // // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // // // // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _fetchAndSetCurrentLocation() async {
// // // // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // // // // //     final Position? p = await _locationService.getCurrentLocation();
// // // // // //     if (!mounted) return;
// // // // // //     if (p != null) {
// // // // // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // // // // //       _showSnackBar('Location fetched!', isError: false);
// // // // // //     } else {
// // // // // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // // // // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _geocodeAddress() async {
// // // // // //      if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // // //     FocusScope.of(context).unfocus();
// // // // // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // // // // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // // // // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // // // // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // // // // //     try {
// // // // // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // // // // //       if (!mounted) return;
// // // // // //       if (r != null) {
// // // // // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // // // // //         _showSnackBar('Location found!', isError: false);
// // // // // //       } else {
// // // // // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // // // // //         _showSnackBar('Address lookup failed.', isError: true);
// // // // // //       }
// // // // // //     } catch (e) {
// // // // // //       if (!mounted) return;
// // // // // //       String err = e.toString().replaceFirst('Exception: ', '');
// // // // // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // // // // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _launchGoogleMaps() async {
// // // // // //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// // // // // //     try {
// // // // // //       if (await canLaunchUrl(googleMapsUri)) {
// // // // // //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// // // // // //       } else {
// // // // // //         _showSnackBar('Could not open Google Maps. Please open it manually.', isError: true);
// // // // // //       }
// // // // // //     } catch (e) {
// // // // // //        _showSnackBar('Error opening Google Maps: $e', isError: true);
// // // // // //     }
// // // // // //   }

// // // // // //   Future<void> _pickAndUploadImage() async {
// // // // // //      if (_isUploadingImage) return;
// // // // // //     setState(() { _imageErrorText = null; });

// // // // // //     try {
// // // // // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // // // // //       if (pickedFile == null) return;

// // // // // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // // // // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// // // // // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // // // // //         pickedFile,
// // // // // //         uploadPreset: _venueImageUploadPreset,
// // // // // //         folder: 'venue_images',
// // // // // //       );

// // // // // //       if (!mounted) return;

// // // // // //       if (uploadedUrl != null) {
// // // // // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // // // // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // // // // //       } else {
// // // // // //         throw Exception("Cloudinary returned a null URL.");
// // // // // //       }
// // // // // //     } catch (e) {
// // // // // //       if (!mounted) return;
// // // // // //       setState(() { _isUploadingImage = false; });
// // // // // //       debugPrint("Image pick/upload error: $e");
// // // // // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // //     }
// // // // // //   }

// // // // // //   void _clearImage() {
// // // // // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // // // // //     _showSnackBar('Image removed.', isError: false);
// // // // // //   }

// // // // // //   Future<void> _submitForm() async {
// // // // // //     setState(() {
// // // // // //       _imageErrorText = null;
// // // // // //       _sportsErrorText = null;
// // // // // //     });

// // // // // //     if (_isLoading || _isUploadingImage) {
// // // // // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // // // // //     }
// // // // // //     if (_isCheckingVenueName) {
// // // // // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // // // // //     }
// // // // // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // // // // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // // // // //     }

// // // // // //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// // // // // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// // // // // //     bool areSportsSelected = _selectedSports.isNotEmpty;

// // // // // //     if (!isImagePresent) {
// // // // // //         setState(() { _imageErrorText = 'Venue image is required.'; });
// // // // // //     }
// // // // // //     if (!areSportsSelected) {
// // // // // //         setState(() { _sportsErrorText = 'At least one sport is required.'; });
// // // // // //     }

// // // // // //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// // // // // //       setState(() { _isLoading = true; });

// // // // // //       if (!_isEditMode && _selectedLocation == null) {
// // // // // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // // // // //         setState(() { _isLoading = false; }); return;
// // // // // //       }

// // // // // //       try {
// // // // // //         List<String> sportTypes = List.from(_selectedSports);
// // // // // //         if (sportTypes.isEmpty) sportTypes.add('General');

// // // // // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // // // // //         Set<String> keywords = {};
// // // // // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // // // // //         addWordsToKeywordsSet(_nameController.text.trim());
// // // // // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // // // // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // // // // //         List<String> searchKeywordsList = keywords.toList();

// // // // // //         Map<String, dynamic> venueData = {
// // // // // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // // // // //           'sportType': sportTypes,
// // // // // //           'description': _descriptionController.text.trim(),
// // // // // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // // // // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // // // // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // // // // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // // // // //           'searchKeywords': searchKeywordsList,
// // // // // //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// // // // // //           'operatingHours': {
// // // // // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // // // // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // // // // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // // // // //           },
// // // // // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // // // // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // // // // //         };

// // // // // //         if (_isEditMode) {
// // // // // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // // // // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // // // // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // // // // //           _showSnackBar('Venue updated!', isError: false);
// // // // // //         } else {
// // // // // //           await _firestoreService.addVenue(venueData);
// // // // // //           _showSnackBar('Venue added!', isError: false);
// // // // // //         }
// // // // // //         if (mounted) Navigator.pop(context, true);
// // // // // //       } catch (e) {
// // // // // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // // // // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // // //       } finally {
// // // // // //         if (mounted) setState(() { _isLoading = false; });
// // // // // //       }
// // // // // //     } else {
// // // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // // // // //       String errorMessage = "Please fix errors in the form.";
// // // // // //       if (!isTextFormFieldsValid) { /* Errors shown by fields */ }
// // // // // //       else if (!isImagePresent && !areSportsSelected) {
// // // // // //           errorMessage = "Please upload a venue image and add at least one sport.";
// // // // // //       } else if (!isImagePresent) {
// // // // // //           errorMessage = "Please upload a venue image.";
// // // // // //       } else if (!areSportsSelected) {
// // // // // //           errorMessage = "Please add at least one sport.";
// // // // // //       }
// // // // // //       _showSnackBar(errorMessage, isError: true);
// // // // // //     }
// // // // // //   }

// // // // // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) {
// // // // // //     if (!mounted) return;
// // // // // //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// // // // // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // // // // //       content: Text(message),
// // // // // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // // // // //       behavior: SnackBarBehavior.floating,
// // // // // //       margin: const EdgeInsets.all(10),
// // // // // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// // // // // //     ));
// // // // // //   }

// // // // // //   Widget _buildImageUploadSection() {
// // // // // //     Widget imagePreview;
// // // // // //     const double previewSize = 150.0;

// // // // // //     if (_isUploadingImage && _selectedImageFile == null) {
// // // // // //       imagePreview = const Center(child: CircularProgressIndicator());
// // // // // //     } else if (_selectedImageFile != null) {
// // // // // //       imagePreview = kIsWeb
// // // // // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // // // // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // // // // //     } else if (_imageUrlController.text.isNotEmpty) {
// // // // // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // // // // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // // // // //         loadingBuilder: (context, child, loadingProgress) {
// // // // // //           if (loadingProgress == null) return child;
// // // // // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // // // // //         },
// // // // // //       );
// // // // // //     } else {
// // // // // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // // // // //     }

// // // // // //     return Column(
// // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // //       children: [
// // // // // //         Center(
// // // // // //           child: Column(
// // // // // //             children: [
// // // // // //               GestureDetector(
// // // // // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // // // // //                 child: Container(
// // // // // //                   height: previewSize,
// // // // // //                   width: previewSize,
// // // // // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // // // // //                   decoration: BoxDecoration(
// // // // // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // // // // //                     border: Border.all(
// // // // // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // // // // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // // // // //                     ),
// // // // // //                     borderRadius: BorderRadius.circular(8.0),
// // // // // //                   ),
// // // // // //                   child: ClipRRect(
// // // // // //                     borderRadius: BorderRadius.circular(7.0),
// // // // // //                     child: Stack(
// // // // // //                       fit: StackFit.expand,
// // // // // //                       children: [
// // // // // //                         imagePreview,
// // // // // //                         if (_isUploadingImage)
// // // // // //                           Container(
// // // // // //                             color: Colors.black.withOpacity(0.4),
// // // // // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // // // // //                           ),
// // // // // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // // // // //                           Positioned(
// // // // // //                             top: 4,
// // // // // //                             right: 4,
// // // // // //                             child: Material(
// // // // // //                               color: Colors.black54,
// // // // // //                               shape: const CircleBorder(),
// // // // // //                               child: InkWell(
// // // // // //                                 customBorder: const CircleBorder(),
// // // // // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // // // // //                                 child: const Padding(
// // // // // //                                   padding: EdgeInsets.all(6.0),
// // // // // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // // // // //                                 ),
// // // // // //                               ),
// // // // // //                             ),
// // // // // //                           ),
// // // // // //                       ],
// // // // // //                     ),
// // // // // //                   ),
// // // // // //                 ),
// // // // // //               ),
// // // // // //               if (!_isUploadingImage)
// // // // // //                 OutlinedButton.icon(
// // // // // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // // // // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // // // // //                   onPressed: _pickAndUploadImage,
// // // // // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // // // // //                 ),
// // // // // //             ],
// // // // // //           ),
// // // // // //         ),
// // // // // //         if (_isUploadingImage)
// // // // // //           Center(
// // // // // //             child: Padding(
// // // // // //               padding: const EdgeInsets.only(top: 10.0),
// // // // // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // // // // //             ),
// // // // // //           ),
// // // // // //         if (_imageErrorText != null)
// // // // // //             Padding(
// // // // // //                 padding: const EdgeInsets.only(top: 8.0),
// // // // // //                 child: Center(
// // // // // //                   child: Text(
// // // // // //                     _imageErrorText!,
// // // // // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // //                     textAlign: TextAlign.center,
// // // // // //                   ),
// // // // // //                 ),
// // // // // //             ),
// // // // // //         Visibility(
// // // // // //           visible: false, maintainState: true,
// // // // // //           child: TextFormField(
// // // // // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // // // // //           ),
// // // // // //         ),
// // // // // //       ],
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildSportsInputSection() {
// // // // // //     return Column(
// // // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // // //       children: [
// // // // // //         // TextField for inputting sports
// // // // // //         TextFormField(
// // // // // //           controller: _sportInputController,
// // // // // //           focusNode: _sportInputFocusNode,
// // // // // //           textCapitalization: TextCapitalization.words,
// // // // // //           decoration: InputDecoration(
// // // // // //             // labelText: 'Sports Offered*', // <<<< REMOVED LABELTEXT
// // // // // //             hintText: 'Sports Offered* (Type & press Enter)', // <<<< UPDATED HINT TEXT
// // // // // //             prefixIcon: const Icon(Icons.fitness_center), // <<<< KEPT PREFIX ICON
// // // // // //             // Standard border and focused border styling
// // // // // //             border: OutlineInputBorder(
// // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline),
// // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // //             ),
// // // // // //             focusedBorder: OutlineInputBorder(
// // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).primaryColor, width: 1.5),
// // // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // // //             ),
// // // // // //              enabledBorder: OutlineInputBorder( // Added for consistency
// // // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// // // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // // //             ),
// // // // // //             errorBorder: OutlineInputBorder(
// // // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // //             ),
// // // // // //             focusedErrorBorder: OutlineInputBorder(
// // // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // // //             ),
// // // // // //           ),
// // // // // //           onFieldSubmitted: (_) => _addSportFromInput(),
// // // // // //         ),
// // // // // //         // Chips display area
// // // // // //         if (_selectedSports.isNotEmpty)
// // // // // //           Padding(
// // // // // //             padding: const EdgeInsets.only(top: 8.0),
// // // // // //             child: Container(
// // // // // //               width: double.infinity,
// // // // // //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// // // // // //               child: Wrap(
// // // // // //                 spacing: 8.0,
// // // // // //                 runSpacing: 4.0,
// // // // // //                 children: _selectedSports.map((sport) {
// // // // // //                   return InputChip(
// // // // // //                     label: Text(sport),
// // // // // //                     labelStyle: TextStyle(color: Theme.of(context).colorScheme.onSecondaryContainer),
// // // // // //                     backgroundColor: Theme.of(context).colorScheme.secondaryContainer.withOpacity(0.7),
// // // // // //                     deleteIconColor: Theme.of(context).colorScheme.onSecondaryContainer.withOpacity(0.7),
// // // // // //                     onDeleted: () => _removeSport(sport),
// // // // // //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// // // // // //                     padding: const EdgeInsets.all(6),
// // // // // //                   );
// // // // // //                 }).toList(),
// // // // // //               ),
// // // // // //             ),
// // // // // //           ),
// // // // // //         // Error message display
// // // // // //         if (_sportsErrorText != null)
// // // // // //           Padding(
// // // // // //             padding: const EdgeInsets.only(top: 8.0, left: 12.0), // Align error with TextFormField content padding if any
// // // // // //             child: Text(
// // // // // //               _sportsErrorText!,
// // // // // //               style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // // //             ),
// // // // // //           ),
// // // // // //       ],
// // // // // //     );
// // // // // //   }


// // // // // //   @override
// // // // // //   Widget build(BuildContext context) {
// // // // // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // // // // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // // // // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;

// // // // // //     Widget nameSuffixIcon;
// // // // // //     if (_isCheckingVenueName) {
// // // // // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // // // // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // // // // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // // // // //     } else {
// // // // // //       nameSuffixIcon = const SizedBox.shrink();
// // // // // //     }

// // // // // //     return Scaffold(
// // // // // //       appBar: AppBar(title: Text(_isEditMode ? 'Edit Venue' : 'Add New Venue')),
// // // // // //       body: SingleChildScrollView(
// // // // // //         child: GestureDetector(
// // // // // //           onTap: () => FocusScope.of(context).unfocus(),
// // // // // //           // This Container replaces the previous Padding widget to create the "box" effect.
// // // // // //           child: Container(
// // // // // //             // Margin provides space around the container, separating it from the screen edges.
// // // // // //             margin: const EdgeInsets.all(16.0),
// // // // // //             // Padding provides space inside the container, before the form content begins.
// // // // // //             padding: const EdgeInsets.all(16.0),
// // // // // //             decoration: BoxDecoration(
// // // // // //               // Using the theme's card color makes the UI adaptive to light/dark themes.
// // // // // //               color: Theme.of(context).cardColor,
// // // // // //               // Rounded corners give a modern, card-like appearance as seen in the reference image.
// // // // // //               borderRadius: BorderRadius.circular(16.0),
// // // // // //               // A subtle border to define the container's edges, also inspired by the reference image.
// // // // // //               border: Border.all(
// // // // // //                 color: Theme.of(context).dividerColor,
// // // // // //                 width: 1.0,
// // // // // //               ),
// // // // // //             ),
// // // // // //             child: Form(
// // // // // //               key: _formKey,
// // // // // //               autovalidateMode: _autovalidateMode,
// // // // // //               child: AbsorbPointer(
// // // // // //                 absorbing: anyOperationInProgress,
// // // // // //                 child: Opacity(
// // // // // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // // // // //                   child: Column(
// // // // // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // // // // //                     children: [
// // // // // //                       _buildSectionHeader("Core Details"),
// // // // // //                       TextFormField(
// // // // // //                         controller: _nameController,
// // // // // //                         decoration: InputDecoration(
// // // // // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // // // // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // // // // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // // // // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // // // // //                                      ? _venueNameErrorText : null,
// // // // // //                         ),
// // // // // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // // // // //                         textCapitalization: TextCapitalization.words
// // // // // //                       ),
// // // // // //                       const SizedBox(height: 15),

// // // // // //                       _buildSportsInputSection(),
// // // // // //                       const SizedBox(height: 15),

// // // // // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // // // // //                       const SizedBox(height: 20),

// // // // // //                       _buildSectionHeader("Venue Image*"),
// // // // // //                       _buildImageUploadSection(),
// // // // // //                       const SizedBox(height: 20),

// // // // // //                       _buildSectionHeader("Address & Location*"),
// // // // // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // // // //                       const SizedBox(height: 15),
// // // // // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // // // // //                       const SizedBox(height: 15),
// // // // // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // // // // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),

// // // // // //                       _buildSectionHeader("Venue on Google Maps*"),
// // // // // //                       Row(
// // // // // //                         children: [
// // // // // //                           Expanded(
// // // // // //                             child: OutlinedButton.icon(
// // // // // //                               icon: const Icon(Icons.map_outlined, size: 18),
// // // // // //                               label: const Text('Open Google Maps'),
// // // // // //                               onPressed: anyOperationInProgress ? null : _launchGoogleMaps,
// // // // // //                               style: OutlinedButton.styleFrom(
// // // // // //                                 padding: const EdgeInsets.symmetric(vertical: 12),
// // // // // //                               ),
// // // // // //                             ),
// // // // // //                           ),
// // // // // //                         ],
// // // // // //                       ),
// // // // // //                       const SizedBox(height: 10),
// // // // // //                       TextFormField(
// // // // // //                         controller: _googleMapsUrlController,
// // // // // //                         decoration: const InputDecoration(
// // // // // //                           labelText: 'Pasted Google Maps Link*',
// // // // // //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// // // // // //                           prefixIcon: Icon(Icons.link),
// // // // // //                         ),
// // // // // //                         validator: (value) {
// // // // // //                           if (value == null || value.trim().isEmpty) {
// // // // // //                             return 'Google Maps link is required.';
// // // // // //                           }
// // // // // //                           final trimmedValue = value.trim();
// // // // // //                           final uri = Uri.tryParse(trimmedValue);
// // // // // //                           if (uri == null || !uri.isAbsolute) {
// // // // // //                             return 'Please enter a valid URL.';
// // // // // //                           }
// // // // // //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// // // // // //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// // // // // //                               !lowerTrimmedValue.contains('google.') &&
// // // // // //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// // // // // //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// // // // // //                           }
// // // // // //                           return null;
// // // // // //                         },
// // // // // //                         keyboardType: TextInputType.url,
// // // // // //                       ),
// // // // // //                       Padding(
// // // // // //                         padding: const EdgeInsets.only(top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// // // // // //                         child: Text(
// // // // // //                           "1. Click 'Open Google Maps' above.\n"
// // // // // //                           "2. In Google Maps, find the exact venue.\n"
// // // // // //                           "3. Use the 'Share' option and 'Copy link'.\n"
// // // // // //                           "4. Paste the link in the field above.",
// // // // // //                           style: TextStyle(fontSize: 12.5, color: Theme.of(context).hintColor),
// // // // // //                           textAlign: TextAlign.start,
// // // // // //                         ),
// // // // // //                       ),
// // // // // //                       const SizedBox(height: 20),

// // // // // //                       _buildSectionHeader("Operating Hours*"),
// // // // // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // // // // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // // // // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // // // // //                       _buildSectionHeader("Contact & Other Info"),
// // // // // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // // // // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // // // // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // // // // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // // // // //                       _buildSectionHeader("Status & Settings"),
// // // // // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // // // // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // // // // //                       Row(
// // // // // //                         mainAxisAlignment: MainAxisAlignment.center,
// // // // // //                         children: [
// // // // // //                           SizedBox(
// // // // // //                             width: 200,
// // // // // //                             child: ElevatedButton.icon(
// // // // // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // // // // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // // // // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // // // // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // // // // //                             ),
// // // // // //                           ),
// // // // // //                         ],
// // // // // //                       ),
// // // // // //                       const SizedBox(height: 20),
// // // // // //                     ],
// // // // // //                   ),
// // // // // //                 ),
// // // // // //               ),
// // // // // //             ),
// // // // // //           ),
// // // // // //         ),
// // // // // //       ),
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // // // // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // // // // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // // // // //   }

// // // // // //   Widget _buildSectionHeader(String title) {
// // // // // //      return Padding(
// // // // // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // // // // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // // // //     );
// // // // // //   }

// // // // // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // // // // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // // // // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // // // // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // // // // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // // // // //     }
// // // // // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // // // // //     if (kIsWeb) {
// // // // // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // // // // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // // // // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // // // // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // // // // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // // // // //         final double totalAvailableWidth = constraints.maxWidth;
// // // // // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // // // // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // // // // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // // // // //         } else {
// // // // // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // // // // //         }
// // // // // //       });
// // // // // //     } else {
// // // // // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // // // // //     }
// // // // // //   }
// // // // // // }

// // // // // import 'dart:async';
// // // // // import 'dart:io'; // For File, used for non-web image preview

// // // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // // // import 'package:flutter/material.dart';
// // // // // import 'package:geolocator/geolocator.dart';
// // // // // import 'package:image_picker/image_picker.dart';
// // // // // import 'package:mm_associates/features/auth/services/auth_service.dart'; // Added for AuthService
// // // // // import 'package:mm_associates/features/profile/screens/profile_screen.dart'; // Added for ProfileScreen
// // // // // import 'package:url_launcher/url_launcher.dart';

// // // // // import '../../../../core/services/geocoding_service.dart';
// // // // // import '../../../../core/services/image_upload_service.dart';
// // // // // import '../../../../core/services/location_service.dart';
// // // // // import '../../../../features/data/services/firestore_service.dart';

// // // // // class AddVenueFormScreen extends StatefulWidget {
// // // // //   final String? venueIdToEdit;
// // // // //   final Map<String, dynamic>? initialData;

// // // // //   const AddVenueFormScreen({
// // // // //     super.key,
// // // // //     this.venueIdToEdit,
// // // // //     this.initialData,
// // // // //   });

// // // // //   @override
// // // // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // // // }

// // // // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // // // //   final _formKey = GlobalKey<FormState>();
// // // // //   final FirestoreService _firestoreService = FirestoreService();
// // // // //   final LocationService _locationService = LocationService();
// // // // //   final LocationIQService _geocodingService = LocationIQService();
// // // // //   final FirebaseAuth _auth = FirebaseAuth.instance;
// // // // //   final AuthService _authService = AuthService(); // Added AuthService instance

// // // // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // // // //   final ImagePicker _picker = ImagePicker();

// // // // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// // // // //   // Controllers
// // // // //   final _nameController = TextEditingController();
// // // // //   final _descriptionController = TextEditingController();
// // // // //   final _imageUrlController = TextEditingController();
// // // // //   final _addressController = TextEditingController();
// // // // //   final _cityController = TextEditingController();
// // // // //   final _countryController = TextEditingController();
// // // // //   final _weekdayStartController = TextEditingController();
// // // // //   final _weekdayEndController = TextEditingController();
// // // // //   final _saturdayStartController = TextEditingController();
// // // // //   final _saturdayEndController = TextEditingController();
// // // // //   final _sundayStartController = TextEditingController();
// // // // //   final _sundayEndController = TextEditingController();
// // // // //   final _phoneController = TextEditingController();
// // // // //   final _websiteController = TextEditingController();
// // // // //   final _emailController = TextEditingController();
// // // // //   final _facilitiesController = TextEditingController();
// // // // //   final _googleMapsUrlController = TextEditingController();

// // // // //   List<String> _selectedSports = [];
// // // // //   final _sportInputController = TextEditingController();
// // // // //   final _sportInputFocusNode = FocusNode();
// // // // //   String? _sportsErrorText;

// // // // //   bool _isActive = true;
// // // // //   bool _bookingEnabled = true;
// // // // //   bool _isLoading = false;
// // // // //   bool _isFetchingLocation = false;
// // // // //   bool _isGeocoding = false;
// // // // //   GeoPoint? _selectedLocation;
// // // // //   String? _locationStatusMessage;

// // // // //   Timer? _venueNameDebouncer;
// // // // //   bool _isCheckingVenueName = false;
// // // // //   bool _venueNameIsAvailable = true;
// // // // //   String? _venueNameErrorText;
// // // // //   String? _initialVenueNameLowercase;

// // // // //   XFile? _selectedImageFile;
// // // // //   bool _isUploadingImage = false;
// // // // //   String? _imageErrorText;

// // // // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // // // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // // // //   @override
// // // // //   void initState() {
// // // // //     super.initState();
// // // // //     if (_isEditMode && widget.initialData != null) {
// // // // //       _prefillFormData(widget.initialData!);
// // // // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // // // //     }
// // // // //     _nameController.addListener(_onNameChanged);
// // // // //   }

// // // // //   void _prefillFormData(Map<String, dynamic> data) {
// // // // //     _nameController.text = data['name'] ?? '';
// // // // //     _selectedSports = (data['sportType'] as List<dynamic>?)?.map((s) => s.toString().trim()).where((s) => s.isNotEmpty).toList() ?? [];
// // // // //     _descriptionController.text = data['description'] ?? '';
// // // // //     _addressController.text = data['address'] ?? '';
// // // // //     _cityController.text = data['city'] ?? '';
// // // // //     _countryController.text = data['country'] ?? '';
// // // // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // // // //     _isActive = data['isActive'] ?? true;
// // // // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // // // //     _phoneController.text = data['phoneNumber'] ?? '';
// // // // //     _websiteController.text = data['website'] ?? '';
// // // // //     _emailController.text = data['email'] ?? '';
// // // // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// // // // //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// // // // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // // // //     if (initialLocation != null) {
// // // // //       _selectedLocation = initialLocation;
// // // // //       _locationStatusMessage = 'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // // // //     }

// // // // //     if (data['operatingHours'] is Map) {
// // // // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // // // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // // // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // // // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // // // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // // // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // // // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // // // //     }
// // // // //   }

// // // // //   @override
// // // // //   void dispose() {
// // // // //     _nameController.removeListener(_onNameChanged);
// // // // //     _nameController.dispose();
// // // // //     _venueNameDebouncer?.cancel();
// // // // //     _sportInputController.dispose();
// // // // //     _sportInputFocusNode.dispose();
// // // // //     _descriptionController.dispose();
// // // // //     _imageUrlController.dispose();
// // // // //     _addressController.dispose();
// // // // //     _cityController.dispose();
// // // // //     _countryController.dispose();
// // // // //     _weekdayStartController.dispose();
// // // // //     _weekdayEndController.dispose();
// // // // //     _saturdayStartController.dispose();
// // // // //     _saturdayEndController.dispose();
// // // // //     _sundayStartController.dispose();
// // // // //     _sundayEndController.dispose();
// // // // //     _phoneController.dispose();
// // // // //     _websiteController.dispose();
// // // // //     _emailController.dispose();
// // // // //     _facilitiesController.dispose();
// // // // //     _googleMapsUrlController.dispose();
// // // // //     super.dispose();
// // // // //   }

// // // // //   void _addSportFromInput() {
// // // // //     final sportName = _sportInputController.text.trim();
// // // // //     if (sportName.isNotEmpty) {
// // // // //       final capitalizedSportName = sportName
// // // // //           .split(' ')
// // // // //           .map((word) => word.isNotEmpty ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}' : '')
// // // // //           .join(' ');

// // // // //       if (!_selectedSports.any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// // // // //         setState(() {
// // // // //           _selectedSports.add(capitalizedSportName);
// // // // //           _sportsErrorText = null;
// // // // //         });
// // // // //       }
// // // // //       _sportInputController.clear();
// // // // //       _sportInputFocusNode.requestFocus();
// // // // //     }
// // // // //   }

// // // // //   void _removeSport(String sportName) {
// // // // //     setState(() {
// // // // //       _selectedSports.remove(sportName);
// // // // //       if (_selectedSports.isEmpty && _autovalidateMode == AutovalidateMode.onUserInteraction) {
// // // // //         _sportsErrorText = 'At least one sport is required.';
// // // // //       }
// // // // //     });
// // // // //   }


// // // // //   void _onNameChanged() {
// // // // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // // // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // // // //       final name = _nameController.text.trim();
// // // // //       if (name.isNotEmpty) {
// // // // //         _checkVenueNameUniqueness(name);
// // // // //       } else {
// // // // //         setState(() {
// // // // //           _isCheckingVenueName = false;
// // // // //           _venueNameIsAvailable = true;
// // // // //           _venueNameErrorText = null;
// // // // //         });
// // // // //       }
// // // // //     });
// // // // //   }

// // // // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // // // //     if (!mounted) return;
// // // // //     setState(() {
// // // // //       _isCheckingVenueName = true;
// // // // //       _venueNameIsAvailable = true;
// // // // //       _venueNameErrorText = null;
// // // // //     });
// // // // //     final nameLower = name.toLowerCase();
// // // // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // // // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // // // //       return;
// // // // //     }
// // // // //     try {
// // // // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // // // //       if (!mounted) return;
// // // // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // // // //     } catch (e) {
// // // // //       if (!mounted) return;
// // // // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // // // //       debugPrint("Error checking venue name: $e");
// // // // //     }
// // // // //   }

// // // // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // // // //     TimeOfDay? initialTime;
// // // // //     if (controller.text.isNotEmpty) {
// // // // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // // // //     }
// // // // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // // // //     if (picked != null) {
// // // // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // // // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // // // //     }
// // // // //   }

// // // // //   Future<void> _fetchAndSetCurrentLocation() async {
// // // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // // // //     final Position? p = await _locationService.getCurrentLocation();
// // // // //     if (!mounted) return;
// // // // //     if (p != null) {
// // // // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // // // //       _showSnackBar('Location fetched!', isError: false);
// // // // //     } else {
// // // // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // // // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // // // //     }
// // // // //   }

// // // // //   Future<void> _geocodeAddress() async {
// // // // //      if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // // //     FocusScope.of(context).unfocus();
// // // // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // // // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // // // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // // // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // // // //     try {
// // // // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // // // //       if (!mounted) return;
// // // // //       if (r != null) {
// // // // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // // // //         _showSnackBar('Location found!', isError: false);
// // // // //       } else {
// // // // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // // // //         _showSnackBar('Address lookup failed.', isError: true);
// // // // //       }
// // // // //     } catch (e) {
// // // // //       if (!mounted) return;
// // // // //       String err = e.toString().replaceFirst('Exception: ', '');
// // // // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // // // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // // // //     }
// // // // //   }

// // // // //   Future<void> _launchGoogleMaps() async {
// // // // //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// // // // //     try {
// // // // //       if (await canLaunchUrl(googleMapsUri)) {
// // // // //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// // // // //       } else {
// // // // //         _showSnackBar('Could not open Google Maps. Please open it manually.', isError: true);
// // // // //       }
// // // // //     } catch (e) {
// // // // //        _showSnackBar('Error opening Google Maps: $e', isError: true);
// // // // //     }
// // // // //   }

// // // // //   Future<void> _pickAndUploadImage() async {
// // // // //      if (_isUploadingImage) return;
// // // // //     setState(() { _imageErrorText = null; });

// // // // //     try {
// // // // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // // // //       if (pickedFile == null) return;

// // // // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // // // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// // // // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // // // //         pickedFile,
// // // // //         uploadPreset: _venueImageUploadPreset,
// // // // //         folder: 'venue_images',
// // // // //       );

// // // // //       if (!mounted) return;

// // // // //       if (uploadedUrl != null) {
// // // // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // // // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // // // //       } else {
// // // // //         throw Exception("Cloudinary returned a null URL.");
// // // // //       }
// // // // //     } catch (e) {
// // // // //       if (!mounted) return;
// // // // //       setState(() { _isUploadingImage = false; });
// // // // //       debugPrint("Image pick/upload error: $e");
// // // // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // //     }
// // // // //   }

// // // // //   void _clearImage() {
// // // // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // // // //     _showSnackBar('Image removed.', isError: false);
// // // // //   }

// // // // //   Future<void> _submitForm() async {
// // // // //     setState(() {
// // // // //       _imageErrorText = null;
// // // // //       _sportsErrorText = null;
// // // // //     });

// // // // //     if (_isLoading || _isUploadingImage) {
// // // // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // // // //     }
// // // // //     if (_isCheckingVenueName) {
// // // // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // // // //     }
// // // // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // // // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // // // //     }

// // // // //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// // // // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// // // // //     bool areSportsSelected = _selectedSports.isNotEmpty;

// // // // //     if (!isImagePresent) {
// // // // //         setState(() { _imageErrorText = 'Venue image is required.'; });
// // // // //     }
// // // // //     if (!areSportsSelected) {
// // // // //         setState(() { _sportsErrorText = 'At least one sport is required.'; });
// // // // //     }

// // // // //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// // // // //       setState(() { _isLoading = true; });

// // // // //       if (!_isEditMode && _selectedLocation == null) {
// // // // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // // // //         setState(() { _isLoading = false; }); return;
// // // // //       }

// // // // //       try {
// // // // //         List<String> sportTypes = List.from(_selectedSports);
// // // // //         if (sportTypes.isEmpty) sportTypes.add('General');

// // // // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // // // //         Set<String> keywords = {};
// // // // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // // // //         addWordsToKeywordsSet(_nameController.text.trim());
// // // // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // // // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // // // //         List<String> searchKeywordsList = keywords.toList();

// // // // //         Map<String, dynamic> venueData = {
// // // // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // // // //           'sportType': sportTypes,
// // // // //           'description': _descriptionController.text.trim(),
// // // // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // // // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // // // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // // // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // // // //           'searchKeywords': searchKeywordsList,
// // // // //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// // // // //           'operatingHours': {
// // // // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // // // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // // // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // // // //           },
// // // // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // // // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // // // //         };

// // // // //         if (_isEditMode) {
// // // // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // // // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // // // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // // // //           _showSnackBar('Venue updated!', isError: false);
// // // // //         } else {
// // // // //           await _firestoreService.addVenue(venueData);
// // // // //           _showSnackBar('Venue added!', isError: false);
// // // // //         }
// // // // //         if (mounted) Navigator.pop(context, true); // This will pop the form screen
// // // // //       } catch (e) {
// // // // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // // // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // // //       } finally {
// // // // //         if (mounted) setState(() { _isLoading = false; });
// // // // //       }
// // // // //     } else {
// // // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // // // //       String errorMessage = "Please fix errors in the form.";
// // // // //       if (!isTextFormFieldsValid) { /* Errors shown by fields */ }
// // // // //       else if (!isImagePresent && !areSportsSelected) {
// // // // //           errorMessage = "Please upload a venue image and add at least one sport.";
// // // // //       } else if (!isImagePresent) {
// // // // //           errorMessage = "Please upload a venue image.";
// // // // //       } else if (!areSportsSelected) {
// // // // //           errorMessage = "Please add at least one sport.";
// // // // //       }
// // // // //       _showSnackBar(errorMessage, isError: true);
// // // // //     }
// // // // //   }

// // // // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) {
// // // // //     if (!mounted) return;
// // // // //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// // // // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // // // //       content: Text(message),
// // // // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // // // //       behavior: SnackBarBehavior.floating,
// // // // //       margin: const EdgeInsets.all(10),
// // // // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// // // // //     ));
// // // // //   }

// // // // //   Future<void> _showLogoutConfirmationDialogForForm(BuildContext context) async {
// // // // //     if (!context.mounted) return;
// // // // //     return showDialog<void>(
// // // // //       context: context,
// // // // //       barrierDismissible: false,
// // // // //       builder: (BuildContext dialogContext) {
// // // // //         return AlertDialog(
// // // // //           title: const Text('Confirm Logout'),
// // // // //           content: const SingleChildScrollView(
// // // // //             child: ListBody(children: <Widget>[Text('Are you sure you want to sign out?')]),
// // // // //           ),
// // // // //           shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
// // // // //           actions: <Widget>[
// // // // //             TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
// // // // //             TextButton(
// // // // //               child: const Text('Logout', style: TextStyle(color: Colors.red)),
// // // // //               onPressed: () async {
// // // // //                 Navigator.of(dialogContext).pop();
// // // // //                 try {
// // // // //                   await _authService.signOut();
// // // // //                   // After signing out, the AuthWrapper should handle navigation
// // // // //                   // So, no explicit Navigator.pushNamedAndRemoveUntil needed here
// // // // //                   // if AuthWrapper listens to auth state changes correctly.
// // // // //                   // If AddVenueFormScreen is the root, then app might close or go to login.
// // // // //                 } catch (e) {
// // // // //                   debugPrint("Error during sign out from form: $e");
// // // // //                   if (context.mounted) {
// // // // //                     _showSnackBar('Error signing out: ${e.toString()}', isError: true);
// // // // //                   }
// // // // //                 }
// // // // //               },
// // // // //             ),
// // // // //           ],
// // // // //         );
// // // // //       },
// // // // //     );
// // // // //   }

// // // // //   Widget _buildImageUploadSection() {
// // // // //     Widget imagePreview;
// // // // //     const double previewSize = 150.0;

// // // // //     if (_isUploadingImage && _selectedImageFile == null) {
// // // // //       imagePreview = const Center(child: CircularProgressIndicator());
// // // // //     } else if (_selectedImageFile != null) {
// // // // //       imagePreview = kIsWeb
// // // // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // // // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // // // //     } else if (_imageUrlController.text.isNotEmpty) {
// // // // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // // // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // // // //         loadingBuilder: (context, child, loadingProgress) {
// // // // //           if (loadingProgress == null) return child;
// // // // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // // // //         },
// // // // //       );
// // // // //     } else {
// // // // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // // // //     }

// // // // //     return Column(
// // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // //       children: [
// // // // //         Center(
// // // // //           child: Column(
// // // // //             children: [
// // // // //               GestureDetector(
// // // // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // // // //                 child: Container(
// // // // //                   height: previewSize,
// // // // //                   width: previewSize,
// // // // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // // // //                   decoration: BoxDecoration(
// // // // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // // // //                     border: Border.all(
// // // // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // // // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // // // //                     ),
// // // // //                     borderRadius: BorderRadius.circular(8.0),
// // // // //                   ),
// // // // //                   child: ClipRRect(
// // // // //                     borderRadius: BorderRadius.circular(7.0),
// // // // //                     child: Stack(
// // // // //                       fit: StackFit.expand,
// // // // //                       children: [
// // // // //                         imagePreview,
// // // // //                         if (_isUploadingImage)
// // // // //                           Container(
// // // // //                             color: Colors.black.withOpacity(0.4),
// // // // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // // // //                           ),
// // // // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // // // //                           Positioned(
// // // // //                             top: 4,
// // // // //                             right: 4,
// // // // //                             child: Material(
// // // // //                               color: Colors.black54,
// // // // //                               shape: const CircleBorder(),
// // // // //                               child: InkWell(
// // // // //                                 customBorder: const CircleBorder(),
// // // // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // // // //                                 child: const Padding(
// // // // //                                   padding: EdgeInsets.all(6.0),
// // // // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // // // //                                 ),
// // // // //                               ),
// // // // //                             ),
// // // // //                           ),
// // // // //                       ],
// // // // //                     ),
// // // // //                   ),
// // // // //                 ),
// // // // //               ),
// // // // //               if (!_isUploadingImage)
// // // // //                 OutlinedButton.icon(
// // // // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // // // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // // // //                   onPressed: _pickAndUploadImage,
// // // // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // // // //                 ),
// // // // //             ],
// // // // //           ),
// // // // //         ),
// // // // //         if (_isUploadingImage)
// // // // //           Center(
// // // // //             child: Padding(
// // // // //               padding: const EdgeInsets.only(top: 10.0),
// // // // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // // // //             ),
// // // // //           ),
// // // // //         if (_imageErrorText != null)
// // // // //             Padding(
// // // // //                 padding: const EdgeInsets.only(top: 8.0),
// // // // //                 child: Center(
// // // // //                   child: Text(
// // // // //                     _imageErrorText!,
// // // // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // //                     textAlign: TextAlign.center,
// // // // //                   ),
// // // // //                 ),
// // // // //             ),
// // // // //         Visibility(
// // // // //           visible: false, maintainState: true,
// // // // //           child: TextFormField(
// // // // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // // // //           ),
// // // // //         ),
// // // // //       ],
// // // // //     );
// // // // //   }

// // // // //   Widget _buildSportsInputSection() {
// // // // //     return Column(
// // // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // // //       children: [
// // // // //         TextFormField(
// // // // //           controller: _sportInputController,
// // // // //           focusNode: _sportInputFocusNode,
// // // // //           textCapitalization: TextCapitalization.words,
// // // // //           decoration: InputDecoration(
// // // // //             hintText: 'Sports Offered* (Type & press Enter)', 
// // // // //             prefixIcon: const Icon(Icons.fitness_center), 
// // // // //             border: OutlineInputBorder(
// // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline),
// // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // //             ),
// // // // //             focusedBorder: OutlineInputBorder(
// // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).primaryColor, width: 1.5),
// // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // //             ),
// // // // //              enabledBorder: OutlineInputBorder( 
// // // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// // // // //                borderRadius: BorderRadius.circular(4.0),
// // // // //             ),
// // // // //             errorBorder: OutlineInputBorder(
// // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // //             ),
// // // // //             focusedErrorBorder: OutlineInputBorder(
// // // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // // //               borderRadius: BorderRadius.circular(4.0),
// // // // //             ),
// // // // //           ),
// // // // //           onFieldSubmitted: (_) => _addSportFromInput(),
// // // // //         ),
// // // // //         if (_selectedSports.isNotEmpty)
// // // // //           Padding(
// // // // //             padding: const EdgeInsets.only(top: 8.0),
// // // // //             child: Container(
// // // // //               width: double.infinity,
// // // // //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// // // // //               child: Wrap(
// // // // //                 spacing: 8.0,
// // // // //                 runSpacing: 4.0,
// // // // //                 children: _selectedSports.map((sport) {
// // // // //                   return InputChip(
// // // // //                     label: Text(sport),
// // // // //                     labelStyle: TextStyle(color: Theme.of(context).colorScheme.onSecondaryContainer),
// // // // //                     backgroundColor: Theme.of(context).colorScheme.secondaryContainer.withOpacity(0.7),
// // // // //                     deleteIconColor: Theme.of(context).colorScheme.onSecondaryContainer.withOpacity(0.7),
// // // // //                     onDeleted: () => _removeSport(sport),
// // // // //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// // // // //                     padding: const EdgeInsets.all(6),
// // // // //                   );
// // // // //                 }).toList(),
// // // // //               ),
// // // // //             ),
// // // // //           ),
// // // // //         if (_sportsErrorText != null)
// // // // //           Padding(
// // // // //             padding: const EdgeInsets.only(top: 8.0, left: 12.0),
// // // // //             child: Text(
// // // // //               _sportsErrorText!,
// // // // //               style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // // //             ),
// // // // //           ),
// // // // //       ],
// // // // //     );
// // // // //   }


// // // // //   @override
// // // // //   Widget build(BuildContext context) {
// // // // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // // // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // // // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;
// // // // //     final bool isLoggedIn = _auth.currentUser != null;

// // // // //     Widget nameSuffixIcon;
// // // // //     if (_isCheckingVenueName) {
// // // // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // // // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // // // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // // // //     } else {
// // // // //       nameSuffixIcon = const SizedBox.shrink();
// // // // //     }

// // // // //     return Scaffold(
// // // // //       appBar: AppBar(
// // // // //         title: Text(_isEditMode ? 'Edit Venue' : 'Add New Venue'),
// // // // //         actions: isLoggedIn ? <Widget>[ // Only show actions if user is logged in
// // // // //           IconButton(
// // // // //             icon: const Icon(Icons.person_outline_rounded),
// // // // //             tooltip: 'My Profile',
// // // // //             onPressed: () {
// // // // //               if (!context.mounted) return;
// // // // //               Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()));
// // // // //             },
// // // // //           ),
// // // // //         ] : null, // No actions if not logged in
// // // // //       ),
// // // // //       body: SingleChildScrollView(
// // // // //         child: GestureDetector(
// // // // //           onTap: () => FocusScope.of(context).unfocus(),
// // // // //           child: Padding(
// // // // //             padding: const EdgeInsets.all(16.0),
// // // // //             child: Form(
// // // // //               key: _formKey,
// // // // //               autovalidateMode: _autovalidateMode,
// // // // //               child: AbsorbPointer(
// // // // //                 absorbing: anyOperationInProgress,
// // // // //                 child: Opacity(
// // // // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // // // //                   child: Column(
// // // // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // // // //                     children: [
// // // // //                       _buildSectionHeader("Core Details"),
// // // // //                       TextFormField(
// // // // //                         controller: _nameController,
// // // // //                         decoration: InputDecoration(
// // // // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // // // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // // // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // // // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // // // //                                      ? _venueNameErrorText : null,
// // // // //                         ),
// // // // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // // // //                         textCapitalization: TextCapitalization.words
// // // // //                       ),
// // // // //                       const SizedBox(height: 15),

// // // // //                       _buildSportsInputSection(),
// // // // //                       const SizedBox(height: 15),

// // // // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // // // //                       const SizedBox(height: 20),

// // // // //                       _buildSectionHeader("Venue Image*"),
// // // // //                       _buildImageUploadSection(),
// // // // //                       const SizedBox(height: 20),

// // // // //                       _buildSectionHeader("Address & Location*"),
// // // // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // // //                       const SizedBox(height: 15),
// // // // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // // // //                       const SizedBox(height: 15),
// // // // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // // // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),

// // // // //                       _buildSectionHeader("Venue on Google Maps*"),
// // // // //                       Row(
// // // // //                         children: [
// // // // //                           Expanded(
// // // // //                             child: OutlinedButton.icon(
// // // // //                               icon: const Icon(Icons.map_outlined, size: 18),
// // // // //                               label: const Text('Open Google Maps'),
// // // // //                               onPressed: anyOperationInProgress ? null : _launchGoogleMaps,
// // // // //                               style: OutlinedButton.styleFrom(
// // // // //                                 padding: const EdgeInsets.symmetric(vertical: 12),
// // // // //                               ),
// // // // //                             ),
// // // // //                           ),
// // // // //                         ],
// // // // //                       ),
// // // // //                       const SizedBox(height: 10),
// // // // //                       TextFormField(
// // // // //                         controller: _googleMapsUrlController,
// // // // //                         decoration: const InputDecoration(
// // // // //                           labelText: 'Pasted Google Maps Link*',
// // // // //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// // // // //                           prefixIcon: Icon(Icons.link),
// // // // //                         ),
// // // // //                         validator: (value) {
// // // // //                           if (value == null || value.trim().isEmpty) {
// // // // //                             return 'Google Maps link is required.';
// // // // //                           }
// // // // //                           final trimmedValue = value.trim();
// // // // //                           final uri = Uri.tryParse(trimmedValue);
// // // // //                           if (uri == null || !uri.isAbsolute) {
// // // // //                             return 'Please enter a valid URL.';
// // // // //                           }
// // // // //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// // // // //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// // // // //                               !lowerTrimmedValue.contains('google.') &&
// // // // //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// // // // //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// // // // //                           }
// // // // //                           return null;
// // // // //                         },
// // // // //                         keyboardType: TextInputType.url,
// // // // //                       ),
// // // // //                       Padding(
// // // // //                         padding: const EdgeInsets.only(top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// // // // //                         child: Text(
// // // // //                           "1. Click 'Open Google Maps' above.\n"
// // // // //                           "2. In Google Maps, find the exact venue.\n"
// // // // //                           "3. Use the 'Share' option and 'Copy link'.\n"
// // // // //                           "4. Paste the link in the field above.",
// // // // //                           style: TextStyle(fontSize: 12.5, color: Theme.of(context).hintColor),
// // // // //                           textAlign: TextAlign.start,
// // // // //                         ),
// // // // //                       ),
// // // // //                       const SizedBox(height: 20),

// // // // //                       _buildSectionHeader("Operating Hours*"),
// // // // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // // // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // // // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // // // //                       _buildSectionHeader("Contact & Other Info"),
// // // // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // // // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // // // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // // // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // // // //                       _buildSectionHeader("Status & Settings"),
// // // // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // // // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // // // //                       Row(
// // // // //                         mainAxisAlignment: MainAxisAlignment.center,
// // // // //                         children: [
// // // // //                           SizedBox(
// // // // //                             width: 200,
// // // // //                             child: ElevatedButton.icon(
// // // // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // // // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // // // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // // // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // // // //                             ),
// // // // //                           ),
// // // // //                         ],
// // // // //                       ),
// // // // //                       const SizedBox(height: 20),
// // // // //                     ],
// // // // //                   ),
// // // // //                 ),
// // // // //               ),
// // // // //             ),
// // // // //           ),
// // // // //         ),
// // // // //       ),
// // // // //     );
// // // // //   }

// // // // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // // // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // // // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // // // //   }

// // // // //   Widget _buildSectionHeader(String title) {
// // // // //      return Padding(
// // // // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // // // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // // //     );
// // // // //   }

// // // // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // // // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // // // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // // // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // // // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // // // //     }
// // // // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // // // //     if (kIsWeb) {
// // // // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // // // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // // // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // // // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // // // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // // // //         final double totalAvailableWidth = constraints.maxWidth;
// // // // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // // // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // // // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // // // //         } else {
// // // // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // // // //         }
// // // // //       });
// // // // //     } else {
// // // // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // // // //     }
// // // // //   }
// // // // // }

// // // // //--------------new admin related changes added here------------------
// // // // import 'dart:async';
// // // // import 'dart:io'; // For File, used for non-web image preview

// // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // // import 'package:flutter/material.dart';
// // // // import 'package:geolocator/geolocator.dart';
// // // // import 'package:image_picker/image_picker.dart';
// // // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // // // import 'package:url_launcher/url_launcher.dart';

// // // // import '../../../../core/services/geocoding_service.dart';
// // // // import '../../../../core/services/image_upload_service.dart';
// // // // import '../../../../core/services/location_service.dart';
// // // // import '../../../../features/data/services/firestore_service.dart';

// // // // class AddVenueFormScreen extends StatefulWidget {
// // // //   final String? venueIdToEdit;
// // // //   final Map<String, dynamic>? initialData;
// // // //   /// True if an admin is landing here directly as their "home" page.
// // // //   /// This will add a button to navigate to the user-facing app view.
// // // //   final bool isDirectAdminAccess;

// // // //   const AddVenueFormScreen({
// // // //     super.key,
// // // //     this.venueIdToEdit,
// // // //     this.initialData,
// // // //     this.isDirectAdminAccess = false, // <<< ADDED PARAMETER WITH DEFAULT
// // // //   });

// // // //   @override
// // // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // // }

// // // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // // //   final _formKey = GlobalKey<FormState>();
// // // //   final FirestoreService _firestoreService = FirestoreService();
// // // //   final LocationService _locationService = LocationService();
// // // //   final LocationIQService _geocodingService = LocationIQService();
// // // //   final FirebaseAuth _auth = FirebaseAuth.instance;
// // // //   final AuthService _authService = AuthService();

// // // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // // //   final ImagePicker _picker = ImagePicker();

// // // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// // // //   // Controllers
// // // //   final _nameController = TextEditingController();
// // // //   final _descriptionController = TextEditingController();
// // // //   final _imageUrlController = TextEditingController();
// // // //   final _addressController = TextEditingController();
// // // //   final _cityController = TextEditingController();
// // // //   final _countryController = TextEditingController();
// // // //   final _weekdayStartController = TextEditingController();
// // // //   final _weekdayEndController = TextEditingController();
// // // //   final _saturdayStartController = TextEditingController();
// // // //   final _saturdayEndController = TextEditingController();
// // // //   final _sundayStartController = TextEditingController();
// // // //   final _sundayEndController = TextEditingController();
// // // //   final _phoneController = TextEditingController();
// // // //   final _websiteController = TextEditingController();
// // // //   final _emailController = TextEditingController();
// // // //   final _facilitiesController = TextEditingController();
// // // //   final _googleMapsUrlController = TextEditingController();

// // // //   List<String> _selectedSports = [];
// // // //   final _sportInputController = TextEditingController();
// // // //   final _sportInputFocusNode = FocusNode();
// // // //   String? _sportsErrorText;

// // // //   bool _isActive = true;
// // // //   bool _bookingEnabled = true;
// // // //   bool _isLoading = false;
// // // //   bool _isFetchingLocation = false;
// // // //   bool _isGeocoding = false;
// // // //   GeoPoint? _selectedLocation;
// // // //   String? _locationStatusMessage;

// // // //   Timer? _venueNameDebouncer;
// // // //   bool _isCheckingVenueName = false;
// // // //   bool _venueNameIsAvailable = true;
// // // //   String? _venueNameErrorText;
// // // //   String? _initialVenueNameLowercase;

// // // //   XFile? _selectedImageFile;
// // // //   bool _isUploadingImage = false;
// // // //   String? _imageErrorText;

// // // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // // //   @override
// // // //   void initState() {
// // // //     super.initState();
// // // //     if (_isEditMode && widget.initialData != null) {
// // // //       _prefillFormData(widget.initialData!);
// // // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // // //     }
// // // //     _nameController.addListener(_onNameChanged);
// // // //   }

// // // //   void _prefillFormData(Map<String, dynamic> data) {
// // // //     _nameController.text = data['name'] ?? '';
// // // //     _selectedSports = (data['sportType'] as List<dynamic>?)?.map((s) => s.toString().trim()).where((s) => s.isNotEmpty).toList() ?? [];
// // // //     _descriptionController.text = data['description'] ?? '';
// // // //     _addressController.text = data['address'] ?? '';
// // // //     _cityController.text = data['city'] ?? '';
// // // //     _countryController.text = data['country'] ?? '';
// // // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // // //     _isActive = data['isActive'] ?? true;
// // // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // // //     _phoneController.text = data['phoneNumber'] ?? '';
// // // //     _websiteController.text = data['website'] ?? '';
// // // //     _emailController.text = data['email'] ?? '';
// // // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// // // //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// // // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // // //     if (initialLocation != null) {
// // // //       _selectedLocation = initialLocation;
// // // //       _locationStatusMessage = 'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // // //     }

// // // //     if (data['operatingHours'] is Map) {
// // // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // // //     }
// // // //   }

// // // //   @override
// // // //   void dispose() {
// // // //     _nameController.removeListener(_onNameChanged);
// // // //     _nameController.dispose();
// // // //     _venueNameDebouncer?.cancel();
// // // //     _sportInputController.dispose();
// // // //     _sportInputFocusNode.dispose();
// // // //     _descriptionController.dispose();
// // // //     _imageUrlController.dispose();
// // // //     _addressController.dispose();
// // // //     _cityController.dispose();
// // // //     _countryController.dispose();
// // // //     _weekdayStartController.dispose();
// // // //     _weekdayEndController.dispose();
// // // //     _saturdayStartController.dispose();
// // // //     _saturdayEndController.dispose();
// // // //     _sundayStartController.dispose();
// // // //     _sundayEndController.dispose();
// // // //     _phoneController.dispose();
// // // //     _websiteController.dispose();
// // // //     _emailController.dispose();
// // // //     _facilitiesController.dispose();
// // // //     _googleMapsUrlController.dispose();
// // // //     super.dispose();
// // // //   }

// // // //   void _addSportFromInput() {
// // // //     final sportName = _sportInputController.text.trim();
// // // //     if (sportName.isNotEmpty) {
// // // //       final capitalizedSportName = sportName
// // // //           .split(' ')
// // // //           .map((word) => word.isNotEmpty ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}' : '')
// // // //           .join(' ');

// // // //       if (!_selectedSports.any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// // // //         setState(() {
// // // //           _selectedSports.add(capitalizedSportName);
// // // //           _sportsErrorText = null;
// // // //         });
// // // //       }
// // // //       _sportInputController.clear();
// // // //       _sportInputFocusNode.requestFocus();
// // // //     }
// // // //   }

// // // //   void _removeSport(String sportName) {
// // // //     setState(() {
// // // //       _selectedSports.remove(sportName);
// // // //       if (_selectedSports.isEmpty && _autovalidateMode == AutovalidateMode.onUserInteraction) {
// // // //         _sportsErrorText = 'At least one sport is required.';
// // // //       }
// // // //     });
// // // //   }


// // // //   void _onNameChanged() {
// // // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // // //       final name = _nameController.text.trim();
// // // //       if (name.isNotEmpty) {
// // // //         _checkVenueNameUniqueness(name);
// // // //       } else {
// // // //         setState(() {
// // // //           _isCheckingVenueName = false;
// // // //           _venueNameIsAvailable = true;
// // // //           _venueNameErrorText = null;
// // // //         });
// // // //       }
// // // //     });
// // // //   }

// // // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // // //     if (!mounted) return;
// // // //     setState(() {
// // // //       _isCheckingVenueName = true;
// // // //       _venueNameIsAvailable = true;
// // // //       _venueNameErrorText = null;
// // // //     });
// // // //     final nameLower = name.toLowerCase();
// // // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // // //       return;
// // // //     }
// // // //     try {
// // // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // // //       if (!mounted) return;
// // // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // // //     } catch (e) {
// // // //       if (!mounted) return;
// // // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // // //       debugPrint("Error checking venue name: $e");
// // // //     }
// // // //   }

// // // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // // //     TimeOfDay? initialTime;
// // // //     if (controller.text.isNotEmpty) {
// // // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // // //     }
// // // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // // //     if (picked != null) {
// // // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // // //     }
// // // //   }

// // // //   Future<void> _fetchAndSetCurrentLocation() async {
// // // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // // //     final Position? p = await _locationService.getCurrentLocation();
// // // //     if (!mounted) return;
// // // //     if (p != null) {
// // // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // // //       _showSnackBar('Location fetched!', isError: false);
// // // //     } else {
// // // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // // //     }
// // // //   }

// // // //   Future<void> _geocodeAddress() async {
// // // //      if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // // //     FocusScope.of(context).unfocus();
// // // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // // //     try {
// // // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // // //       if (!mounted) return;
// // // //       if (r != null) {
// // // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // // //         _showSnackBar('Location found!', isError: false);
// // // //       } else {
// // // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // // //         _showSnackBar('Address lookup failed.', isError: true);
// // // //       }
// // // //     } catch (e) {
// // // //       if (!mounted) return;
// // // //       String err = e.toString().replaceFirst('Exception: ', '');
// // // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // // //     }
// // // //   }

// // // //   Future<void> _launchGoogleMaps() async {
// // // //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// // // //     try {
// // // //       if (await canLaunchUrl(googleMapsUri)) {
// // // //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// // // //       } else {
// // // //         _showSnackBar('Could not open Google Maps. Please open it manually.', isError: true);
// // // //       }
// // // //     } catch (e) {
// // // //        _showSnackBar('Error opening Google Maps: $e', isError: true);
// // // //     }
// // // //   }

// // // //   Future<void> _pickAndUploadImage() async {
// // // //      if (_isUploadingImage) return;
// // // //     setState(() { _imageErrorText = null; });

// // // //     try {
// // // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // // //       if (pickedFile == null) return;

// // // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// // // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // // //         pickedFile,
// // // //         uploadPreset: _venueImageUploadPreset,
// // // //         folder: 'venue_images',
// // // //       );

// // // //       if (!mounted) return;

// // // //       if (uploadedUrl != null) {
// // // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // // //       } else {
// // // //         throw Exception("Cloudinary returned a null URL.");
// // // //       }
// // // //     } catch (e) {
// // // //       if (!mounted) return;
// // // //       setState(() { _isUploadingImage = false; });
// // // //       debugPrint("Image pick/upload error: $e");
// // // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // //     }
// // // //   }

// // // //   void _clearImage() {
// // // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // // //     _showSnackBar('Image removed.', isError: false);
// // // //   }

// // // //   Future<void> _submitForm() async {
// // // //     setState(() {
// // // //       _imageErrorText = null;
// // // //       _sportsErrorText = null;
// // // //     });

// // // //     if (_isLoading || _isUploadingImage) {
// // // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // // //     }
// // // //     if (_isCheckingVenueName) {
// // // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // // //     }
// // // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // // //     }

// // // //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// // // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// // // //     bool areSportsSelected = _selectedSports.isNotEmpty;

// // // //     if (!isImagePresent) {
// // // //         setState(() { _imageErrorText = 'Venue image is required.'; });
// // // //     }
// // // //     if (!areSportsSelected) {
// // // //         setState(() { _sportsErrorText = 'At least one sport is required.'; });
// // // //     }

// // // //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// // // //       setState(() { _isLoading = true; });

// // // //       if (!_isEditMode && _selectedLocation == null) {
// // // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // // //         setState(() { _isLoading = false; }); return;
// // // //       }

// // // //       try {
// // // //         List<String> sportTypes = List.from(_selectedSports);
// // // //         if (sportTypes.isEmpty) sportTypes.add('General');

// // // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // // //         Set<String> keywords = {};
// // // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // // //         addWordsToKeywordsSet(_nameController.text.trim());
// // // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // // //         List<String> searchKeywordsList = keywords.toList();

// // // //         Map<String, dynamic> venueData = {
// // // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // // //           'sportType': sportTypes,
// // // //           'description': _descriptionController.text.trim(),
// // // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // // //           'searchKeywords': searchKeywordsList,
// // // //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// // // //           'operatingHours': {
// // // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // // //           },
// // // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // // //         };

// // // //         if (_isEditMode) {
// // // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // // //           _showSnackBar('Venue updated!', isError: false);
// // // //         } else {
// // // //           await _firestoreService.addVenue(venueData);
// // // //           _showSnackBar('Venue added!', isError: false);
// // // //         }
// // // //         if (mounted) Navigator.pop(context, true);
// // // //       } catch (e) {
// // // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // // //       } finally {
// // // //         if (mounted) setState(() { _isLoading = false; });
// // // //       }
// // // //     } else {
// // // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // // //       String errorMessage = "Please fix errors in the form.";
// // // //       if (!isTextFormFieldsValid) { /* Errors shown by fields */ }
// // // //       else if (!isImagePresent && !areSportsSelected) {
// // // //           errorMessage = "Please upload a venue image and add at least one sport.";
// // // //       } else if (!isImagePresent) {
// // // //           errorMessage = "Please upload a venue image.";
// // // //       } else if (!areSportsSelected) {
// // // //           errorMessage = "Please add at least one sport.";
// // // //       }
// // // //       _showSnackBar(errorMessage, isError: true);
// // // //     }
// // // //   }

// // // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) {
// // // //     if (!mounted) return;
// // // //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// // // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // // //       content: Text(message),
// // // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // // //       behavior: SnackBarBehavior.floating,
// // // //       margin: const EdgeInsets.all(10),
// // // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// // // //     ));
// // // //   }

// // // //   Future<void> _showLogoutConfirmationDialogForForm(BuildContext context) async {
// // // //     if (!context.mounted) return;
// // // //     return showDialog<void>(
// // // //       context: context,
// // // //       barrierDismissible: false,
// // // //       builder: (BuildContext dialogContext) {
// // // //         return AlertDialog(
// // // //           title: const Text('Confirm Logout'),
// // // //           content: const SingleChildScrollView(
// // // //             child: ListBody(children: <Widget>[Text('Are you sure you want to sign out?')]),
// // // //           ),
// // // //           shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
// // // //           actions: <Widget>[
// // // //             TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
// // // //             TextButton(
// // // //               child: const Text('Logout', style: TextStyle(color: Colors.red)),
// // // //               onPressed: () async {
// // // //                 Navigator.of(dialogContext).pop();
// // // //                 try {
// // // //                   await _authService.signOut();
// // // //                 } catch (e) {
// // // //                   debugPrint("Error during sign out from form: $e");
// // // //                   if (context.mounted) {
// // // //                     _showSnackBar('Error signing out: ${e.toString()}', isError: true);
// // // //                   }
// // // //                 }
// // // //               },
// // // //             ),
// // // //           ],
// // // //         );
// // // //       },
// // // //     );
// // // //   }

// // // //   // --- All UI build methods (_buildImageUploadSection, etc.) are identical ---

// // // //   Widget _buildImageUploadSection() {
// // // //     Widget imagePreview;
// // // //     const double previewSize = 150.0;

// // // //     if (_isUploadingImage && _selectedImageFile == null) {
// // // //       imagePreview = const Center(child: CircularProgressIndicator());
// // // //     } else if (_selectedImageFile != null) {
// // // //       imagePreview = kIsWeb
// // // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // // //     } else if (_imageUrlController.text.isNotEmpty) {
// // // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // // //         loadingBuilder: (context, child, loadingProgress) {
// // // //           if (loadingProgress == null) return child;
// // // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // // //         },
// // // //       );
// // // //     } else {
// // // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // // //     }

// // // //     return Column(
// // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // //       children: [
// // // //         Center(
// // // //           child: Column(
// // // //             children: [
// // // //               GestureDetector(
// // // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // // //                 child: Container(
// // // //                   height: previewSize,
// // // //                   width: previewSize,
// // // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // // //                   decoration: BoxDecoration(
// // // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // // //                     border: Border.all(
// // // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // // //                     ),
// // // //                     borderRadius: BorderRadius.circular(8.0),
// // // //                   ),
// // // //                   child: ClipRRect(
// // // //                     borderRadius: BorderRadius.circular(7.0),
// // // //                     child: Stack(
// // // //                       fit: StackFit.expand,
// // // //                       children: [
// // // //                         imagePreview,
// // // //                         if (_isUploadingImage)
// // // //                           Container(
// // // //                             color: Colors.black.withOpacity(0.4),
// // // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // // //                           ),
// // // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // // //                           Positioned(
// // // //                             top: 4,
// // // //                             right: 4,
// // // //                             child: Material(
// // // //                               color: Colors.black54,
// // // //                               shape: const CircleBorder(),
// // // //                               child: InkWell(
// // // //                                 customBorder: const CircleBorder(),
// // // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // // //                                 child: const Padding(
// // // //                                   padding: EdgeInsets.all(6.0),
// // // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // // //                                 ),
// // // //                               ),
// // // //                             ),
// // // //                           ),
// // // //                       ],
// // // //                     ),
// // // //                   ),
// // // //                 ),
// // // //               ),
// // // //               if (!_isUploadingImage)
// // // //                 OutlinedButton.icon(
// // // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // // //                   onPressed: _pickAndUploadImage,
// // // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // // //                 ),
// // // //             ],
// // // //           ),
// // // //         ),
// // // //         if (_isUploadingImage)
// // // //           Center(
// // // //             child: Padding(
// // // //               padding: const EdgeInsets.only(top: 10.0),
// // // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // // //             ),
// // // //           ),
// // // //         if (_imageErrorText != null)
// // // //             Padding(
// // // //                 padding: const EdgeInsets.only(top: 8.0),
// // // //                 child: Center(
// // // //                   child: Text(
// // // //                     _imageErrorText!,
// // // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // //                     textAlign: TextAlign.center,
// // // //                   ),
// // // //                 ),
// // // //             ),
// // // //         Visibility(
// // // //           visible: false, maintainState: true,
// // // //           child: TextFormField(
// // // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // // //           ),
// // // //         ),
// // // //       ],
// // // //     );
// // // //   }

// // // //   Widget _buildSportsInputSection() {
// // // //     return Column(
// // // //       crossAxisAlignment: CrossAxisAlignment.start,
// // // //       children: [
// // // //         TextFormField(
// // // //           controller: _sportInputController,
// // // //           focusNode: _sportInputFocusNode,
// // // //           textCapitalization: TextCapitalization.words,
// // // //           decoration: InputDecoration(
// // // //             hintText: 'Sports Offered* (Type & press Enter)', 
// // // //             prefixIcon: const Icon(Icons.fitness_center), 
// // // //             border: OutlineInputBorder(
// // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline),
// // // //               borderRadius: BorderRadius.circular(4.0),
// // // //             ),
// // // //             focusedBorder: OutlineInputBorder(
// // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).primaryColor, width: 1.5),
// // // //                borderRadius: BorderRadius.circular(4.0),
// // // //             ),
// // // //              enabledBorder: OutlineInputBorder( 
// // // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// // // //                borderRadius: BorderRadius.circular(4.0),
// // // //             ),
// // // //             errorBorder: OutlineInputBorder(
// // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // //               borderRadius: BorderRadius.circular(4.0),
// // // //             ),
// // // //             focusedErrorBorder: OutlineInputBorder(
// // // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // // //               borderRadius: BorderRadius.circular(4.0),
// // // //             ),
// // // //           ),
// // // //           onFieldSubmitted: (_) => _addSportFromInput(),
// // // //         ),
// // // //         if (_selectedSports.isNotEmpty)
// // // //           Padding(
// // // //             padding: const EdgeInsets.only(top: 8.0),
// // // //             child: Container(
// // // //               width: double.infinity,
// // // //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// // // //               child: Wrap(
// // // //                 spacing: 8.0,
// // // //                 runSpacing: 4.0,
// // // //                 children: _selectedSports.map((sport) {
// // // //                   return InputChip(
// // // //                     label: Text(sport),
// // // //                     labelStyle: TextStyle(color: Theme.of(context).colorScheme.onSecondaryContainer),
// // // //                     backgroundColor: Theme.of(context).colorScheme.secondaryContainer.withOpacity(0.7),
// // // //                     deleteIconColor: Theme.of(context).colorScheme.onSecondaryContainer.withOpacity(0.7),
// // // //                     onDeleted: () => _removeSport(sport),
// // // //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// // // //                     padding: const EdgeInsets.all(6),
// // // //                   );
// // // //                 }).toList(),
// // // //               ),
// // // //             ),
// // // //           ),
// // // //         if (_sportsErrorText != null)
// // // //           Padding(
// // // //             padding: const EdgeInsets.only(top: 8.0, left: 12.0),
// // // //             child: Text(
// // // //               _sportsErrorText!,
// // // //               style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // // //             ),
// // // //           ),
// // // //       ],
// // // //     );
// // // //   }

// // // //   @override
// // // //   Widget build(BuildContext context) {
// // // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;
// // // //     final bool isLoggedIn = _auth.currentUser != null;

// // // //     Widget nameSuffixIcon;
// // // //     if (_isCheckingVenueName) {
// // // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // // //     } else {
// // // //       nameSuffixIcon = const SizedBox.shrink();
// // // //     }

// // // //     // <<< MODIFICATION IS HERE
// // // //     final List<Widget> appBarActions = [];

// // // //     if (isLoggedIn) {
// // // //       appBarActions.add(
// // // //         IconButton(
// // // //           icon: const Icon(Icons.person_outline_rounded),
// // // //           tooltip: 'My Profile',
// // // //           onPressed: () {
// // // //             if (!context.mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()));
// // // //           },
// // // //         ),
// // // //       );
// // // //     }
// // // //     // <<< END OF MODIFICATION

// // // //     return Scaffold(
// // // //       appBar: AppBar(
// // // //         title: Text(_isEditMode ? 'Edit Venue' : 'Add New Venue'),
// // // //         // Use the dynamically built list of actions.
// // // //         actions: appBarActions.isNotEmpty ? appBarActions : null,
// // // //       ),
// // // //       body: SingleChildScrollView(
// // // //         child: GestureDetector(
// // // //           onTap: () => FocusScope.of(context).unfocus(),
// // // //           child: Padding(
// // // //             padding: const EdgeInsets.all(16.0),
// // // //             child: Form(
// // // //               key: _formKey,
// // // //               autovalidateMode: _autovalidateMode,
// // // //               child: AbsorbPointer(
// // // //                 absorbing: anyOperationInProgress,
// // // //                 child: Opacity(
// // // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // // //                   child: Column(
// // // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // // //                     children: [
// // // //                       // --- The rest of the form body is IDENTICAL to what you provided ---
// // // //                       _buildSectionHeader("Core Details"),
// // // //                       TextFormField(
// // // //                         controller: _nameController,
// // // //                         decoration: InputDecoration(
// // // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // // //                                      ? _venueNameErrorText : null,
// // // //                         ),
// // // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // // //                         textCapitalization: TextCapitalization.words
// // // //                       ),
// // // //                       const SizedBox(height: 15),

// // // //                       _buildSportsInputSection(),
// // // //                       const SizedBox(height: 15),

// // // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // // //                       const SizedBox(height: 20),

// // // //                       _buildSectionHeader("Venue Image*"),
// // // //                       _buildImageUploadSection(),
// // // //                       const SizedBox(height: 20),

// // // //                       _buildSectionHeader("Address & Location*"),
// // // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // // //                       const SizedBox(height: 15),
// // // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // // //                       const SizedBox(height: 15),
// // // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),

// // // //                       _buildSectionHeader("Venue on Google Maps*"),
// // // //                       Row(
// // // //                         children: [
// // // //                           Expanded(
// // // //                             child: OutlinedButton.icon(
// // // //                               icon: const Icon(Icons.map_outlined, size: 18),
// // // //                               label: const Text('Open Google Maps'),
// // // //                               onPressed: anyOperationInProgress ? null : _launchGoogleMaps,
// // // //                               style: OutlinedButton.styleFrom(
// // // //                                 padding: const EdgeInsets.symmetric(vertical: 12),
// // // //                               ),
// // // //                             ),
// // // //                           ),
// // // //                         ],
// // // //                       ),
// // // //                       const SizedBox(height: 10),
// // // //                       TextFormField(
// // // //                         controller: _googleMapsUrlController,
// // // //                         decoration: const InputDecoration(
// // // //                           labelText: 'Pasted Google Maps Link*',
// // // //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// // // //                           prefixIcon: Icon(Icons.link),
// // // //                         ),
// // // //                         validator: (value) {
// // // //                           if (value == null || value.trim().isEmpty) {
// // // //                             return 'Google Maps link is required.';
// // // //                           }
// // // //                           final trimmedValue = value.trim();
// // // //                           final uri = Uri.tryParse(trimmedValue);
// // // //                           if (uri == null || !uri.isAbsolute) {
// // // //                             return 'Please enter a valid URL.';
// // // //                           }
// // // //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// // // //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// // // //                               !lowerTrimmedValue.contains('google.') &&
// // // //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// // // //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// // // //                           }
// // // //                           return null;
// // // //                         },
// // // //                         keyboardType: TextInputType.url,
// // // //                       ),
// // // //                       Padding(
// // // //                         padding: const EdgeInsets.only(top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// // // //                         child: Text(
// // // //                           "1. Click 'Open Google Maps' above.\n"
// // // //                           "2. In Google Maps, find the exact venue.\n"
// // // //                           "3. Use the 'Share' option and 'Copy link'.\n"
// // // //                           "4. Paste the link in the field above.",
// // // //                           style: TextStyle(fontSize: 12.5, color: Theme.of(context).hintColor),
// // // //                           textAlign: TextAlign.start,
// // // //                         ),
// // // //                       ),
// // // //                       const SizedBox(height: 20),

// // // //                       _buildSectionHeader("Operating Hours*"),
// // // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // // //                       _buildSectionHeader("Contact & Other Info"),
// // // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // // //                       _buildSectionHeader("Status & Settings"),
// // // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // // //                       Row(
// // // //                         mainAxisAlignment: MainAxisAlignment.center,
// // // //                         children: [
// // // //                           SizedBox(
// // // //                             width: 200,
// // // //                             child: ElevatedButton.icon(
// // // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // // //                             ),
// // // //                           ),
// // // //                         ],
// // // //                       ),
// // // //                       const SizedBox(height: 20),
// // // //                     ],
// // // //                   ),
// // // //                 ),
// // // //               ),
// // // //             ),
// // // //           ),
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // // //   }

// // // //   Widget _buildSectionHeader(String title) {
// // // //      return Padding(
// // // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // //     );
// // // //   }

// // // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // // //     }
// // // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // // //     if (kIsWeb) {
// // // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // // //         final double totalAvailableWidth = constraints.maxWidth;
// // // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // // //         } else {
// // // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // // //         }
// // // //       });
// // // //     } else {
// // // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // // //     }
// // // //   }
// // // // }

// // // import 'dart:async';
// // // import 'dart:io'; // For File, used for non-web image preview

// // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // import 'package:firebase_auth/firebase_auth.dart';
// // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // import 'package:flutter/material.dart';
// // // import 'package:geolocator/geolocator.dart';
// // // import 'package:image_picker/image_picker.dart';
// // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // // import 'package:mm_associates/features/user/services/user_service.dart';
// // // import 'package:url_launcher/url_launcher.dart';

// // // import '../../../../core/services/geocoding_service.dart';
// // // import '../../../../core/services/image_upload_service.dart';
// // // import '../../../../core/services/location_service.dart';
// // // import '../../../../features/data/services/firestore_service.dart';

// // // class AddVenueFormScreen extends StatefulWidget {
// // //   final String? venueIdToEdit;
// // //   final Map<String, dynamic>? initialData;

// // //   /// True if an admin is landing here directly as their "home" page.
// // //   /// This will add a button to navigate to the user-facing app view.
// // //   final bool isDirectAdminAccess;

// // //   const AddVenueFormScreen({
// // //     super.key,
// // //     this.venueIdToEdit,
// // //     this.initialData,
// // //     this.isDirectAdminAccess = false,
// // //   });

// // //   @override
// // //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // // }

// // // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// // //   final _formKey = GlobalKey<FormState>();
// // //   final FirestoreService _firestoreService = FirestoreService();
// // //   final LocationService _locationService = LocationService();
// // //   final LocationIQService _geocodingService = LocationIQService();
// // //   final FirebaseAuth _auth = FirebaseAuth.instance;
// // //   final AuthService _authService = AuthService();
// // //   // ADDED: UserService to fetch user data
// // //   final UserService _userService = UserService();

// // //   final ImageUploadService _imageUploadService = ImageUploadService();
// // //   final ImagePicker _picker = ImagePicker();

// // //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// // //   // Controllers
// // //   final _nameController = TextEditingController();
// // //   final _descriptionController = TextEditingController();
// // //   final _imageUrlController = TextEditingController();
// // //   final _addressController = TextEditingController();
// // //   final _cityController = TextEditingController();
// // //   final _countryController = TextEditingController();
// // //   final _weekdayStartController = TextEditingController();
// // //   final _weekdayEndController = TextEditingController();
// // //   final _saturdayStartController = TextEditingController();
// // //   final _saturdayEndController = TextEditingController();
// // //   final _sundayStartController = TextEditingController();
// // //   final _sundayEndController = TextEditingController();
// // //   final _phoneController = TextEditingController();
// // //   final _websiteController = TextEditingController();
// // //   final _emailController = TextEditingController();
// // //   final _facilitiesController = TextEditingController();
// // //   final _googleMapsUrlController = TextEditingController();

// // //   List<String> _selectedSports = [];
// // //   final _sportInputController = TextEditingController();
// // //   final _sportInputFocusNode = FocusNode();
// // //   String? _sportsErrorText;

// // //   bool _isActive = true;
// // //   bool _bookingEnabled = true;
// // //   bool _isLoading = false;
// // //   bool _isFetchingLocation = false;
// // //   bool _isGeocoding = false;
// // //   GeoPoint? _selectedLocation;
// // //   String? _locationStatusMessage;

// // //   Timer? _venueNameDebouncer;
// // //   bool _isCheckingVenueName = false;
// // //   bool _venueNameIsAvailable = true;
// // //   String? _venueNameErrorText;
// // //   String? _initialVenueNameLowercase;

// // //   XFile? _selectedImageFile;
// // //   bool _isUploadingImage = false;
// // //   String? _imageErrorText;

// // //   // ADDED: State for AppBar user info
// // //   String? _userName;
// // //   bool _isLoadingName = true;

// // //   bool get _isEditMode => widget.venueIdToEdit != null;
// // //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// // //   @override
// // //   void initState() {
// // //     super.initState();
// // //     if (_isEditMode && widget.initialData != null) {
// // //       _prefillFormData(widget.initialData!);
// // //       _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
// // //     }
// // //     _nameController.addListener(_onNameChanged);
// // //     // ADDED: Fetch user name on screen initialization
// // //     _fetchUserName();
// // //   }

// // //   // --- All other methods remain exactly the same ---
// // //   // (prefill, dispose, validation, geocoding, image upload, form submission, etc.)

// // //   void _prefillFormData(Map<String, dynamic> data) {
// // //     _nameController.text = data['name'] ?? '';
// // //     _selectedSports = (data['sportType'] as List<dynamic>?)?.map((s) => s.toString().trim()).where((s) => s.isNotEmpty).toList() ?? [];
// // //     _descriptionController.text = data['description'] ?? '';
// // //     _addressController.text = data['address'] ?? '';
// // //     _cityController.text = data['city'] ?? '';
// // //     _countryController.text = data['country'] ?? '';
// // //     _imageUrlController.text = data['imageUrl'] ?? '';
// // //     _isActive = data['isActive'] ?? true;
// // //     _bookingEnabled = data['bookingEnabled'] ?? true;
// // //     _phoneController.text = data['phoneNumber'] ?? '';
// // //     _websiteController.text = data['website'] ?? '';
// // //     _emailController.text = data['email'] ?? '';
// // //     _facilitiesController.text = (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// // //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// // //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// // //     if (initialLocation != null) {
// // //       _selectedLocation = initialLocation;
// // //       _locationStatusMessage = 'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// // //     }

// // //     if (data['operatingHours'] is Map) {
// // //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// // //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// // //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// // //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// // //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// // //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// // //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// // //     }
// // //   }

// // //   @override
// // //   void dispose() {
// // //     _nameController.removeListener(_onNameChanged);
// // //     _nameController.dispose();
// // //     _venueNameDebouncer?.cancel();
// // //     _sportInputController.dispose();
// // //     _sportInputFocusNode.dispose();
// // //     _descriptionController.dispose();
// // //     _imageUrlController.dispose();
// // //     _addressController.dispose();
// // //     _cityController.dispose();
// // //     _countryController.dispose();
// // //     _weekdayStartController.dispose();
// // //     _weekdayEndController.dispose();
// // //     _saturdayStartController.dispose();
// // //     _saturdayEndController.dispose();
// // //     _sundayStartController.dispose();
// // //     _sundayEndController.dispose();
// // //     _phoneController.dispose();
// // //     _websiteController.dispose();
// // //     _emailController.dispose();
// // //     _facilitiesController.dispose();
// // //     _googleMapsUrlController.dispose();
// // //     super.dispose();
// // //   }

// // //   // --- ADDED: Method to fetch user name for the AppBar ---
// // //   Future<void> _fetchUserName() async {
// // //     if (!mounted) return;
// // //     setState(() => _isLoadingName = true);
// // //     final currentUser = _auth.currentUser;
// // //     if (currentUser == null) {
// // //       if (mounted) setState(() { _userName = 'Guest'; _isLoadingName = false; });
// // //       return;
// // //     }
// // //     try {
// // //       final userData = await _userService.getUserProfileData();
// // //       if (!mounted) return;
// // //       final fetchedName = userData?['name'] as String? ?? currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // //       setState(() { _userName = fetchedName; });
// // //     } catch (e) {
// // //       if (!mounted) return;
// // //       final fallbackName = currentUser.displayName ?? currentUser.email?.split('@')[0] ?? 'User';
// // //       setState(() { _userName = fallbackName; });
// // //       debugPrint("Error fetching user name: $e");
// // //     } finally {
// // //       if (mounted) setState(() => _isLoadingName = false);
// // //     }
// // //   }


// // //   void _addSportFromInput() {
// // //     final sportName = _sportInputController.text.trim();
// // //     if (sportName.isNotEmpty) {
// // //       final capitalizedSportName = sportName
// // //           .split(' ')
// // //           .map((word) => word.isNotEmpty ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}' : '')
// // //           .join(' ');

// // //       if (!_selectedSports.any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// // //         setState(() {
// // //           _selectedSports.add(capitalizedSportName);
// // //           _sportsErrorText = null;
// // //         });
// // //       }
// // //       _sportInputController.clear();
// // //       _sportInputFocusNode.requestFocus();
// // //     }
// // //   }

// // //   void _removeSport(String sportName) {
// // //     setState(() {
// // //       _selectedSports.remove(sportName);
// // //       if (_selectedSports.isEmpty && _autovalidateMode == AutovalidateMode.onUserInteraction) {
// // //         _sportsErrorText = 'At least one sport is required.';
// // //       }
// // //     });
// // //   }


// // //   void _onNameChanged() {
// // //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// // //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// // //       final name = _nameController.text.trim();
// // //       if (name.isNotEmpty) {
// // //         _checkVenueNameUniqueness(name);
// // //       } else {
// // //         setState(() {
// // //           _isCheckingVenueName = false;
// // //           _venueNameIsAvailable = true;
// // //           _venueNameErrorText = null;
// // //         });
// // //       }
// // //     });
// // //   }

// // //   Future<void> _checkVenueNameUniqueness(String name) async {
// // //     if (!mounted) return;
// // //     setState(() {
// // //       _isCheckingVenueName = true;
// // //       _venueNameIsAvailable = true;
// // //       _venueNameErrorText = null;
// // //     });
// // //     final nameLower = name.toLowerCase();
// // //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// // //       setState(() { _isCheckingVenueName = false; _venueNameIsAvailable = true; _venueNameErrorText = null; });
// // //       return;
// // //     }
// // //     try {
// // //       final bool exists = await _firestoreService.checkVenueNameExists(nameLower, _isEditMode ? widget.venueIdToEdit : null);
// // //       if (!mounted) return;
// // //       setState(() { _venueNameIsAvailable = !exists; _venueNameErrorText = exists ? 'Venue name already exists.' : null; _isCheckingVenueName = false; });
// // //     } catch (e) {
// // //       if (!mounted) return;
// // //       setState(() { _venueNameIsAvailable = false; _venueNameErrorText = 'Error checking name. Please try again.'; _isCheckingVenueName = false; });
// // //       debugPrint("Error checking venue name: $e");
// // //     }
// // //   }

// // //   Future<void> _selectTime(BuildContext context, TextEditingController controller) async {
// // //     TimeOfDay? initialTime;
// // //     if (controller.text.isNotEmpty) {
// // //       try { final parts = controller.text.split(':'); if (parts.length == 2) initialTime = TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1])); } catch (e) {/* ignore */}
// // //     }
// // //     final TimeOfDay? picked = await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// // //     if (picked != null) {
// // //       setState(() { controller.text = "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}"; });
// // //       if (_autovalidateMode == AutovalidateMode.onUserInteraction) _formKey.currentState?.validate();
// // //     }
// // //   }

// // //   Future<void> _fetchAndSetCurrentLocation() async {
// // //     if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // //     setState(() { _isFetchingLocation = true; _locationStatusMessage = 'Fetching...'; _selectedLocation = null; });
// // //     final Position? p = await _locationService.getCurrentLocation();
// // //     if (!mounted) return;
// // //     if (p != null) {
// // //       setState(() { _selectedLocation = GeoPoint(p.latitude, p.longitude); _locationStatusMessage = 'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}'; _isFetchingLocation = false; });
// // //       _showSnackBar('Location fetched!', isError: false);
// // //     } else {
// // //       setState(() { _locationStatusMessage = 'Could not get location.'; _isFetchingLocation = false; _selectedLocation = null; });
// // //       _showSnackBar('Could not fetch location. Check permissions/service.', isError: true);
// // //     }
// // //   }

// // //   Future<void> _geocodeAddress() async {
// // //      if (!mounted || _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage) return;
// // //     FocusScope.of(context).unfocus();
// // //     final fullAddressQuery = [_addressController.text.trim(), _cityController.text.trim(), _countryController.text.trim()].where((s) => s.isNotEmpty).join(', ');
// // //     if (fullAddressQuery.length < 5) { _showSnackBar('Enter Address, City, Country.', isError: true); return; }
// // //     debugPrint("Geocoding: '$fullAddressQuery'");
// // //     setState(() { _isGeocoding = true; _locationStatusMessage = 'Finding for "$fullAddressQuery"...'; _selectedLocation = null; });
// // //     try {
// // //       final GeoPoint? r = await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// // //       if (!mounted) return;
// // //       if (r != null) {
// // //         setState(() { _selectedLocation = r; _locationStatusMessage = 'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}'; _isGeocoding = false; });
// // //         _showSnackBar('Location found!', isError: false);
// // //       } else {
// // //         setState(() { _locationStatusMessage = 'Could not find location.'; _isGeocoding = false; _selectedLocation = null; });
// // //         _showSnackBar('Address lookup failed.', isError: true);
// // //       }
// // //     } catch (e) {
// // //       if (!mounted) return;
// // //       String err = e.toString().replaceFirst('Exception: ', '');
// // //       setState(() { _locationStatusMessage = "Geocoding failed: $err"; _isGeocoding = false; _selectedLocation = null; });
// // //       _showSnackBar("Geocoding error: $err", isError: true); debugPrint("Geocoding error: $e");
// // //     }
// // //   }

// // //   Future<void> _launchGoogleMaps() async {
// // //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// // //     try {
// // //       if (await canLaunchUrl(googleMapsUri)) {
// // //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// // //       } else {
// // //         _showSnackBar('Could not open Google Maps. Please open it manually.', isError: true);
// // //       }
// // //     } catch (e) {
// // //        _showSnackBar('Error opening Google Maps: $e', isError: true);
// // //     }
// // //   }

// // //   Future<void> _pickAndUploadImage() async {
// // //      if (_isUploadingImage) return;
// // //     setState(() { _imageErrorText = null; });

// // //     try {
// // //       final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
// // //       if (pickedFile == null) return;

// // //       setState(() { _selectedImageFile = pickedFile; _isUploadingImage = true; _imageUrlController.clear(); });
// // //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// // //       final String? uploadedUrl = await _imageUploadService.uploadImageToCloudinary(
// // //         pickedFile,
// // //         uploadPreset: _venueImageUploadPreset,
// // //         folder: 'venue_images',
// // //       );

// // //       if (!mounted) return;

// // //       if (uploadedUrl != null) {
// // //         setState(() { _imageUrlController.text = uploadedUrl; _selectedImageFile = null; _isUploadingImage = false; });
// // //         _showSnackBar('Image uploaded successfully!', isError: false);
// // //       } else {
// // //         throw Exception("Cloudinary returned a null URL.");
// // //       }
// // //     } catch (e) {
// // //       if (!mounted) return;
// // //       setState(() { _isUploadingImage = false; });
// // //       debugPrint("Image pick/upload error: $e");
// // //       _showSnackBar('Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // //     }
// // //   }

// // //   void _clearImage() {
// // //     setState(() { _imageUrlController.clear(); _selectedImageFile = null; _isUploadingImage = false; _imageErrorText = null; });
// // //     _showSnackBar('Image removed.', isError: false);
// // //   }

// // //   Future<void> _submitForm() async {
// // //     setState(() {
// // //       _imageErrorText = null;
// // //       _sportsErrorText = null;
// // //     });

// // //     if (_isLoading || _isUploadingImage) {
// // //       _showSnackBar('Please wait for current operations to complete.', isError: true); return;
// // //     }
// // //     if (_isCheckingVenueName) {
// // //       _showSnackBar('Venue name check in progress. Please wait.', isError: true); return;
// // //     }
// // //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// // //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
// // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; }); _formKey.currentState?.validate(); return;
// // //     }

// // //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// // //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// // //     bool areSportsSelected = _selectedSports.isNotEmpty;

// // //     if (!isImagePresent) {
// // //         setState(() { _imageErrorText = 'Venue image is required.'; });
// // //     }
// // //     if (!areSportsSelected) {
// // //         setState(() { _sportsErrorText = 'At least one sport is required.'; });
// // //     }

// // //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// // //       setState(() { _isLoading = true; });

// // //       if (!_isEditMode && _selectedLocation == null) {
// // //         _showSnackBar('Set venue location using "Use Current" or "Find Address".', isError: true);
// // //         setState(() { _isLoading = false; }); return;
// // //       }

// // //       try {
// // //         List<String> sportTypes = List.from(_selectedSports);
// // //         if (sportTypes.isEmpty) sportTypes.add('General');

// // //         List<String> facilitiesList = _facilitiesController.text.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

// // //         Set<String> keywords = {};
// // //         void addWordsToKeywordsSet(String text) { if (text.isNotEmpty) { final words = text.toLowerCase().split(RegExp(r"[\s,.-]+")); for (var word in words) if (word.isNotEmpty && word.length > 1) keywords.add(word); } }
// // //         addWordsToKeywordsSet(_nameController.text.trim());
// // //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// // //         addWordsToKeywordsSet(_addressController.text.trim()); addWordsToKeywordsSet(_cityController.text.trim()); addWordsToKeywordsSet(_countryController.text.trim());
// // //         List<String> searchKeywordsList = keywords.toList();

// // //         Map<String, dynamic> venueData = {
// // //           'name': _nameController.text.trim(), 'name_lowercase': _nameController.text.trim().toLowerCase(),
// // //           'sportType': sportTypes,
// // //           'description': _descriptionController.text.trim(),
// // //           'address': _addressController.text.trim(), 'city': _cityController.text.trim(), 'country': _countryController.text.trim(),
// // //           'imageUrl': _imageUrlController.text.trim(), 'isActive': _isActive, 'bookingEnabled': _bookingEnabled,
// // //           'slotDurationMinutes': 60, 'phoneNumber': _phoneController.text.trim(),
// // //           'website': _websiteController.text.trim(), 'email': _emailController.text.trim(), 'facilities': facilitiesList,
// // //           'searchKeywords': searchKeywordsList,
// // //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// // //           'operatingHours': {
// // //             'weekday': {'start': _weekdayStartController.text.trim(), 'end': _weekdayEndController.text.trim()},
// // //             'saturday': {'start': _saturdayStartController.text.trim(), 'end': _saturdayEndController.text.trim()},
// // //             'sunday': {'start': _sundayStartController.text.trim(), 'end': _sundayEndController.text.trim()},
// // //           },
// // //           if (_selectedLocation != null) 'location': _selectedLocation,
// // //           if (!_isEditMode) ...{ 'creatorUid': _auth.currentUser?.uid, 'createdAt': FieldValue.serverTimestamp() },
// // //         };

// // //         if (_isEditMode) {
// // //           venueData.remove('createdAt'); venueData.remove('creatorUid');
// // //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// // //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// // //           _showSnackBar('Venue updated!', isError: false);
// // //         } else {
// // //           await _firestoreService.addVenue(venueData);
// // //           _showSnackBar('Venue added!', isError: false);
// // //         }
// // //         if (mounted) Navigator.pop(context, true);
// // //       } catch (e) {
// // //         debugPrint("Submit error: $e"); if (!mounted) return;
// // //         _showSnackBar('Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}', isError: true);
// // //       } finally {
// // //         if (mounted) setState(() { _isLoading = false; });
// // //       }
// // //     } else {
// // //       setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
// // //       String errorMessage = "Please fix errors in the form.";
// // //       if (!isTextFormFieldsValid) { /* Errors shown by fields */ }
// // //       else if (!isImagePresent && !areSportsSelected) {
// // //           errorMessage = "Please upload a venue image and add at least one sport.";
// // //       } else if (!isImagePresent) {
// // //           errorMessage = "Please upload a venue image.";
// // //       } else if (!areSportsSelected) {
// // //           errorMessage = "Please add at least one sport.";
// // //       }
// // //       _showSnackBar(errorMessage, isError: true);
// // //     }
// // //   }

// // //   void _showSnackBar(String message, {required bool isError, int durationSeconds = 3}) {
// // //     if (!mounted) return;
// // //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// // //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// // //       content: Text(message),
// // //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// // //       behavior: SnackBarBehavior.floating,
// // //       margin: const EdgeInsets.all(10),
// // //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// // //     ));
// // //   }

// // //   Future<void> _showLogoutConfirmationDialogForForm(BuildContext context) async {
// // //     if (!context.mounted) return;
// // //     return showDialog<void>(
// // //       context: context,
// // //       barrierDismissible: false,
// // //       builder: (BuildContext dialogContext) {
// // //         return AlertDialog(
// // //           title: const Text('Confirm Logout'),
// // //           content: const SingleChildScrollView(
// // //             child: ListBody(children: <Widget>[Text('Are you sure you want to sign out?')]),
// // //           ),
// // //           shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
// // //           actions: <Widget>[
// // //             TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
// // //             TextButton(
// // //               child: const Text('Logout', style: TextStyle(color: Colors.red)),
// // //               onPressed: () async {
// // //                 Navigator.of(dialogContext).pop();
// // //                 try {
// // //                   await _authService.signOut();
// // //                 } catch (e) {
// // //                   debugPrint("Error during sign out from form: $e");
// // //                   if (context.mounted) {
// // //                     _showSnackBar('Error signing out: ${e.toString()}', isError: true);
// // //                   }
// // //                 }
// // //               },
// // //             ),
// // //           ],
// // //         );
// // //       },
// // //     );
// // //   }

// // //   // --- All UI build methods (_buildImageUploadSection, etc.) are identical ---

// // //   Widget _buildImageUploadSection() {
// // //     Widget imagePreview;
// // //     const double previewSize = 150.0;

// // //     if (_isUploadingImage && _selectedImageFile == null) {
// // //       imagePreview = const Center(child: CircularProgressIndicator());
// // //     } else if (_selectedImageFile != null) {
// // //       imagePreview = kIsWeb
// // //           ? Image.network(_selectedImageFile!.path, width: previewSize, height: previewSize, fit: BoxFit.cover)
// // //           : Image.file(File(_selectedImageFile!.path), width: previewSize, height: previewSize, fit: BoxFit.cover);
// // //     } else if (_imageUrlController.text.isNotEmpty) {
// // //       imagePreview = Image.network(_imageUrlController.text, width: previewSize, height: previewSize, fit: BoxFit.cover,
// // //         errorBuilder: (context, error, stackTrace) => const Center(child: Icon(Icons.broken_image_outlined, size: 40, color: Colors.grey)),
// // //         loadingBuilder: (context, child, loadingProgress) {
// // //           if (loadingProgress == null) return child;
// // //           return Center(child: CircularProgressIndicator(value: loadingProgress.expectedTotalBytes != null ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes! : null));
// // //         },
// // //       );
// // //     } else {
// // //       imagePreview = Center(child: Icon(Icons.add_a_photo_outlined, size: 40, color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// // //     }

// // //     return Column(
// // //       crossAxisAlignment: CrossAxisAlignment.start,
// // //       children: [
// // //         Center(
// // //           child: Column(
// // //             children: [
// // //               GestureDetector(
// // //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// // //                 child: Container(
// // //                   height: previewSize,
// // //                   width: previewSize,
// // //                   margin: const EdgeInsets.only(bottom: 10.0),
// // //                   decoration: BoxDecoration(
// // //                     color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.3),
// // //                     border: Border.all(
// // //                       color: _imageErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.5),
// // //                       width: _imageErrorText != null ? 1.5 : 1.0,
// // //                     ),
// // //                     borderRadius: BorderRadius.circular(8.0),
// // //                   ),
// // //                   child: ClipRRect(
// // //                     borderRadius: BorderRadius.circular(7.0),
// // //                     child: Stack(
// // //                       fit: StackFit.expand,
// // //                       children: [
// // //                         imagePreview,
// // //                         if (_isUploadingImage)
// // //                           Container(
// // //                             color: Colors.black.withOpacity(0.4),
// // //                             child: const Center(child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3,)),
// // //                           ),
// // //                         if (!_isUploadingImage && (_imageUrlController.text.isNotEmpty || _selectedImageFile != null))
// // //                           Positioned(
// // //                             top: 4,
// // //                             right: 4,
// // //                             child: Material(
// // //                               color: Colors.black54,
// // //                               shape: const CircleBorder(),
// // //                               child: InkWell(
// // //                                 customBorder: const CircleBorder(),
// // //                                 onTap: _isUploadingImage ? null : _clearImage,
// // //                                 child: const Padding(
// // //                                   padding: EdgeInsets.all(6.0),
// // //                                   child: Icon(Icons.close, color: Colors.white, size: 18),
// // //                                 ),
// // //                               ),
// // //                             ),
// // //                           ),
// // //                       ],
// // //                     ),
// // //                   ),
// // //                 ),
// // //               ),
// // //               if (!_isUploadingImage)
// // //                 OutlinedButton.icon(
// // //                   icon: Icon(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? Icons.edit_outlined : Icons.add_photo_alternate_outlined, size: 18),
// // //                   label: Text(_imageUrlController.text.isNotEmpty || _selectedImageFile != null ? 'Change Image' : 'Select Image*'),
// // //                   onPressed: _pickAndUploadImage,
// // //                   style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
// // //                 ),
// // //             ],
// // //           ),
// // //         ),
// // //         if (_isUploadingImage)
// // //           Center(
// // //             child: Padding(
// // //               padding: const EdgeInsets.only(top: 10.0),
// // //               child: Text("Uploading, please wait...", style: TextStyle(color: Theme.of(context).primaryColor, fontStyle: FontStyle.italic)),
// // //             ),
// // //           ),
// // //         if (_imageErrorText != null)
// // //             Padding(
// // //                 padding: const EdgeInsets.only(top: 8.0),
// // //                 child: Center(
// // //                   child: Text(
// // //                     _imageErrorText!,
// // //                     style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // //                     textAlign: TextAlign.center,
// // //                   ),
// // //                 ),
// // //             ),
// // //         Visibility(
// // //           visible: false, maintainState: true,
// // //           child: TextFormField(
// // //             controller: _imageUrlController, decoration: const InputDecoration(labelText: 'Image URL'),
// // //           ),
// // //         ),
// // //       ],
// // //     );
// // //   }

// // //   Widget _buildSportsInputSection() {
// // //     return Column(
// // //       crossAxisAlignment: CrossAxisAlignment.start,
// // //       children: [
// // //         TextFormField(
// // //           controller: _sportInputController,
// // //           focusNode: _sportInputFocusNode,
// // //           textCapitalization: TextCapitalization.words,
// // //           decoration: InputDecoration(
// // //             hintText: 'Sports Offered* (Type & press Enter)', 
// // //             prefixIcon: const Icon(Icons.fitness_center), 
// // //             border: OutlineInputBorder(
// // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline),
// // //               borderRadius: BorderRadius.circular(4.0),
// // //             ),
// // //             focusedBorder: OutlineInputBorder(
// // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).primaryColor, width: 1.5),
// // //                borderRadius: BorderRadius.circular(4.0),
// // //             ),
// // //              enabledBorder: OutlineInputBorder( 
// // //               borderSide: BorderSide(color: _sportsErrorText != null ? Theme.of(context).colorScheme.error : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// // //                borderRadius: BorderRadius.circular(4.0),
// // //             ),
// // //             errorBorder: OutlineInputBorder(
// // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // //               borderRadius: BorderRadius.circular(4.0),
// // //             ),
// // //             focusedErrorBorder: OutlineInputBorder(
// // //               borderSide: BorderSide(color: Theme.of(context).colorScheme.error, width: 1.5),
// // //               borderRadius: BorderRadius.circular(4.0),
// // //             ),
// // //           ),
// // //           onFieldSubmitted: (_) => _addSportFromInput(),
// // //         ),
// // //         if (_selectedSports.isNotEmpty)
// // //           Padding(
// // //             padding: const EdgeInsets.only(top: 8.0),
// // //             child: Container(
// // //               width: double.infinity,
// // //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// // //               child: Wrap(
// // //                 spacing: 8.0,
// // //                 runSpacing: 4.0,
// // //                 children: _selectedSports.map((sport) {
// // //                   return InputChip(
// // //                     label: Text(sport),
// // //                     labelStyle: TextStyle(color: Theme.of(context).colorScheme.onSecondaryContainer),
// // //                     backgroundColor: Theme.of(context).colorScheme.secondaryContainer.withOpacity(0.7),
// // //                     deleteIconColor: Theme.of(context).colorScheme.onSecondaryContainer.withOpacity(0.7),
// // //                     onDeleted: () => _removeSport(sport),
// // //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// // //                     padding: const EdgeInsets.all(6),
// // //                   );
// // //                 }).toList(),
// // //               ),
// // //             ),
// // //           ),
// // //         if (_sportsErrorText != null)
// // //           Padding(
// // //             padding: const EdgeInsets.only(top: 8.0, left: 12.0),
// // //             child: Text(
// // //               _sportsErrorText!,
// // //               style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 12),
// // //             ),
// // //           ),
// // //       ],
// // //     );
// // //   }

// // //   // --- NEW: Custom AppBar builder method ---
// // //   AppBar _buildAppBar(BuildContext context) {
// // //     final theme = Theme.of(context);
// // //     final bool isLoggedIn = _auth.currentUser != null;
// // //     final String pageTitle = _isEditMode ? 'Edit Venue' : 'Add New Venue';

// // //     final List<Widget> appBarActions = [
// // //       if (isLoggedIn)
// // //         IconButton(
// // //           icon: const Icon(Icons.person_outline_rounded),
// // //           tooltip: 'My Profile',
// // //           onPressed: () {
// // //             if (!context.mounted) return;
// // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const ProfileScreen()));
// // //           },
// // //         ),
// // //       if (kIsWeb) const SizedBox(width: 16),
// // //     ];

// // //     return AppBar(
// // //       title: kIsWeb
// // //           ? Stack(
// // //               alignment: Alignment.center,
// // //               children: [
// // //                 Align(
// // //                   alignment: Alignment.centerLeft,
// // //                   child: Row(
// // //                     mainAxisSize: MainAxisSize.min,
// // //                     children: [
// // //                       Text('MM Associates', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color ?? theme.primaryColor)),
// // //                       const SizedBox(width: 24),
// // //                       if (_isLoadingName && isLoggedIn)
// // //                         const Padding(padding: EdgeInsets.only(right: 16.0), child: SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)))
// // //                       else if (_userName != null && isLoggedIn)
// // //                         Flexible( // Prevents overflow on narrow web windows
// // //                           child: Padding(
// // //                             padding: const EdgeInsets.only(right: 16.0),
// // //                             child: Text(
// // //                               'Hi, ${_userName!.split(' ')[0]}!',
// // //                               style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: theme.textTheme.bodyLarge?.color),
// // //                               overflow: TextOverflow.ellipsis,
// // //                             ),
// // //                           ),
// // //                         ),
// // //                     ],
// // //                   ),
// // //                 ),
// // //                 Center(
// // //                   child: Text(pageTitle, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w600)),
// // //                 ),
// // //               ],
// // //             )
// // //           : Text(pageTitle),
// // //       actions: appBarActions,
// // //       backgroundColor: kIsWeb ? theme.canvasColor : null, // Use theme default for mobile
// // //       elevation: kIsWeb ? 1.0 : null,
// // //       iconTheme: kIsWeb ? theme.iconTheme.copyWith(color: theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : null,
// // //       actionsIconTheme: kIsWeb ? theme.iconTheme.copyWith(color: theme.brightness == Brightness.dark ? Colors.white70 : Colors.black87) : null,
// // //     );
// // //   }

// // //   @override
// // //   Widget build(BuildContext context) {
// // //     final bool anyOperationInProgress = _isLoading || _isFetchingLocation || _isGeocoding || _isUploadingImage || _isCheckingVenueName;
// // //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// // //     final IconData submitBtnIcon = _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;

// // //     Widget nameSuffixIcon;
// // //     if (_isCheckingVenueName) {
// // //       nameSuffixIcon = const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// // //     } else if (_nameController.text.trim().isNotEmpty && (_isEditMode ? _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase : true)) {
// // //       nameSuffixIcon = _venueNameIsAvailable ? const Icon(Icons.check_circle_outline, color: Colors.green) : Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error);
// // //     } else {
// // //       nameSuffixIcon = const SizedBox.shrink();
// // //     }
    
// // //     return Scaffold(
// // //       // --- MODIFIED: Using the new AppBar builder ---
// // //       appBar: _buildAppBar(context),
// // //       body: SingleChildScrollView(
// // //         child: GestureDetector(
// // //           onTap: () => FocusScope.of(context).unfocus(),
// // //           child: Padding(
// // //             padding: const EdgeInsets.all(16.0),
// // //             child: Form(
// // //               key: _formKey,
// // //               autovalidateMode: _autovalidateMode,
// // //               child: AbsorbPointer(
// // //                 absorbing: anyOperationInProgress,
// // //                 child: Opacity(
// // //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// // //                   child: Column(
// // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // //                     children: [
// // //                       // --- The rest of the form body is IDENTICAL to what you provided ---
// // //                       _buildSectionHeader("Core Details"),
// // //                       TextFormField(
// // //                         controller: _nameController,
// // //                         decoration: InputDecoration(
// // //                           labelText: 'Venue Name*', prefixIcon: const Icon(Icons.sports_soccer),
// // //                           suffixIcon: Padding(padding: const EdgeInsets.only(right: 12.0), child: nameSuffixIcon),
// // //                           errorText: ((_nameController.text.isNotEmpty && !_isCheckingVenueName && !_isEditMode) ||
// // //                                      (_nameController.text.isNotEmpty && !_isCheckingVenueName && _isEditMode && _nameController.text.trim().toLowerCase() != _initialVenueNameLowercase))
// // //                                      ? _venueNameErrorText : null,
// // //                         ),
// // //                         validator: (v) { if (v == null || v.trim().isEmpty) return 'Required'; return null; },
// // //                         textCapitalization: TextCapitalization.words
// // //                       ),
// // //                       const SizedBox(height: 15),

// // //                       _buildSportsInputSection(),
// // //                       const SizedBox(height: 15),

// // //                       TextFormField(controller: _descriptionController, decoration: const InputDecoration(labelText: 'Description', prefixIcon: Icon(Icons.description_outlined), alignLabelWithHint: true), maxLines: 3, textCapitalization: TextCapitalization.sentences),
// // //                       const SizedBox(height: 20),

// // //                       _buildSectionHeader("Venue Image*"),
// // //                       _buildImageUploadSection(),
// // //                       const SizedBox(height: 20),

// // //                       _buildSectionHeader("Address & Location*"),
// // //                       TextFormField(controller: _addressController, decoration: const InputDecoration(labelText: 'Address Line*', prefixIcon: Icon(Icons.location_on_outlined)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words),
// // //                       const SizedBox(height: 15),
// // //                       Row(children: [ Expanded(child: TextFormField(controller: _cityController, decoration: const InputDecoration(labelText: 'City*', prefixIcon: Icon(Icons.location_city)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)), const SizedBox(width: 10), Expanded(child: TextFormField(controller: _countryController, decoration: const InputDecoration(labelText: 'Country*', prefixIcon: Icon(Icons.public)), validator: (v) => v!.trim().isEmpty ? 'Required' : null, textCapitalization: TextCapitalization.words)) ]),
// // //                       const SizedBox(height: 15),
// // //                       Row(children: [ Expanded(child: OutlinedButton.icon(icon: _isFetchingLocation ? _buildButtonSpinner() : const Icon(Icons.my_location, size: 18), label: const Text('Use Current'), onPressed: anyOperationInProgress ? null : _fetchAndSetCurrentLocation, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))), const SizedBox(width: 10), Expanded(child: OutlinedButton.icon(icon: _isGeocoding ? _buildButtonSpinner() : const Icon(Icons.location_searching, size: 18), label: const Text('Find Address'), onPressed: anyOperationInProgress ? null : _geocodeAddress, style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)))) ]),
// // //                       Padding(padding: const EdgeInsets.only(top: 10.0, bottom: 5.0), child: Text(_locationStatusMessage ?? (_isEditMode && _selectedLocation != null ? 'Location previously set' : 'Location not set* (Required for new venues)'), style: TextStyle(fontSize: 13, color: Colors.grey[700]), textAlign: TextAlign.center)),

// // //                       _buildSectionHeader("Venue on Google Maps*"),
// // //                       Row(
// // //                         children: [
// // //                           Expanded(
// // //                             child: OutlinedButton.icon(
// // //                               icon: const Icon(Icons.map_outlined, size: 18),
// // //                               label: const Text('Open Google Maps'),
// // //                               onPressed: anyOperationInProgress ? null : _launchGoogleMaps,
// // //                               style: OutlinedButton.styleFrom(
// // //                                 padding: const EdgeInsets.symmetric(vertical: 12),
// // //                               ),
// // //                             ),
// // //                           ),
// // //                         ],
// // //                       ),
// // //                       const SizedBox(height: 10),
// // //                       TextFormField(
// // //                         controller: _googleMapsUrlController,
// // //                         decoration: const InputDecoration(
// // //                           labelText: 'Pasted Google Maps Link*',
// // //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// // //                           prefixIcon: Icon(Icons.link),
// // //                         ),
// // //                         validator: (value) {
// // //                           if (value == null || value.trim().isEmpty) {
// // //                             return 'Google Maps link is required.';
// // //                           }
// // //                           final trimmedValue = value.trim();
// // //                           final uri = Uri.tryParse(trimmedValue);
// // //                           if (uri == null || !uri.isAbsolute) {
// // //                             return 'Please enter a valid URL.';
// // //                           }
// // //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// // //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// // //                               !lowerTrimmedValue.contains('google.') &&
// // //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// // //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// // //                           }
// // //                           return null;
// // //                         },
// // //                         keyboardType: TextInputType.url,
// // //                       ),
// // //                       Padding(
// // //                         padding: const EdgeInsets.only(top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// // //                         child: Text(
// // //                           "1. Click 'Open Google Maps' above.\n"
// // //                           "2. In Google Maps, find the exact venue.\n"
// // //                           "3. Use the 'Share' option and 'Copy link'.\n"
// // //                           "4. Paste the link in the field above.",
// // //                           style: TextStyle(fontSize: 12.5, color: Theme.of(context).hintColor),
// // //                           textAlign: TextAlign.start,
// // //                         ),
// // //                       ),
// // //                       const SizedBox(height: 20),

// // //                       _buildSectionHeader("Operating Hours*"),
// // //                       _buildOperatingHoursRow("Weekday", _weekdayStartController, _weekdayEndController), const SizedBox(height: 12),
// // //                       _buildOperatingHoursRow("Saturday", _saturdayStartController, _saturdayEndController), const SizedBox(height: 12),
// // //                       _buildOperatingHoursRow("Sunday", _sundayStartController, _sundayEndController), const SizedBox(height: 20),

// // //                       _buildSectionHeader("Contact & Other Info"),
// // //                       TextFormField(controller: _phoneController, decoration: const InputDecoration(labelText: 'Phone (Optional)', prefixIcon: Icon(Icons.phone_outlined)), keyboardType: TextInputType.phone), const SizedBox(height: 15),
// // //                       TextFormField(controller: _emailController, decoration: const InputDecoration(labelText: 'Email (Optional)', prefixIcon: Icon(Icons.email_outlined)), keyboardType: TextInputType.emailAddress, validator: (v) { if (v!.trim().isNotEmpty && !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(v.trim())) return 'Invalid email'; return null; }), const SizedBox(height: 15),
// // //                       TextFormField(controller: _websiteController, decoration: const InputDecoration(labelText: 'Website (Optional)', prefixIcon: Icon(Icons.language_outlined)), keyboardType: TextInputType.url, validator: (v) { if (v!.trim().isNotEmpty && (Uri.tryParse(v.trim())?.isAbsolute ?? false) == false) return 'Invalid URL'; return null; }), const SizedBox(height: 15),
// // //                       TextFormField(controller: _facilitiesController, decoration: const InputDecoration(labelText: 'Facilities (Optional)', hintText: 'Comma-separated', prefixIcon: Icon(Icons.local_offer_outlined)), textCapitalization: TextCapitalization.words), const SizedBox(height: 20),

// // //                       _buildSectionHeader("Status & Settings"),
// // //                       SwitchListTile(title: const Text('Booking Enabled?'), subtitle: const Text('Can users make bookings for this venue?'), value: _bookingEnabled, onChanged: anyOperationInProgress ? null : (v) => setState(() => _bookingEnabled = v), secondary: Icon(_bookingEnabled ? Icons.event_available : Icons.event_busy, color: _bookingEnabled ? Theme.of(context).primaryColor : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 10),
// // //                       SwitchListTile(title: const Text('Venue is Active?'), subtitle: const Text('Inactive venues won\'t appear in searches.'), value: _isActive, onChanged: anyOperationInProgress ? null : (v) => setState(() => _isActive = v), secondary: Icon(_isActive ? Icons.check_circle : Icons.cancel_outlined, color: _isActive ? Colors.green : Colors.grey), contentPadding: EdgeInsets.zero, dense: true), const SizedBox(height: 25),

// // //                       Row(
// // //                         mainAxisAlignment: MainAxisAlignment.center,
// // //                         children: [
// // //                           SizedBox(
// // //                             width: 200,
// // //                             child: ElevatedButton.icon(
// // //                                 icon: (anyOperationInProgress && (_isLoading || _isUploadingImage)) ? _buildButtonSpinner(size: 20, color: Colors.white) : Icon(submitBtnIcon),
// // //                                 label: Text((anyOperationInProgress && (_isLoading || _isUploadingImage)) ? 'Saving...' : submitBtnTxt),
// // //                                 onPressed: anyOperationInProgress ? null : _submitForm,
// // //                                 style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 15), textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
// // //                             ),
// // //                           ),
// // //                         ],
// // //                       ),
// // //                       const SizedBox(height: 20),
// // //                     ],
// // //                   ),
// // //                 ),
// // //               ),
// // //             ),
// // //           ),
// // //         ),
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// // //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// // //     return SizedBox(width: size, height: size, child: CircularProgressIndicator(strokeWidth: 2, valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// // //   }

// // //   Widget _buildSectionHeader(String title) {
// // //      return Padding(
// // //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// // //       child: Text(title, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
// // //     );
// // //   }

// // //   Widget _buildOperatingHoursRow(String dayLabel, TextEditingController startController, TextEditingController endController) {
// // //     const double dayLabelColumnWidth = 90.0; const double gapBetweenLabelAndTimes = 8.0; const double preferredTimeFieldWidth = 105.0; const double horizontalPaddingForToText = 5.0;
// // //     String? timeValidator(String? value) { if (value == null || value.trim().isEmpty) return 'Required'; if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").hasMatch(value.trim())) return 'HH:MM'; return null; }
// // //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// // //       return InkWell(onTap: () => _selectTime(context, controller), child: AbsorbPointer(child: TextFormField(controller: controller, textAlign: TextAlign.center, decoration: InputDecoration(labelText: labelText, contentPadding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0), isDense: true, border: const OutlineInputBorder(), suffixIcon: const Icon(Icons.access_time, size: 18)), validator: timeValidator)));
// // //     }
// // //     Widget dayLabelWidget = SizedBox(width: dayLabelColumnWidth, child: Text(dayLabel, style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500), textAlign: TextAlign.start));
// // //     if (kIsWeb) {
// // //       Widget buildWebTimeInput(TextEditingController controller, String labelText) { return SizedBox(width: preferredTimeFieldWidth, child: buildCoreTimeInput(controller, labelText)); }
// // //       final TextPainter textPainter = TextPainter(text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)), maxLines: 1, textDirection: TextDirection.ltr)..layout(minWidth: 0, maxWidth: double.infinity);
// // //       final double widthOfToTextWithPadding = textPainter.width + (2 * horizontalPaddingForToText);
// // //       final double requiredWidthForTimeControlsGroupWeb = (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// // //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// // //         final double totalAvailableWidth = constraints.maxWidth;
// // //         final double singleLineRequiredWidthWeb = dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// // //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// // //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: Row(children: [ Flexible(child: buildWebTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Flexible(child: buildWebTimeInput(endController, 'End')), const Spacer()]))]);
// // //         } else {
// // //           return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [ dayLabelWidget, const SizedBox(height: 8.0), Padding(padding: const EdgeInsets.only(left: 0.0), child: Row(mainAxisSize: MainAxisSize.min, children: [ buildWebTimeInput(startController, 'Start'), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), buildWebTimeInput(endController, 'End')]))]);
// // //         }
// // //       });
// // //     } else {
// // //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [ dayLabelWidget, const SizedBox(width: gapBetweenLabelAndTimes), Expanded(child: buildCoreTimeInput(startController, 'Start')), Padding(padding: const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText), child: Text("to", style: const TextStyle(fontSize: 14))), Expanded(child: buildCoreTimeInput(endController, 'End'))]);
// // //     }
// // //   }
// // // }


// // import 'dart:async';
// // import 'dart:io'; // For File, used for non-web image preview

// // import 'package:cloud_firestore/cloud_firestore.dart';
// // import 'package:firebase_auth/firebase_auth.dart';
// // import 'package:flutter/foundation.dart' show kIsWeb;
// // import 'package:flutter/material.dart';
// // import 'package:geolocator/geolocator.dart';
// // import 'package:image_picker/image_picker.dart';
// // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// // import 'package:mm_associates/features/user/services/user_service.dart';
// // import 'package:url_launcher/url_launcher.dart';

// // import '../../../../core/services/geocoding_service.dart';
// // import '../../../../core/services/image_upload_service.dart';
// // import '../../../../core/services/location_service.dart';
// // import '../../../../features/data/services/firestore_service.dart';

// // class AddVenueFormScreen extends StatefulWidget {
// //   final String? venueIdToEdit;
// //   final Map<String, dynamic>? initialData;

// //   /// True if an admin is landing here directly as their "home" page.
// //   /// This will add a button to navigate to the user-facing app view.
// //   final bool isDirectAdminAccess;

// //   const AddVenueFormScreen({
// //     super.key,
// //     this.venueIdToEdit,
// //     this.initialData,
// //     this.isDirectAdminAccess = false,
// //   });

// //   @override
// //   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// // }

// // class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
// //   final _formKey = GlobalKey<FormState>();
// //   final FirestoreService _firestoreService = FirestoreService();
// //   final LocationService _locationService = LocationService();
// //   final LocationIQService _geocodingService = LocationIQService();
// //   final FirebaseAuth _auth = FirebaseAuth.instance;
// //   final AuthService _authService = AuthService();
// //   final UserService _userService = UserService();

// //   final ImageUploadService _imageUploadService = ImageUploadService();
// //   final ImagePicker _picker = ImagePicker();

// //   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

// //   // Controllers
// //   final _nameController = TextEditingController();
// //   final _descriptionController = TextEditingController();
// //   final _imageUrlController = TextEditingController();
// //   final _addressController = TextEditingController();
// //   final _cityController = TextEditingController();
// //   final _countryController = TextEditingController();
// //   final _weekdayStartController = TextEditingController();
// //   final _weekdayEndController = TextEditingController();
// //   final _saturdayStartController = TextEditingController();
// //   final _saturdayEndController = TextEditingController();
// //   final _sundayStartController = TextEditingController();
// //   final _sundayEndController = TextEditingController();
// //   final _phoneController = TextEditingController();
// //   final _websiteController = TextEditingController();
// //   final _emailController = TextEditingController();
// //   final _facilitiesController = TextEditingController();
// //   final _googleMapsUrlController = TextEditingController();

// //   List<String> _selectedSports = [];
// //   final _sportInputController = TextEditingController();
// //   final _sportInputFocusNode = FocusNode();
// //   String? _sportsErrorText;

// //   bool _isActive = true;
// //   bool _bookingEnabled = true;
// //   bool _isLoading = false;
// //   bool _isFetchingLocation = false;
// //   bool _isGeocoding = false;
// //   GeoPoint? _selectedLocation;
// //   String? _locationStatusMessage;

// //   Timer? _venueNameDebouncer;
// //   bool _isCheckingVenueName = false;
// //   bool _venueNameIsAvailable = true;
// //   String? _venueNameErrorText;
// //   String? _initialVenueNameLowercase;

// //   XFile? _selectedImageFile;
// //   bool _isUploadingImage = false;
// //   String? _imageErrorText;

// //   // --- State for new AppBar design ---
// //   String? _userName;
// //   String? _userProfilePicUrl;
// //   bool _isLoadingName = true;

// //   bool get _isEditMode => widget.venueIdToEdit != null;
// //   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

// //   @override
// //   void initState() {
// //     super.initState();
// //     if (_isEditMode && widget.initialData != null) {
// //       _prefillFormData(widget.initialData!);
// //       _initialVenueNameLowercase =
// //           widget.initialData!['name']?.toString().trim().toLowerCase();
// //     }
// //     _nameController.addListener(_onNameChanged);
// //     _fetchUserNameAndPic();
// //   }

// //   void _prefillFormData(Map<String, dynamic> data) {
// //     _nameController.text = data['name'] ?? '';
// //     _selectedSports = (data['sportType'] as List<dynamic>?)
// //             ?.map((s) => s.toString().trim())
// //             .where((s) => s.isNotEmpty)
// //             .toList() ??
// //         [];
// //     _descriptionController.text = data['description'] ?? '';
// //     _addressController.text = data['address'] ?? '';
// //     _cityController.text = data['city'] ?? '';
// //     _countryController.text = data['country'] ?? '';
// //     _imageUrlController.text = data['imageUrl'] ?? '';
// //     _isActive = data['isActive'] ?? true;
// //     _bookingEnabled = data['bookingEnabled'] ?? true;
// //     _phoneController.text = data['phoneNumber'] ?? '';
// //     _websiteController.text = data['website'] ?? '';
// //     _emailController.text = data['email'] ?? '';
// //     _facilitiesController.text =
// //         (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
// //     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

// //     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
// //     if (initialLocation != null) {
// //       _selectedLocation = initialLocation;
// //       _locationStatusMessage =
// //           'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
// //     }

// //     if (data['operatingHours'] is Map) {
// //       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
// //       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
// //       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
// //       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
// //       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
// //       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
// //       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
// //     }
// //   }

// //   @override
// //   void dispose() {
// //     _nameController.removeListener(_onNameChanged);
// //     _nameController.dispose();
// //     _venueNameDebouncer?.cancel();
// //     _sportInputController.dispose();
// //     _sportInputFocusNode.dispose();
// //     _descriptionController.dispose();
// //     _imageUrlController.dispose();
// //     _addressController.dispose();
// //     _cityController.dispose();
// //     _countryController.dispose();
// //     _weekdayStartController.dispose();
// //     _weekdayEndController.dispose();
// //     _saturdayStartController.dispose();
// //     _saturdayEndController.dispose();
// //     _sundayStartController.dispose();
// //     _sundayEndController.dispose();
// //     _phoneController.dispose();
// //     _websiteController.dispose();
// //     _emailController.dispose();
// //     _facilitiesController.dispose();
// //     _googleMapsUrlController.dispose();
// //     super.dispose();
// //   }

// //   Future<void> _fetchUserNameAndPic() async {
// //     if (!mounted) return;
// //     setState(() => _isLoadingName = true);
// //     final currentUser = _auth.currentUser;
// //     if (currentUser == null) {
// //       if (mounted)
// //         setState(() {
// //           _userName = 'Guest';
// //           _userProfilePicUrl = null;
// //           _isLoadingName = false;
// //         });
// //       return;
// //     }
// //     try {
// //       final userData = await _userService.getUserProfileData();
// //       if (!mounted) return;
// //       final fetchedName = userData?['name'] as String? ??
// //           currentUser.displayName ??
// //           currentUser.email?.split('@')[0] ??
// //           'User';
// //       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
// //       setState(() {
// //         _userName = fetchedName;
// //         _userProfilePicUrl = fetchedPicUrl;
// //       });
// //     } catch (e) {
// //       if (!mounted) return;
// //       final fallbackName = currentUser.displayName ??
// //           currentUser.email?.split('@')[0] ??
// //           'User';
// //       setState(() {
// //         _userName = fallbackName;
// //         _userProfilePicUrl = null;
// //       });
// //       debugPrint("Error fetching user name: $e");
// //     } finally {
// //       if (mounted) setState(() => _isLoadingName = false);
// //     }
// //   }

// //   // --- All other methods remain the same ---
// //   // (addSport, removeSport, onNameChanged, geocoding, image upload, form submission, etc.)

// //   void _addSportFromInput() {
// //     final sportName = _sportInputController.text.trim();
// //     if (sportName.isNotEmpty) {
// //       final capitalizedSportName = sportName
// //           .split(' ')
// //           .map((word) => word.isNotEmpty
// //               ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}'
// //               : '')
// //           .join(' ');

// //       if (!_selectedSports
// //           .any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
// //         setState(() {
// //           _selectedSports.add(capitalizedSportName);
// //           _sportsErrorText = null;
// //         });
// //       }
// //       _sportInputController.clear();
// //       _sportInputFocusNode.requestFocus();
// //     }
// //   }

// //   void _removeSport(String sportName) {
// //     setState(() {
// //       _selectedSports.remove(sportName);
// //       if (_selectedSports.isEmpty &&
// //           _autovalidateMode == AutovalidateMode.onUserInteraction) {
// //         _sportsErrorText = 'At least one sport is required.';
// //       }
// //     });
// //   }

// //   void _onNameChanged() {
// //     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
// //     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
// //       final name = _nameController.text.trim();
// //       if (name.isNotEmpty) {
// //         _checkVenueNameUniqueness(name);
// //       } else {
// //         setState(() {
// //           _isCheckingVenueName = false;
// //           _venueNameIsAvailable = true;
// //           _venueNameErrorText = null;
// //         });
// //       }
// //     });
// //   }

// //   Future<void> _checkVenueNameUniqueness(String name) async {
// //     if (!mounted) return;
// //     setState(() {
// //       _isCheckingVenueName = true;
// //       _venueNameIsAvailable = true;
// //       _venueNameErrorText = null;
// //     });
// //     final nameLower = name.toLowerCase();
// //     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
// //       setState(() {
// //         _isCheckingVenueName = false;
// //         _venueNameIsAvailable = true;
// //         _venueNameErrorText = null;
// //       });
// //       return;
// //     }
// //     try {
// //       final bool exists = await _firestoreService.checkVenueNameExists(
// //           nameLower, _isEditMode ? widget.venueIdToEdit : null);
// //       if (!mounted) return;
// //       setState(() {
// //         _venueNameIsAvailable = !exists;
// //         _venueNameErrorText = exists ? 'Venue name already exists.' : null;
// //         _isCheckingVenueName = false;
// //       });
// //     } catch (e) {
// //       if (!mounted) return;
// //       setState(() {
// //         _venueNameIsAvailable = false;
// //         _venueNameErrorText = 'Error checking name. Please try again.';
// //         _isCheckingVenueName = false;
// //       });
// //       debugPrint("Error checking venue name: $e");
// //     }
// //   }

// //   Future<void> _selectTime(
// //       BuildContext context, TextEditingController controller) async {
// //     TimeOfDay? initialTime;
// //     if (controller.text.isNotEmpty) {
// //       try {
// //         final parts = controller.text.split(':');
// //         if (parts.length == 2)
// //           initialTime =
// //               TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
// //       } catch (e) {
// //         /* ignore */
// //       }
// //     }
// //     final TimeOfDay? picked =
// //         await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
// //     if (picked != null) {
// //       setState(() {
// //         controller.text =
// //             "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}";
// //       });
// //       if (_autovalidateMode == AutovalidateMode.onUserInteraction)
// //         _formKey.currentState?.validate();
// //     }
// //   }

// //   Future<void> _fetchAndSetCurrentLocation() async {
// //     if (!mounted ||
// //         _isLoading ||
// //         _isFetchingLocation ||
// //         _isGeocoding ||
// //         _isUploadingImage) return;
// //     setState(() {
// //       _isFetchingLocation = true;
// //       _locationStatusMessage = 'Fetching...';
// //       _selectedLocation = null;
// //     });
// //     final Position? p = await _locationService.getCurrentLocation();
// //     if (!mounted) return;
// //     if (p != null) {
// //       setState(() {
// //         _selectedLocation = GeoPoint(p.latitude, p.longitude);
// //         _locationStatusMessage =
// //             'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}';
// //         _isFetchingLocation = false;
// //       });
// //       _showSnackBar('Location fetched!', isError: false);
// //     } else {
// //       setState(() {
// //         _locationStatusMessage = 'Could not get location.';
// //         _isFetchingLocation = false;
// //         _selectedLocation = null;
// //       });
// //       _showSnackBar('Could not fetch location. Check permissions/service.',
// //           isError: true);
// //     }
// //   }

// //   Future<void> _geocodeAddress() async {
// //     if (!mounted ||
// //         _isLoading ||
// //         _isFetchingLocation ||
// //         _isGeocoding ||
// //         _isUploadingImage) return;
// //     FocusScope.of(context).unfocus();
// //     final fullAddressQuery = [
// //       _addressController.text.trim(),
// //       _cityController.text.trim(),
// //       _countryController.text.trim()
// //     ].where((s) => s.isNotEmpty).join(', ');
// //     if (fullAddressQuery.length < 5) {
// //       _showSnackBar('Enter Address, City, Country.', isError: true);
// //       return;
// //     }
// //     debugPrint("Geocoding: '$fullAddressQuery'");
// //     setState(() {
// //       _isGeocoding = true;
// //       _locationStatusMessage = 'Finding for "$fullAddressQuery"...';
// //       _selectedLocation = null;
// //     });
// //     try {
// //       final GeoPoint? r =
// //           await _geocodingService.getCoordsFromAddress(fullAddressQuery);
// //       if (!mounted) return;
// //       if (r != null) {
// //         setState(() {
// //           _selectedLocation = r;
// //           _locationStatusMessage =
// //               'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}';
// //           _isGeocoding = false;
// //         });
// //         _showSnackBar('Location found!', isError: false);
// //       } else {
// //         setState(() {
// //           _locationStatusMessage = 'Could not find location.';
// //           _isGeocoding = false;
// //           _selectedLocation = null;
// //         });
// //         _showSnackBar('Address lookup failed.', isError: true);
// //       }
// //     } catch (e) {
// //       if (!mounted) return;
// //       String err = e.toString().replaceFirst('Exception: ', '');
// //       setState(() {
// //         _locationStatusMessage = "Geocoding failed: $err";
// //         _isGeocoding = false;
// //         _selectedLocation = null;
// //       });
// //       _showSnackBar("Geocoding error: $err", isError: true);
// //       debugPrint("Geocoding error: $e");
// //     }
// //   }

// //   Future<void> _launchGoogleMaps() async {
// //     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
// //     try {
// //       if (await canLaunchUrl(googleMapsUri)) {
// //         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
// //       } else {
// //         _showSnackBar('Could not open Google Maps. Please open it manually.',
// //             isError: true);
// //       }
// //     } catch (e) {
// //       _showSnackBar('Error opening Google Maps: $e', isError: true);
// //     }
// //   }

// //   Future<void> _pickAndUploadImage() async {
// //     if (_isUploadingImage) return;
// //     setState(() {
// //       _imageErrorText = null;
// //     });

// //     try {
// //       final XFile? pickedFile = await _picker.pickImage(
// //           source: ImageSource.gallery,
// //           imageQuality: 70,
// //           maxWidth: 1024,
// //           maxHeight: 1024);
// //       if (pickedFile == null) return;

// //       setState(() {
// //         _selectedImageFile = pickedFile;
// //         _isUploadingImage = true;
// //         _imageUrlController.clear();
// //       });
// //       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

// //       final String? uploadedUrl =
// //           await _imageUploadService.uploadImageToCloudinary(
// //         pickedFile,
// //         uploadPreset: _venueImageUploadPreset,
// //         folder: 'venue_images',
// //       );

// //       if (!mounted) return;

// //       if (uploadedUrl != null) {
// //         setState(() {
// //           _imageUrlController.text = uploadedUrl;
// //           _selectedImageFile = null;
// //           _isUploadingImage = false;
// //         });
// //         _showSnackBar('Image uploaded successfully!', isError: false);
// //       } else {
// //         throw Exception("Cloudinary returned a null URL.");
// //       }
// //     } catch (e) {
// //       if (!mounted) return;
// //       setState(() {
// //         _isUploadingImage = false;
// //       });
// //       debugPrint("Image pick/upload error: $e");
// //       _showSnackBar(
// //           'Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}',
// //           isError: true);
// //     }
// //   }

// //   void _clearImage() {
// //     setState(() {
// //       _imageUrlController.clear();
// //       _selectedImageFile = null;
// //       _isUploadingImage = false;
// //       _imageErrorText = null;
// //     });
// //     _showSnackBar('Image removed.', isError: false);
// //   }

// //   Future<void> _submitForm() async {
// //     setState(() {
// //       _imageErrorText = null;
// //       _sportsErrorText = null;
// //     });

// //     if (_isLoading || _isUploadingImage) {
// //       _showSnackBar('Please wait for current operations to complete.',
// //           isError: true);
// //       return;
// //     }
// //     if (_isCheckingVenueName) {
// //       _showSnackBar('Venue name check in progress. Please wait.', isError: true);
// //       return;
// //     }
// //     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
// //       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.',
// //           isError: true);
// //       setState(() {
// //         _autovalidateMode = AutovalidateMode.onUserInteraction;
// //       });
// //       _formKey.currentState?.validate();
// //       return;
// //     }

// //     bool isTextFormFieldsValid = _formKey.currentState!.validate();
// //     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
// //     bool areSportsSelected = _selectedSports.isNotEmpty;

// //     if (!isImagePresent) {
// //       setState(() {
// //         _imageErrorText = 'Venue image is required.';
// //       });
// //     }
// //     if (!areSportsSelected) {
// //       setState(() {
// //         _sportsErrorText = 'At least one sport is required.';
// //       });
// //     }

// //     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
// //       setState(() {
// //         _isLoading = true;
// //       });

// //       if (!_isEditMode && _selectedLocation == null) {
// //         _showSnackBar(
// //             'Set venue location using "Use Current" or "Find Address".',
// //             isError: true);
// //         setState(() {
// //           _isLoading = false;
// //         });
// //         return;
// //       }

// //       try {
// //         List<String> sportTypes = List.from(_selectedSports);
// //         if (sportTypes.isEmpty) sportTypes.add('General');

// //         List<String> facilitiesList = _facilitiesController.text
// //             .split(',')
// //             .map((s) => s.trim())
// //             .where((s) => s.isNotEmpty)
// //             .toList();

// //         Set<String> keywords = {};
// //         void addWordsToKeywordsSet(String text) {
// //           if (text.isNotEmpty) {
// //             final words = text.toLowerCase().split(RegExp(r"[\s,.-]+"));
// //             for (var word in words)
// //               if (word.isNotEmpty && word.length > 1) keywords.add(word);
// //           }
// //         }

// //         addWordsToKeywordsSet(_nameController.text.trim());
// //         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
// //         addWordsToKeywordsSet(_addressController.text.trim());
// //         addWordsToKeywordsSet(_cityController.text.trim());
// //         addWordsToKeywordsSet(_countryController.text.trim());
// //         List<String> searchKeywordsList = keywords.toList();

// //         Map<String, dynamic> venueData = {
// //           'name': _nameController.text.trim(),
// //           'name_lowercase': _nameController.text.trim().toLowerCase(),
// //           'sportType': sportTypes,
// //           'description': _descriptionController.text.trim(),
// //           'address': _addressController.text.trim(),
// //           'city': _cityController.text.trim(),
// //           'country': _countryController.text.trim(),
// //           'imageUrl': _imageUrlController.text.trim(),
// //           'isActive': _isActive,
// //           'bookingEnabled': _bookingEnabled,
// //           'slotDurationMinutes': 60,
// //           'phoneNumber': _phoneController.text.trim(),
// //           'website': _websiteController.text.trim(),
// //           'email': _emailController.text.trim(),
// //           'facilities': facilitiesList,
// //           'searchKeywords': searchKeywordsList,
// //           'googleMapsUrl': _googleMapsUrlController.text.trim(),
// //           'operatingHours': {
// //             'weekday': {
// //               'start': _weekdayStartController.text.trim(),
// //               'end': _weekdayEndController.text.trim()
// //             },
// //             'saturday': {
// //               'start': _saturdayStartController.text.trim(),
// //               'end': _saturdayEndController.text.trim()
// //             },
// //             'sunday': {
// //               'start': _sundayStartController.text.trim(),
// //               'end': _sundayEndController.text.trim()
// //             },
// //           },
// //           if (_selectedLocation != null) 'location': _selectedLocation,
// //           if (!_isEditMode) ...{
// //             'creatorUid': _auth.currentUser?.uid,
// //             'createdAt': FieldValue.serverTimestamp()
// //           },
// //         };

// //         if (_isEditMode) {
// //           venueData.remove('createdAt');
// //           venueData.remove('creatorUid');
// //           venueData['updatedAt'] = FieldValue.serverTimestamp();
// //           await _firestoreService.updateVenue(widget.venueIdToEdit!, venueData);
// //           _showSnackBar('Venue updated!', isError: false);
// //         } else {
// //           await _firestoreService.addVenue(venueData);
// //           _showSnackBar('Venue added!', isError: false);
// //         }
// //         if (mounted) Navigator.pop(context, true);
// //       } catch (e) {
// //         debugPrint("Submit error: $e");
// //         if (!mounted) return;
// //         _showSnackBar(
// //             'Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}',
// //             isError: true);
// //       } finally {
// //         if (mounted)
// //           setState(() {
// //             _isLoading = false;
// //           });
// //       }
// //     } else {
// //       setState(() {
// //         _autovalidateMode = AutovalidateMode.onUserInteraction;
// //       });
// //       String errorMessage = "Please fix errors in the form.";
// //       if (!isTextFormFieldsValid) {
// //         /* Errors shown by fields */
// //       } else if (!isImagePresent && !areSportsSelected) {
// //         errorMessage = "Please upload a venue image and add at least one sport.";
// //       } else if (!isImagePresent) {
// //         errorMessage = "Please upload a venue image.";
// //       } else if (!areSportsSelected) {
// //         errorMessage = "Please add at least one sport.";
// //       }
// //       _showSnackBar(errorMessage, isError: true);
// //     }
// //   }

// //   void _showSnackBar(String message,
// //       {required bool isError, int durationSeconds = 3}) {
// //     if (!mounted) return;
// //     ScaffoldMessenger.of(context).removeCurrentSnackBar();
// //     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
// //       content: Text(message),
// //       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
// //       behavior: SnackBarBehavior.floating,
// //       margin: const EdgeInsets.all(10),
// //       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
// //     ));
// //   }

// //   // --- REBUILT: Custom AppBar method, now without the page title ---
// //   AppBar _buildAppBar(BuildContext context) {
// //     final theme = Theme.of(context);
// //     final bool isLoggedIn = _auth.currentUser != null;
// //     final appBarBackgroundColor =
// //         theme.appBarTheme.backgroundColor ?? theme.primaryColor;
// //     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ??
// //         theme.appBarTheme.iconTheme?.color ??
// //         (kIsWeb
// //             ? (theme.brightness == Brightness.dark
// //                 ? Colors.white70
// //                 : Colors.black87)
// //             : Colors.white);
// //     final titleTextStyle = theme.appBarTheme.titleTextStyle?.copyWith(
// //             color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ??
// //         TextStyle(
// //             color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white,
// //             fontSize: 20,
// //             fontWeight: FontWeight.w500);

// //     return AppBar(
// //       toolbarHeight: 70.0,
// //       automaticallyImplyLeading: false,
// //       backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
// //       elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
// //       iconTheme: theme.iconTheme.copyWith(
// //           color: kIsWeb
// //               ? (theme.brightness == Brightness.dark
// //                   ? Colors.white70
// //                   : Colors.black87)
// //               : Colors.white),
// //       actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
// //       title: kIsWeb
// //           ? Row(children: [
// //               Text('MM Associates',
// //                   style: TextStyle(
// //                       fontSize: 20,
// //                       fontWeight: FontWeight.bold,
// //                       color: theme.textTheme.titleLarge?.color ??
// //                           theme.primaryColor)),
// //               const SizedBox(width: 24),
// //               if (_isLoadingName && isLoggedIn)
// //                 const Padding(
// //                     padding: EdgeInsets.only(right: 16.0),
// //                     child: SizedBox(
// //                         width: 18,
// //                         height: 18,
// //                         child: CircularProgressIndicator(strokeWidth: 2)))
// //               else if (_userName != null && isLoggedIn)
// //                 Padding(
// //                     padding: const EdgeInsets.only(right: 16.0),
// //                     child: Text('Hi, ${_userName!.split(' ')[0]}!',
// //                         style: TextStyle(
// //                             fontSize: 16,
// //                             fontWeight: FontWeight.w500,
// //                             color: theme.textTheme.bodyLarge?.color),
// //                         overflow: TextOverflow.ellipsis)),
// //               const Spacer(),
// //             ])
// //           : Row(children: [
// //               if (isLoggedIn)
// //                 GestureDetector(
// //                   onTap: () {
// //                     if (!context.mounted) return;
// //                     Navigator.push(
// //                         context,
// //                         MaterialPageRoute(
// //                             builder: (context) => const ProfileScreen()));
// //                   },
// //                   child: Padding(
// //                     padding: const EdgeInsets.only(right: 10.0),
// //                     child: CircleAvatar(
// //                         radius: 18,
// //                         backgroundColor: Colors.white24,
// //                         backgroundImage: _userProfilePicUrl != null &&
// //                                 _userProfilePicUrl!.isNotEmpty
// //                             ? NetworkImage(_userProfilePicUrl!)
// //                             : null,
// //                         child: _userProfilePicUrl == null ||
// //                                 _userProfilePicUrl!.isEmpty
// //                             ? Icon(Icons.person_outline,
// //                                 size: 20, color: Colors.white.withOpacity(0.8))
// //                             : null),
// //                   ),
// //                 ),
// //               if (_isLoadingName && isLoggedIn)
// //                 const SizedBox(
// //                     width: 18,
// //                     height: 18,
// //                     child: CircularProgressIndicator(
// //                         strokeWidth: 2,
// //                         valueColor:
// //                             AlwaysStoppedAnimation<Color>(Colors.white70)))
// //               else if (_userName != null && isLoggedIn)
// //                 Flexible(
// //                   child: Text('Hi, ${_userName!.split(' ')[0]}!',
// //                       style: titleTextStyle.copyWith(
// //                           fontSize: 18, fontWeight: FontWeight.w500),
// //                       overflow: TextOverflow.ellipsis),
// //                 )
// //               else
// //                 // Fallback title if not logged in
// //                 Text('MM Associates', style: titleTextStyle),
// //             ]),
// //       centerTitle: false, // Title is now always left-aligned
// //       actions: [
// //         if (isLoggedIn)
// //           IconButton(
// //             icon: Icon(Icons.person_outline_rounded, color: actionsIconColor),
// //             tooltip: 'My Profile',
// //             onPressed: () {
// //               if (!context.mounted) return;
// //               Navigator.push(
// //                   context,
// //                   MaterialPageRoute(
// //                       builder: (context) => const ProfileScreen()));
// //             },
// //           ),
// //         if (kIsWeb) const SizedBox(width: 8),
// //       ],
// //     );
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final bool anyOperationInProgress = _isLoading ||
// //         _isFetchingLocation ||
// //         _isGeocoding ||
// //         _isUploadingImage ||
// //         _isCheckingVenueName;
// //     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
// //     final IconData submitBtnIcon =
// //         _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;
// //     final String pageTitle = _isEditMode ? 'Edit Venue' : 'Add New Venue'; // Title for the body

// //     Widget nameSuffixIcon;
// //     if (_isCheckingVenueName) {
// //       nameSuffixIcon = const SizedBox(
// //           width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
// //     } else if (_nameController.text.trim().isNotEmpty &&
// //         (_isEditMode
// //             ? _nameController.text.trim().toLowerCase() !=
// //                 _initialVenueNameLowercase
// //             : true)) {
// //       nameSuffixIcon = _venueNameIsAvailable
// //           ? const Icon(Icons.check_circle_outline, color: Colors.green)
// //           : Icon(Icons.error_outline,
// //               color: Theme.of(context).colorScheme.error);
// //     } else {
// //       nameSuffixIcon = const SizedBox.shrink();
// //     }

// //     return Scaffold(
// //       appBar: _buildAppBar(context),
// //       body: SingleChildScrollView(
// //         child: GestureDetector(
// //           onTap: () => FocusScope.of(context).unfocus(),
// //           child: Padding(
// //             padding: const EdgeInsets.all(16.0),
// //             child: Form(
// //               key: _formKey,
// //               autovalidateMode: _autovalidateMode,
// //               child: AbsorbPointer(
// //                 absorbing: anyOperationInProgress,
// //                 child: Opacity(
// //                   opacity: anyOperationInProgress ? 0.7 : 1.0,
// //                   child: Column(
// //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// //                     children: [
// //                       // --- NEW: Centered Page Title in the Body ---
// //                       Center(
// //                         child: Padding(
// //                           padding: const EdgeInsets.only(bottom: 24.0, top: 8.0),
// //                           child: Text(
// //                             pageTitle,
// //                             style: Theme.of(context).textTheme.headlineSmall?.copyWith(
// //                                   fontWeight: FontWeight.bold,
// //                                 ),
// //                             textAlign: TextAlign.center,
// //                           ),
// //                         ),
// //                       ),
// //                       // --- The rest of the form body is IDENTICAL ---
// //                       _buildSectionHeader("Core Details"),
// //                       TextFormField(
// //                           controller: _nameController,
// //                           decoration: InputDecoration(
// //                             labelText: 'Venue Name*',
// //                             prefixIcon: const Icon(Icons.sports_soccer),
// //                             suffixIcon: Padding(
// //                                 padding: const EdgeInsets.only(right: 12.0),
// //                                 child: nameSuffixIcon),
// //                             errorText: ((_nameController.text.isNotEmpty &&
// //                                         !_isCheckingVenueName &&
// //                                         !_isEditMode) ||
// //                                     (_nameController.text.isNotEmpty &&
// //                                         !_isCheckingVenueName &&
// //                                         _isEditMode &&
// //                                         _nameController.text
// //                                                 .trim()
// //                                                 .toLowerCase() !=
// //                                             _initialVenueNameLowercase))
// //                                 ? _venueNameErrorText
// //                                 : null,
// //                           ),
// //                           validator: (v) {
// //                             if (v == null || v.trim().isEmpty) return 'Required';
// //                             return null;
// //                           },
// //                           textCapitalization: TextCapitalization.words),
// //                       const SizedBox(height: 15),
// //                       _buildSportsInputSection(),
// //                       const SizedBox(height: 15),
// //                       TextFormField(
// //                           controller: _descriptionController,
// //                           decoration: const InputDecoration(
// //                               labelText: 'Description',
// //                               prefixIcon: Icon(Icons.description_outlined),
// //                               alignLabelWithHint: true),
// //                           maxLines: 3,
// //                           textCapitalization: TextCapitalization.sentences),
// //                       const SizedBox(height: 20),
// //                       _buildSectionHeader("Venue Image*"),
// //                       _buildImageUploadSection(),
// //                       const SizedBox(height: 20),
// //                       _buildSectionHeader("Address & Location*"),
// //                       TextFormField(
// //                           controller: _addressController,
// //                           decoration: const InputDecoration(
// //                               labelText: 'Address Line*',
// //                               prefixIcon: Icon(Icons.location_on_outlined)),
// //                           validator: (v) =>
// //                               v!.trim().isEmpty ? 'Required' : null,
// //                           textCapitalization: TextCapitalization.words),
// //                       const SizedBox(height: 15),
// //                       Row(children: [
// //                         Expanded(
// //                             child: TextFormField(
// //                                 controller: _cityController,
// //                                 decoration: const InputDecoration(
// //                                     labelText: 'City*',
// //                                     prefixIcon: Icon(Icons.location_city)),
// //                                 validator: (v) =>
// //                                     v!.trim().isEmpty ? 'Required' : null,
// //                                 textCapitalization: TextCapitalization.words)),
// //                         const SizedBox(width: 10),
// //                         Expanded(
// //                             child: TextFormField(
// //                                 controller: _countryController,
// //                                 decoration: const InputDecoration(
// //                                     labelText: 'Country*',
// //                                     prefixIcon: Icon(Icons.public)),
// //                                 validator: (v) =>
// //                                     v!.trim().isEmpty ? 'Required' : null,
// //                                 textCapitalization: TextCapitalization.words))
// //                       ]),
// //                       const SizedBox(height: 15),
// //                       Row(children: [
// //                         Expanded(
// //                             child: OutlinedButton.icon(
// //                                 icon: _isFetchingLocation
// //                                     ? _buildButtonSpinner()
// //                                     : const Icon(Icons.my_location, size: 18),
// //                                 label: const Text('Use Current'),
// //                                 onPressed: anyOperationInProgress
// //                                     ? null
// //                                     : _fetchAndSetCurrentLocation,
// //                                 style: OutlinedButton.styleFrom(
// //                                     padding: const EdgeInsets.symmetric(
// //                                         vertical: 12)))),
// //                         const SizedBox(width: 10),
// //                         Expanded(
// //                             child: OutlinedButton.icon(
// //                                 icon: _isGeocoding
// //                                     ? _buildButtonSpinner()
// //                                     : const Icon(Icons.location_searching,
// //                                         size: 18),
// //                                 label: const Text('Find Address'),
// //                                 onPressed: anyOperationInProgress
// //                                     ? null
// //                                     : _geocodeAddress,
// //                                 style: OutlinedButton.styleFrom(
// //                                     padding: const EdgeInsets.symmetric(
// //                                         vertical: 12))))
// //                       ]),
// //                       Padding(
// //                           padding: const EdgeInsets.only(top: 10.0, bottom: 5.0),
// //                           child: Text(
// //                               _locationStatusMessage ??
// //                                   (_isEditMode && _selectedLocation != null
// //                                       ? 'Location previously set'
// //                                       : 'Location not set* (Required for new venues)'),
// //                               style: TextStyle(
// //                                   fontSize: 13, color: Colors.grey[700]),
// //                               textAlign: TextAlign.center)),
// //                       _buildSectionHeader("Venue on Google Maps*"),
// //                       Row(
// //                         children: [
// //                           Expanded(
// //                             child: OutlinedButton.icon(
// //                               icon: const Icon(Icons.map_outlined, size: 18),
// //                               label: const Text('Open Google Maps'),
// //                               onPressed:
// //                                   anyOperationInProgress ? null : _launchGoogleMaps,
// //                               style: OutlinedButton.styleFrom(
// //                                 padding:
// //                                     const EdgeInsets.symmetric(vertical: 12),
// //                               ),
// //                             ),
// //                           ),
// //                         ],
// //                       ),
// //                       const SizedBox(height: 10),
// //                       TextFormField(
// //                         controller: _googleMapsUrlController,
// //                         decoration: const InputDecoration(
// //                           labelText: 'Pasted Google Maps Link*',
// //                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
// //                           prefixIcon: Icon(Icons.link),
// //                         ),
// //                         validator: (value) {
// //                           if (value == null || value.trim().isEmpty) {
// //                             return 'Google Maps link is required.';
// //                           }
// //                           final trimmedValue = value.trim();
// //                           final uri = Uri.tryParse(trimmedValue);
// //                           if (uri == null || !uri.isAbsolute) {
// //                             return 'Please enter a valid URL.';
// //                           }
// //                           final lowerTrimmedValue = trimmedValue.toLowerCase();
// //                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
// //                               !lowerTrimmedValue.contains('google.') &&
// //                               !lowerTrimmedValue.contains('goo.gl/maps')) {
// //                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
// //                           }
// //                           return null;
// //                         },
// //                         keyboardType: TextInputType.url,
// //                       ),
// //                       Padding(
// //                         padding: const EdgeInsets.only(
// //                             top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
// //                         child: Text(
// //                           "1. Click 'Open Google Maps' above.\n"
// //                           "2. In Google Maps, find the exact venue.\n"
// //                           "3. Use the 'Share' option and 'Copy link'.\n"
// //                           "4. Paste the link in the field above.",
// //                           style: TextStyle(
// //                               fontSize: 12.5,
// //                               color: Theme.of(context).hintColor),
// //                           textAlign: TextAlign.start,
// //                         ),
// //                       ),
// //                       const SizedBox(height: 20),
// //                       _buildSectionHeader("Operating Hours*"),
// //                       _buildOperatingHoursRow(
// //                           "Weekday", _weekdayStartController, _weekdayEndController),
// //                       const SizedBox(height: 12),
// //                       _buildOperatingHoursRow("Saturday", _saturdayStartController,
// //                           _saturdayEndController),
// //                       const SizedBox(height: 12),
// //                       _buildOperatingHoursRow(
// //                           "Sunday", _sundayStartController, _sundayEndController),
// //                       const SizedBox(height: 20),
// //                       _buildSectionHeader("Contact & Other Info"),
// //                       TextFormField(
// //                           controller: _phoneController,
// //                           decoration: const InputDecoration(
// //                               labelText: 'Phone (Optional)',
// //                               prefixIcon: Icon(Icons.phone_outlined)),
// //                           keyboardType: TextInputType.phone),
// //                       const SizedBox(height: 15),
// //                       TextFormField(
// //                           controller: _emailController,
// //                           decoration: const InputDecoration(
// //                               labelText: 'Email (Optional)',
// //                               prefixIcon: Icon(Icons.email_outlined)),
// //                           keyboardType: TextInputType.emailAddress,
// //                           validator: (v) {
// //                             if (v!.trim().isNotEmpty &&
// //                                 !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
// //                                     .hasMatch(v.trim()))
// //                               return 'Invalid email';
// //                             return null;
// //                           }),
// //                       const SizedBox(height: 15),
// //                       TextFormField(
// //                           controller: _websiteController,
// //                           decoration: const InputDecoration(
// //                               labelText: 'Website (Optional)',
// //                               prefixIcon: Icon(Icons.language_outlined)),
// //                           keyboardType: TextInputType.url,
// //                           validator: (v) {
// //                             if (v!.trim().isNotEmpty &&
// //                                 (Uri.tryParse(v.trim())?.isAbsolute ?? false) ==
// //                                     false) return 'Invalid URL';
// //                             return null;
// //                           }),
// //                       const SizedBox(height: 15),
// //                       TextFormField(
// //                           controller: _facilitiesController,
// //                           decoration: const InputDecoration(
// //                               labelText: 'Facilities (Optional)',
// //                               hintText: 'Comma-separated',
// //                               prefixIcon: Icon(Icons.local_offer_outlined)),
// //                           textCapitalization: TextCapitalization.words),
// //                       const SizedBox(height: 20),
// //                       _buildSectionHeader("Status & Settings"),
// //                       SwitchListTile(
// //                           title: const Text('Booking Enabled?'),
// //                           subtitle: const Text(
// //                               'Can users make bookings for this venue?'),
// //                           value: _bookingEnabled,
// //                           onChanged: anyOperationInProgress
// //                               ? null
// //                               : (v) => setState(() => _bookingEnabled = v),
// //                           secondary: Icon(
// //                               _bookingEnabled
// //                                   ? Icons.event_available
// //                                   : Icons.event_busy,
// //                               color: _bookingEnabled
// //                                   ? Theme.of(context).primaryColor
// //                                   : Colors.grey),
// //                           contentPadding: EdgeInsets.zero,
// //                           dense: true),
// //                       const SizedBox(height: 10),
// //                       SwitchListTile(
// //                           title: const Text('Venue is Active?'),
// //                           subtitle: const Text(
// //                               'Inactive venues won\'t appear in searches.'),
// //                           value: _isActive,
// //                           onChanged: anyOperationInProgress
// //                               ? null
// //                               : (v) => setState(() => _isActive = v),
// //                           secondary: Icon(
// //                               _isActive
// //                                   ? Icons.check_circle
// //                                   : Icons.cancel_outlined,
// //                               color: _isActive ? Colors.green : Colors.grey),
// //                           contentPadding: EdgeInsets.zero,
// //                           dense: true),
// //                       const SizedBox(height: 25),
// //                       Row(
// //                         mainAxisAlignment: MainAxisAlignment.center,
// //                         children: [
// //                           SizedBox(
// //                             width: 200,
// //                             child: ElevatedButton.icon(
// //                                 icon: (anyOperationInProgress &&
// //                                         (_isLoading || _isUploadingImage))
// //                                     ? _buildButtonSpinner(
// //                                         size: 20, color: Colors.white)
// //                                     : Icon(submitBtnIcon),
// //                                 label: Text((anyOperationInProgress &&
// //                                         (_isLoading || _isUploadingImage))
// //                                     ? 'Saving...'
// //                                     : submitBtnTxt),
// //                                 onPressed:
// //                                     anyOperationInProgress ? null : _submitForm,
// //                                 style: ElevatedButton.styleFrom(
// //                                     padding: const EdgeInsets.symmetric(
// //                                         vertical: 15),
// //                                     textStyle: const TextStyle(
// //                                         fontSize: 16,
// //                                         fontWeight: FontWeight.bold))),
// //                           ),
// //                         ],
// //                       ),
// //                       const SizedBox(height: 20),
// //                     ],
// //                   ),
// //                 ),
// //               ),
// //             ),
// //           ),
// //         ),
// //       ),
// //     );
// //   }

// //   Widget _buildImageUploadSection() {
// //     Widget imagePreview;
// //     const double previewSize = 150.0;

// //     if (_isUploadingImage && _selectedImageFile == null) {
// //       imagePreview = const Center(child: CircularProgressIndicator());
// //     } else if (_selectedImageFile != null) {
// //       imagePreview = kIsWeb
// //           ? Image.network(_selectedImageFile!.path,
// //               width: previewSize, height: previewSize, fit: BoxFit.cover)
// //           : Image.file(File(_selectedImageFile!.path),
// //               width: previewSize, height: previewSize, fit: BoxFit.cover);
// //     } else if (_imageUrlController.text.isNotEmpty) {
// //       imagePreview = Image.network(
// //         _imageUrlController.text,
// //         width: previewSize,
// //         height: previewSize,
// //         fit: BoxFit.cover,
// //         errorBuilder: (context, error, stackTrace) => const Center(
// //             child: Icon(Icons.broken_image_outlined,
// //                 size: 40, color: Colors.grey)),
// //         loadingBuilder: (context, child, loadingProgress) {
// //           if (loadingProgress == null) return child;
// //           return Center(
// //               child: CircularProgressIndicator(
// //                   value: loadingProgress.expectedTotalBytes != null
// //                       ? loadingProgress.cumulativeBytesLoaded /
// //                           loadingProgress.expectedTotalBytes!
// //                       : null));
// //         },
// //       );
// //     } else {
// //       imagePreview = Center(
// //           child: Icon(Icons.add_a_photo_outlined,
// //               size: 40,
// //               color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
// //     }

// //     return Column(
// //       crossAxisAlignment: CrossAxisAlignment.start,
// //       children: [
// //         Center(
// //           child: Column(
// //             children: [
// //               GestureDetector(
// //                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
// //                 child: Container(
// //                   height: previewSize,
// //                   width: previewSize,
// //                   margin: const EdgeInsets.only(bottom: 10.0),
// //                   decoration: BoxDecoration(
// //                     color: Theme.of(context)
// //                         .colorScheme
// //                         .surfaceVariant
// //                         .withOpacity(0.3),
// //                     border: Border.all(
// //                       color: _imageErrorText != null
// //                           ? Theme.of(context).colorScheme.error
// //                           : Theme.of(context)
// //                               .colorScheme
// //                               .outline
// //                               .withOpacity(0.5),
// //                       width: _imageErrorText != null ? 1.5 : 1.0,
// //                     ),
// //                     borderRadius: BorderRadius.circular(8.0),
// //                   ),
// //                   child: ClipRRect(
// //                     borderRadius: BorderRadius.circular(7.0),
// //                     child: Stack(
// //                       fit: StackFit.expand,
// //                       children: [
// //                         imagePreview,
// //                         if (_isUploadingImage)
// //                           Container(
// //                             color: Colors.black.withOpacity(0.4),
// //                             child: const Center(
// //                                 child: CircularProgressIndicator(
// //                               color: Colors.white,
// //                               strokeWidth: 3,
// //                             )),
// //                           ),
// //                         if (!_isUploadingImage &&
// //                             (_imageUrlController.text.isNotEmpty ||
// //                                 _selectedImageFile != null))
// //                           Positioned(
// //                             top: 4,
// //                             right: 4,
// //                             child: Material(
// //                               color: Colors.black54,
// //                               shape: const CircleBorder(),
// //                               child: InkWell(
// //                                 customBorder: const CircleBorder(),
// //                                 onTap: _isUploadingImage ? null : _clearImage,
// //                                 child: const Padding(
// //                                   padding: EdgeInsets.all(6.0),
// //                                   child:
// //                                       Icon(Icons.close, color: Colors.white, size: 18),
// //                                 ),
// //                               ),
// //                             ),
// //                           ),
// //                       ],
// //                     ),
// //                   ),
// //                 ),
// //               ),
// //               if (!_isUploadingImage)
// //                 OutlinedButton.icon(
// //                   icon: Icon(
// //                       _imageUrlController.text.isNotEmpty ||
// //                               _selectedImageFile != null
// //                           ? Icons.edit_outlined
// //                           : Icons.add_photo_alternate_outlined,
// //                       size: 18),
// //                   label: Text(_imageUrlController.text.isNotEmpty ||
// //                           _selectedImageFile != null
// //                       ? 'Change Image'
// //                       : 'Select Image*'),
// //                   onPressed: _pickAndUploadImage,
// //                   style: OutlinedButton.styleFrom(
// //                       padding: const EdgeInsets.symmetric(
// //                           horizontal: 20, vertical: 10)),
// //                 ),
// //             ],
// //           ),
// //         ),
// //         if (_isUploadingImage)
// //           Center(
// //             child: Padding(
// //               padding: const EdgeInsets.only(top: 10.0),
// //               child: Text("Uploading, please wait...",
// //                   style: TextStyle(
// //                       color: Theme.of(context).primaryColor,
// //                       fontStyle: FontStyle.italic)),
// //             ),
// //           ),
// //         if (_imageErrorText != null)
// //           Padding(
// //             padding: const EdgeInsets.only(top: 8.0),
// //             child: Center(
// //               child: Text(
// //                 _imageErrorText!,
// //                 style: TextStyle(
// //                     color: Theme.of(context).colorScheme.error, fontSize: 12),
// //                 textAlign: TextAlign.center,
// //               ),
// //             ),
// //           ),
// //         Visibility(
// //           visible: false,
// //           maintainState: true,
// //           child: TextFormField(
// //             controller: _imageUrlController,
// //             decoration: const InputDecoration(labelText: 'Image URL'),
// //           ),
// //         ),
// //       ],
// //     );
// //   }

// //   Widget _buildSportsInputSection() {
// //     return Column(
// //       crossAxisAlignment: CrossAxisAlignment.start,
// //       children: [
// //         TextFormField(
// //           controller: _sportInputController,
// //           focusNode: _sportInputFocusNode,
// //           textCapitalization: TextCapitalization.words,
// //           decoration: InputDecoration(
// //             hintText: 'Sports Offered* (Type & press Enter)',
// //             prefixIcon: const Icon(Icons.fitness_center),
// //             border: OutlineInputBorder(
// //               borderSide: BorderSide(
// //                   color: _sportsErrorText != null
// //                       ? Theme.of(context).colorScheme.error
// //                       : Theme.of(context).colorScheme.outline),
// //               borderRadius: BorderRadius.circular(4.0),
// //             ),
// //             focusedBorder: OutlineInputBorder(
// //               borderSide: BorderSide(
// //                   color: _sportsErrorText != null
// //                       ? Theme.of(context).colorScheme.error
// //                       : Theme.of(context).primaryColor,
// //                   width: 1.5),
// //               borderRadius: BorderRadius.circular(4.0),
// //             ),
// //             enabledBorder: OutlineInputBorder(
// //               borderSide: BorderSide(
// //                   color: _sportsErrorText != null
// //                       ? Theme.of(context).colorScheme.error
// //                       : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
// //               borderRadius: BorderRadius.circular(4.0),
// //             ),
// //             errorBorder: OutlineInputBorder(
// //               borderSide: BorderSide(
// //                   color: Theme.of(context).colorScheme.error, width: 1.5),
// //               borderRadius: BorderRadius.circular(4.0),
// //             ),
// //             focusedErrorBorder: OutlineInputBorder(
// //               borderSide: BorderSide(
// //                   color: Theme.of(context).colorScheme.error, width: 1.5),
// //               borderRadius: BorderRadius.circular(4.0),
// //             ),
// //           ),
// //           onFieldSubmitted: (_) => _addSportFromInput(),
// //         ),
// //         if (_selectedSports.isNotEmpty)
// //           Padding(
// //             padding: const EdgeInsets.only(top: 8.0),
// //             child: Container(
// //               width: double.infinity,
// //               padding: const EdgeInsets.symmetric(vertical: 4.0),
// //               child: Wrap(
// //                 spacing: 8.0,
// //                 runSpacing: 4.0,
// //                 children: _selectedSports.map((sport) {
// //                   return InputChip(
// //                     label: Text(sport),
// //                     labelStyle: TextStyle(
// //                         color: Theme.of(context).colorScheme.onSecondaryContainer),
// //                     backgroundColor: Theme.of(context)
// //                         .colorScheme
// //                         .secondaryContainer
// //                         .withOpacity(0.7),
// //                     deleteIconColor: Theme.of(context)
// //                         .colorScheme
// //                         .onSecondaryContainer
// //                         .withOpacity(0.7),
// //                     onDeleted: () => _removeSport(sport),
// //                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
// //                     padding: const EdgeInsets.all(6),
// //                   );
// //                 }).toList(),
// //               ),
// //             ),
// //           ),
// //         if (_sportsErrorText != null)
// //           Padding(
// //             padding: const EdgeInsets.only(top: 8.0, left: 12.0),
// //             child: Text(
// //               _sportsErrorText!,
// //               style: TextStyle(
// //                   color: Theme.of(context).colorScheme.error, fontSize: 12),
// //             ),
// //           ),
// //       ],
// //     );
// //   }

// //   Widget _buildButtonSpinner({double size = 16, Color? color}) {
// //     final resolvedColor = color ?? Theme.of(context).primaryColor;
// //     return SizedBox(
// //         width: size,
// //         height: size,
// //         child: CircularProgressIndicator(
// //             strokeWidth: 2,
// //             valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
// //   }

// //   Widget _buildSectionHeader(String title) {
// //     return Padding(
// //       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
// //       child: Text(title,
// //           style: Theme.of(context)
// //               .textTheme
// //               .titleMedium
// //               ?.copyWith(fontWeight: FontWeight.bold)),
// //     );
// //   }

// //   Widget _buildOperatingHoursRow(String dayLabel,
// //       TextEditingController startController, TextEditingController endController) {
// //     const double dayLabelColumnWidth = 90.0;
// //     const double gapBetweenLabelAndTimes = 8.0;
// //     const double preferredTimeFieldWidth = 105.0;
// //     const double horizontalPaddingForToText = 5.0;
// //     String? timeValidator(String? value) {
// //       if (value == null || value.trim().isEmpty) return 'Required';
// //       if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
// //           .hasMatch(value.trim())) return 'HH:MM';
// //       return null;
// //     }

// //     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
// //       return InkWell(
// //           onTap: () => _selectTime(context, controller),
// //           child: AbsorbPointer(
// //               child: TextFormField(
// //                   controller: controller,
// //                   textAlign: TextAlign.center,
// //                   decoration: InputDecoration(
// //                       labelText: labelText,
// //                       contentPadding: const EdgeInsets.symmetric(
// //                           horizontal: 4.0, vertical: 8.0),
// //                       isDense: true,
// //                       border: const OutlineInputBorder(),
// //                       suffixIcon: const Icon(Icons.access_time, size: 18)),
// //                   validator: timeValidator)));
// //     }

// //     Widget dayLabelWidget = SizedBox(
// //         width: dayLabelColumnWidth,
// //         child: Text(dayLabel,
// //             style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500),
// //             textAlign: TextAlign.start));
// //     if (kIsWeb) {
// //       Widget buildWebTimeInput(TextEditingController controller, String labelText) {
// //         return SizedBox(
// //             width: preferredTimeFieldWidth,
// //             child: buildCoreTimeInput(controller, labelText));
// //       }

// //       final TextPainter textPainter = TextPainter(
// //           text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)),
// //           maxLines: 1,
// //           textDirection: TextDirection.ltr)
// //         ..layout(minWidth: 0, maxWidth: double.infinity);
// //       final double widthOfToTextWithPadding =
// //           textPainter.width + (2 * horizontalPaddingForToText);
// //       final double requiredWidthForTimeControlsGroupWeb =
// //           (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
// //       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
// //         final double totalAvailableWidth = constraints.maxWidth;
// //         final double singleLineRequiredWidthWeb =
// //             dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
// //         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
// //           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
// //             dayLabelWidget,
// //             const SizedBox(width: gapBetweenLabelAndTimes),
// //             Expanded(
// //                 child: Row(children: [
// //               Flexible(child: buildWebTimeInput(startController, 'Start')),
// //               Padding(
// //                   padding: const EdgeInsets.symmetric(
// //                       horizontal: horizontalPaddingForToText),
// //                   child: Text("to", style: const TextStyle(fontSize: 14))),
// //               Flexible(child: buildWebTimeInput(endController, 'End')),
// //               const Spacer()
// //             ]))
// //           ]);
// //         } else {
// //           return Column(
// //               crossAxisAlignment: CrossAxisAlignment.start,
// //               children: [
// //                 dayLabelWidget,
// //                 const SizedBox(height: 8.0),
// //                 Padding(
// //                     padding: const EdgeInsets.only(left: 0.0),
// //                     child:
// //                         Row(mainAxisSize: MainAxisSize.min, children: [
// //                       buildWebTimeInput(startController, 'Start'),
// //                       Padding(
// //                           padding: const EdgeInsets.symmetric(
// //                               horizontal: horizontalPaddingForToText),
// //                           child: Text("to", style: const TextStyle(fontSize: 14))),
// //                       buildWebTimeInput(endController, 'End')
// //                     ]))
// //               ]);
// //         }
// //       });
// //     } else {
// //       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
// //         dayLabelWidget,
// //         const SizedBox(width: gapBetweenLabelAndTimes),
// //         Expanded(child: buildCoreTimeInput(startController, 'Start')),
// //         Padding(
// //             padding:
// //                 const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText),
// //             child: Text("to", style: const TextStyle(fontSize: 14))),
// //         Expanded(child: buildCoreTimeInput(endController, 'End'))
// //       ]);
// //     }
// //   }
// // }



// //----form changes----
// import 'dart:async';
// import 'dart:io'; // For File, used for non-web image preview

// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:flutter/foundation.dart' show kIsWeb;
// import 'package:flutter/material.dart';
// import 'package:geolocator/geolocator.dart';
// import 'package:image_picker/image_picker.dart';
// import 'package:mm_associates/features/auth/services/auth_service.dart';
// import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// import 'package:mm_associates/features/user/services/user_service.dart';
// import 'package:url_launcher/url_launcher.dart';

// import '../../../../core/services/geocoding_service.dart';
// import '../../../../core/services/image_upload_service.dart';
// import '../../../../core/services/location_service.dart';
// import '../../../../features/data/services/firestore_service.dart';

// // Assuming 'CitySelectionScreen' is defined in this path.
// // The user has requested not to include its code here.
// // Please ensure this import path is correct for your project structure.
// import 'city_selection_screen.dart';


// class AddVenueFormScreen extends StatefulWidget {
//   final String? venueIdToEdit;
//   final Map<String, dynamic>? initialData;

//   /// True if an admin is landing here directly as their "home" page.
//   /// This will add a button to navigate to the user-facing app view.
//   final bool isDirectAdminAccess;

//   const AddVenueFormScreen({
//     super.key,
//     this.venueIdToEdit,
//     this.initialData,
//     this.isDirectAdminAccess = false,
//   });

//   @override
//   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// }

// class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
//   final _formKey = GlobalKey<FormState>();
//   final FirestoreService _firestoreService = FirestoreService();
//   final LocationService _locationService = LocationService();
//   final LocationIQService _geocodingService = LocationIQService();
//   final FirebaseAuth _auth = FirebaseAuth.instance;
//   final AuthService _authService = AuthService();
//   final UserService _userService = UserService();

//   final ImageUploadService _imageUploadService = ImageUploadService();
//   final ImagePicker _picker = ImagePicker();

//   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

//   // Controllers
//   final _nameController = TextEditingController();
//   final _descriptionController = TextEditingController();
//   final _imageUrlController = TextEditingController();
//   final _addressController = TextEditingController();
//   final _areaController = TextEditingController();
//   final _countryController = TextEditingController();
//   final _weekdayStartController = TextEditingController();
//   final _weekdayEndController = TextEditingController();
//   final _saturdayStartController = TextEditingController();
//   final _saturdayEndController = TextEditingController();
//   final _sundayStartController = TextEditingController();
//   final _sundayEndController = TextEditingController();
//   final _phoneController = TextEditingController();
//   final _websiteController = TextEditingController();
//   final _emailController = TextEditingController();
//   final _facilitiesController = TextEditingController();
//   final _googleMapsUrlController = TextEditingController();

//   String? _selectedCity;

//   List<String> _selectedSports = [];
//   final _sportInputController = TextEditingController();
//   final _sportInputFocusNode = FocusNode();
//   String? _sportsErrorText;

//   bool _isActive = true;
//   bool _bookingEnabled = true;
//   bool _isLoading = false;
//   bool _isFetchingLocation = false;
//   bool _isGeocoding = false;
//   GeoPoint? _selectedLocation;
//   String? _locationStatusMessage;

//   Timer? _venueNameDebouncer;
//   bool _isCheckingVenueName = false;
//   bool _venueNameIsAvailable = true;
//   String? _venueNameErrorText;
//   String? _initialVenueNameLowercase;

//   XFile? _selectedImageFile;
//   bool _isUploadingImage = false;
//   String? _imageErrorText;

//   String? _userName;
//   String? _userProfilePicUrl;
//   bool _isLoadingName = true;
  
//   // MODIFICATION: Use an internal state variable to manage edit mode.
//   String? _currentVenueIdToEdit;
//   // MODIFICATION: Getter now uses the internal state variable.
//   bool get _isEditMode => _currentVenueIdToEdit != null;
//   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

//   @override
//   void initState() {
//     super.initState();
//     // MODIFICATION: Initialize the internal state variable.
//     _currentVenueIdToEdit = widget.venueIdToEdit;
    
//     if (_isEditMode && widget.initialData != null) {
//       _prefillFormData(widget.initialData!);
//       _initialVenueNameLowercase =
//           widget.initialData!['name']?.toString().trim().toLowerCase();
//     }
//     _nameController.addListener(_onNameChanged);
//     _fetchUserNameAndPic();
//   }

//   void _prefillFormData(Map<String, dynamic> data) {
//     _nameController.text = data['name'] ?? '';
//     _selectedSports = (data['sportType'] as List<dynamic>?)
//             ?.map((s) => s.toString().trim())
//             .where((s) => s.isNotEmpty)
//             .toList() ??
//         [];
//     _descriptionController.text = data['description'] ?? '';
//     _addressController.text = data['address'] ?? '';
//     _areaController.text = data['area'] ?? '';
//     _selectedCity = data['city'] as String?;
//     _countryController.text = data['country'] ?? '';
//     _imageUrlController.text = data['imageUrl'] ?? '';
//     _isActive = data['isActive'] ?? true;
//     _bookingEnabled = data['bookingEnabled'] ?? true;
//     _phoneController.text = data['phoneNumber'] ?? '';
//     _websiteController.text = data['website'] ?? '';
//     _emailController.text = data['email'] ?? '';
//     _facilitiesController.text =
//         (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
//     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

//     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
//     if (initialLocation != null) {
//       _selectedLocation = initialLocation;
//       _locationStatusMessage =
//           'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
//     }

//     if (data['operatingHours'] is Map) {
//       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
//       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
//       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
//       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
//       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
//       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
//       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
//     }
//   }

//   @override
//   void dispose() {
//     _nameController.removeListener(_onNameChanged);
//     _nameController.dispose();
//     _venueNameDebouncer?.cancel();
//     _sportInputController.dispose();
//     _sportInputFocusNode.dispose();
//     _descriptionController.dispose();
//     _imageUrlController.dispose();
//     _addressController.dispose();
//     _areaController.dispose();
//     _countryController.dispose();
//     _weekdayStartController.dispose();
//     _weekdayEndController.dispose();
//     _saturdayStartController.dispose();
//     _saturdayEndController.dispose();
//     _sundayStartController.dispose();
//     _sundayEndController.dispose();
//     _phoneController.dispose();
//     _websiteController.dispose();
//     _emailController.dispose();
//     _facilitiesController.dispose();
//     _googleMapsUrlController.dispose();
//     super.dispose();
//   }

//   Future<void> _fetchUserNameAndPic() async {
//     if (!mounted) return;
//     setState(() => _isLoadingName = true);
//     final currentUser = _auth.currentUser;
//     if (currentUser == null) {
//       if (mounted)
//         setState(() {
//           _userName = 'Guest';
//           _userProfilePicUrl = null;
//           _isLoadingName = false;
//         });
//       return;
//     }
//     try {
//       final userData = await _userService.getUserProfileData();
//       if (!mounted) return;
//       final fetchedName = userData?['name'] as String? ??
//           currentUser.displayName ??
//           currentUser.email?.split('@')[0] ??
//           'User';
//       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
//       setState(() {
//         _userName = fetchedName;
//         _userProfilePicUrl = fetchedPicUrl;
//       });
//     } catch (e) {
//       if (!mounted) return;
//       final fallbackName = currentUser.displayName ??
//           currentUser.email?.split('@')[0] ??
//           'User';
//       setState(() {
//         _userName = fallbackName;
//         _userProfilePicUrl = null;
//       });
//       debugPrint("Error fetching user name: $e");
//     } finally {
//       if (mounted) setState(() => _isLoadingName = false);
//     }
//   }

//   void _addSportFromInput() {
//     final sportName = _sportInputController.text.trim();
//     if (sportName.isNotEmpty) {
//       final capitalizedSportName = sportName
//           .split(' ')
//           .map((word) => word.isNotEmpty
//               ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}'
//               : '')
//           .join(' ');

//       if (!_selectedSports
//           .any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
//         setState(() {
//           _selectedSports.add(capitalizedSportName);
//           _sportsErrorText = null;
//         });
//       }
//       _sportInputController.clear();
//       _sportInputFocusNode.requestFocus();
//     }
//   }

//   void _removeSport(String sportName) {
//     setState(() {
//       _selectedSports.remove(sportName);
//       if (_selectedSports.isEmpty &&
//           _autovalidateMode == AutovalidateMode.onUserInteraction) {
//         _sportsErrorText = 'At least one sport is required.';
//       }
//     });
//   }

//   void _onNameChanged() {
//     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
//     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
//       final name = _nameController.text.trim();
//       if (name.isNotEmpty) {
//         _checkVenueNameUniqueness(name);
//       } else {
//         setState(() {
//           _isCheckingVenueName = false;
//           _venueNameIsAvailable = true;
//           _venueNameErrorText = null;
//         });
//       }
//     });
//   }

//   Future<void> _checkVenueNameUniqueness(String name) async {
//     if (!mounted) return;
//     setState(() {
//       _isCheckingVenueName = true;
//       _venueNameIsAvailable = true;
//       _venueNameErrorText = null;
//     });
//     final nameLower = name.toLowerCase();
//     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
//       setState(() {
//         _isCheckingVenueName = false;
//         _venueNameIsAvailable = true;
//         _venueNameErrorText = null;
//       });
//       return;
//     }
//     try {
//       final bool exists = await _firestoreService.checkVenueNameExists(
//           nameLower, _isEditMode ? _currentVenueIdToEdit : null); // Use state variable
//       if (!mounted) return;
//       setState(() {
//         _venueNameIsAvailable = !exists;
//         _venueNameErrorText = exists ? 'Venue name already exists.' : null;
//         _isCheckingVenueName = false;
//       });
//     } catch (e) {
//       if (!mounted) return;
//       setState(() {
//         _venueNameIsAvailable = false;
//         _venueNameErrorText = 'Error checking name. Please try again.';
//         _isCheckingVenueName = false;
//       });
//       debugPrint("Error checking venue name: $e");
//     }
//   }

//   Future<void> _selectTime(
//       BuildContext context, TextEditingController controller) async {
//     TimeOfDay? initialTime;
//     if (controller.text.isNotEmpty) {
//       try {
//         final parts = controller.text.split(':');
//         if (parts.length == 2)
//           initialTime =
//               TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
//       } catch (e) {
//         /* ignore */
//       }
//     }
//     final TimeOfDay? picked =
//         await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
//     if (picked != null) {
//       setState(() {
//         controller.text =
//             "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}";
//       });
//       if (_autovalidateMode == AutovalidateMode.onUserInteraction)
//         _formKey.currentState?.validate();
//     }
//   }

//   Future<void> _fetchAndSetCurrentLocation() async {
//     if (!mounted ||
//         _isLoading ||
//         _isFetchingLocation ||
//         _isGeocoding ||
//         _isUploadingImage) return;
//     setState(() {
//       _isFetchingLocation = true;
//       _locationStatusMessage = 'Fetching...';
//       _selectedLocation = null;
//     });
//     final Position? p = await _locationService.getCurrentLocation();
//     if (!mounted) return;
//     if (p != null) {
//       setState(() {
//         _selectedLocation = GeoPoint(p.latitude, p.longitude);
//         _locationStatusMessage =
//             'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}';
//         _isFetchingLocation = false;
//       });
//       _showSnackBar('Location fetched!', isError: false);
//     } else {
//       setState(() {
//         _locationStatusMessage = 'Could not get location.';
//         _isFetchingLocation = false;
//         _selectedLocation = null;
//       });
//       _showSnackBar('Could not fetch location. Check permissions/service.',
//           isError: true);
//     }
//   }

//   Future<void> _geocodeAddress() async {
//     if (!mounted ||
//         _isLoading ||
//         _isFetchingLocation ||
//         _isGeocoding ||
//         _isUploadingImage) return;
//     FocusScope.of(context).unfocus();
//     final fullAddressQuery = [
//       _addressController.text.trim(),
//       _areaController.text.trim(),
//       _selectedCity ?? '',
//       _countryController.text.trim()
//     ].where((s) => s.isNotEmpty).join(', ');
//     if (fullAddressQuery.length < 5) {
//       _showSnackBar('Enter Address, Area, City, and Country.', isError: true);
//       return;
//     }
//     debugPrint("Geocoding: '$fullAddressQuery'");
//     setState(() {
//       _isGeocoding = true;
//       _locationStatusMessage = 'Finding for "$fullAddressQuery"...';
//       _selectedLocation = null;
//     });
//     try {
//       final GeoPoint? r =
//           await _geocodingService.getCoordsFromAddress(fullAddressQuery);
//       if (!mounted) return;
//       if (r != null) {
//         setState(() {
//           _selectedLocation = r;
//           _locationStatusMessage =
//               'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}';
//           _isGeocoding = false;
//         });
//         _showSnackBar('Location found!', isError: false);
//       } else {
//         setState(() {
//           _locationStatusMessage = 'Could not find location.';
//           _isGeocoding = false;
//           _selectedLocation = null;
//         });
//         _showSnackBar('Address lookup failed.', isError: true);
//       }
//     } catch (e) {
//       if (!mounted) return;
//       String err = e.toString().replaceFirst('Exception: ', '');
//       setState(() {
//         _locationStatusMessage = "Geocoding failed: $err";
//         _isGeocoding = false;
//         _selectedLocation = null;
//       });
//       _showSnackBar("Geocoding error: $err", isError: true);
//       debugPrint("Geocoding error: $e");
//     }
//   }

//   Future<void> _launchGoogleMaps() async {
//     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
//     try {
//       if (await canLaunchUrl(googleMapsUri)) {
//         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
//       } else {
//         _showSnackBar('Could not open Google Maps. Please open it manually.',
//             isError: true);
//       }
//     } catch (e) {
//       _showSnackBar('Error opening Google Maps: $e', isError: true);
//     }
//   }

//   Future<void> _pickAndUploadImage() async {
//     if (_isUploadingImage) return;
//     setState(() {
//       _imageErrorText = null;
//     });

//     try {
//       final XFile? pickedFile = await _picker.pickImage(
//           source: ImageSource.gallery,
//           imageQuality: 70,
//           maxWidth: 1024,
//           maxHeight: 1024);
//       if (pickedFile == null) return;

//       setState(() {
//         _selectedImageFile = pickedFile;
//         _isUploadingImage = true;
//         _imageUrlController.clear();
//       });
//       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

//       final String? uploadedUrl =
//           await _imageUploadService.uploadImageToCloudinary(
//         pickedFile,
//         uploadPreset: _venueImageUploadPreset,
//         folder: 'venue_images',
//       );

//       if (!mounted) return;

//       if (uploadedUrl != null) {
//         setState(() {
//           _imageUrlController.text = uploadedUrl;
//           _selectedImageFile = null;
//           _isUploadingImage = false;
//         });
//         _showSnackBar('Image uploaded successfully!', isError: false);
//       } else {
//         throw Exception("Cloudinary returned a null URL.");
//       }
//     } catch (e) {
//       if (!mounted) return;
//       setState(() {
//         _isUploadingImage = false;
//       });
//       debugPrint("Image pick/upload error: $e");
//       _showSnackBar(
//           'Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}',
//           isError: true);
//     }
//   }

//   void _clearImage() {
//     setState(() {
//       _imageUrlController.clear();
//       _selectedImageFile = null;
//       _isUploadingImage = false;
//       _imageErrorText = null;
//     });
//     _showSnackBar('Image removed.', isError: false);
//   }

//   void _resetFormForNewEntry() {
//     if (!mounted) return;
//     _formKey.currentState?.reset();
//     _nameController.clear();
//     _descriptionController.clear();
//     _imageUrlController.clear();
//     _addressController.clear();
//     _areaController.clear();
//     _countryController.clear();
//     _weekdayStartController.clear();
//     _weekdayEndController.clear();
//     _saturdayStartController.clear();
//     _saturdayEndController.clear();
//     _sundayStartController.clear();
//     _sundayEndController.clear();
//     _phoneController.clear();
//     _websiteController.clear();
//     _emailController.clear();
//     _facilitiesController.clear();
//     _googleMapsUrlController.clear();
//     _sportInputController.clear();
//     setState(() {
//       _selectedSports = [];
//       _selectedCity = null;
//       _selectedImageFile = null;
//       _isActive = true;
//       _bookingEnabled = true;
//       _selectedLocation = null;
//       _locationStatusMessage = null;
//       _venueNameIsAvailable = true;
//       _venueNameErrorText = null;
//       _initialVenueNameLowercase = null; // Clear this for new entries
//       _autovalidateMode = AutovalidateMode.disabled;
//     });
//   }

//   Future<void> _submitForm() async {
//     setState(() {
//       _imageErrorText = null;
//       _sportsErrorText = null;
//     });

//     if (_isLoading || _isUploadingImage) {
//       _showSnackBar('Please wait for current operations to complete.',
//           isError: true);
//       return;
//     }
//     if (_isCheckingVenueName) {
//       _showSnackBar('Venue name check in progress. Please wait.', isError: true);
//       return;
//     }
//     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
//       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.',
//           isError: true);
//       setState(() {
//         _autovalidateMode = AutovalidateMode.onUserInteraction;
//       });
//       _formKey.currentState?.validate();
//       return;
//     }

//     bool isTextFormFieldsValid = _formKey.currentState!.validate();
//     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
//     bool areSportsSelected = _selectedSports.isNotEmpty;

//     if (!isImagePresent) {
//       setState(() {
//         _imageErrorText = 'Venue image is required.';
//       });
//     }
//     if (!areSportsSelected) {
//       setState(() {
//         _sportsErrorText = 'At least one sport is required.';
//       });
//     }

//     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
//       setState(() {
//         _isLoading = true;
//       });

//       if (!_isEditMode && _selectedLocation == null) {
//         _showSnackBar(
//             'Set venue location using "Use Current" or "Find Address".',
//             isError: true);
//         setState(() {
//           _isLoading = false;
//         });
//         return;
//       }

//       try {
//         List<String> sportTypes = List.from(_selectedSports);
//         if (sportTypes.isEmpty) sportTypes.add('General');

//         List<String> facilitiesList = _facilitiesController.text
//             .split(',')
//             .map((s) => s.trim())
//             .where((s) => s.isNotEmpty)
//             .toList();

//         Set<String> keywords = {};
//         void addWordsToKeywordsSet(String text) {
//           if (text.isNotEmpty) {
//             final words = text.toLowerCase().split(RegExp(r"[\s,.-]+"));
//             for (var word in words)
//               if (word.isNotEmpty && word.length > 1) keywords.add(word);
//           }
//         }

//         addWordsToKeywordsSet(_nameController.text.trim());
//         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
//         addWordsToKeywordsSet(_addressController.text.trim());
//         addWordsToKeywordsSet(_areaController.text.trim());
//         addWordsToKeywordsSet(_selectedCity ?? '');
//         addWordsToKeywordsSet(_countryController.text.trim());
//         List<String> searchKeywordsList = keywords.toList();

//         Map<String, dynamic> venueData = {
//           'name': _nameController.text.trim(),
//           'name_lowercase': _nameController.text.trim().toLowerCase(),
//           'sportType': sportTypes,
//           'description': _descriptionController.text.trim(),
//           'address': _addressController.text.trim(),
//           'area': _areaController.text.trim(),
//           'city': _selectedCity,
//           'country': _countryController.text.trim(),
//           'imageUrl': _imageUrlController.text.trim(),
//           'isActive': _isActive,
//           'bookingEnabled': _bookingEnabled,
//           'slotDurationMinutes': 60,
//           'phoneNumber': _phoneController.text.trim(),
//           'website': _websiteController.text.trim(),
//           'email': _emailController.text.trim(),
//           'facilities': facilitiesList,
//           'searchKeywords': searchKeywordsList,
//           'googleMapsUrl': _googleMapsUrlController.text.trim(),
//           'operatingHours': {
//             'weekday': {
//               'start': _weekdayStartController.text.trim(),
//               'end': _weekdayEndController.text.trim()
//             },
//             'saturday': {
//               'start': _saturdayStartController.text.trim(),
//               'end': _saturdayEndController.text.trim()
//             },
//             'sunday': {
//               'start': _sundayStartController.text.trim(),
//               'end': _sundayEndController.text.trim()
//             },
//           },
//           if (_selectedLocation != null) 'location': _selectedLocation,
//           if (!_isEditMode) ...{
//             'creatorUid': _auth.currentUser?.uid,
//             'createdAt': FieldValue.serverTimestamp()
//           },
//         };

//         if (_isEditMode) {
//           venueData.remove('createdAt');
//           venueData.remove('creatorUid');
//           venueData['updatedAt'] = FieldValue.serverTimestamp();
//           // Use the state variable for the ID
//           await _firestoreService.updateVenue(_currentVenueIdToEdit!, venueData);
//           _showSnackBar('Venue updated successfully!', isError: false);
          
//           // MODIFICATION: After successful edit, reset the form to "create" mode
//           setState(() {
//             _currentVenueIdToEdit = null;
//           });
//           _resetFormForNewEntry();

//         } else {
//           await _firestoreService.addVenue(venueData);
//           _showSnackBar('Venue added successfully!', isError: false);
//           _resetFormForNewEntry();
//         }

//       } catch (e) {
//         debugPrint("Submit error: $e");
//         if (!mounted) return;
//         _showSnackBar(
//             'Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}',
//             isError: true);
//       } finally {
//         if (mounted)
//           setState(() {
//             _isLoading = false;
//           });
//       }
//     } else {
//       setState(() {
//         _autovalidateMode = AutovalidateMode.onUserInteraction;
//       });
//       String errorMessage = "Please fix errors in the form.";
//       if (!isTextFormFieldsValid) {
//         /* Errors shown by fields */
//       } else if (!isImagePresent && !areSportsSelected) {
//         errorMessage = "Please upload a venue image and add at least one sport.";
//       } else if (!isImagePresent) {
//         errorMessage = "Please upload a venue image.";
//       } else if (!areSportsSelected) {
//         errorMessage = "Please add at least one sport.";
//       }
//       _showSnackBar(errorMessage, isError: true);
//     }
//   }

//   void _showSnackBar(String message,
//       {required bool isError, int durationSeconds = 3}) {
//     if (!mounted) return;
//     ScaffoldMessenger.of(context).removeCurrentSnackBar();
//     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
//       content: Text(message),
//       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
//       behavior: SnackBarBehavior.floating,
//       margin: const EdgeInsets.all(10),
//       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
//     ));
//   }

//   AppBar _buildAppBar(BuildContext context) {
//     final theme = Theme.of(context);
//     final bool isLoggedIn = _auth.currentUser != null;
//     final appBarBackgroundColor =
//         theme.appBarTheme.backgroundColor ?? theme.primaryColor;
//     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ??
//         theme.appBarTheme.iconTheme?.color ??
//         (kIsWeb
//             ? (theme.brightness == Brightness.dark
//                 ? Colors.white70
//                 : Colors.black87)
//             : Colors.white);
//     final titleTextStyle = theme.appBarTheme.titleTextStyle?.copyWith(
//             color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ??
//         TextStyle(
//             color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white,
//             fontSize: 20,
//             fontWeight: FontWeight.w500);

//     return AppBar(
//       toolbarHeight: 70.0,
//       automaticallyImplyLeading: false,
//       backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
//       elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
//       iconTheme: theme.iconTheme.copyWith(
//           color: kIsWeb
//               ? (theme.brightness == Brightness.dark
//                   ? Colors.white70
//                   : Colors.black87)
//               : Colors.white),
//       actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
//       title: kIsWeb
//           ? Row(children: [
//               Text('MM Associates',
//                   style: TextStyle(
//                       fontSize: 20,
//                       fontWeight: FontWeight.bold,
//                       color: theme.textTheme.titleLarge?.color ??
//                           theme.primaryColor)),
//               const SizedBox(width: 24),
//               if (_isLoadingName && isLoggedIn)
//                 const Padding(
//                     padding: EdgeInsets.only(right: 16.0),
//                     child: SizedBox(
//                         width: 18,
//                         height: 18,
//                         child: CircularProgressIndicator(strokeWidth: 2)))
//               else if (_userName != null && isLoggedIn)
//                 Padding(
//                     padding: const EdgeInsets.only(right: 16.0),
//                     child: Text('Hi, ${_userName!.split(' ')[0]}!',
//                         style: TextStyle(
//                             fontSize: 16,
//                             fontWeight: FontWeight.w500,
//                             color: theme.textTheme.bodyLarge?.color),
//                         overflow: TextOverflow.ellipsis)),
//               const Spacer(),
//             ])
//           : Row(children: [
//               if (isLoggedIn)
//                 GestureDetector(
//                   onTap: () {
//                     if (!context.mounted) return;
//                     Navigator.push(
//                         context,
//                         MaterialPageRoute(
//                             builder: (context) => const ProfileScreen()));
//                   },
//                   child: Padding(
//                     padding: const EdgeInsets.only(right: 10.0),
//                     child: CircleAvatar(
//                         radius: 18,
//                         backgroundColor: Colors.white24,
//                         backgroundImage: _userProfilePicUrl != null &&
//                                 _userProfilePicUrl!.isNotEmpty
//                             ? NetworkImage(_userProfilePicUrl!)
//                             : null,
//                         child: _userProfilePicUrl == null ||
//                                 _userProfilePicUrl!.isEmpty
//                             ? Icon(Icons.person_outline,
//                                 size: 20, color: Colors.white.withOpacity(0.8))
//                             : null),
//                   ),
//                 ),
//               if (_isLoadingName && isLoggedIn)
//                 const SizedBox(
//                     width: 18,
//                     height: 18,
//                     child: CircularProgressIndicator(
//                         strokeWidth: 2,
//                         valueColor:
//                             AlwaysStoppedAnimation<Color>(Colors.white70)))
//               else if (_userName != null && isLoggedIn)
//                 Flexible(
//                   child: Text('Hi, ${_userName!.split(' ')[0]}!',
//                       style: titleTextStyle.copyWith(
//                           fontSize: 18, fontWeight: FontWeight.w500),
//                       overflow: TextOverflow.ellipsis),
//                 )
//               else
//                 Text('MM Associates', style: titleTextStyle),
//             ]),
//       centerTitle: false,
//       actions: [
//         if (isLoggedIn)
//           IconButton(
//             icon: Icon(Icons.person_outline_rounded, color: actionsIconColor),
//             tooltip: 'My Profile',
//             onPressed: () {
//               if (!context.mounted) return;
//               Navigator.push(
//                   context,
//                   MaterialPageRoute(
//                       builder: (context) => const ProfileScreen()));
//             },
//           ),
//         if (kIsWeb) const SizedBox(width: 8),
//       ],
//     );
//   }

//   @override
//   Widget build(BuildContext context) {
//     final bool anyOperationInProgress = _isLoading ||
//         _isFetchingLocation ||
//         _isGeocoding ||
//         _isUploadingImage ||
//         _isCheckingVenueName;
//     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
//     final IconData submitBtnIcon =
//         _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;
//     final String pageTitle = _isEditMode ? 'Edit Venue' : 'Add New Venue';

//     Widget nameSuffixIcon;
//     if (_isCheckingVenueName) {
//       nameSuffixIcon = const SizedBox(
//           width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
//     } else if (_nameController.text.trim().isNotEmpty &&
//         (_isEditMode
//             ? _nameController.text.trim().toLowerCase() !=
//                 _initialVenueNameLowercase
//             : true)) {
//       nameSuffixIcon = _venueNameIsAvailable
//           ? const Icon(Icons.check_circle_outline, color: Colors.green)
//           : Icon(Icons.error_outline,
//               color: Theme.of(context).colorScheme.error);
//     } else {
//       nameSuffixIcon = const SizedBox.shrink();
//     }

//     return Scaffold(
//       appBar: _buildAppBar(context),
//       body: SingleChildScrollView(
//         child: GestureDetector(
//           onTap: () => FocusScope.of(context).unfocus(),
//           child: Padding(
//             padding: const EdgeInsets.all(16.0),
//             child: Form(
//               key: _formKey,
//               autovalidateMode: _autovalidateMode,
//               child: AbsorbPointer(
//                 absorbing: anyOperationInProgress,
//                 child: Opacity(
//                   opacity: anyOperationInProgress ? 0.7 : 1.0,
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.stretch,
//                     children: [
//                       Center(
//                         child: Padding(
//                           padding: const EdgeInsets.only(bottom: 24.0, top: 8.0),
//                           child: Text(
//                             pageTitle,
//                             style: Theme.of(context).textTheme.headlineSmall?.copyWith(
//                                   fontWeight: FontWeight.bold,
//                                 ),
//                             textAlign: TextAlign.center,
//                           ),
//                         ),
//                       ),
//                       _buildSectionHeader("Core Details"),
//                       TextFormField(
//                           controller: _nameController,
//                           decoration: InputDecoration(
//                             labelText: 'Venue Name*',
//                             prefixIcon: const Icon(Icons.sports_soccer),
//                             suffixIcon: Padding(
//                                 padding: const EdgeInsets.only(right: 12.0),
//                                 child: nameSuffixIcon),
//                             errorText: ((_nameController.text.isNotEmpty &&
//                                         !_isCheckingVenueName &&
//                                         !_isEditMode) ||
//                                     (_nameController.text.isNotEmpty &&
//                                         !_isCheckingVenueName &&
//                                         _isEditMode &&
//                                         _nameController.text
//                                                 .trim()
//                                                 .toLowerCase() !=
//                                             _initialVenueNameLowercase))
//                                 ? _venueNameErrorText
//                                 : null,
//                           ),
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) return 'Required';
//                             return null;
//                           },
//                           textCapitalization: TextCapitalization.words),
//                       const SizedBox(height: 15),
//                       _buildSportsInputSection(),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _descriptionController,
//                           decoration: const InputDecoration(
//                               labelText: 'Description',
//                               prefixIcon: Icon(Icons.description_outlined),
//                               alignLabelWithHint: true),
//                           maxLines: 3,
//                           textCapitalization: TextCapitalization.sentences),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Venue Image*"),
//                       _buildImageUploadSection(),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Address & Location*"),
//                       TextFormField(
//                           controller: _addressController,
//                           decoration: const InputDecoration(
//                               labelText: 'Address Line*',
//                               prefixIcon: Icon(Icons.location_on_outlined)),
//                           validator: (v) =>
//                               v!.trim().isEmpty ? 'Required' : null,
//                           textCapitalization: TextCapitalization.words),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _areaController,
//                           decoration: const InputDecoration(
//                               labelText: 'Area / Locality*',
//                               hintText: 'e.g., Borivali, Koramangala',
//                               prefixIcon: Icon(Icons.explore_outlined)),
//                           validator: (v) =>
//                               v!.trim().isEmpty ? 'Required' : null,
//                           textCapitalization: TextCapitalization.words),
//                       const SizedBox(height: 15),
//                       Row(children: [
//                         Expanded(
//                           child: FormField<String>(
//                             // Use a key to force rebuild when city changes externally
//                             key: ValueKey(_selectedCity),
//                             initialValue: _selectedCity,
//                             validator: (value) {
//                               if (value == null || value.isEmpty) {
//                                 return 'City is required';
//                               }
//                               return null;
//                             },
//                             builder: (FormFieldState<String> state) {
//                               void handleTap() async {
//                                 if (anyOperationInProgress) return;
//                                 final result = await Navigator.push<String?>(
//                                   context,
//                                   MaterialPageRoute(builder: (context) => CitySelectionScreen(currentSelectedCity: state.value)),
//                                 );
                                
//                                 if (result != null) {
//                                   state.didChange(result);
//                                   setState(() {
//                                     _selectedCity = result;
//                                   });
//                                 }
//                               }

//                               return InkWell(
//                                 onTap: handleTap,
//                                 child: InputDecorator(
//                                   decoration: InputDecoration(
//                                     labelText: 'City*',
//                                     prefixIcon: const Icon(Icons.location_city),
//                                     errorText: state.errorText,
//                                     border: const OutlineInputBorder(),
//                                     contentPadding: const EdgeInsets.fromLTRB(12.0, 16.0, 12.0, 16.0),
//                                   ),
//                                   child: Row(
//                                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                                     children: [
//                                       Expanded(
//                                         child: Text(
//                                           state.value ?? 'Tap to select city',
//                                           overflow: TextOverflow.ellipsis,
//                                           softWrap: false,
//                                           style: state.value == null
//                                             ? TextStyle(color: Theme.of(context).hintColor, fontSize: 16)
//                                             : Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.normal),
//                                         ),
//                                       ),
//                                       const Icon(Icons.arrow_drop_down, color: Colors.grey),
//                                     ],
//                                   ),
//                                 ),
//                               );
//                             },
//                           ),
//                         ),
//                         const SizedBox(width: 10),
//                         Expanded(
//                             child: TextFormField(
//                                 controller: _countryController,
//                                 decoration: const InputDecoration(
//                                     labelText: 'Country*',
//                                     prefixIcon: Icon(Icons.public)),
//                                 validator: (v) =>
//                                     v!.trim().isEmpty ? 'Required' : null,
//                                 textCapitalization: TextCapitalization.words))
//                       ]),
//                       const SizedBox(height: 15),
//                       Row(children: [
//                         Expanded(
//                             child: OutlinedButton.icon(
//                                 icon: _isFetchingLocation
//                                     ? _buildButtonSpinner()
//                                     : const Icon(Icons.my_location, size: 18),
//                                 label: const Text('Use Current'),
//                                 onPressed: anyOperationInProgress
//                                     ? null
//                                     : _fetchAndSetCurrentLocation,
//                                 style: OutlinedButton.styleFrom(
//                                     padding: const EdgeInsets.symmetric(
//                                         vertical: 12)))),
//                         const SizedBox(width: 10),
//                         Expanded(
//                             child: OutlinedButton.icon(
//                                 icon: _isGeocoding
//                                     ? _buildButtonSpinner()
//                                     : const Icon(Icons.location_searching,
//                                         size: 18),
//                                 label: const Text('Find Address'),
//                                 onPressed: anyOperationInProgress
//                                     ? null
//                                     : _geocodeAddress,
//                                 style: OutlinedButton.styleFrom(
//                                     padding: const EdgeInsets.symmetric(
//                                         vertical: 12))))
//                       ]),
//                       Padding(
//                           padding: const EdgeInsets.only(top: 10.0, bottom: 5.0),
//                           child: Text(
//                               _locationStatusMessage ??
//                                   (_isEditMode && _selectedLocation != null
//                                       ? 'Location previously set'
//                                       : 'Location not set* (Required for new venues)'),
//                               style: TextStyle(
//                                   fontSize: 13, color: Colors.grey[700]),
//                               textAlign: TextAlign.center)),
//                       _buildSectionHeader("Venue on Google Maps*"),
//                       Row(
//                         children: [
//                           Expanded(
//                             child: OutlinedButton.icon(
//                               icon: const Icon(Icons.map_outlined, size: 18),
//                               label: const Text('Open Google Maps'),
//                               onPressed:
//                                   anyOperationInProgress ? null : _launchGoogleMaps,
//                               style: OutlinedButton.styleFrom(
//                                 padding:
//                                     const EdgeInsets.symmetric(vertical: 12),
//                               ),
//                             ),
//                           ),
//                         ],
//                       ),
//                       const SizedBox(height: 10),
//                       TextFormField(
//                         controller: _googleMapsUrlController,
//                         decoration: const InputDecoration(
//                           labelText: 'Pasted Google Maps Link*',
//                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
//                           prefixIcon: Icon(Icons.link),
//                         ),
//                         validator: (value) {
//                           if (value == null || value.trim().isEmpty) {
//                             return 'Google Maps link is required.';
//                           }
//                           final trimmedValue = value.trim();
//                           final uri = Uri.tryParse(trimmedValue);
//                           if (uri == null || !uri.isAbsolute) {
//                             return 'Please enter a valid URL.';
//                           }
//                           final lowerTrimmedValue = trimmedValue.toLowerCase();
//                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
//                               !lowerTrimmedValue.contains('google.') &&
//                               !lowerTrimmedValue.contains('goo.gl/maps')) {
//                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
//                           }
//                           return null;
//                         },
//                         keyboardType: TextInputType.url,
//                       ),
//                       Padding(
//                         padding: const EdgeInsets.only(
//                             top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
//                         child: Text(
//                           "1. Click 'Open Google Maps' above.\n"
//                           "2. In Google Maps, find the exact venue.\n"
//                           "3. Use the 'Share' option and 'Copy link'.\n"
//                           "4. Paste the link in the field above.",
//                           style: TextStyle(
//                               fontSize: 12.5,
//                               color: Theme.of(context).hintColor),
//                           textAlign: TextAlign.start,
//                         ),
//                       ),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Operating Hours*"),
//                       _buildOperatingHoursRow(
//                           "Weekday", _weekdayStartController, _weekdayEndController),
//                       const SizedBox(height: 12),
//                       _buildOperatingHoursRow("Saturday", _saturdayStartController,
//                           _saturdayEndController),
//                       const SizedBox(height: 12),
//                       _buildOperatingHoursRow(
//                           "Sunday", _sundayStartController, _sundayEndController),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Contact & Other Info"),
//                       TextFormField(
//                           controller: _phoneController,
//                           decoration: const InputDecoration(
//                               labelText: 'Phone*',
//                               prefixIcon: Icon(Icons.phone_outlined)),
//                           keyboardType: TextInputType.phone,
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) {
//                               return 'Phone number is required';
//                             }
//                             return null;
//                           }),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _emailController,
//                           decoration: const InputDecoration(
//                               labelText: 'Email*',
//                               prefixIcon: Icon(Icons.email_outlined)),
//                           keyboardType: TextInputType.emailAddress,
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) {
//                               return 'Email is required';
//                             }
//                             if (!RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
//                                 .hasMatch(v.trim()))
//                               return 'Please enter a valid email address';
//                             return null;
//                           }),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _websiteController,
//                           decoration: const InputDecoration(
//                               labelText: 'Website (Optional)',
//                               prefixIcon: Icon(Icons.language_outlined)),
//                           keyboardType: TextInputType.url,
//                           validator: (v) {
//                             if (v!.trim().isNotEmpty &&
//                                 (Uri.tryParse(v.trim())?.isAbsolute ?? false) ==
//                                     false) return 'Invalid URL';
//                             return null;
//                           }),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _facilitiesController,
//                           decoration: const InputDecoration(
//                               labelText: 'Facilities*',
//                               hintText: 'e.g., Parking, Washroom, Cafe (Comma-separated)',
//                               prefixIcon: Icon(Icons.local_offer_outlined)),
//                           textCapitalization: TextCapitalization.words,
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) {
//                               return 'At least one facility is required';
//                             }
//                             return null;
//                           }),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Status & Settings"),
//                       SwitchListTile(
//                           title: const Text('Booking Enabled?'),
//                           subtitle: const Text(
//                               'Can users make bookings for this venue?'),
//                           value: _bookingEnabled,
//                           onChanged: anyOperationInProgress
//                               ? null
//                               : (v) => setState(() => _bookingEnabled = v),
//                           secondary: Icon(
//                               _bookingEnabled
//                                   ? Icons.event_available
//                                   : Icons.event_busy,
//                               color: _bookingEnabled
//                                   ? Theme.of(context).primaryColor
//                                   : Colors.grey),
//                           contentPadding: EdgeInsets.zero,
//                           dense: true),
//                       const SizedBox(height: 10),
//                       SwitchListTile(
//                           title: const Text('Venue is Active?'),
//                           subtitle: const Text(
//                               'Inactive venues won\'t appear in searches.'),
//                           value: _isActive,
//                           onChanged: anyOperationInProgress
//                               ? null
//                               : (v) => setState(() => _isActive = v),
//                           secondary: Icon(
//                               _isActive
//                                   ? Icons.check_circle
//                                   : Icons.cancel_outlined,
//                               color: _isActive ? Colors.green : Colors.grey),
//                           contentPadding: EdgeInsets.zero,
//                           dense: true),
//                       const SizedBox(height: 25),
//                       Row(
//                         mainAxisAlignment: MainAxisAlignment.center,
//                         children: [
//                           SizedBox(
//                             width: 200,
//                             child: ElevatedButton.icon(
//                                 icon: (anyOperationInProgress &&
//                                         (_isLoading || _isUploadingImage))
//                                     ? _buildButtonSpinner(
//                                         size: 20, color: Colors.white)
//                                     : Icon(submitBtnIcon),
//                                 label: Text((anyOperationInProgress &&
//                                         (_isLoading || _isUploadingImage))
//                                     ? 'Saving...'
//                                     : submitBtnTxt),
//                                 onPressed:
//                                     anyOperationInProgress ? null : _submitForm,
//                                 style: ElevatedButton.styleFrom(
//                                     padding: const EdgeInsets.symmetric(
//                                         vertical: 15),
//                                     textStyle: const TextStyle(
//                                         fontSize: 16,
//                                         fontWeight: FontWeight.bold))),
//                           ),
//                         ],
//                       ),
//                       const SizedBox(height: 20),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ),
//         ),
//       ),
//     );
//   }

//   Widget _buildImageUploadSection() {
//     Widget imagePreview;
//     const double previewSize = 150.0;

//     if (_isUploadingImage && _selectedImageFile == null) {
//       imagePreview = const Center(child: CircularProgressIndicator());
//     } else if (_selectedImageFile != null) {
//       imagePreview = kIsWeb
//           ? Image.network(_selectedImageFile!.path,
//               width: previewSize, height: previewSize, fit: BoxFit.cover)
//           : Image.file(File(_selectedImageFile!.path),
//               width: previewSize, height: previewSize, fit: BoxFit.cover);
//     } else if (_imageUrlController.text.isNotEmpty) {
//       imagePreview = Image.network(
//         _imageUrlController.text,
//         width: previewSize,
//         height: previewSize,
//         fit: BoxFit.cover,
//         errorBuilder: (context, error, stackTrace) => const Center(
//             child: Icon(Icons.broken_image_outlined,
//                 size: 40, color: Colors.grey)),
//         loadingBuilder: (context, child, loadingProgress) {
//           if (loadingProgress == null) return child;
//           return Center(
//               child: CircularProgressIndicator(
//                   value: loadingProgress.expectedTotalBytes != null
//                       ? loadingProgress.cumulativeBytesLoaded /
//                           loadingProgress.expectedTotalBytes!
//                       : null));
//         },
//       );
//     } else {
//       imagePreview = Center(
//           child: Icon(Icons.add_a_photo_outlined,
//               size: 40,
//               color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
//     }

//     return Column(
//       crossAxisAlignment: CrossAxisAlignment.start,
//       children: [
//         Center(
//           child: Column(
//             children: [
//               GestureDetector(
//                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
//                 child: Container(
//                   height: previewSize,
//                   width: previewSize,
//                   margin: const EdgeInsets.only(bottom: 10.0),
//                   decoration: BoxDecoration(
//                     color: Theme.of(context)
//                         .colorScheme
//                         .surfaceVariant
//                         .withOpacity(0.3),
//                     border: Border.all(
//                       color: _imageErrorText != null
//                           ? Theme.of(context).colorScheme.error
//                           : Theme.of(context)
//                               .colorScheme
//                               .outline
//                               .withOpacity(0.5),
//                       width: _imageErrorText != null ? 1.5 : 1.0,
//                     ),
//                     borderRadius: BorderRadius.circular(8.0),
//                   ),
//                   child: ClipRRect(
//                     borderRadius: BorderRadius.circular(7.0),
//                     child: Stack(
//                       fit: StackFit.expand,
//                       children: [
//                         imagePreview,
//                         if (_isUploadingImage)
//                           Container(
//                             color: Colors.black.withOpacity(0.4),
//                             child: const Center(
//                                 child: CircularProgressIndicator(
//                               color: Colors.white,
//                               strokeWidth: 3,
//                             )),
//                           ),
//                         if (!_isUploadingImage &&
//                             (_imageUrlController.text.isNotEmpty ||
//                                 _selectedImageFile != null))
//                           Positioned(
//                             top: 4,
//                             right: 4,
//                             child: Material(
//                               color: Colors.black54,
//                               shape: const CircleBorder(),
//                               child: InkWell(
//                                 customBorder: const CircleBorder(),
//                                 onTap: _isUploadingImage ? null : _clearImage,
//                                 child: const Padding(
//                                   padding: EdgeInsets.all(6.0),
//                                   child:
//                                       Icon(Icons.close, color: Colors.white, size: 18),
//                                 ),
//                               ),
//                             ),
//                           ),
//                       ],
//                     ),
//                   ),
//                 ),
//               ),
//               if (!_isUploadingImage)
//                 OutlinedButton.icon(
//                   icon: Icon(
//                       _imageUrlController.text.isNotEmpty ||
//                               _selectedImageFile != null
//                           ? Icons.edit_outlined
//                           : Icons.add_photo_alternate_outlined,
//                       size: 18),
//                   label: Text(_imageUrlController.text.isNotEmpty ||
//                           _selectedImageFile != null
//                       ? 'Change Image'
//                       : 'Select Image*'),
//                   onPressed: _pickAndUploadImage,
//                   style: OutlinedButton.styleFrom(
//                       padding: const EdgeInsets.symmetric(
//                           horizontal: 20, vertical: 10)),
//                 ),
//             ],
//           ),
//         ),
//         if (_isUploadingImage)
//           Center(
//             child: Padding(
//               padding: const EdgeInsets.only(top: 10.0),
//               child: Text("Uploading, please wait...",
//                   style: TextStyle(
//                       color: Theme.of(context).primaryColor,
//                       fontStyle: FontStyle.italic)),
//             ),
//           ),
//         if (_imageErrorText != null)
//           Padding(
//             padding: const EdgeInsets.only(top: 8.0),
//             child: Center(
//               child: Text(
//                 _imageErrorText!,
//                 style: TextStyle(
//                     color: Theme.of(context).colorScheme.error, fontSize: 12),
//                 textAlign: TextAlign.center,
//               ),
//             ),
//           ),
//         Visibility(
//           visible: false,
//           maintainState: true,
//           child: TextFormField(
//             controller: _imageUrlController,
//             decoration: const InputDecoration(labelText: 'Image URL'),
//           ),
//         ),
//       ],
//     );
//   }

//   Widget _buildSportsInputSection() {
//     return Column(
//       crossAxisAlignment: CrossAxisAlignment.start,
//       children: [
//         TextFormField(
//           controller: _sportInputController,
//           focusNode: _sportInputFocusNode,
//           textCapitalization: TextCapitalization.words,
//           decoration: InputDecoration(
//             hintText: 'e.g., Cricket, Football (Type & press Enter)*',
//             prefixIcon: const Icon(Icons.fitness_center),
//             border: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: _sportsErrorText != null
//                       ? Theme.of(context).colorScheme.error
//                       : Theme.of(context).colorScheme.outline),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             focusedBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: _sportsErrorText != null
//                       ? Theme.of(context).colorScheme.error
//                       : Theme.of(context).primaryColor,
//                   width: 1.5),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             enabledBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: _sportsErrorText != null
//                       ? Theme.of(context).colorScheme.error
//                       : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             errorBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: Theme.of(context).colorScheme.error, width: 1.5),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             focusedErrorBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: Theme.of(context).colorScheme.error, width: 1.5),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//           ),
//           onFieldSubmitted: (_) => _addSportFromInput(),
//         ),
//         if (_selectedSports.isNotEmpty)
//           Padding(
//             padding: const EdgeInsets.only(top: 8.0),
//             child: Container(
//               width: double.infinity,
//               padding: const EdgeInsets.symmetric(vertical: 4.0),
//               child: Wrap(
//                 spacing: 8.0,
//                 runSpacing: 4.0,
//                 children: _selectedSports.map((sport) {
//                   return InputChip(
//                     label: Text(sport),
//                     labelStyle: TextStyle(
//                         color: Theme.of(context).colorScheme.onSecondaryContainer),
//                     backgroundColor: Theme.of(context)
//                         .colorScheme
//                         .secondaryContainer
//                         .withOpacity(0.7),
//                     deleteIconColor: Theme.of(context)
//                         .colorScheme
//                         .onSecondaryContainer
//                         .withOpacity(0.7),
//                     onDeleted: () => _removeSport(sport),
//                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
//                     padding: const EdgeInsets.all(6),
//                   );
//                 }).toList(),
//               ),
//             ),
//           ),
//         if (_sportsErrorText != null)
//           Padding(
//             padding: const EdgeInsets.only(top: 8.0, left: 12.0),
//             child: Text(
//               _sportsErrorText!,
//               style: TextStyle(
//                   color: Theme.of(context).colorScheme.error, fontSize: 12),
//             ),
//           ),
//       ],
//     );
//   }

//   Widget _buildButtonSpinner({double size = 16, Color? color}) {
//     final resolvedColor = color ?? Theme.of(context).primaryColor;
//     return SizedBox(
//         width: size,
//         height: size,
//         child: CircularProgressIndicator(
//             strokeWidth: 2,
//             valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
//   }

//   Widget _buildSectionHeader(String title) {
//     return Padding(
//       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
//       child: Text(title,
//           style: Theme.of(context)
//               .textTheme
//               .titleMedium
//               ?.copyWith(fontWeight: FontWeight.bold)),
//     );
//   }

//   Widget _buildOperatingHoursRow(String dayLabel,
//       TextEditingController startController, TextEditingController endController) {
//     const double dayLabelColumnWidth = 90.0;
//     const double gapBetweenLabelAndTimes = 8.0;
//     const double preferredTimeFieldWidth = 105.0;
//     const double horizontalPaddingForToText = 5.0;
//     String? timeValidator(String? value) {
//       if (value == null || value.trim().isEmpty) return 'Required';
//       if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
//           .hasMatch(value.trim())) return 'HH:MM';
//       return null;
//     }

//     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
//       return InkWell(
//           onTap: () => _selectTime(context, controller),
//           child: AbsorbPointer(
//               child: TextFormField(
//                   controller: controller,
//                   textAlign: TextAlign.center,
//                   decoration: InputDecoration(
//                       labelText: labelText,
//                       contentPadding: const EdgeInsets.symmetric(
//                           horizontal: 4.0, vertical: 8.0),
//                       isDense: true,
//                       border: const OutlineInputBorder(),
//                       suffixIcon: const Icon(Icons.access_time, size: 18)),
//                   validator: timeValidator)));
//     }

//     Widget dayLabelWidget = SizedBox(
//         width: dayLabelColumnWidth,
//         child: Text(dayLabel,
//             style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500),
//             textAlign: TextAlign.start));
//     if (kIsWeb) {
//       Widget buildWebTimeInput(TextEditingController controller, String labelText) {
//         return SizedBox(
//             width: preferredTimeFieldWidth,
//             child: buildCoreTimeInput(controller, labelText));
//       }

//       final TextPainter textPainter = TextPainter(
//           text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)),
//           maxLines: 1,
//           textDirection: TextDirection.ltr)
//         ..layout(minWidth: 0, maxWidth: double.infinity);
//       final double widthOfToTextWithPadding =
//           textPainter.width + (2 * horizontalPaddingForToText);
//       final double requiredWidthForTimeControlsGroupWeb =
//           (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
//       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
//         final double totalAvailableWidth = constraints.maxWidth;
//         final double singleLineRequiredWidthWeb =
//             dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
//         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
//           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
//             dayLabelWidget,
//             const SizedBox(width: gapBetweenLabelAndTimes),
//             Expanded(
//                 child: Row(children: [
//               Flexible(child: buildWebTimeInput(startController, 'Start')),
//               Padding(
//                   padding: const EdgeInsets.symmetric(
//                       horizontal: horizontalPaddingForToText),
//                   child: Text("to", style: const TextStyle(fontSize: 14))),
//               Flexible(child: buildWebTimeInput(endController, 'End')),
//               const Spacer()
//             ]))
//           ]);
//         } else {
//           return Column(
//               crossAxisAlignment: CrossAxisAlignment.start,
//               children: [
//                 dayLabelWidget,
//                 const SizedBox(height: 8.0),
//                 Padding(
//                     padding: const EdgeInsets.only(left: 0.0),
//                     child:
//                         Row(mainAxisSize: MainAxisSize.min, children: [
//                       buildWebTimeInput(startController, 'Start'),
//                       Padding(
//                           padding: const EdgeInsets.symmetric(
//                               horizontal: horizontalPaddingForToText),
//                           child: Text("to", style: const TextStyle(fontSize: 14))),
//                       buildWebTimeInput(endController, 'End')
//                     ]))
//               ]);
//         }
//       });
//     } else {
//       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
//         dayLabelWidget,
//         const SizedBox(width: gapBetweenLabelAndTimes),
//         Expanded(child: buildCoreTimeInput(startController, 'Start')),
//         Padding(
//             padding:
//                 const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText),
//             child: Text("to", style: const TextStyle(fontSize: 14))),
//         Expanded(child: buildCoreTimeInput(endController, 'End'))
//       ]);
//     }
//   }
// }


===== features\home\screens\venue_form.dart =====

// import 'dart:async';
// import 'dart:io'; // For File, used for non-web image preview

// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:flutter/foundation.dart' show kIsWeb;
// import 'package:flutter/material.dart';
// import 'package:geolocator/geolocator.dart';
// import 'package:image_picker/image_picker.dart';
// import 'package:mm_associates/features/auth/services/auth_service.dart';
// import 'package:mm_associates/features/profile/screens/profile_screen.dart';
// import 'package:mm_associates/features/user/services/user_service.dart';
// import 'package:url_launcher/url_launcher.dart';

// import '../../../../core/services/geocoding_service.dart';
// import '../../../../core/services/image_upload_service.dart';
// import '../../../../core/services/location_service.dart';
// import '../../../../features/data/services/firestore_service.dart';

// // Assuming 'CitySelectionScreen' is defined in this path.
// // The user has requested not to include its code here.
// // Please ensure this import path is correct for your project structure.
// import 'city_selection_screen.dart';


// class AddVenueFormScreen extends StatefulWidget {
//   final String? venueIdToEdit;
//   final Map<String, dynamic>? initialData;

//   /// True if an admin is landing here directly as their "home" page.
//   /// This will add a button to navigate to the user-facing app view.
//   final bool isDirectAdminAccess;

//   const AddVenueFormScreen({
//     super.key,
//     this.venueIdToEdit,
//     this.initialData,
//     this.isDirectAdminAccess = false,
//   });

//   @override
//   State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
// }

// class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
//   final _formKey = GlobalKey<FormState>();
//   final FirestoreService _firestoreService = FirestoreService();
//   final LocationService _locationService = LocationService();
//   final LocationIQService _geocodingService = LocationIQService();
//   final FirebaseAuth _auth = FirebaseAuth.instance;
//   final AuthService _authService = AuthService();
//   final UserService _userService = UserService();

//   final ImageUploadService _imageUploadService = ImageUploadService();
//   final ImagePicker _picker = ImagePicker();

//   static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

//   // Controllers
//   final _nameController = TextEditingController();
//   final _descriptionController = TextEditingController();
//   final _imageUrlController = TextEditingController();
//   final _addressController = TextEditingController();
//   final _areaController = TextEditingController();
//   final _countryController = TextEditingController();
//   final _weekdayStartController = TextEditingController();
//   final _weekdayEndController = TextEditingController();
//   final _saturdayStartController = TextEditingController();
//   final _saturdayEndController = TextEditingController();
//   final _sundayStartController = TextEditingController();
//   final _sundayEndController = TextEditingController();
//   final _phoneController = TextEditingController();
//   final _websiteController = TextEditingController();
//   final _emailController = TextEditingController();
//   final _facilitiesController = TextEditingController();
//   final _googleMapsUrlController = TextEditingController();

//   String? _selectedCity;

//   List<String> _selectedSports = [];
//   final _sportInputController = TextEditingController();
//   final _sportInputFocusNode = FocusNode();
//   String? _sportsErrorText;

//   bool _isActive = true;
//   bool _bookingEnabled = true;
//   bool _isLoading = false;
//   bool _isFetchingLocation = false;
//   bool _isGeocoding = false;
//   GeoPoint? _selectedLocation;
//   String? _locationStatusMessage;

//   Timer? _venueNameDebouncer;
//   bool _isCheckingVenueName = false;
//   bool _venueNameIsAvailable = true;
//   String? _venueNameErrorText;
//   String? _initialVenueNameLowercase;

//   XFile? _selectedImageFile;
//   bool _isUploadingImage = false;
//   String? _imageErrorText;

//   String? _userName;
//   String? _userProfilePicUrl;
//   bool _isLoadingName = true;
  
//   // MODIFICATION: Use an internal state variable to manage edit mode.
//   String? _currentVenueIdToEdit;
//   // MODIFICATION: Getter now uses the internal state variable.
//   bool get _isEditMode => _currentVenueIdToEdit != null;
//   AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

//   @override
//   void initState() {
//     super.initState();
//     // MODIFICATION: Initialize the internal state variable.
//     _currentVenueIdToEdit = widget.venueIdToEdit;
    
//     if (_isEditMode && widget.initialData != null) {
//       _prefillFormData(widget.initialData!);
//       _initialVenueNameLowercase =
//           widget.initialData!['name']?.toString().trim().toLowerCase();
//     }
//     _nameController.addListener(_onNameChanged);
//     _fetchUserNameAndPic();
//   }

//   void _prefillFormData(Map<String, dynamic> data) {
//     _nameController.text = data['name'] ?? '';
//     _selectedSports = (data['sportType'] as List<dynamic>?)
//             ?.map((s) => s.toString().trim())
//             .where((s) => s.isNotEmpty)
//             .toList() ??
//         [];
//     _descriptionController.text = data['description'] ?? '';
//     _addressController.text = data['address'] ?? '';
//     _areaController.text = data['area'] ?? '';
//     _selectedCity = data['city'] as String?;
//     _countryController.text = data['country'] ?? '';
//     _imageUrlController.text = data['imageUrl'] ?? '';
//     _isActive = data['isActive'] ?? true;
//     _bookingEnabled = data['bookingEnabled'] ?? true;
//     _phoneController.text = data['phoneNumber'] ?? '';
//     _websiteController.text = data['website'] ?? '';
//     _emailController.text = data['email'] ?? '';
//     _facilitiesController.text =
//         (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
//     _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

//     final GeoPoint? initialLocation = data['location'] as GeoPoint?;
//     if (initialLocation != null) {
//       _selectedLocation = initialLocation;
//       _locationStatusMessage =
//           'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
//     }

//     if (data['operatingHours'] is Map) {
//       final hoursMap = data['operatingHours'] as Map<String, dynamic>;
//       _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
//       _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
//       _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
//       _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
//       _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
//       _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
//     }
//   }

//   @override
//   void dispose() {
//     _nameController.removeListener(_onNameChanged);
//     _nameController.dispose();
//     _venueNameDebouncer?.cancel();
//     _sportInputController.dispose();
//     _sportInputFocusNode.dispose();
//     _descriptionController.dispose();
//     _imageUrlController.dispose();
//     _addressController.dispose();
//     _areaController.dispose();
//     _countryController.dispose();
//     _weekdayStartController.dispose();
//     _weekdayEndController.dispose();
//     _saturdayStartController.dispose();
//     _saturdayEndController.dispose();
//     _sundayStartController.dispose();
//     _sundayEndController.dispose();
//     _phoneController.dispose();
//     _websiteController.dispose();
//     _emailController.dispose();
//     _facilitiesController.dispose();
//     _googleMapsUrlController.dispose();
//     super.dispose();
//   }

//   Future<void> _fetchUserNameAndPic() async {
//     if (!mounted) return;
//     setState(() => _isLoadingName = true);
//     final currentUser = _auth.currentUser;
//     if (currentUser == null) {
//       if (mounted)
//         setState(() {
//           _userName = 'Guest';
//           _userProfilePicUrl = null;
//           _isLoadingName = false;
//         });
//       return;
//     }
//     try {
//       final userData = await _userService.getUserProfileData();
//       if (!mounted) return;
//       final fetchedName = userData?['name'] as String? ??
//           currentUser.displayName ??
//           currentUser.email?.split('@')[0] ??
//           'User';
//       final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
//       setState(() {
//         _userName = fetchedName;
//         _userProfilePicUrl = fetchedPicUrl;
//       });
//     } catch (e) {
//       if (!mounted) return;
//       final fallbackName = currentUser.displayName ??
//           currentUser.email?.split('@')[0] ??
//           'User';
//       setState(() {
//         _userName = fallbackName;
//         _userProfilePicUrl = null;
//       });
//       debugPrint("Error fetching user name: $e");
//     } finally {
//       if (mounted) setState(() => _isLoadingName = false);
//     }
//   }

//   void _addSportFromInput() {
//     final sportName = _sportInputController.text.trim();
//     if (sportName.isNotEmpty) {
//       final capitalizedSportName = sportName
//           .split(' ')
//           .map((word) => word.isNotEmpty
//               ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}'
//               : '')
//           .join(' ');

//       if (!_selectedSports
//           .any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
//         setState(() {
//           _selectedSports.add(capitalizedSportName);
//           _sportsErrorText = null;
//         });
//       }
//       _sportInputController.clear();
//       _sportInputFocusNode.requestFocus();
//     }
//   }

//   void _removeSport(String sportName) {
//     setState(() {
//       _selectedSports.remove(sportName);
//       if (_selectedSports.isEmpty &&
//           _autovalidateMode == AutovalidateMode.onUserInteraction) {
//         _sportsErrorText = 'At least one sport is required.';
//       }
//     });
//   }

//   void _onNameChanged() {
//     if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
//     _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
//       final name = _nameController.text.trim();
//       if (name.isNotEmpty) {
//         _checkVenueNameUniqueness(name);
//       } else {
//         setState(() {
//           _isCheckingVenueName = false;
//           _venueNameIsAvailable = true;
//           _venueNameErrorText = null;
//         });
//       }
//     });
//   }

//   Future<void> _checkVenueNameUniqueness(String name) async {
//     if (!mounted) return;
//     setState(() {
//       _isCheckingVenueName = true;
//       _venueNameIsAvailable = true;
//       _venueNameErrorText = null;
//     });
//     final nameLower = name.toLowerCase();
//     if (_isEditMode && nameLower == _initialVenueNameLowercase) {
//       setState(() {
//         _isCheckingVenueName = false;
//         _venueNameIsAvailable = true;
//         _venueNameErrorText = null;
//       });
//       return;
//     }
//     try {
//       final bool exists = await _firestoreService.checkVenueNameExists(
//           nameLower, _isEditMode ? _currentVenueIdToEdit : null); // Use state variable
//       if (!mounted) return;
//       setState(() {
//         _venueNameIsAvailable = !exists;
//         _venueNameErrorText = exists ? 'Venue name already exists.' : null;
//         _isCheckingVenueName = false;
//       });
//     } catch (e) {
//       if (!mounted) return;
//       setState(() {
//         _venueNameIsAvailable = false;
//         _venueNameErrorText = 'Error checking name. Please try again.';
//         _isCheckingVenueName = false;
//       });
//       debugPrint("Error checking venue name: $e");
//     }
//   }

//   Future<void> _selectTime(
//       BuildContext context, TextEditingController controller) async {
//     TimeOfDay? initialTime;
//     if (controller.text.isNotEmpty) {
//       try {
//         final parts = controller.text.split(':');
//         if (parts.length == 2)
//           initialTime =
//               TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
//       } catch (e) {
//         /* ignore */
//       }
//     }
//     final TimeOfDay? picked =
//         await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
//     if (picked != null) {
//       setState(() {
//         controller.text =
//             "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}";
//       });
//       if (_autovalidateMode == AutovalidateMode.onUserInteraction)
//         _formKey.currentState?.validate();
//     }
//   }

//   Future<void> _fetchAndSetCurrentLocation() async {
//     if (!mounted ||
//         _isLoading ||
//         _isFetchingLocation ||
//         _isGeocoding ||
//         _isUploadingImage) return;
//     setState(() {
//       _isFetchingLocation = true;
//       _locationStatusMessage = 'Fetching...';
//       _selectedLocation = null;
//     });
//     final Position? p = await _locationService.getCurrentLocation();
//     if (!mounted) return;
//     if (p != null) {
//       setState(() {
//         _selectedLocation = GeoPoint(p.latitude, p.longitude);
//         _locationStatusMessage =
//             'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}';
//         _isFetchingLocation = false;
//       });
//       _showSnackBar('Location fetched!', isError: false);
//     } else {
//       setState(() {
//         _locationStatusMessage = 'Could not get location.';
//         _isFetchingLocation = false;
//         _selectedLocation = null;
//       });
//       _showSnackBar('Could not fetch location. Check permissions/service.',
//           isError: true);
//     }
//   }

//   Future<void> _geocodeAddress() async {
//     if (!mounted ||
//         _isLoading ||
//         _isFetchingLocation ||
//         _isGeocoding ||
//         _isUploadingImage) return;
//     FocusScope.of(context).unfocus();
//     final fullAddressQuery = [
//       _addressController.text.trim(),
//       _areaController.text.trim(),
//       _selectedCity ?? '',
//       _countryController.text.trim()
//     ].where((s) => s.isNotEmpty).join(', ');
//     if (fullAddressQuery.length < 5) {
//       _showSnackBar('Enter Address, Area, City, and Country.', isError: true);
//       return;
//     }
//     debugPrint("Geocoding: '$fullAddressQuery'");
//     setState(() {
//       _isGeocoding = true;
//       _locationStatusMessage = 'Finding for "$fullAddressQuery"...';
//       _selectedLocation = null;
//     });
//     try {
//       final GeoPoint? r =
//           await _geocodingService.getCoordsFromAddress(fullAddressQuery);
//       if (!mounted) return;
//       if (r != null) {
//         setState(() {
//           _selectedLocation = r;
//           _locationStatusMessage =
//               'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}';
//           _isGeocoding = false;
//         });
//         _showSnackBar('Location found!', isError: false);
//       } else {
//         setState(() {
//           _locationStatusMessage = 'Could not find location.';
//           _isGeocoding = false;
//           _selectedLocation = null;
//         });
//         _showSnackBar('Address lookup failed.', isError: true);
//       }
//     } catch (e) {
//       if (!mounted) return;
//       String err = e.toString().replaceFirst('Exception: ', '');
//       setState(() {
//         _locationStatusMessage = "Geocoding failed: $err";
//         _isGeocoding = false;
//         _selectedLocation = null;
//       });
//       _showSnackBar("Geocoding error: $err", isError: true);
//       debugPrint("Geocoding error: $e");
//     }
//   }

//   Future<void> _launchGoogleMaps() async {
//     final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
//     try {
//       if (await canLaunchUrl(googleMapsUri)) {
//         await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
//       } else {
//         _showSnackBar('Could not open Google Maps. Please open it manually.',
//             isError: true);
//       }
//     } catch (e) {
//       _showSnackBar('Error opening Google Maps: $e', isError: true);
//     }
//   }

//   Future<void> _pickAndUploadImage() async {
//     if (_isUploadingImage) return;
//     setState(() {
//       _imageErrorText = null;
//     });

//     try {
//       final XFile? pickedFile = await _picker.pickImage(
//           source: ImageSource.gallery,
//           imageQuality: 70,
//           maxWidth: 1024,
//           maxHeight: 1024);
//       if (pickedFile == null) return;

//       setState(() {
//         _selectedImageFile = pickedFile;
//         _isUploadingImage = true;
//         _imageUrlController.clear();
//       });
//       _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

//       final String? uploadedUrl =
//           await _imageUploadService.uploadImageToCloudinary(
//         pickedFile,
//         uploadPreset: _venueImageUploadPreset,
//         folder: 'venue_images',
//       );

//       if (!mounted) return;

//       if (uploadedUrl != null) {
//         setState(() {
//           _imageUrlController.text = uploadedUrl;
//           _selectedImageFile = null;
//           _isUploadingImage = false;
//         });
//         _showSnackBar('Image uploaded successfully!', isError: false);
//       } else {
//         throw Exception("Cloudinary returned a null URL.");
//       }
//     } catch (e) {
//       if (!mounted) return;
//       setState(() {
//         _isUploadingImage = false;
//       });
//       debugPrint("Image pick/upload error: $e");
//       _showSnackBar(
//           'Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}',
//           isError: true);
//     }
//   }

//   void _clearImage() {
//     setState(() {
//       _imageUrlController.clear();
//       _selectedImageFile = null;
//       _isUploadingImage = false;
//       _imageErrorText = null;
//     });
//     _showSnackBar('Image removed.', isError: false);
//   }

//   void _resetFormForNewEntry() {
//     if (!mounted) return;
//     _formKey.currentState?.reset();
//     _nameController.clear();
//     _descriptionController.clear();
//     _imageUrlController.clear();
//     _addressController.clear();
//     _areaController.clear();
//     _countryController.clear();
//     _weekdayStartController.clear();
//     _weekdayEndController.clear();
//     _saturdayStartController.clear();
//     _saturdayEndController.clear();
//     _sundayStartController.clear();
//     _sundayEndController.clear();
//     _phoneController.clear();
//     _websiteController.clear();
//     _emailController.clear();
//     _facilitiesController.clear();
//     _googleMapsUrlController.clear();
//     _sportInputController.clear();
//     setState(() {
//       _selectedSports = [];
//       _selectedCity = null;
//       _selectedImageFile = null;
//       _isActive = true;
//       _bookingEnabled = true;
//       _selectedLocation = null;
//       _locationStatusMessage = null;
//       _venueNameIsAvailable = true;
//       _venueNameErrorText = null;
//       _initialVenueNameLowercase = null; // Clear this for new entries
//       _autovalidateMode = AutovalidateMode.disabled;
//     });
//   }

//   Future<void> _submitForm() async {
//     setState(() {
//       _imageErrorText = null;
//       _sportsErrorText = null;
//     });

//     if (_isLoading || _isUploadingImage) {
//       _showSnackBar('Please wait for current operations to complete.',
//           isError: true);
//       return;
//     }
//     if (_isCheckingVenueName) {
//       _showSnackBar('Venue name check in progress. Please wait.', isError: true);
//       return;
//     }
//     if (!_venueNameIsAvailable && _nameController.text.trim().isNotEmpty) {
//       _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.',
//           isError: true);
//       setState(() {
//         _autovalidateMode = AutovalidateMode.onUserInteraction;
//       });
//       _formKey.currentState?.validate();
//       return;
//     }

//     bool isTextFormFieldsValid = _formKey.currentState!.validate();
//     bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
//     bool areSportsSelected = _selectedSports.isNotEmpty;

//     if (!isImagePresent) {
//       setState(() {
//         _imageErrorText = 'Venue image is required.';
//       });
//     }
//     if (!areSportsSelected) {
//       setState(() {
//         _sportsErrorText = 'At least one sport is required.';
//       });
//     }

//     if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
//       setState(() {
//         _isLoading = true;
//       });

//       if (!_isEditMode && _selectedLocation == null) {
//         _showSnackBar(
//             'Set venue location using "Use Current" or "Find Address".',
//             isError: true);
//         setState(() {
//           _isLoading = false;
//         });
//         return;
//       }

//       try {
//         List<String> sportTypes = List.from(_selectedSports);
//         if (sportTypes.isEmpty) sportTypes.add('General');

//         List<String> facilitiesList = _facilitiesController.text
//             .split(',')
//             .map((s) => s.trim())
//             .where((s) => s.isNotEmpty)
//             .toList();

//         Set<String> keywords = {};
//         void addWordsToKeywordsSet(String text) {
//           if (text.isNotEmpty) {
//             final words = text.toLowerCase().split(RegExp(r"[\s,.-]+"));
//             for (var word in words)
//               if (word.isNotEmpty && word.length > 1) keywords.add(word);
//           }
//         }

//         addWordsToKeywordsSet(_nameController.text.trim());
//         for (String sport in sportTypes) addWordsToKeywordsSet(sport);
//         addWordsToKeywordsSet(_addressController.text.trim());
//         addWordsToKeywordsSet(_areaController.text.trim());
//         addWordsToKeywordsSet(_selectedCity ?? '');
//         addWordsToKeywordsSet(_countryController.text.trim());
//         List<String> searchKeywordsList = keywords.toList();

//         Map<String, dynamic> venueData = {
//           'name': _nameController.text.trim(),
//           'name_lowercase': _nameController.text.trim().toLowerCase(),
//           'sportType': sportTypes,
//           'description': _descriptionController.text.trim(),
//           'address': _addressController.text.trim(),
//           'area': _areaController.text.trim(),
//           'city': _selectedCity,
//           'country': _countryController.text.trim(),
//           'imageUrl': _imageUrlController.text.trim(),
//           'isActive': _isActive,
//           'bookingEnabled': _bookingEnabled,
//           'slotDurationMinutes': 60,
//           'phoneNumber': _phoneController.text.trim(),
//           'website': _websiteController.text.trim(),
//           'email': _emailController.text.trim(),
//           'facilities': facilitiesList,
//           'searchKeywords': searchKeywordsList,
//           'googleMapsUrl': _googleMapsUrlController.text.trim(),
//           'operatingHours': {
//             'weekday': {
//               'start': _weekdayStartController.text.trim(),
//               'end': _weekdayEndController.text.trim()
//             },
//             'saturday': {
//               'start': _saturdayStartController.text.trim(),
//               'end': _saturdayEndController.text.trim()
//             },
//             'sunday': {
//               'start': _sundayStartController.text.trim(),
//               'end': _sundayEndController.text.trim()
//             },
//           },
//           if (_selectedLocation != null) 'location': _selectedLocation,
//           if (!_isEditMode) ...{
//             'creatorUid': _auth.currentUser?.uid,
//             'createdAt': FieldValue.serverTimestamp()
//           },
//         };

//         if (_isEditMode) {
//           venueData.remove('createdAt');
//           venueData.remove('creatorUid');
//           venueData['updatedAt'] = FieldValue.serverTimestamp();
//           // Use the state variable for the ID
//           await _firestoreService.updateVenue(_currentVenueIdToEdit!, venueData);
//           _showSnackBar('Venue updated successfully!', isError: false);
          
//           // MODIFICATION: After successful edit, reset the form to "create" mode
//           setState(() {
//             _currentVenueIdToEdit = null;
//           });
//           _resetFormForNewEntry();

//         } else {
//           await _firestoreService.addVenue(venueData);
//           _showSnackBar('Venue added successfully!', isError: false);
//           _resetFormForNewEntry();
//         }

//       } catch (e) {
//         debugPrint("Submit error: $e");
//         if (!mounted) return;
//         _showSnackBar(
//             'Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}',
//             isError: true);
//       } finally {
//         if (mounted)
//           setState(() {
//             _isLoading = false;
//           });
//       }
//     } else {
//       setState(() {
//         _autovalidateMode = AutovalidateMode.onUserInteraction;
//       });
//       String errorMessage = "Please fix errors in the form.";
//       if (!isTextFormFieldsValid) {
//         /* Errors shown by fields */
//       } else if (!isImagePresent && !areSportsSelected) {
//         errorMessage = "Please upload a venue image and add at least one sport.";
//       } else if (!isImagePresent) {
//         errorMessage = "Please upload a venue image.";
//       } else if (!areSportsSelected) {
//         errorMessage = "Please add at least one sport.";
//       }
//       _showSnackBar(errorMessage, isError: true);
//     }
//   }

//   void _showSnackBar(String message,
//       {required bool isError, int durationSeconds = 3}) {
//     if (!mounted) return;
//     ScaffoldMessenger.of(context).removeCurrentSnackBar();
//     ScaffoldMessenger.of(context).showSnackBar(SnackBar(
//       content: Text(message),
//       backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
//       behavior: SnackBarBehavior.floating,
//       margin: const EdgeInsets.all(10),
//       duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
//     ));
//   }

//   AppBar _buildAppBar(BuildContext context) {
//     final theme = Theme.of(context);
//     final bool isLoggedIn = _auth.currentUser != null;
//     final appBarBackgroundColor =
//         theme.appBarTheme.backgroundColor ?? theme.primaryColor;
//     final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ??
//         theme.appBarTheme.iconTheme?.color ??
//         (kIsWeb
//             ? (theme.brightness == Brightness.dark
//                 ? Colors.white70
//                 : Colors.black87)
//             : Colors.white);
//     final titleTextStyle = theme.appBarTheme.titleTextStyle?.copyWith(
//             color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ??
//         TextStyle(
//             color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white,
//             fontSize: 20,
//             fontWeight: FontWeight.w500);

//     return AppBar(
//       toolbarHeight: 70.0,
//       automaticallyImplyLeading: false,
//       backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
//       elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
//       iconTheme: theme.iconTheme.copyWith(
//           color: kIsWeb
//               ? (theme.brightness == Brightness.dark
//                   ? Colors.white70
//                   : Colors.black87)
//               : Colors.white),
//       actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
//       title: kIsWeb
//           ? Row(children: [
//               Text('MM Associates',
//                   style: TextStyle(
//                       fontSize: 20,
//                       fontWeight: FontWeight.bold,
//                       color: theme.textTheme.titleLarge?.color ??
//                           theme.primaryColor)),
//               const SizedBox(width: 24),
//               if (_isLoadingName && isLoggedIn)
//                 const Padding(
//                     padding: EdgeInsets.only(right: 16.0),
//                     child: SizedBox(
//                         width: 18,
//                         height: 18,
//                         child: CircularProgressIndicator(strokeWidth: 2)))
//               else if (_userName != null && isLoggedIn)
//                 Padding(
//                     padding: const EdgeInsets.only(right: 16.0),
//                     child: Text('Hi, ${_userName!.split(' ')[0]}!',
//                         style: TextStyle(
//                             fontSize: 16,
//                             fontWeight: FontWeight.w500,
//                             color: theme.textTheme.bodyLarge?.color),
//                         overflow: TextOverflow.ellipsis)),
//               const Spacer(),
//             ])
//           : Row(children: [
//               if (isLoggedIn)
//                 GestureDetector(
//                   onTap: () {
//                     if (!context.mounted) return;
//                     Navigator.push(
//                         context,
//                         MaterialPageRoute(
//                             builder: (context) => const ProfileScreen()));
//                   },
//                   child: Padding(
//                     padding: const EdgeInsets.only(right: 10.0),
//                     child: CircleAvatar(
//                         radius: 18,
//                         backgroundColor: Colors.white24,
//                         backgroundImage: _userProfilePicUrl != null &&
//                                 _userProfilePicUrl!.isNotEmpty
//                             ? NetworkImage(_userProfilePicUrl!)
//                             : null,
//                         child: _userProfilePicUrl == null ||
//                                 _userProfilePicUrl!.isEmpty
//                             ? Icon(Icons.person_outline,
//                                 size: 20, color: Colors.white.withOpacity(0.8))
//                             : null),
//                   ),
//                 ),
//               if (_isLoadingName && isLoggedIn)
//                 const SizedBox(
//                     width: 18,
//                     height: 18,
//                     child: CircularProgressIndicator(
//                         strokeWidth: 2,
//                         valueColor:
//                             AlwaysStoppedAnimation<Color>(Colors.white70)))
//               else if (_userName != null && isLoggedIn)
//                 Flexible(
//                   child: Text('Hi, ${_userName!.split(' ')[0]}!',
//                       style: titleTextStyle.copyWith(
//                           fontSize: 18, fontWeight: FontWeight.w500),
//                       overflow: TextOverflow.ellipsis),
//                 )
//               else
//                 Text('MM Associates', style: titleTextStyle),
//             ]),
//       centerTitle: false,
//       actions: [
//         if (isLoggedIn)
//           IconButton(
//             icon: Icon(Icons.person_outline_rounded, color: actionsIconColor),
//             tooltip: 'My Profile',
//             onPressed: () {
//               if (!context.mounted) return;
//               Navigator.push(
//                   context,
//                   MaterialPageRoute(
//                       builder: (context) => const ProfileScreen()));
//             },
//           ),
//         if (kIsWeb) const SizedBox(width: 8),
//       ],
//     );
//   }

//   @override
//   Widget build(BuildContext context) {
//     final bool anyOperationInProgress = _isLoading ||
//         _isFetchingLocation ||
//         _isGeocoding ||
//         _isUploadingImage ||
//         _isCheckingVenueName;
//     final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
//     final IconData submitBtnIcon =
//         _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;
//     final String pageTitle = _isEditMode ? 'Edit Venue' : 'Add New Venue';

//     Widget nameSuffixIcon;
//     if (_isCheckingVenueName) {
//       nameSuffixIcon = const SizedBox(
//           width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
//     } else if (_nameController.text.trim().isNotEmpty &&
//         (_isEditMode
//             ? _nameController.text.trim().toLowerCase() !=
//                 _initialVenueNameLowercase
//             : true)) {
//       nameSuffixIcon = _venueNameIsAvailable
//           ? const Icon(Icons.check_circle_outline, color: Colors.green)
//           : Icon(Icons.error_outline,
//               color: Theme.of(context).colorScheme.error);
//     } else {
//       nameSuffixIcon = const SizedBox.shrink();
//     }

//     return Scaffold(
//       appBar: _buildAppBar(context),
//       body: SingleChildScrollView(
//         child: GestureDetector(
//           onTap: () => FocusScope.of(context).unfocus(),
//           child: Padding(
//             padding: const EdgeInsets.all(16.0),
//             child: Form(
//               key: _formKey,
//               autovalidateMode: _autovalidateMode,
//               child: AbsorbPointer(
//                 absorbing: anyOperationInProgress,
//                 child: Opacity(
//                   opacity: anyOperationInProgress ? 0.7 : 1.0,
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.stretch,
//                     children: [
//                       Center(
//                         child: Padding(
//                           padding: const EdgeInsets.only(bottom: 24.0, top: 8.0),
//                           child: Text(
//                             pageTitle,
//                             style: Theme.of(context).textTheme.headlineSmall?.copyWith(
//                                   fontWeight: FontWeight.bold,
//                                 ),
//                             textAlign: TextAlign.center,
//                           ),
//                         ),
//                       ),
//                       _buildSectionHeader("Core Details"),
//                       TextFormField(
//                           controller: _nameController,
//                           decoration: InputDecoration(
//                             labelText: 'Venue Name*',
//                             prefixIcon: const Icon(Icons.sports_soccer),
//                             suffixIcon: Padding(
//                                 padding: const EdgeInsets.only(right: 12.0),
//                                 child: nameSuffixIcon),
//                             errorText: ((_nameController.text.isNotEmpty &&
//                                         !_isCheckingVenueName &&
//                                         !_isEditMode) ||
//                                     (_nameController.text.isNotEmpty &&
//                                         !_isCheckingVenueName &&
//                                         _isEditMode &&
//                                         _nameController.text
//                                                 .trim()
//                                                 .toLowerCase() !=
//                                             _initialVenueNameLowercase))
//                                 ? _venueNameErrorText
//                                 : null,
//                           ),
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) return 'Required';
//                             return null;
//                           },
//                           textCapitalization: TextCapitalization.words),
//                       const SizedBox(height: 15),
//                       _buildSportsInputSection(),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _descriptionController,
//                           decoration: const InputDecoration(
//                               labelText: 'Description',
//                               prefixIcon: Icon(Icons.description_outlined),
//                               alignLabelWithHint: true),
//                           maxLines: 3,
//                           textCapitalization: TextCapitalization.sentences),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Venue Image*"),
//                       _buildImageUploadSection(),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Address & Location*"),
//                       TextFormField(
//                           controller: _addressController,
//                           decoration: const InputDecoration(
//                               labelText: 'Address Line*',
//                               prefixIcon: Icon(Icons.location_on_outlined)),
//                           validator: (v) =>
//                               v!.trim().isEmpty ? 'Required' : null,
//                           textCapitalization: TextCapitalization.words),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _areaController,
//                           decoration: const InputDecoration(
//                               labelText: 'Area / Locality*',
//                               hintText: 'e.g., Borivali, Koramangala',
//                               prefixIcon: Icon(Icons.explore_outlined)),
//                           validator: (v) =>
//                               v!.trim().isEmpty ? 'Required' : null,
//                           textCapitalization: TextCapitalization.words),
//                       const SizedBox(height: 15),
//                       Row(children: [
//                         Expanded(
//                           child: FormField<String>(
//                             // Use a key to force rebuild when city changes externally
//                             key: ValueKey(_selectedCity),
//                             initialValue: _selectedCity,
//                             validator: (value) {
//                               if (value == null || value.isEmpty) {
//                                 return 'City is required';
//                               }
//                               return null;
//                             },
//                             builder: (FormFieldState<String> state) {
//                               void handleTap() async {
//                                 if (anyOperationInProgress) return;
//                                 final result = await Navigator.push<String?>(
//                                   context,
//                                   MaterialPageRoute(builder: (context) => CitySelectionScreen(currentSelectedCity: state.value)),
//                                 );
                                
//                                 if (result != null) {
//                                   state.didChange(result);
//                                   setState(() {
//                                     _selectedCity = result;
//                                   });
//                                 }
//                               }

//                               return InkWell(
//                                 onTap: handleTap,
//                                 child: InputDecorator(
//                                   decoration: InputDecoration(
//                                     labelText: 'City*',
//                                     prefixIcon: const Icon(Icons.location_city),
//                                     errorText: state.errorText,
//                                     border: const OutlineInputBorder(),
//                                     contentPadding: const EdgeInsets.fromLTRB(12.0, 16.0, 12.0, 16.0),
//                                   ),
//                                   child: Row(
//                                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                                     children: [
//                                       Expanded(
//                                         child: Text(
//                                           state.value ?? 'Tap to select city',
//                                           overflow: TextOverflow.ellipsis,
//                                           softWrap: false,
//                                           style: state.value == null
//                                             ? TextStyle(color: Theme.of(context).hintColor, fontSize: 16)
//                                             : Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.normal),
//                                         ),
//                                       ),
//                                       const Icon(Icons.arrow_drop_down, color: Colors.grey),
//                                     ],
//                                   ),
//                                 ),
//                               );
//                             },
//                           ),
//                         ),
//                         const SizedBox(width: 10),
//                         Expanded(
//                             child: TextFormField(
//                                 controller: _countryController,
//                                 decoration: const InputDecoration(
//                                     labelText: 'Country*',
//                                     prefixIcon: Icon(Icons.public)),
//                                 validator: (v) =>
//                                     v!.trim().isEmpty ? 'Required' : null,
//                                 textCapitalization: TextCapitalization.words))
//                       ]),
//                       const SizedBox(height: 15),
//                       Row(children: [
//                         Expanded(
//                             child: OutlinedButton.icon(
//                                 icon: _isFetchingLocation
//                                     ? _buildButtonSpinner()
//                                     : const Icon(Icons.my_location, size: 18),
//                                 label: const Text('Use Current'),
//                                 onPressed: anyOperationInProgress
//                                     ? null
//                                     : _fetchAndSetCurrentLocation,
//                                 style: OutlinedButton.styleFrom(
//                                     padding: const EdgeInsets.symmetric(
//                                         vertical: 12)))),
//                         const SizedBox(width: 10),
//                         Expanded(
//                             child: OutlinedButton.icon(
//                                 icon: _isGeocoding
//                                     ? _buildButtonSpinner()
//                                     : const Icon(Icons.location_searching,
//                                         size: 18),
//                                 label: const Text('Find Address'),
//                                 onPressed: anyOperationInProgress
//                                     ? null
//                                     : _geocodeAddress,
//                                 style: OutlinedButton.styleFrom(
//                                     padding: const EdgeInsets.symmetric(
//                                         vertical: 12))))
//                       ]),
//                       Padding(
//                           padding: const EdgeInsets.only(top: 10.0, bottom: 5.0),
//                           child: Text(
//                               _locationStatusMessage ??
//                                   (_isEditMode && _selectedLocation != null
//                                       ? 'Location previously set'
//                                       : 'Location not set* (Required for new venues)'),
//                               style: TextStyle(
//                                   fontSize: 13, color: Colors.grey[700]),
//                               textAlign: TextAlign.center)),
//                       _buildSectionHeader("Venue on Google Maps*"),
//                       Row(
//                         children: [
//                           Expanded(
//                             child: OutlinedButton.icon(
//                               icon: const Icon(Icons.map_outlined, size: 18),
//                               label: const Text('Open Google Maps'),
//                               onPressed:
//                                   anyOperationInProgress ? null : _launchGoogleMaps,
//                               style: OutlinedButton.styleFrom(
//                                 padding:
//                                     const EdgeInsets.symmetric(vertical: 12),
//                               ),
//                             ),
//                           ),
//                         ],
//                       ),
//                       const SizedBox(height: 10),
//                       TextFormField(
//                         controller: _googleMapsUrlController,
//                         decoration: const InputDecoration(
//                           labelText: 'Pasted Google Maps Link*',
//                           hintText: 'e.g., https://maps.app.goo.gl/xxxx',
//                           prefixIcon: Icon(Icons.link),
//                         ),
//                         validator: (value) {
//                           if (value == null || value.trim().isEmpty) {
//                             return 'Google Maps link is required.';
//                           }
//                           final trimmedValue = value.trim();
//                           final uri = Uri.tryParse(trimmedValue);
//                           if (uri == null || !uri.isAbsolute) {
//                             return 'Please enter a valid URL.';
//                           }
//                           final lowerTrimmedValue = trimmedValue.toLowerCase();
//                           if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
//                               !lowerTrimmedValue.contains('google.') &&
//                               !lowerTrimmedValue.contains('goo.gl/maps')) {
//                             return 'Please paste a valid Google Maps link (e.g., from Share button).';
//                           }
//                           return null;
//                         },
//                         keyboardType: TextInputType.url,
//                       ),
//                       Padding(
//                         padding: const EdgeInsets.only(
//                             top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
//                         child: Text(
//                           "1. Click 'Open Google Maps' above.\n"
//                           "2. In Google Maps, find the exact venue.\n"
//                           "3. Use the 'Share' option and 'Copy link'.\n"
//                           "4. Paste the link in the field above.",
//                           style: TextStyle(
//                               fontSize: 12.5,
//                               color: Theme.of(context).hintColor),
//                           textAlign: TextAlign.start,
//                         ),
//                       ),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Operating Hours*"),
//                       _buildOperatingHoursRow(
//                           "Weekday", _weekdayStartController, _weekdayEndController),
//                       const SizedBox(height: 12),
//                       _buildOperatingHoursRow("Saturday", _saturdayStartController,
//                           _saturdayEndController),
//                       const SizedBox(height: 12),
//                       _buildOperatingHoursRow(
//                           "Sunday", _sundayStartController, _sundayEndController),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Contact & Other Info"),
//                       TextFormField(
//                           controller: _phoneController,
//                           decoration: const InputDecoration(
//                               labelText: 'Phone*',
//                               prefixIcon: Icon(Icons.phone_outlined)),
//                           keyboardType: TextInputType.phone,
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) {
//                               return 'Phone number is required';
//                             }
//                             return null;
//                           }),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _emailController,
//                           decoration: const InputDecoration(
//                               labelText: 'Email*',
//                               prefixIcon: Icon(Icons.email_outlined)),
//                           keyboardType: TextInputType.emailAddress,
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) {
//                               return 'Email is required';
//                             }
//                             if (!RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
//                                 .hasMatch(v.trim()))
//                               return 'Please enter a valid email address';
//                             return null;
//                           }),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _websiteController,
//                           decoration: const InputDecoration(
//                               labelText: 'Website (Optional)',
//                               prefixIcon: Icon(Icons.language_outlined)),
//                           keyboardType: TextInputType.url,
//                           validator: (v) {
//                             if (v!.trim().isNotEmpty &&
//                                 (Uri.tryParse(v.trim())?.isAbsolute ?? false) ==
//                                     false) return 'Invalid URL';
//                             return null;
//                           }),
//                       const SizedBox(height: 15),
//                       TextFormField(
//                           controller: _facilitiesController,
//                           decoration: const InputDecoration(
//                               labelText: 'Facilities*',
//                               hintText: 'e.g., Parking, Washroom, Cafe (Comma-separated)',
//                               prefixIcon: Icon(Icons.local_offer_outlined)),
//                           textCapitalization: TextCapitalization.words,
//                           validator: (v) {
//                             if (v == null || v.trim().isEmpty) {
//                               return 'At least one facility is required';
//                             }
//                             return null;
//                           }),
//                       const SizedBox(height: 20),
//                       _buildSectionHeader("Status & Settings"),
//                       SwitchListTile(
//                           title: const Text('Booking Enabled?'),
//                           subtitle: const Text(
//                               'Can users make bookings for this venue?'),
//                           value: _bookingEnabled,
//                           onChanged: anyOperationInProgress
//                               ? null
//                               : (v) => setState(() => _bookingEnabled = v),
//                           secondary: Icon(
//                               _bookingEnabled
//                                   ? Icons.event_available
//                                   : Icons.event_busy,
//                               color: _bookingEnabled
//                                   ? Theme.of(context).primaryColor
//                                   : Colors.grey),
//                           contentPadding: EdgeInsets.zero,
//                           dense: true),
//                       const SizedBox(height: 10),
//                       SwitchListTile(
//                           title: const Text('Venue is Active?'),
//                           subtitle: const Text(
//                               'Inactive venues won\'t appear in searches.'),
//                           value: _isActive,
//                           onChanged: anyOperationInProgress
//                               ? null
//                               : (v) => setState(() => _isActive = v),
//                           secondary: Icon(
//                               _isActive
//                                   ? Icons.check_circle
//                                   : Icons.cancel_outlined,
//                               color: _isActive ? Colors.green : Colors.grey),
//                           contentPadding: EdgeInsets.zero,
//                           dense: true),
//                       const SizedBox(height: 25),
//                       Row(
//                         mainAxisAlignment: MainAxisAlignment.center,
//                         children: [
//                           SizedBox(
//                             width: 200,
//                             child: ElevatedButton.icon(
//                                 icon: (anyOperationInProgress &&
//                                         (_isLoading || _isUploadingImage))
//                                     ? _buildButtonSpinner(
//                                         size: 20, color: Colors.white)
//                                     : Icon(submitBtnIcon),
//                                 label: Text((anyOperationInProgress &&
//                                         (_isLoading || _isUploadingImage))
//                                     ? 'Saving...'
//                                     : submitBtnTxt),
//                                 onPressed:
//                                     anyOperationInProgress ? null : _submitForm,
//                                 style: ElevatedButton.styleFrom(
//                                     padding: const EdgeInsets.symmetric(
//                                         vertical: 15),
//                                     textStyle: const TextStyle(
//                                         fontSize: 16,
//                                         fontWeight: FontWeight.bold))),
//                           ),
//                         ],
//                       ),
//                       const SizedBox(height: 20),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ),
//         ),
//       ),
//     );
//   }

//   Widget _buildImageUploadSection() {
//     Widget imagePreview;
//     const double previewSize = 150.0;

//     if (_isUploadingImage && _selectedImageFile == null) {
//       imagePreview = const Center(child: CircularProgressIndicator());
//     } else if (_selectedImageFile != null) {
//       imagePreview = kIsWeb
//           ? Image.network(_selectedImageFile!.path,
//               width: previewSize, height: previewSize, fit: BoxFit.cover)
//           : Image.file(File(_selectedImageFile!.path),
//               width: previewSize, height: previewSize, fit: BoxFit.cover);
//     } else if (_imageUrlController.text.isNotEmpty) {
//       imagePreview = Image.network(
//         _imageUrlController.text,
//         width: previewSize,
//         height: previewSize,
//         fit: BoxFit.cover,
//         errorBuilder: (context, error, stackTrace) => const Center(
//             child: Icon(Icons.broken_image_outlined,
//                 size: 40, color: Colors.grey)),
//         loadingBuilder: (context, child, loadingProgress) {
//           if (loadingProgress == null) return child;
//           return Center(
//               child: CircularProgressIndicator(
//                   value: loadingProgress.expectedTotalBytes != null
//                       ? loadingProgress.cumulativeBytesLoaded /
//                           loadingProgress.expectedTotalBytes!
//                       : null));
//         },
//       );
//     } else {
//       imagePreview = Center(
//           child: Icon(Icons.add_a_photo_outlined,
//               size: 40,
//               color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
//     }

//     return Column(
//       crossAxisAlignment: CrossAxisAlignment.start,
//       children: [
//         Center(
//           child: Column(
//             children: [
//               GestureDetector(
//                 onTap: _isUploadingImage ? null : _pickAndUploadImage,
//                 child: Container(
//                   height: previewSize,
//                   width: previewSize,
//                   margin: const EdgeInsets.only(bottom: 10.0),
//                   decoration: BoxDecoration(
//                     color: Theme.of(context)
//                         .colorScheme
//                         .surfaceVariant
//                         .withOpacity(0.3),
//                     border: Border.all(
//                       color: _imageErrorText != null
//                           ? Theme.of(context).colorScheme.error
//                           : Theme.of(context)
//                               .colorScheme
//                               .outline
//                               .withOpacity(0.5),
//                       width: _imageErrorText != null ? 1.5 : 1.0,
//                     ),
//                     borderRadius: BorderRadius.circular(8.0),
//                   ),
//                   child: ClipRRect(
//                     borderRadius: BorderRadius.circular(7.0),
//                     child: Stack(
//                       fit: StackFit.expand,
//                       children: [
//                         imagePreview,
//                         if (_isUploadingImage)
//                           Container(
//                             color: Colors.black.withOpacity(0.4),
//                             child: const Center(
//                                 child: CircularProgressIndicator(
//                               color: Colors.white,
//                               strokeWidth: 3,
//                             )),
//                           ),
//                         if (!_isUploadingImage &&
//                             (_imageUrlController.text.isNotEmpty ||
//                                 _selectedImageFile != null))
//                           Positioned(
//                             top: 4,
//                             right: 4,
//                             child: Material(
//                               color: Colors.black54,
//                               shape: const CircleBorder(),
//                               child: InkWell(
//                                 customBorder: const CircleBorder(),
//                                 onTap: _isUploadingImage ? null : _clearImage,
//                                 child: const Padding(
//                                   padding: EdgeInsets.all(6.0),
//                                   child:
//                                       Icon(Icons.close, color: Colors.white, size: 18),
//                                 ),
//                               ),
//                             ),
//                           ),
//                       ],
//                     ),
//                   ),
//                 ),
//               ),
//               if (!_isUploadingImage)
//                 OutlinedButton.icon(
//                   icon: Icon(
//                       _imageUrlController.text.isNotEmpty ||
//                               _selectedImageFile != null
//                           ? Icons.edit_outlined
//                           : Icons.add_photo_alternate_outlined,
//                       size: 18),
//                   label: Text(_imageUrlController.text.isNotEmpty ||
//                           _selectedImageFile != null
//                       ? 'Change Image'
//                       : 'Select Image*'),
//                   onPressed: _pickAndUploadImage,
//                   style: OutlinedButton.styleFrom(
//                       padding: const EdgeInsets.symmetric(
//                           horizontal: 20, vertical: 10)),
//                 ),
//             ],
//           ),
//         ),
//         if (_isUploadingImage)
//           Center(
//             child: Padding(
//               padding: const EdgeInsets.only(top: 10.0),
//               child: Text("Uploading, please wait...",
//                   style: TextStyle(
//                       color: Theme.of(context).primaryColor,
//                       fontStyle: FontStyle.italic)),
//             ),
//           ),
//         if (_imageErrorText != null)
//           Padding(
//             padding: const EdgeInsets.only(top: 8.0),
//             child: Center(
//               child: Text(
//                 _imageErrorText!,
//                 style: TextStyle(
//                     color: Theme.of(context).colorScheme.error, fontSize: 12),
//                 textAlign: TextAlign.center,
//               ),
//             ),
//           ),
//         Visibility(
//           visible: false,
//           maintainState: true,
//           child: TextFormField(
//             controller: _imageUrlController,
//             decoration: const InputDecoration(labelText: 'Image URL'),
//           ),
//         ),
//       ],
//     );
//   }

//   Widget _buildSportsInputSection() {
//     return Column(
//       crossAxisAlignment: CrossAxisAlignment.start,
//       children: [
//         TextFormField(
//           controller: _sportInputController,
//           focusNode: _sportInputFocusNode,
//           textCapitalization: TextCapitalization.words,
//           decoration: InputDecoration(
//             hintText: 'e.g., Cricket, Football (Type & press Enter)*',
//             prefixIcon: const Icon(Icons.fitness_center),
//             border: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: _sportsErrorText != null
//                       ? Theme.of(context).colorScheme.error
//                       : Theme.of(context).colorScheme.outline),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             focusedBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: _sportsErrorText != null
//                       ? Theme.of(context).colorScheme.error
//                       : Theme.of(context).primaryColor,
//                   width: 1.5),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             enabledBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: _sportsErrorText != null
//                       ? Theme.of(context).colorScheme.error
//                       : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             errorBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: Theme.of(context).colorScheme.error, width: 1.5),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//             focusedErrorBorder: OutlineInputBorder(
//               borderSide: BorderSide(
//                   color: Theme.of(context).colorScheme.error, width: 1.5),
//               borderRadius: BorderRadius.circular(4.0),
//             ),
//           ),
//           onFieldSubmitted: (_) => _addSportFromInput(),
//         ),
//         if (_selectedSports.isNotEmpty)
//           Padding(
//             padding: const EdgeInsets.only(top: 8.0),
//             child: Container(
//               width: double.infinity,
//               padding: const EdgeInsets.symmetric(vertical: 4.0),
//               child: Wrap(
//                 spacing: 8.0,
//                 runSpacing: 4.0,
//                 children: _selectedSports.map((sport) {
//                   return InputChip(
//                     label: Text(sport),
//                     labelStyle: TextStyle(
//                         color: Theme.of(context).colorScheme.onSecondaryContainer),
//                     backgroundColor: Theme.of(context)
//                         .colorScheme
//                         .secondaryContainer
//                         .withOpacity(0.7),
//                     deleteIconColor: Theme.of(context)
//                         .colorScheme
//                         .onSecondaryContainer
//                         .withOpacity(0.7),
//                     onDeleted: () => _removeSport(sport),
//                     materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
//                     padding: const EdgeInsets.all(6),
//                   );
//                 }).toList(),
//               ),
//             ),
//           ),
//         if (_sportsErrorText != null)
//           Padding(
//             padding: const EdgeInsets.only(top: 8.0, left: 12.0),
//             child: Text(
//               _sportsErrorText!,
//               style: TextStyle(
//                   color: Theme.of(context).colorScheme.error, fontSize: 12),
//             ),
//           ),
//       ],
//     );
//   }

//   Widget _buildButtonSpinner({double size = 16, Color? color}) {
//     final resolvedColor = color ?? Theme.of(context).primaryColor;
//     return SizedBox(
//         width: size,
//         height: size,
//         child: CircularProgressIndicator(
//             strokeWidth: 2,
//             valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
//   }

//   Widget _buildSectionHeader(String title) {
//     return Padding(
//       padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
//       child: Text(title,
//           style: Theme.of(context)
//               .textTheme
//               .titleMedium
//               ?.copyWith(fontWeight: FontWeight.bold)),
//     );
//   }

//   Widget _buildOperatingHoursRow(String dayLabel,
//       TextEditingController startController, TextEditingController endController) {
//     const double dayLabelColumnWidth = 90.0;
//     const double gapBetweenLabelAndTimes = 8.0;
//     const double preferredTimeFieldWidth = 105.0;
//     const double horizontalPaddingForToText = 5.0;
//     String? timeValidator(String? value) {
//       if (value == null || value.trim().isEmpty) return 'Required';
//       if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
//           .hasMatch(value.trim())) return 'HH:MM';
//       return null;
//     }

//     Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
//       return InkWell(
//           onTap: () => _selectTime(context, controller),
//           child: AbsorbPointer(
//               child: TextFormField(
//                   controller: controller,
//                   textAlign: TextAlign.center,
//                   decoration: InputDecoration(
//                       labelText: labelText,
//                       contentPadding: const EdgeInsets.symmetric(
//                           horizontal: 4.0, vertical: 8.0),
//                       isDense: true,
//                       border: const OutlineInputBorder(),
//                       suffixIcon: const Icon(Icons.access_time, size: 18)),
//                   validator: timeValidator)));
//     }

//     Widget dayLabelWidget = SizedBox(
//         width: dayLabelColumnWidth,
//         child: Text(dayLabel,
//             style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500),
//             textAlign: TextAlign.start));
//     if (kIsWeb) {
//       Widget buildWebTimeInput(TextEditingController controller, String labelText) {
//         return SizedBox(
//             width: preferredTimeFieldWidth,
//             child: buildCoreTimeInput(controller, labelText));
//       }

//       final TextPainter textPainter = TextPainter(
//           text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)),
//           maxLines: 1,
//           textDirection: TextDirection.ltr)
//         ..layout(minWidth: 0, maxWidth: double.infinity);
//       final double widthOfToTextWithPadding =
//           textPainter.width + (2 * horizontalPaddingForToText);
//       final double requiredWidthForTimeControlsGroupWeb =
//           (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
//       return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
//         final double totalAvailableWidth = constraints.maxWidth;
//         final double singleLineRequiredWidthWeb =
//             dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
//         if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
//           return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
//             dayLabelWidget,
//             const SizedBox(width: gapBetweenLabelAndTimes),
//             Expanded(
//                 child: Row(children: [
//               Flexible(child: buildWebTimeInput(startController, 'Start')),
//               Padding(
//                   padding: const EdgeInsets.symmetric(
//                       horizontal: horizontalPaddingForToText),
//                   child: Text("to", style: const TextStyle(fontSize: 14))),
//               Flexible(child: buildWebTimeInput(endController, 'End')),
//               const Spacer()
//             ]))
//           ]);
//         } else {
//           return Column(
//               crossAxisAlignment: CrossAxisAlignment.start,
//               children: [
//                 dayLabelWidget,
//                 const SizedBox(height: 8.0),
//                 Padding(
//                     padding: const EdgeInsets.only(left: 0.0),
//                     child:
//                         Row(mainAxisSize: MainAxisSize.min, children: [
//                       buildWebTimeInput(startController, 'Start'),
//                       Padding(
//                           padding: const EdgeInsets.symmetric(
//                               horizontal: horizontalPaddingForToText),
//                           child: Text("to", style: const TextStyle(fontSize: 14))),
//                       buildWebTimeInput(endController, 'End')
//                     ]))
//               ]);
//         }
//       });
//     } else {
//       return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
//         dayLabelWidget,
//         const SizedBox(width: gapBetweenLabelAndTimes),
//         Expanded(child: buildCoreTimeInput(startController, 'Start')),
//         Padding(
//             padding:
//                 const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText),
//             child: Text("to", style: const TextStyle(fontSize: 14))),
//         Expanded(child: buildCoreTimeInput(endController, 'End'))
//       ]);
//     }
//   }
// }


//---venue name check based on location

import 'dart:async';
import 'dart:io'; // For File, used for non-web image preview

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:image_picker/image_picker.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:mm_associates/features/profile/screens/profile_screen.dart';
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:url_launcher/url_launcher.dart';

import '../../../../core/services/geocoding_service.dart';
import '../../../../core/services/image_upload_service.dart';
import '../../../../core/services/location_service.dart';
import '../../../../features/data/services/firestore_service.dart';

// Assuming 'CitySelectionScreen' is defined in this path.
// The user has requested not to include its code here.
// Please ensure this import path is correct for your project structure.
import 'city_selection_screen.dart';


class AddVenueFormScreen extends StatefulWidget {
  final String? venueIdToEdit;
  final Map<String, dynamic>? initialData;

  /// True if an admin is landing here directly as their "home" page.
  /// This will add a button to navigate to the user-facing app view.
  final bool isDirectAdminAccess;

  const AddVenueFormScreen({
    super.key,
    this.venueIdToEdit,
    this.initialData,
    this.isDirectAdminAccess = false,
  });

  @override
  State<AddVenueFormScreen> createState() => _AddVenueFormScreenState();
}

class _AddVenueFormScreenState extends State<AddVenueFormScreen> {
  final _formKey = GlobalKey<FormState>();
  final FirestoreService _firestoreService = FirestoreService();
  final LocationService _locationService = LocationService();
  final LocationIQService _geocodingService = LocationIQService();
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final AuthService _authService = AuthService();
  final UserService _userService = UserService();

  final ImageUploadService _imageUploadService = ImageUploadService();
  final ImagePicker _picker = ImagePicker();

  static const String _venueImageUploadPreset = 'mm_associates_venue_pics';

  // Controllers
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _imageUrlController = TextEditingController();
  final _addressController = TextEditingController();
  final _areaController = TextEditingController();
  final _countryController = TextEditingController();
  final _weekdayStartController = TextEditingController();
  final _weekdayEndController = TextEditingController();
  final _saturdayStartController = TextEditingController();
  final _saturdayEndController = TextEditingController();
  final _sundayStartController = TextEditingController();
  final _sundayEndController = TextEditingController();
  final _phoneController = TextEditingController();
  final _websiteController = TextEditingController();
  final _emailController = TextEditingController();
  final _facilitiesController = TextEditingController();
  final _googleMapsUrlController = TextEditingController();

  String? _selectedCity;

  List<String> _selectedSports = [];
  final _sportInputController = TextEditingController();
  final _sportInputFocusNode = FocusNode();
  String? _sportsErrorText;

  bool _isActive = true;
  bool _bookingEnabled = true;
  bool _isLoading = false;
  bool _isFetchingLocation = false;
  bool _isGeocoding = false;
  GeoPoint? _selectedLocation;
  String? _locationStatusMessage;

  // Uniqueness check state
  Timer? _venueNameDebouncer;
  bool _isCheckingVenueName = false;
  bool _venueNameIsAvailable = true;
  String? _venueNameErrorText;
  bool _hasRunUniquenessCheck = false;

  // Initial values for edit mode comparison
  String? _initialVenueNameLowercase;
  String? _initialCity;
  String? _initialArea;

  XFile? _selectedImageFile;
  bool _isUploadingImage = false;
  String? _imageErrorText;

  String? _userName;
  String? _userProfilePicUrl;
  bool _isLoadingName = true;
  
  String? _currentVenueIdToEdit;
  bool get _isEditMode => _currentVenueIdToEdit != null;
  AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

  @override
  void initState() {
    super.initState();
    _currentVenueIdToEdit = widget.venueIdToEdit;
    
    if (_isEditMode && widget.initialData != null) {
      _prefillFormData(widget.initialData!);
      _initialVenueNameLowercase = widget.initialData!['name']?.toString().trim().toLowerCase();
      _initialCity = widget.initialData!['city'] as String?;
      _initialArea = widget.initialData!['area'] as String?;
    }
    
    // Listen to changes on all identifying fields to re-trigger the uniqueness check
    _nameController.addListener(_onIdentityFieldsChanged);
    _areaController.addListener(_onIdentityFieldsChanged);

    _fetchUserNameAndPic();
  }

  void _prefillFormData(Map<String, dynamic> data) {
    _nameController.text = data['name'] ?? '';
    _selectedSports = (data['sportType'] as List<dynamic>?)
            ?.map((s) => s.toString().trim())
            .where((s) => s.isNotEmpty)
            .toList() ??
        [];
    _descriptionController.text = data['description'] ?? '';
    _addressController.text = data['address'] ?? '';
    _areaController.text = data['area'] ?? '';
    _selectedCity = data['city'] as String?;
    _countryController.text = data['country'] ?? '';
    _imageUrlController.text = data['imageUrl'] ?? '';
    _isActive = data['isActive'] ?? true;
    _bookingEnabled = data['bookingEnabled'] ?? true;
    _phoneController.text = data['phoneNumber'] ?? '';
    _websiteController.text = data['website'] ?? '';
    _emailController.text = data['email'] ?? '';
    _facilitiesController.text =
        (data['facilities'] as List<dynamic>?)?.join(', ') ?? '';
    _googleMapsUrlController.text = data['googleMapsUrl'] ?? '';

    final GeoPoint? initialLocation = data['location'] as GeoPoint?;
    if (initialLocation != null) {
      _selectedLocation = initialLocation;
      _locationStatusMessage =
          'Current Location: Lat: ${initialLocation.latitude.toStringAsFixed(5)}, Lng: ${initialLocation.longitude.toStringAsFixed(5)}';
    }

    if (data['operatingHours'] is Map) {
      final hoursMap = data['operatingHours'] as Map<String, dynamic>;
      _weekdayStartController.text = hoursMap['weekday']?['start'] ?? '';
      _weekdayEndController.text = hoursMap['weekday']?['end'] ?? '';
      _saturdayStartController.text = hoursMap['saturday']?['start'] ?? '';
      _saturdayEndController.text = hoursMap['saturday']?['end'] ?? '';
      _sundayStartController.text = hoursMap['sunday']?['start'] ?? '';
      _sundayEndController.text = hoursMap['sunday']?['end'] ?? '';
    }
  }

  @override
  void dispose() {
    _nameController.removeListener(_onIdentityFieldsChanged);
    _areaController.removeListener(_onIdentityFieldsChanged);
    _nameController.dispose();
    _areaController.dispose();
    _venueNameDebouncer?.cancel();
    _sportInputController.dispose();
    _sportInputFocusNode.dispose();
    _descriptionController.dispose();
    _imageUrlController.dispose();
    _addressController.dispose();
    _countryController.dispose();
    _weekdayStartController.dispose();
    _weekdayEndController.dispose();
    _saturdayStartController.dispose();
    _saturdayEndController.dispose();
    _sundayStartController.dispose();
    _sundayEndController.dispose();
    _phoneController.dispose();
    _websiteController.dispose();
    _emailController.dispose();
    _facilitiesController.dispose();
    _googleMapsUrlController.dispose();
    super.dispose();
  }

  Future<void> _fetchUserNameAndPic() async {
    if (!mounted) return;
    setState(() => _isLoadingName = true);
    final currentUser = _auth.currentUser;
    if (currentUser == null) {
      if (mounted)
        setState(() {
          _userName = 'Guest';
          _userProfilePicUrl = null;
          _isLoadingName = false;
        });
      return;
    }
    try {
      final userData = await _userService.getUserProfileData();
      if (!mounted) return;
      final fetchedName = userData?['name'] as String? ??
          currentUser.displayName ??
          currentUser.email?.split('@')[0] ??
          'User';
      final fetchedPicUrl = userData?['profilePictureUrl'] as String?;
      setState(() {
        _userName = fetchedName;
        _userProfilePicUrl = fetchedPicUrl;
      });
    } catch (e) {
      if (!mounted) return;
      final fallbackName = currentUser.displayName ??
          currentUser.email?.split('@')[0] ??
          'User';
      setState(() {
        _userName = fallbackName;
        _userProfilePicUrl = null;
      });
      debugPrint("Error fetching user name: $e");
    } finally {
      if (mounted) setState(() => _isLoadingName = false);
    }
  }

  void _addSportFromInput() {
    final sportName = _sportInputController.text.trim();
    if (sportName.isNotEmpty) {
      final capitalizedSportName = sportName
          .split(' ')
          .map((word) => word.isNotEmpty
              ? '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}'
              : '')
          .join(' ');

      if (!_selectedSports
          .any((s) => s.toLowerCase() == capitalizedSportName.toLowerCase())) {
        setState(() {
          _selectedSports.add(capitalizedSportName);
          _sportsErrorText = null;
        });
      }
      _sportInputController.clear();
      _sportInputFocusNode.requestFocus();
    }
  }

  void _removeSport(String sportName) {
    setState(() {
      _selectedSports.remove(sportName);
      if (_selectedSports.isEmpty &&
          _autovalidateMode == AutovalidateMode.onUserInteraction) {
        _sportsErrorText = 'At least one sport is required.';
      }
    });
  }

  void _onIdentityFieldsChanged() {
    if (_venueNameDebouncer?.isActive ?? false) _venueNameDebouncer!.cancel();
    _venueNameDebouncer = Timer(const Duration(milliseconds: 750), () {
      final name = _nameController.text.trim();
      final area = _areaController.text.trim();
      final city = _selectedCity;

      // Don't run the check unless all three identifying fields are filled.
      if (name.isEmpty || area.isEmpty || city == null || city.isEmpty) {
        setState(() {
          _isCheckingVenueName = false;
          _hasRunUniquenessCheck = false;
          _venueNameIsAvailable = true; // No known conflict
          _venueNameErrorText = null;
        });
        return;
      }

      _checkVenueNameUniqueness(name, city, area);
    });
  }

  Future<void> _checkVenueNameUniqueness(String name, String city, String area) async {
    if (!mounted) return;
    setState(() {
      _isCheckingVenueName = true;
      _hasRunUniquenessCheck = false;
      _venueNameIsAvailable = true;
      _venueNameErrorText = null;
    });

    final nameLower = name.toLowerCase();
    
    // In edit mode, if the identifying combination is the same as the initial one, it's valid.
    if (_isEditMode && nameLower == _initialVenueNameLowercase && city == _initialCity && area == _initialArea) {
      setState(() {
        _isCheckingVenueName = false;
        _hasRunUniquenessCheck = true; // A check was "made" and it passed
        _venueNameIsAvailable = true;
        _venueNameErrorText = null;
      });
      return;
    }
    
    try {
      final bool exists = await _firestoreService.checkVenueNameExists(
        nameLower, city, area.toLowerCase(), _currentVenueIdToEdit
      );
      if (!mounted) return;
      setState(() {
        _venueNameIsAvailable = !exists;
        _venueNameErrorText = exists ? 'Name already exists in this City and Area.' : null;
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _venueNameIsAvailable = false;
        _venueNameErrorText = 'Error checking name. Please try again.';
      });
      debugPrint("Error checking venue name: $e");
    } finally {
      if (mounted) {
        setState(() {
          _isCheckingVenueName = false;
          _hasRunUniquenessCheck = true; // Mark that a check has completed.
        });
      }
    }
  }

  Future<void> _selectTime(
      BuildContext context, TextEditingController controller) async {
    TimeOfDay? initialTime;
    if (controller.text.isNotEmpty) {
      try {
        final parts = controller.text.split(':');
        if (parts.length == 2)
          initialTime =
              TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
      } catch (e) {
        /* ignore */
      }
    }
    final TimeOfDay? picked =
        await showTimePicker(context: context, initialTime: initialTime ?? TimeOfDay.now());
    if (picked != null) {
      setState(() {
        controller.text =
            "${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}";
      });
      if (_autovalidateMode == AutovalidateMode.onUserInteraction)
        _formKey.currentState?.validate();
    }
  }

  Future<void> _fetchAndSetCurrentLocation() async {
    if (!mounted ||
        _isLoading ||
        _isFetchingLocation ||
        _isGeocoding ||
        _isUploadingImage) return;
    setState(() {
      _isFetchingLocation = true;
      _locationStatusMessage = 'Fetching...';
      _selectedLocation = null;
    });
    final Position? p = await _locationService.getCurrentLocation();
    if (!mounted) return;
    if (p != null) {
      setState(() {
        _selectedLocation = GeoPoint(p.latitude, p.longitude);
        _locationStatusMessage =
            'Selected: Lat: ${p.latitude.toStringAsFixed(5)}, Lng: ${p.longitude.toStringAsFixed(5)}';
        _isFetchingLocation = false;
      });
      _showSnackBar('Location fetched!', isError: false);
    } else {
      setState(() {
        _locationStatusMessage = 'Could not get location.';
        _isFetchingLocation = false;
        _selectedLocation = null;
      });
      _showSnackBar('Could not fetch location. Check permissions/service.',
          isError: true);
    }
  }

  Future<void> _geocodeAddress() async {
    if (!mounted ||
        _isLoading ||
        _isFetchingLocation ||
        _isGeocoding ||
        _isUploadingImage) return;
    FocusScope.of(context).unfocus();
    final fullAddressQuery = [
      _addressController.text.trim(),
      _areaController.text.trim(),
      _selectedCity ?? '',
      _countryController.text.trim()
    ].where((s) => s.isNotEmpty).join(', ');
    if (fullAddressQuery.length < 5) {
      _showSnackBar('Enter Address, Area, City, and Country.', isError: true);
      return;
    }
    debugPrint("Geocoding: '$fullAddressQuery'");
    setState(() {
      _isGeocoding = true;
      _locationStatusMessage = 'Finding for "$fullAddressQuery"...';
      _selectedLocation = null;
    });
    try {
      final GeoPoint? r =
          await _geocodingService.getCoordsFromAddress(fullAddressQuery);
      if (!mounted) return;
      if (r != null) {
        setState(() {
          _selectedLocation = r;
          _locationStatusMessage =
              'Selected: Lat: ${r.latitude.toStringAsFixed(5)}, Lng: ${r.longitude.toStringAsFixed(5)}';
          _isGeocoding = false;
        });
        _showSnackBar('Location found!', isError: false);
      } else {
        setState(() {
          _locationStatusMessage = 'Could not find location.';
          _isGeocoding = false;
          _selectedLocation = null;
        });
        _showSnackBar('Address lookup failed.', isError: true);
      }
    } catch (e) {
      if (!mounted) return;
      String err = e.toString().replaceFirst('Exception: ', '');
      setState(() {
        _locationStatusMessage = "Geocoding failed: $err";
        _isGeocoding = false;
        _selectedLocation = null;
      });
      _showSnackBar("Geocoding error: $err", isError: true);
      debugPrint("Geocoding error: $e");
    }
  }

  Future<void> _launchGoogleMaps() async {
    final Uri googleMapsUri = Uri.parse('https://maps.google.com/');
    try {
      if (await canLaunchUrl(googleMapsUri)) {
        await launchUrl(googleMapsUri, mode: LaunchMode.externalApplication);
      } else {
        _showSnackBar('Could not open Google Maps. Please open it manually.',
            isError: true);
      }
    } catch (e) {
      _showSnackBar('Error opening Google Maps: $e', isError: true);
    }
  }

  Future<void> _pickAndUploadImage() async {
    if (_isUploadingImage) return;
    setState(() {
      _imageErrorText = null;
    });

    try {
      final XFile? pickedFile = await _picker.pickImage(
          source: ImageSource.gallery,
          imageQuality: 70,
          maxWidth: 1024,
          maxHeight: 1024);
      if (pickedFile == null) return;

      setState(() {
        _selectedImageFile = pickedFile;
        _isUploadingImage = true;
        _imageUrlController.clear();
      });
      _showSnackBar('Uploading image...', isError: false, durationSeconds: 10);

      final String? uploadedUrl =
          await _imageUploadService.uploadImageToCloudinary(
        pickedFile,
        uploadPreset: _venueImageUploadPreset,
        folder: 'venue_images',
      );

      if (!mounted) return;

      if (uploadedUrl != null) {
        setState(() {
          _imageUrlController.text = uploadedUrl;
          _selectedImageFile = null;
          _isUploadingImage = false;
        });
        _showSnackBar('Image uploaded successfully!', isError: false);
      } else {
        throw Exception("Cloudinary returned a null URL.");
      }
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _isUploadingImage = false;
      });
      debugPrint("Image pick/upload error: $e");
      _showSnackBar(
          'Image upload failed: ${e.toString().replaceFirst("Exception: ", "")}',
          isError: true);
    }
  }

  void _clearImage() {
    setState(() {
      _imageUrlController.clear();
      _selectedImageFile = null;
      _isUploadingImage = false;
      _imageErrorText = null;
    });
    _showSnackBar('Image removed.', isError: false);
  }

  void _resetFormForNewEntry() {
    if (!mounted) return;
    _formKey.currentState?.reset();
    _nameController.clear();
    _descriptionController.clear();
    _imageUrlController.clear();
    _addressController.clear();
    _areaController.clear();
    _countryController.clear();
    _weekdayStartController.clear();
    _weekdayEndController.clear();
    _saturdayStartController.clear();
    _saturdayEndController.clear();
    _sundayStartController.clear();
    _sundayEndController.clear();
    _phoneController.clear();
    _websiteController.clear();
    _emailController.clear();
    _facilitiesController.clear();
    _googleMapsUrlController.clear();
    _sportInputController.clear();
    setState(() {
      _selectedSports = [];
      _selectedCity = null;
      _selectedImageFile = null;
      _isActive = true;
      _bookingEnabled = true;
      _selectedLocation = null;
      _locationStatusMessage = null;
      _venueNameIsAvailable = true;
      _venueNameErrorText = null;
      _hasRunUniquenessCheck = false;
      _initialVenueNameLowercase = null; 
      _initialCity = null;
      _initialArea = null;
      _autovalidateMode = AutovalidateMode.disabled;
    });
  }

  Future<void> _submitForm() async {
    setState(() {
      _imageErrorText = null;
      _sportsErrorText = null;
    });

    if (_isLoading || _isUploadingImage) {
      _showSnackBar('Please wait for current operations to complete.',
          isError: true);
      return;
    }
    if (_isCheckingVenueName) {
      _showSnackBar('Venue name check in progress. Please wait.', isError: true);
      return;
    }
    // Final check for name availability before submitting
    if (_hasRunUniquenessCheck && !_venueNameIsAvailable) {
        _showSnackBar(_venueNameErrorText ?? 'Venue name is not available.', isError: true);
        setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
        _formKey.currentState?.validate();
        return;
    }


    bool isTextFormFieldsValid = _formKey.currentState!.validate();
    bool isImagePresent = _imageUrlController.text.trim().isNotEmpty;
    bool areSportsSelected = _selectedSports.isNotEmpty;

    if (!isImagePresent) {
      setState(() {
        _imageErrorText = 'Venue image is required.';
      });
    }
    if (!areSportsSelected) {
      setState(() {
        _sportsErrorText = 'At least one sport is required.';
      });
    }

    if (isTextFormFieldsValid && isImagePresent && areSportsSelected) {
      setState(() {
        _isLoading = true;
      });

      if (!_isEditMode && _selectedLocation == null) {
        _showSnackBar(
            'Set venue location using "Use Current" or "Find Address".',
            isError: true);
        setState(() {
          _isLoading = false;
        });
        return;
      }

      try {
        List<String> sportTypes = List.from(_selectedSports);
        if (sportTypes.isEmpty) sportTypes.add('General');

        List<String> facilitiesList = _facilitiesController.text
            .split(',')
            .map((s) => s.trim())
            .where((s) => s.isNotEmpty)
            .toList();

        Set<String> keywords = {};
        void addWordsToKeywordsSet(String text) {
          if (text.isNotEmpty) {
            final words = text.toLowerCase().split(RegExp(r"[\s,.-]+"));
            for (var word in words)
              if (word.isNotEmpty && word.length > 1) keywords.add(word);
          }
        }

        addWordsToKeywordsSet(_nameController.text.trim());
        for (String sport in sportTypes) addWordsToKeywordsSet(sport);
        addWordsToKeywordsSet(_addressController.text.trim());
        addWordsToKeywordsSet(_areaController.text.trim());
        addWordsToKeywordsSet(_selectedCity ?? '');
        addWordsToKeywordsSet(_countryController.text.trim());
        List<String> searchKeywordsList = keywords.toList();

        Map<String, dynamic> venueData = {
          'name': _nameController.text.trim(),
          'name_lowercase': _nameController.text.trim().toLowerCase(),
          'sportType': sportTypes,
          'description': _descriptionController.text.trim(),
          'address': _addressController.text.trim(),
          'area': _areaController.text.trim(),
          'city': _selectedCity,
          'country': _countryController.text.trim(),
          'imageUrl': _imageUrlController.text.trim(),
          'isActive': _isActive,
          'bookingEnabled': _bookingEnabled,
          'slotDurationMinutes': 60,
          'phoneNumber': _phoneController.text.trim(),
          'website': _websiteController.text.trim(),
          'email': _emailController.text.trim(),
          'facilities': facilitiesList,
          'searchKeywords': searchKeywordsList,
          'googleMapsUrl': _googleMapsUrlController.text.trim(),
          'operatingHours': {
            'weekday': {
              'start': _weekdayStartController.text.trim(),
              'end': _weekdayEndController.text.trim()
            },
            'saturday': {
              'start': _saturdayStartController.text.trim(),
              'end': _saturdayEndController.text.trim()
            },
            'sunday': {
              'start': _sundayStartController.text.trim(),
              'end': _sundayEndController.text.trim()
            },
          },
          if (_selectedLocation != null) 'location': _selectedLocation,
          if (!_isEditMode) ...{
            'creatorUid': _auth.currentUser?.uid,
            'createdAt': FieldValue.serverTimestamp()
          },
        };

        if (_isEditMode) {
          venueData.remove('createdAt');
          venueData.remove('creatorUid');
          venueData['updatedAt'] = FieldValue.serverTimestamp();
          // Use the state variable for the ID
          await _firestoreService.updateVenue(_currentVenueIdToEdit!, venueData);
          _showSnackBar('Venue updated successfully!', isError: false);
          
          // MODIFICATION: After successful edit, reset the form to "create" mode
          setState(() {
            _currentVenueIdToEdit = null;
          });
          _resetFormForNewEntry();

        } else {
          await _firestoreService.addVenue(venueData);
          _showSnackBar('Venue added successfully!', isError: false);
          _resetFormForNewEntry();
        }

      } catch (e) {
        debugPrint("Submit error: $e");
        if (!mounted) return;
        _showSnackBar(
            'Failed to save venue: ${e.toString().replaceFirst("Exception: ", "")}',
            isError: true);
      } finally {
        if (mounted)
          setState(() {
            _isLoading = false;
          });
      }
    } else {
      setState(() {
        _autovalidateMode = AutovalidateMode.onUserInteraction;
      });
      String errorMessage = "Please fix errors in the form.";
      if (!isTextFormFieldsValid) {
        /* Errors shown by fields */
      } else if (!isImagePresent && !areSportsSelected) {
        errorMessage = "Please upload a venue image and add at least one sport.";
      } else if (!isImagePresent) {
        errorMessage = "Please upload a venue image.";
      } else if (!areSportsSelected) {
        errorMessage = "Please add at least one sport.";
      }
      _showSnackBar(errorMessage, isError: true);
    }
  }

  void _showSnackBar(String message,
      {required bool isError, int durationSeconds = 3}) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text(message),
      backgroundColor: isError ? Theme.of(context).colorScheme.error : Colors.green,
      behavior: SnackBarBehavior.floating,
      margin: const EdgeInsets.all(10),
      duration: Duration(seconds: message == 'Uploading image...' ? 10 : durationSeconds),
    ));
  }

  AppBar _buildAppBar(BuildContext context) {
    final theme = Theme.of(context);
    final bool isLoggedIn = _auth.currentUser != null;
    final appBarBackgroundColor =
        theme.appBarTheme.backgroundColor ?? theme.primaryColor;
    final actionsIconColor = theme.appBarTheme.actionsIconTheme?.color ??
        theme.appBarTheme.iconTheme?.color ??
        (kIsWeb
            ? (theme.brightness == Brightness.dark
                ? Colors.white70
                : Colors.black87)
            : Colors.white);
    final titleTextStyle = theme.appBarTheme.titleTextStyle?.copyWith(
            color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white) ??
        TextStyle(
            color: kIsWeb ? theme.textTheme.titleLarge?.color : Colors.white,
            fontSize: 20,
            fontWeight: FontWeight.w500);

    return AppBar(
      toolbarHeight: 70.0,
      automaticallyImplyLeading: false,
      backgroundColor: kIsWeb ? theme.canvasColor : appBarBackgroundColor,
      elevation: kIsWeb ? 1.0 : theme.appBarTheme.elevation ?? 4.0,
      iconTheme: theme.iconTheme.copyWith(
          color: kIsWeb
              ? (theme.brightness == Brightness.dark
                  ? Colors.white70
                  : Colors.black87)
              : Colors.white),
      actionsIconTheme: theme.iconTheme.copyWith(color: actionsIconColor),
      title: kIsWeb
          ? Row(children: [
              Text('MM Associates',
                  style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                      color: theme.textTheme.titleLarge?.color ??
                          theme.primaryColor)),
              const SizedBox(width: 24),
              if (_isLoadingName && isLoggedIn)
                const Padding(
                    padding: EdgeInsets.only(right: 16.0),
                    child: SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(strokeWidth: 2)))
              else if (_userName != null && isLoggedIn)
                Padding(
                    padding: const EdgeInsets.only(right: 16.0),
                    child: Text('Hi, ${_userName!.split(' ')[0]}!',
                        style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            color: theme.textTheme.bodyLarge?.color),
                        overflow: TextOverflow.ellipsis)),
              const Spacer(),
            ])
          : Row(children: [
              if (isLoggedIn)
                GestureDetector(
                  onTap: () {
                    if (!context.mounted) return;
                    Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) => const ProfileScreen()));
                  },
                  child: Padding(
                    padding: const EdgeInsets.only(right: 10.0),
                    child: CircleAvatar(
                        radius: 18,
                        backgroundColor: Colors.white24,
                        backgroundImage: _userProfilePicUrl != null &&
                                _userProfilePicUrl!.isNotEmpty
                            ? NetworkImage(_userProfilePicUrl!)
                            : null,
                        child: _userProfilePicUrl == null ||
                                _userProfilePicUrl!.isEmpty
                            ? Icon(Icons.person_outline,
                                size: 20, color: Colors.white.withOpacity(0.8))
                            : null),
                  ),
                ),
              if (_isLoadingName && isLoggedIn)
                const SizedBox(
                    width: 18,
                    height: 18,
                    child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor:
                            AlwaysStoppedAnimation<Color>(Colors.white70)))
              else if (_userName != null && isLoggedIn)
                Flexible(
                  child: Text('Hi, ${_userName!.split(' ')[0]}!',
                      style: titleTextStyle.copyWith(
                          fontSize: 18, fontWeight: FontWeight.w500),
                      overflow: TextOverflow.ellipsis),
                )
              else
                Text('MM Associates', style: titleTextStyle),
            ]),
      centerTitle: false,
      actions: [
        if (isLoggedIn)
          IconButton(
            icon: Icon(Icons.person_outline_rounded, color: actionsIconColor),
            tooltip: 'My Profile',
            onPressed: () {
              if (!context.mounted) return;
              Navigator.push(
                  context,
                  MaterialPageRoute(
                      builder: (context) => const ProfileScreen()));
            },
          ),
        if (kIsWeb) const SizedBox(width: 8),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final bool anyOperationInProgress = _isLoading ||
        _isFetchingLocation ||
        _isGeocoding ||
        _isUploadingImage ||
        _isCheckingVenueName;
    final String submitBtnTxt = _isEditMode ? "Update Venue" : "Save Venue";
    final IconData submitBtnIcon =
        _isEditMode ? Icons.edit_outlined : Icons.save_alt_outlined;
    final String pageTitle = _isEditMode ? 'Edit Venue' : 'Add New Venue';

    Widget nameSuffixIcon;
    if (_isCheckingVenueName) {
      nameSuffixIcon = const SizedBox(
          width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2));
    } else if (_hasRunUniquenessCheck) {
      nameSuffixIcon = _venueNameIsAvailable
          ? const Icon(Icons.check_circle_outline, color: Colors.green)
          : Icon(Icons.error_outline,
              color: Theme.of(context).colorScheme.error);
    } else {
      nameSuffixIcon = const SizedBox.shrink();
    }

    return Scaffold(
      appBar: _buildAppBar(context),
      body: SingleChildScrollView(
        child: GestureDetector(
          onTap: () => FocusScope.of(context).unfocus(),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Form(
              key: _formKey,
              autovalidateMode: _autovalidateMode,
              child: AbsorbPointer(
                absorbing: anyOperationInProgress,
                child: Opacity(
                  opacity: anyOperationInProgress ? 0.7 : 1.0,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Center(
                        child: Padding(
                          padding: const EdgeInsets.only(bottom: 24.0, top: 8.0),
                          child: Text(
                            pageTitle,
                            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                            textAlign: TextAlign.center,
                          ),
                        ),
                      ),
                      _buildSectionHeader("Core Details"),
                      TextFormField(
                          controller: _nameController,
                          decoration: InputDecoration(
                            labelText: 'Venue Name*',
                            prefixIcon: const Icon(Icons.sports_soccer),
                            suffixIcon: Padding(
                                padding: const EdgeInsets.only(right: 12.0),
                                child: nameSuffixIcon),
                            errorText: _venueNameErrorText,
                          ),
                          validator: (v) {
                            if (v == null || v.trim().isEmpty) return 'Required';
                            return null;
                          },
                          textCapitalization: TextCapitalization.words),
                      const SizedBox(height: 15),
                      _buildSportsInputSection(),
                      const SizedBox(height: 15),
                      TextFormField(
                          controller: _descriptionController,
                          decoration: const InputDecoration(
                              labelText: 'Description',
                              prefixIcon: Icon(Icons.description_outlined),
                              alignLabelWithHint: true),
                          maxLines: 3,
                          textCapitalization: TextCapitalization.sentences),
                      const SizedBox(height: 20),
                      _buildSectionHeader("Venue Image*"),
                      _buildImageUploadSection(),
                      const SizedBox(height: 20),
                      _buildSectionHeader("Address & Location*"),
                      TextFormField(
                          controller: _addressController,
                          decoration: const InputDecoration(
                              labelText: 'Address Line*',
                              prefixIcon: Icon(Icons.location_on_outlined)),
                          validator: (v) =>
                              v!.trim().isEmpty ? 'Required' : null,
                          textCapitalization: TextCapitalization.words),
                      const SizedBox(height: 15),
                      TextFormField(
                          controller: _areaController,
                          decoration: const InputDecoration(
                              labelText: 'Area / Locality*',
                              hintText: 'e.g., Borivali, Koramangala',
                              prefixIcon: Icon(Icons.explore_outlined)),
                          validator: (v) =>
                              v!.trim().isEmpty ? 'Required' : null,
                          textCapitalization: TextCapitalization.words),
                      const SizedBox(height: 15),
                      Row(children: [
                        Expanded(
                          child: FormField<String>(
                            // Use a key to force rebuild when city changes externally
                            key: ValueKey(_selectedCity),
                            initialValue: _selectedCity,
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return 'City is required';
                              }
                              return null;
                            },
                            builder: (FormFieldState<String> state) {
                              void handleTap() async {
                                if (anyOperationInProgress) return;
                                final result = await Navigator.push<String?>(
                                  context,
                                  MaterialPageRoute(builder: (context) => CitySelectionScreen(currentSelectedCity: state.value)),
                                );
                                
                                if (result != null) {
                                  state.didChange(result);
                                  setState(() {
                                    _selectedCity = result;
                                  });
                                  // Re-trigger the uniqueness check now that the city has changed.
                                  _onIdentityFieldsChanged();
                                }
                              }

                              return InkWell(
                                onTap: handleTap,
                                child: InputDecorator(
                                  decoration: InputDecoration(
                                    labelText: 'City*',
                                    prefixIcon: const Icon(Icons.location_city),
                                    errorText: state.errorText,
                                    border: const OutlineInputBorder(),
                                    contentPadding: const EdgeInsets.fromLTRB(12.0, 16.0, 12.0, 16.0),
                                  ),
                                  child: Row(
                                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                    children: [
                                      Expanded(
                                        child: Text(
                                          state.value ?? 'Tap to select city',
                                          overflow: TextOverflow.ellipsis,
                                          softWrap: false,
                                          style: state.value == null
                                            ? TextStyle(color: Theme.of(context).hintColor, fontSize: 16)
                                            : Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.normal),
                                        ),
                                      ),
                                      const Icon(Icons.arrow_drop_down, color: Colors.grey),
                                    ],
                                  ),
                                ),
                              );
                            },
                          ),
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                            child: TextFormField(
                                controller: _countryController,
                                decoration: const InputDecoration(
                                    labelText: 'Country*',
                                    prefixIcon: Icon(Icons.public)),
                                validator: (v) =>
                                    v!.trim().isEmpty ? 'Required' : null,
                                textCapitalization: TextCapitalization.words))
                      ]),
                      const SizedBox(height: 15),
                      Row(children: [
                        Expanded(
                            child: OutlinedButton.icon(
                                icon: _isFetchingLocation
                                    ? _buildButtonSpinner()
                                    : const Icon(Icons.my_location, size: 18),
                                label: const Text('Use Current'),
                                onPressed: anyOperationInProgress
                                    ? null
                                    : _fetchAndSetCurrentLocation,
                                style: OutlinedButton.styleFrom(
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 12)))),
                        const SizedBox(width: 10),
                        Expanded(
                            child: OutlinedButton.icon(
                                icon: _isGeocoding
                                    ? _buildButtonSpinner()
                                    : const Icon(Icons.location_searching,
                                        size: 18),
                                label: const Text('Find Address'),
                                onPressed: anyOperationInProgress
                                    ? null
                                    : _geocodeAddress,
                                style: OutlinedButton.styleFrom(
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 12))))
                      ]),
                      Padding(
                          padding: const EdgeInsets.only(top: 10.0, bottom: 5.0),
                          child: Text(
                              _locationStatusMessage ??
                                  (_isEditMode && _selectedLocation != null
                                      ? 'Location previously set'
                                      : 'Location not set* (Required for new venues)'),
                              style: TextStyle(
                                  fontSize: 13, color: Colors.grey[700]),
                              textAlign: TextAlign.center)),
                      _buildSectionHeader("Venue on Google Maps*"),
                      Row(
                        children: [
                          Expanded(
                            child: OutlinedButton.icon(
                              icon: const Icon(Icons.map_outlined, size: 18),
                              label: const Text('Open Google Maps'),
                              onPressed:
                                  anyOperationInProgress ? null : _launchGoogleMaps,
                              style: OutlinedButton.styleFrom(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 12),
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 10),
                      TextFormField(
                        controller: _googleMapsUrlController,
                        decoration: const InputDecoration(
                          labelText: 'Pasted Google Maps Link*',
                          hintText: 'e.g., https://maps.app.goo.gl/xxxx',
                          prefixIcon: Icon(Icons.link),
                        ),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'Google Maps link is required.';
                          }
                          final trimmedValue = value.trim();
                          final uri = Uri.tryParse(trimmedValue);
                          if (uri == null || !uri.isAbsolute) {
                            return 'Please enter a valid URL.';
                          }
                          final lowerTrimmedValue = trimmedValue.toLowerCase();
                          if (!lowerTrimmedValue.contains('maps.app.goo.gl') &&
                              !lowerTrimmedValue.contains('google.') &&
                              !lowerTrimmedValue.contains('goo.gl/maps')) {
                            return 'Please paste a valid Google Maps link (e.g., from Share button).';
                          }
                          return null;
                        },
                        keyboardType: TextInputType.url,
                      ),
                      Padding(
                        padding: const EdgeInsets.only(
                            top: 8.0, left: 4.0, right: 4.0, bottom: 5.0),
                        child: Text(
                          "1. Click 'Open Google Maps' above.\n"
                          "2. In Google Maps, find the exact venue.\n"
                          "3. Use the 'Share' option and 'Copy link'.\n"
                          "4. Paste the link in the field above.",
                          style: TextStyle(
                              fontSize: 12.5,
                              color: Theme.of(context).hintColor),
                          textAlign: TextAlign.start,
                        ),
                      ),
                      const SizedBox(height: 20),
                      _buildSectionHeader("Operating Hours*"),
                      _buildOperatingHoursRow(
                          "Weekday", _weekdayStartController, _weekdayEndController),
                      const SizedBox(height: 12),
                      _buildOperatingHoursRow("Saturday", _saturdayStartController,
                          _saturdayEndController),
                      const SizedBox(height: 12),
                      _buildOperatingHoursRow(
                          "Sunday", _sundayStartController, _sundayEndController),
                      const SizedBox(height: 20),
                      _buildSectionHeader("Contact & Other Info"),
                      TextFormField(
                          controller: _phoneController,
                          decoration: const InputDecoration(
                              labelText: 'Phone*',
                              prefixIcon: Icon(Icons.phone_outlined)),
                          keyboardType: TextInputType.phone,
                          validator: (v) {
                            if (v == null || v.trim().isEmpty) {
                              return 'Phone number is required';
                            }
                            return null;
                          }),
                      const SizedBox(height: 15),
                      TextFormField(
                          controller: _emailController,
                          decoration: const InputDecoration(
                              labelText: 'Email*',
                              prefixIcon: Icon(Icons.email_outlined)),
                          keyboardType: TextInputType.emailAddress,
                          validator: (v) {
                            if (v == null || v.trim().isEmpty) {
                              return 'Email is required';
                            }
                            if (!RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
                                .hasMatch(v.trim()))
                              return 'Please enter a valid email address';
                            return null;
                          }),
                      const SizedBox(height: 15),
                      TextFormField(
                          controller: _websiteController,
                          decoration: const InputDecoration(
                              labelText: 'Website (Optional)',
                              prefixIcon: Icon(Icons.language_outlined)),
                          keyboardType: TextInputType.url,
                          validator: (v) {
                            if (v!.trim().isNotEmpty &&
                                (Uri.tryParse(v.trim())?.isAbsolute ?? false) ==
                                    false) return 'Invalid URL';
                            return null;
                          }),
                      const SizedBox(height: 15),
                      TextFormField(
                          controller: _facilitiesController,
                          decoration: const InputDecoration(
                              labelText: 'Facilities*',
                              hintText: 'e.g., Parking, Washroom, Cafe (Comma-separated)',
                              prefixIcon: Icon(Icons.local_offer_outlined)),
                          textCapitalization: TextCapitalization.words,
                          validator: (v) {
                            if (v == null || v.trim().isEmpty) {
                              return 'At least one facility is required';
                            }
                            return null;
                          }),
                      const SizedBox(height: 20),
                      _buildSectionHeader("Status & Settings"),
                      SwitchListTile(
                          title: const Text('Booking Enabled?'),
                          subtitle: const Text(
                              'Can users make bookings for this venue?'),
                          value: _bookingEnabled,
                          onChanged: anyOperationInProgress
                              ? null
                              : (v) => setState(() => _bookingEnabled = v),
                          secondary: Icon(
                              _bookingEnabled
                                  ? Icons.event_available
                                  : Icons.event_busy,
                              color: _bookingEnabled
                                  ? Theme.of(context).primaryColor
                                  : Colors.grey),
                          contentPadding: EdgeInsets.zero,
                          dense: true),
                      const SizedBox(height: 10),
                      SwitchListTile(
                          title: const Text('Venue is Active?'),
                          subtitle: const Text(
                              'Inactive venues won\'t appear in searches.'),
                          value: _isActive,
                          onChanged: anyOperationInProgress
                              ? null
                              : (v) => setState(() => _isActive = v),
                          secondary: Icon(
                              _isActive
                                  ? Icons.check_circle
                                  : Icons.cancel_outlined,
                              color: _isActive ? Colors.green : Colors.grey),
                          contentPadding: EdgeInsets.zero,
                          dense: true),
                      const SizedBox(height: 25),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          SizedBox(
                            width: 200,
                            child: ElevatedButton.icon(
                                icon: (anyOperationInProgress &&
                                        (_isLoading || _isUploadingImage))
                                    ? _buildButtonSpinner(
                                        size: 20, color: Colors.white)
                                    : Icon(submitBtnIcon),
                                label: Text((anyOperationInProgress &&
                                        (_isLoading || _isUploadingImage))
                                    ? 'Saving...'
                                    : submitBtnTxt),
                                onPressed:
                                    anyOperationInProgress ? null : _submitForm,
                                style: ElevatedButton.styleFrom(
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 15),
                                    textStyle: const TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold))),
                          ),
                        ],
                      ),
                      const SizedBox(height: 20),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildImageUploadSection() {
    Widget imagePreview;
    const double previewSize = 150.0;

    if (_isUploadingImage && _selectedImageFile == null) {
      imagePreview = const Center(child: CircularProgressIndicator());
    } else if (_selectedImageFile != null) {
      imagePreview = kIsWeb
          ? Image.network(_selectedImageFile!.path,
              width: previewSize, height: previewSize, fit: BoxFit.cover)
          : Image.file(File(_selectedImageFile!.path),
              width: previewSize, height: previewSize, fit: BoxFit.cover);
    } else if (_imageUrlController.text.isNotEmpty) {
      imagePreview = Image.network(
        _imageUrlController.text,
        width: previewSize,
        height: previewSize,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) => const Center(
            child: Icon(Icons.broken_image_outlined,
                size: 40, color: Colors.grey)),
        loadingBuilder: (context, child, loadingProgress) {
          if (loadingProgress == null) return child;
          return Center(
              child: CircularProgressIndicator(
                  value: loadingProgress.expectedTotalBytes != null
                      ? loadingProgress.cumulativeBytesLoaded /
                          loadingProgress.expectedTotalBytes!
                      : null));
        },
      );
    } else {
      imagePreview = Center(
          child: Icon(Icons.add_a_photo_outlined,
              size: 40,
              color: Theme.of(context).colorScheme.primary.withOpacity(0.7)));
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Center(
          child: Column(
            children: [
              GestureDetector(
                onTap: _isUploadingImage ? null : _pickAndUploadImage,
                child: Container(
                  height: previewSize,
                  width: previewSize,
                  margin: const EdgeInsets.only(bottom: 10.0),
                  decoration: BoxDecoration(
                    color: Theme.of(context)
                        .colorScheme
                        .surfaceVariant
                        .withOpacity(0.3),
                    border: Border.all(
                      color: _imageErrorText != null
                          ? Theme.of(context).colorScheme.error
                          : Theme.of(context)
                              .colorScheme
                              .outline
                              .withOpacity(0.5),
                      width: _imageErrorText != null ? 1.5 : 1.0,
                    ),
                    borderRadius: BorderRadius.circular(8.0),
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(7.0),
                    child: Stack(
                      fit: StackFit.expand,
                      children: [
                        imagePreview,
                        if (_isUploadingImage)
                          Container(
                            color: Colors.black.withOpacity(0.4),
                            child: const Center(
                                child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 3,
                            )),
                          ),
                        if (!_isUploadingImage &&
                            (_imageUrlController.text.isNotEmpty ||
                                _selectedImageFile != null))
                          Positioned(
                            top: 4,
                            right: 4,
                            child: Material(
                              color: Colors.black54,
                              shape: const CircleBorder(),
                              child: InkWell(
                                customBorder: const CircleBorder(),
                                onTap: _isUploadingImage ? null : _clearImage,
                                child: const Padding(
                                  padding: EdgeInsets.all(6.0),
                                  child:
                                      Icon(Icons.close, color: Colors.white, size: 18),
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                ),
              ),
              if (!_isUploadingImage)
                OutlinedButton.icon(
                  icon: Icon(
                      _imageUrlController.text.isNotEmpty ||
                              _selectedImageFile != null
                          ? Icons.edit_outlined
                          : Icons.add_photo_alternate_outlined,
                      size: 18),
                  label: Text(_imageUrlController.text.isNotEmpty ||
                          _selectedImageFile != null
                      ? 'Change Image'
                      : 'Select Image*'),
                  onPressed: _pickAndUploadImage,
                  style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 20, vertical: 10)),
                ),
            ],
          ),
        ),
        if (_isUploadingImage)
          Center(
            child: Padding(
              padding: const EdgeInsets.only(top: 10.0),
              child: Text("Uploading, please wait...",
                  style: TextStyle(
                      color: Theme.of(context).primaryColor,
                      fontStyle: FontStyle.italic)),
            ),
          ),
        if (_imageErrorText != null)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Center(
              child: Text(
                _imageErrorText!,
                style: TextStyle(
                    color: Theme.of(context).colorScheme.error, fontSize: 12),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        Visibility(
          visible: false,
          maintainState: true,
          child: TextFormField(
            controller: _imageUrlController,
            decoration: const InputDecoration(labelText: 'Image URL'),
          ),
        ),
      ],
    );
  }

  Widget _buildSportsInputSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        TextFormField(
          controller: _sportInputController,
          focusNode: _sportInputFocusNode,
          textCapitalization: TextCapitalization.words,
          decoration: InputDecoration(
            hintText: 'e.g., Cricket, Football (Type & press Enter)*',
            prefixIcon: const Icon(Icons.fitness_center),
            border: OutlineInputBorder(
              borderSide: BorderSide(
                  color: _sportsErrorText != null
                      ? Theme.of(context).colorScheme.error
                      : Theme.of(context).colorScheme.outline),
              borderRadius: BorderRadius.circular(4.0),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: BorderSide(
                  color: _sportsErrorText != null
                      ? Theme.of(context).colorScheme.error
                      : Theme.of(context).primaryColor,
                  width: 1.5),
              borderRadius: BorderRadius.circular(4.0),
            ),
            enabledBorder: OutlineInputBorder(
              borderSide: BorderSide(
                  color: _sportsErrorText != null
                      ? Theme.of(context).colorScheme.error
                      : Theme.of(context).colorScheme.outline.withOpacity(0.8)),
              borderRadius: BorderRadius.circular(4.0),
            ),
            errorBorder: OutlineInputBorder(
              borderSide: BorderSide(
                  color: Theme.of(context).colorScheme.error, width: 1.5),
              borderRadius: BorderRadius.circular(4.0),
            ),
            focusedErrorBorder: OutlineInputBorder(
              borderSide: BorderSide(
                  color: Theme.of(context).colorScheme.error, width: 1.5),
              borderRadius: BorderRadius.circular(4.0),
            ),
          ),
          onFieldSubmitted: (_) => _addSportFromInput(),
        ),
        if (_selectedSports.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 4.0),
              child: Wrap(
                spacing: 8.0,
                runSpacing: 4.0,
                children: _selectedSports.map((sport) {
                  return InputChip(
                    label: Text(sport),
                    labelStyle: TextStyle(
                        color: Theme.of(context).colorScheme.onSecondaryContainer),
                    backgroundColor: Theme.of(context)
                        .colorScheme
                        .secondaryContainer
                        .withOpacity(0.7),
                    deleteIconColor: Theme.of(context)
                        .colorScheme
                        .onSecondaryContainer
                        .withOpacity(0.7),
                    onDeleted: () => _removeSport(sport),
                    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    padding: const EdgeInsets.all(6),
                  );
                }).toList(),
              ),
            ),
          ),
        if (_sportsErrorText != null)
          Padding(
            padding: const EdgeInsets.only(top: 8.0, left: 12.0),
            child: Text(
              _sportsErrorText!,
              style: TextStyle(
                  color: Theme.of(context).colorScheme.error, fontSize: 12),
            ),
          ),
      ],
    );
  }

  Widget _buildButtonSpinner({double size = 16, Color? color}) {
    final resolvedColor = color ?? Theme.of(context).primaryColor;
    return SizedBox(
        width: size,
        height: size,
        child: CircularProgressIndicator(
            strokeWidth: 2,
            valueColor: AlwaysStoppedAnimation<Color>(resolvedColor)));
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(top: 15.0, bottom: 10.0),
      child: Text(title,
          style: Theme.of(context)
              .textTheme
              .titleMedium
              ?.copyWith(fontWeight: FontWeight.bold)),
    );
  }

  Widget _buildOperatingHoursRow(String dayLabel,
      TextEditingController startController, TextEditingController endController) {
    const double dayLabelColumnWidth = 90.0;
    const double gapBetweenLabelAndTimes = 8.0;
    const double preferredTimeFieldWidth = 105.0;
    const double horizontalPaddingForToText = 5.0;
    String? timeValidator(String? value) {
      if (value == null || value.trim().isEmpty) return 'Required';
      if (!RegExp(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
          .hasMatch(value.trim())) return 'HH:MM';
      return null;
    }

    Widget buildCoreTimeInput(TextEditingController controller, String labelText) {
      return InkWell(
          onTap: () => _selectTime(context, controller),
          child: AbsorbPointer(
              child: TextFormField(
                  controller: controller,
                  textAlign: TextAlign.center,
                  decoration: InputDecoration(
                      labelText: labelText,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 4.0, vertical: 8.0),
                      isDense: true,
                      border: const OutlineInputBorder(),
                      suffixIcon: const Icon(Icons.access_time, size: 18)),
                  validator: timeValidator)));
    }

    Widget dayLabelWidget = SizedBox(
        width: dayLabelColumnWidth,
        child: Text(dayLabel,
            style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500),
            textAlign: TextAlign.start));
    if (kIsWeb) {
      Widget buildWebTimeInput(TextEditingController controller, String labelText) {
        return SizedBox(
            width: preferredTimeFieldWidth,
            child: buildCoreTimeInput(controller, labelText));
      }

      final TextPainter textPainter = TextPainter(
          text: const TextSpan(text: "to", style: TextStyle(fontSize: 14)),
          maxLines: 1,
          textDirection: TextDirection.ltr)
        ..layout(minWidth: 0, maxWidth: double.infinity);
      final double widthOfToTextWithPadding =
          textPainter.width + (2 * horizontalPaddingForToText);
      final double requiredWidthForTimeControlsGroupWeb =
          (2 * preferredTimeFieldWidth) + widthOfToTextWithPadding;
      return LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {
        final double totalAvailableWidth = constraints.maxWidth;
        final double singleLineRequiredWidthWeb =
            dayLabelColumnWidth + gapBetweenLabelAndTimes + requiredWidthForTimeControlsGroupWeb;
        if (totalAvailableWidth >= singleLineRequiredWidthWeb) {
          return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
            dayLabelWidget,
            const SizedBox(width: gapBetweenLabelAndTimes),
            Expanded(
                child: Row(children: [
              Flexible(child: buildWebTimeInput(startController, 'Start')),
              Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: horizontalPaddingForToText),
                  child: Text("to", style: const TextStyle(fontSize: 14))),
              Flexible(child: buildWebTimeInput(endController, 'End')),
              const Spacer()
            ]))
          ]);
        } else {
          return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                dayLabelWidget,
                const SizedBox(height: 8.0),
                Padding(
                    padding: const EdgeInsets.only(left: 0.0),
                    child:
                        Row(mainAxisSize: MainAxisSize.min, children: [
                      buildWebTimeInput(startController, 'Start'),
                      Padding(
                          padding: const EdgeInsets.symmetric(
                              horizontal: horizontalPaddingForToText),
                          child: Text("to", style: const TextStyle(fontSize: 14))),
                      buildWebTimeInput(endController, 'End')
                    ]))
              ]);
        }
      });
    } else {
      return Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
        dayLabelWidget,
        const SizedBox(width: gapBetweenLabelAndTimes),
        Expanded(child: buildCoreTimeInput(startController, 'Start')),
        Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: horizontalPaddingForToText),
            child: Text("to", style: const TextStyle(fontSize: 14))),
        Expanded(child: buildCoreTimeInput(endController, 'End'))
      ]);
    }
  }
}


===== features\home\widgets\full_screen_image_viewer.dart =====

import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';

class FullScreenImageViewer extends StatelessWidget {
  final String imageUrl;
  final String heroTag;

  const FullScreenImageViewer({
    super.key,
    required this.imageUrl,
    required this.heroTag,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.black,
        elevation: 0,
        iconTheme: const IconThemeData(color: Colors.white), // White back arrow
        leading: IconButton( // Custom back button to ensure it's always visible
          icon: const Icon(Icons.arrow_back_ios_new),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Center(
        child: Hero(
          tag: heroTag,
          child: PhotoView(
            imageProvider: NetworkImage(imageUrl),
            minScale: PhotoViewComputedScale.contained * 0.8, // Start slightly zoomed out
            maxScale: PhotoViewComputedScale.covered * 2.5, // Max zoom factor
            enableRotation: false, // Typically not needed for venue images
            loadingBuilder: (context, event) => Center(
              child: CircularProgressIndicator(
                value: event == null || event.expectedTotalBytes == null
                    ? null
                    : event.cumulativeBytesLoaded / event.expectedTotalBytes!,
                color: Colors.white,
              ),
            ),
            errorBuilder: (context, error, stackTrace) => const Center(
              child: Icon(Icons.broken_image_outlined, color: Colors.white60, size: 60),
            ),
          ),
        ),
      ),
    );
  }
}


===== features\home\widgets\home_search_components copy.dart =====

// // // // import 'package:flutter/material.dart';
// // // // import 'package:flutter/scheduler.dart';
// // // // import 'dart:async';
// // // // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // // // import 'package:mm_associates/features/home/screens/venue_detail_screen.dart';

// // // // /// A widget that provides a search bar for the web platform,
// // // // /// including a suggestion overlay.
// // // // class WebSearchBar extends StatefulWidget {
// // // //   final String initialValue;
// // // //   final String? cityFilter;
// // // //   final FirestoreService firestoreService;
// // // //   final Function(String query) onSearchSubmitted;
// // // //   final Function(String suggestionName) onSuggestionSelected;
// // // //   final VoidCallback onClear;

// // // //   const WebSearchBar({
// // // //     super.key,
// // // //     required this.initialValue,
// // // //     required this.cityFilter,
// // // //     required this.firestoreService,
// // // //     required this.onSearchSubmitted,
// // // //     required this.onSuggestionSelected,
// // // //     required this.onClear,
// // // //   });

// // // //   @override
// // // //   State<WebSearchBar> createState() => _WebSearchBarState();
// // // // }

// // // // class _WebSearchBarState extends State<WebSearchBar> {
// // // //   final TextEditingController _controller = TextEditingController();
// // // //   final FocusNode _focusNode = FocusNode();
// // // //   final LayerLink _layerLink = LayerLink();
// // // //   Timer? _debounce;
// // // //   OverlayEntry? _overlayEntry;

// // // //   bool _isLoadingSuggestions = false;
// // // //   List<Map<String, dynamic>> _suggestions = [];

// // // //   @override
// // // //   void initState() {
// // // //     super.initState();
// // // //     _controller.text = widget.initialValue;
// // // //     _controller.addListener(_onTextChanged);
// // // //     _focusNode.addListener(_onFocusChanged);
// // // //   }

// // // //   @override
// // // //   void didUpdateWidget(covariant WebSearchBar oldWidget) {
// // // //     super.didUpdateWidget(oldWidget);
// // // //     if (widget.initialValue != oldWidget.initialValue &&
// // // //         widget.initialValue != _controller.text) {
// // // //       _controller.text = widget.initialValue;
// // // //     }
// // // //   }

// // // //   void _onTextChanged() {
// // // //     if (_debounce?.isActive ?? false) _debounce!.cancel();
// // // //     _debounce = Timer(const Duration(milliseconds: 500), () {
// // // //       final query = _controller.text.trim();
// // // //       if (query.isNotEmpty && _focusNode.hasFocus) {
// // // //         _fetchSuggestions(query);
// // // //       } else if (mounted) {
// // // //         setState(() {
// // // //           _suggestions = [];
// // // //         });
// // // //         _updateOverlay();
// // // //       }
// // // //     });
// // // //     // This setState is needed to update the clear icon visibility
// // // //     if (mounted) {
// // // //       setState(() {});
// // // //     }
// // // //   }

// // // //   void _onFocusChanged() {
// // // //     if (_focusNode.hasFocus) {
// // // //       _showOverlay();
// // // //       final query = _controller.text.trim();
// // // //       if (query.isNotEmpty && _suggestions.isEmpty) {
// // // //         _fetchSuggestions(query);
// // // //       }
// // // //     } else {
// // // //       _hideOverlay();
// // // //     }
// // // //   }

// // // //   Future<void> _fetchSuggestions(String query) async {
// // // //     if (!mounted) return;
// // // //     setState(() => _isLoadingSuggestions = true);
// // // //     _updateOverlay(); // Update overlay to show loader

// // // //     try {
// // // //       final suggestions = await widget.firestoreService.getVenues(
// // // //         searchQuery: query,
// // // //         cityFilter: widget.cityFilter,
// // // //         limit: 500, // as in original code
// // // //         forSuggestions: true,
// // // //       );
// // // //       if (!mounted) return;
// // // //       setState(() {
// // // //         _suggestions = suggestions;
// // // //         _isLoadingSuggestions = false;
// // // //       });
// // // //     } catch (e) {
// // // //       debugPrint("Error fetching web search suggestions: $e");
// // // //       if (!mounted) return;
// // // //       setState(() {
// // // //         _suggestions = [];
// // // //         _isLoadingSuggestions = false;
// // // //       });
// // // //     } finally {
// // // //       _updateOverlay(); // Update overlay with results or empty state
// // // //     }
// // // //   }

// // // //   void _showOverlay() {
// // // //     if (_overlayEntry != null) return;
// // // //     _overlayEntry = _createOverlayEntry();
// // // //     Overlay.of(context, rootOverlay: true)?.insert(_overlayEntry!);
// // // //   }

// // // //   void _hideOverlay() {
// // // //     // A small delay to allow tap events on the overlay to register
// // // //     Future.delayed(const Duration(milliseconds: 200), () {
// // // //       if (!mounted || _focusNode.hasFocus) return;
// // // //       _overlayEntry?.remove();
// // // //       _overlayEntry = null;
// // // //     });
// // // //   }

// // // //   void _updateOverlay() {
// // // //     _overlayEntry?.markNeedsBuild();
// // // //   }

// // // //   OverlayEntry _createOverlayEntry() {
// // // //     final renderBox = context.findRenderObject() as RenderBox;
// // // //     final size = renderBox.size;
// // // //     final theme = Theme.of(context);

// // // //     return OverlayEntry(
// // // //       builder: (context) => Positioned(
// // // //         width: size.width,
// // // //         child: CompositedTransformFollower(
// // // //           link: _layerLink,
// // // //           showWhenUnlinked: false,
// // // //           offset: Offset(0.0, size.height + 4.0),
// // // //           child: Material(
// // // //             elevation: 4.0,
// // // //             borderRadius: BorderRadius.circular(8),
// // // //             child: Container(
// // // //               constraints: const BoxConstraints(maxHeight: 250),
// // // //               decoration: BoxDecoration(
// // // //                 color: theme.cardColor,
// // // //                 borderRadius: BorderRadius.circular(8),
// // // //                 boxShadow: [
// // // //                   BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 6, offset: const Offset(0, 3)),
// // // //                 ],
// // // //               ),
// // // //               child: _buildSuggestionBody(theme),
// // // //             ),
// // // //           ),
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildSuggestionBody(ThemeData theme) {
// // // //     if (_isLoadingSuggestions) {
// // // //       return const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)));
// // // //     }
// // // //     if (_suggestions.isEmpty) {
// // // //       return Padding(
// // // //         padding: const EdgeInsets.all(16.0),
// // // //         child: Text(
// // // //           _controller.text.isEmpty && _focusNode.hasFocus ? "Start typing to search..." : "No suggestions found.",
// // // //           textAlign: TextAlign.center,
// // // //           style: TextStyle(color: theme.hintColor),
// // // //         ),
// // // //       );
// // // //     }
// // // //     return ListView.builder(
// // // //       shrinkWrap: true,
// // // //       padding: EdgeInsets.zero,
// // // //       itemCount: _suggestions.length,
// // // //       itemBuilder: (context, index) {
// // // //         final venue = _suggestions[index];
// // // //         final String name = venue['name'] as String? ?? 'N/A';
// // // //         final String city = venue['city'] as String? ?? '';
// // // //         return ListTile(
// // // //           title: Text(name, style: const TextStyle(fontSize: 14)),
// // // //           subtitle: city.isNotEmpty ? Text(city, style: const TextStyle(fontSize: 12)) : null,
// // // //           dense: true,
// // // //           contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
// // // //           onTap: () {
// // // //             _controller.text = name;
// // // //             _controller.selection = TextSelection.fromPosition(TextPosition(offset: _controller.text.length));
// // // //             _focusNode.unfocus();
// // // //             widget.onSuggestionSelected(name);
// // // //           },
// // // //         );
// // // //       },
// // // //     );
// // // //   }

// // // //   @override
// // // //   void dispose() {
// // // //     _controller.removeListener(_onTextChanged);
// // // //     _controller.dispose();
// // // //     _focusNode.removeListener(_onFocusChanged);
// // // //     _focusNode.dispose();
// // // //     _debounce?.cancel();
// // // //     // Ensure the overlay is removed when the widget is disposed
// // // //     // Use a post-frame callback to avoid issues during widget tree tear-down.
// // // //     WidgetsBinding.instance.addPostFrameCallback((_) {
// // // //       _overlayEntry?.remove();
// // // //     });
// // // //     super.dispose();
// // // //   }

// // // //   @override
// // // //   Widget build(BuildContext context) {
// // // //     final theme = Theme.of(context);
// // // //     return CompositedTransformTarget(
// // // //       link: _layerLink,
// // // //       child: Container(
// // // //         height: 40,
// // // //         decoration: BoxDecoration(
// // // //           color: theme.inputDecorationTheme.fillColor ?? theme.colorScheme.surfaceContainerLowest,
// // // //           borderRadius: BorderRadius.circular(20),
// // // //         ),
// // // //         child: Center(
// // // //           child: TextField(
// // // //             controller: _controller,
// // // //             focusNode: _focusNode,
// // // //             style: theme.textTheme.bodyMedium,
// // // //             textAlignVertical: TextAlignVertical.center,
// // // //             decoration: InputDecoration(
// // // //               hintText: 'Search venues by name, sport, or city...',
// // // //               hintStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
// // // //               prefixIcon: Icon(Icons.search_outlined, color: theme.hintColor, size: 20),
// // // //               border: InputBorder.none,
// // // //               contentPadding: const EdgeInsets.only(left: 0, right: 10, top: 11, bottom: 11),
// // // //               isDense: true,
// // // //               suffixIcon: _controller.text.isNotEmpty
// // // //                   ? IconButton(
// // // //                       icon: Icon(Icons.clear_rounded, size: 20, color: theme.hintColor),
// // // //                       tooltip: 'Clear Search',
// // // //                       onPressed: () {
// // // //                         _controller.clear();
// // // //                         // _onTextChanged will be called, which will handle state updates.
// // // //                         widget.onClear(); // Notify parent that search is cleared.
// // // //                       },
// // // //                       splashRadius: 18,
// // // //                       constraints: const BoxConstraints(),
// // // //                       padding: EdgeInsets.zero,
// // // //                     )
// // // //                   : null,
// // // //             ),
// // // //             onSubmitted: (value) {
// // // //               _focusNode.unfocus();
// // // //               widget.onSearchSubmitted(value);
// // // //             },
// // // //           ),
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }
// // // // }

// // // // /// A SearchDelegate for finding venues, used on mobile platforms.
// // // // class VenueSearchDelegate extends SearchDelegate<String?> {
// // // //   final FirestoreService firestoreService;
// // // //   final String? initialCityFilter;

// // // //   Timer? _debounce;
// // // //   Future<List<Map<String, dynamic>>>? _suggestionFuture;
// // // //   String _currentFetchingSuggestionQuery = "";

// // // //   VenueSearchDelegate({
// // // //     required this.firestoreService,
// // // //     this.initialCityFilter,
// // // //   }) : super(
// // // //           searchFieldLabel: initialCityFilter != null
// // // //               ? 'Search in $initialCityFilter...'
// // // //               : 'Search venues...',
// // // //         );

// // // //   @override
// // // //   void dispose() {
// // // //     _debounce?.cancel();
// // // //     super.dispose();
// // // //   }

// // // //   void _updateSuggestionFuture(BuildContext delegateContext, String currentQuery) {
// // // //     if (currentQuery.isEmpty) {
// // // //       if (_suggestionFuture != null || _currentFetchingSuggestionQuery.isNotEmpty) {
// // // //         _currentFetchingSuggestionQuery = "";
// // // //         _suggestionFuture = Future.value([]);
// // // //         if(WidgetsBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {
// // // //            WidgetsBinding.instance.addPostFrameCallback((_) {
// // // //               if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // //            });
// // // //         } else {
// // // //            if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // //         }
// // // //       }
// // // //       return;
// // // //     }

// // // //     if (currentQuery != _currentFetchingSuggestionQuery || _suggestionFuture == null) {
// // // //       _currentFetchingSuggestionQuery = currentQuery;
// // // //       _suggestionFuture = firestoreService.getVenues(
// // // //         searchQuery: currentQuery,
// // // //         cityFilter: initialCityFilter,
// // // //         limit: 700,
// // // //         forSuggestions: true,
// // // //       );
// // // //         if(WidgetsBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {
// // // //            WidgetsBinding.instance.addPostFrameCallback((_) {
// // // //              if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // //            });
// // // //         } else {
// // // //            if(delegateContext.mounted) super.showSuggestions(delegateContext);
// // // //         }
// // // //     }
// // // //   }

// // // //   @override
// // // //   void showSuggestions(BuildContext context) {
// // // //     super.showSuggestions(context);
// // // //     _debounce?.cancel();
// // // //     _debounce = Timer(const Duration(milliseconds: 350), () {
// // // //       final String trimmedQuery = query.trim();
// // // //       _updateSuggestionFuture(context, trimmedQuery);
// // // //     });
// // // //   }

// // // //   @override
// // // //   ThemeData appBarTheme(BuildContext context) {
// // // //     final theme = Theme.of(context);
// // // //     final Color primaryColor = theme.primaryColor;
// // // //     final Color appBarFgColor = theme.colorScheme.onPrimary;

// // // //     return theme.copyWith(
// // // //       primaryColor: primaryColor,
// // // //       scaffoldBackgroundColor: theme.canvasColor,
// // // //       appBarTheme: theme.appBarTheme.copyWith(
// // // //         backgroundColor: primaryColor,
// // // //         elevation: 1.0,
// // // //         iconTheme: IconThemeData(color: appBarFgColor),
// // // //         actionsIconTheme: IconThemeData(color: appBarFgColor),
// // // //         titleTextStyle:
// // // //             theme.textTheme.titleLarge?.copyWith(color: appBarFgColor),
// // // //         toolbarTextStyle:
// // // //             theme.textTheme.bodyMedium?.copyWith(color: appBarFgColor),
// // // //       ),
// // // //       inputDecorationTheme: InputDecorationTheme(
// // // //         hintStyle: theme.textTheme.titleMedium
// // // //             ?.copyWith(color: appBarFgColor.withOpacity(0.7)),
// // // //         border: InputBorder.none,
// // // //       ),
// // // //       textSelectionTheme: TextSelectionThemeData(
// // // //           cursorColor: appBarFgColor,
// // // //           selectionColor: appBarFgColor.withOpacity(0.3),
// // // //           selectionHandleColor: appBarFgColor),
// // // //     );
// // // //   }

// // // //   @override
// // // //   List<Widget>? buildActions(BuildContext context) {
// // // //     return [
// // // //       if (query.isNotEmpty)
// // // //         IconButton(
// // // //           icon: const Icon(Icons.search_outlined),
// // // //           tooltip: 'Search',
// // // //           onPressed: () {
// // // //             if (query.trim().isNotEmpty) {
// // // //               close(context, query.trim());
// // // //             }
// // // //           },
// // // //         ),
// // // //       if (query.isNotEmpty)
// // // //         IconButton(
// // // //           icon: const Icon(Icons.clear_rounded),
// // // //           tooltip: 'Clear',
// // // //           onPressed: () {
// // // //             query = '';
// // // //           },
// // // //         ),
// // // //     ];
// // // //   }

// // // //   @override
// // // //   Widget? buildLeading(BuildContext context) {
// // // //     return IconButton(
// // // //       icon: const Icon(Icons.arrow_back_ios_new_rounded),
// // // //       tooltip: 'Back',
// // // //       onPressed: () {
// // // //         close(context, null);
// // // //       },
// // // //     );
// // // //   }

// // // //   @override
// // // //   Widget buildResults(BuildContext context) {
// // // //     final trimmedQuery = query.trim();

// // // //     if (trimmedQuery.isEmpty) {
// // // //       return _buildInfoWidget("Please enter a search term.");
// // // //     }

// // // //     debugPrint("VenueSearchDelegate: Building results for '$trimmedQuery'");

// // // //     return FutureBuilder<List<Map<String, dynamic>>>(
// // // //       future: firestoreService.getVenues(
// // // //         searchQuery: trimmedQuery,
// // // //         cityFilter: initialCityFilter,
// // // //       ),
// // // //       builder: (context, snapshot) {
// // // //         if (snapshot.connectionState == ConnectionState.waiting) {
// // // //           return const Center(child: CircularProgressIndicator());
// // // //         }
// // // //         if (snapshot.hasError) {
// // // //           debugPrint("SearchDelegate Results Error: ${snapshot.error}");
// // // //           return _buildErrorWidget(
// // // //               "Error searching venues. Please try again.");
// // // //         }
// // // //         if (!snapshot.hasData || snapshot.data!.isEmpty) {
// // // //           return _buildNoResultsWidget();
// // // //         }

// // // //         final results = snapshot.data!;
// // // //         return ListView.builder(
// // // //           itemCount: results.length,
// // // //           itemBuilder: (context, index) {
// // // //             final venue = results[index];
// // // //             return _buildVenueListTileForResult(context, venue);
// // // //           },
// // // //         );
// // // //       },
// // // //     );
// // // //   }

// // // //   @override
// // // //   Widget buildSuggestions(BuildContext context) {
// // // //     final currentQuery = query.trim();

// // // //     if (currentQuery.isEmpty) {
// // // //          return _buildInfoWidget("Start typing to search for venues...");
// // // //     }

// // // //     if (_suggestionFuture == null || _currentFetchingSuggestionQuery != currentQuery) {
// // // //         if (_debounce?.isActive ?? false) { 
// // // //              return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // // //         }
// // // //         return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // // //     }

// // // //     return FutureBuilder<List<Map<String, dynamic>>>(
// // // //       future: _suggestionFuture,
// // // //       builder: (context, snapshot) {
// // // //         if (snapshot.connectionState == ConnectionState.waiting && currentQuery.isNotEmpty) {
// // // //           return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // // //         }
// // // //         if (snapshot.hasError) {
// // // //           debugPrint("Suggestion Error: ${snapshot.error}");
// // // //           return _buildErrorWidget("Could not load suggestions.");
// // // //         }

// // // //         if (!snapshot.hasData || snapshot.data!.isEmpty) {
// // // //              return _buildInfoWidget('No suggestions for "$currentQuery".');
// // // //         }

// // // //         final suggestions = snapshot.data!;
// // // //         return ListView.builder(
// // // //           itemCount: suggestions.length,
// // // //           itemBuilder: (context, index) {
// // // //             final venue = suggestions[index];
// // // //             return _buildSuggestionTile(context, venue);
// // // //           },
// // // //         );
// // // //       },
// // // //     );
// // // //   }

// // // //   Widget _buildSuggestionTile(BuildContext context, Map<String, dynamic> venue) {
// // // //     final String name = venue['name'] as String? ?? 'No Name';
// // // //     final String city = venue['city'] as String? ?? '';
// // // //     return ListTile(
// // // //       leading: Icon(Icons.search_outlined, color: Theme.of(context).hintColor),
// // // //       title: Text(name),
// // // //       subtitle: Text(city, maxLines: 1, overflow: TextOverflow.ellipsis),
// // // //       onTap: () {
// // // //         query = name;
// // // //         close(context, name);
// // // //       },
// // // //     );
// // // //   }

// // // //   Widget _buildVenueListTileForResult(BuildContext context, Map<String, dynamic> venue) {
// // // //     final String name = venue['name'] as String? ?? 'No Name';
// // // //     final String city = venue['city'] as String? ?? '';
// // // //     final String address = venue['address'] as String? ?? '';
// // // //     final String venueId = venue['id'] as String;
// // // //     final List<String> sports = (venue['sportType'] as List<dynamic>?)?.whereType<String>().toList() ?? [];
// // // //     final String? imageUrl = venue['imageUrl'] as String?;
// // // //     final double rating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;

// // // //     return ListTile(
// // // //       leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// // // //           ? CircleAvatar(backgroundImage: NetworkImage(imageUrl), radius: 25, backgroundColor: Colors.grey[200])
// // // //           : CircleAvatar(child: Icon(Icons.sports_soccer_outlined, size: 20), radius: 25, backgroundColor: Colors.grey[200]),
// // // //       title: Text(name, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
// // // //       subtitle: Text("${sports.isNotEmpty ? sports.join(', ') : 'Venue'} - ${address.isNotEmpty ? '$address, ' : ''}$city", maxLines: 1, overflow: TextOverflow.ellipsis, style: Theme.of(context).textTheme.bodySmall),
// // // //       trailing: rating > 0 ? Row(mainAxisSize: MainAxisSize.min, children: [
// // // //                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// // // //                 const SizedBox(width: 4),
// // // //                 Text(rating.toStringAsFixed(1), style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
// // // //               ]) : null,
// // // //       onTap: () {
// // // //         close(context, null); 
// // // //         WidgetsBinding.instance.addPostFrameCallback((_) {
// // // //           if (context.mounted) {
// // // //              Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venueId, initialVenueData: venue)));
// // // //           }
// // // //         });
// // // //       },
// // // //     );
// // // //   }

// // // //   Widget _buildNoResultsWidget() {
// // // //     return Center(
// // // //       child: Padding(
// // // //         padding: const EdgeInsets.all(20.0),
// // // //         child: Column(
// // // //           mainAxisAlignment: MainAxisAlignment.center,
// // // //           children: [
// // // //             Icon(Icons.search_off_rounded, size: 60, color: Colors.grey[400]),
// // // //             const SizedBox(height: 15),
// // // //             Text('No venues found matching "$query"${initialCityFilter != null ? ' in $initialCityFilter' : ''}.', textAlign: TextAlign.center, style: TextStyle(fontSize: 17, color: Colors.grey[600])),
// // // //             const SizedBox(height: 10),
// // // //             const Text("Try different keywords or check spelling.", style: TextStyle(color: Colors.grey))
// // // //           ],
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildErrorWidget(String message) {
// // // //     return Center(
// // // //       child: Padding(
// // // //         padding: const EdgeInsets.all(16.0),
// // // //         child: Column(
// // // //           mainAxisAlignment: MainAxisAlignment.center,
// // // //           children: [
// // // //             const Icon(Icons.error_outline_rounded, color: Colors.red, size: 50),
// // // //             const SizedBox(height: 10),
// // // //             Text(message, textAlign: TextAlign.center, style: const TextStyle(color: Colors.redAccent)),
// // // //           ],
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildInfoWidget(String message) {
// // // //     return Center(
// // // //       child: Padding(
// // // //         padding: const EdgeInsets.all(16.0),
// // // //         child: Text(message, style: TextStyle(fontSize: 16, color: Colors.grey[600])),
// // // //       ),
// // // //     );
// // // //   }
// // // // }

// // // ///---web search suggestions--------
// // // import 'package:flutter/material.dart';
// // // import 'package:flutter/scheduler.dart';
// // // import 'dart:async';
// // // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // // import 'package:mm_associates/features/home/screens/venue_detail_screen.dart';

// // // // =========================================================================
// // // // UNCHANGED: Web Search Bar remains exactly the same.
// // // // =========================================================================
// // // class WebSearchBar extends StatefulWidget {
// // //   // ... (All the code for WebSearchBar is exactly the same as before, so it's omitted here for brevity) ...
// // //   final String initialValue;
// // //   final String? cityFilter;
// // //   final FirestoreService firestoreService;
// // //   final Function(String query) onSearchSubmitted;
// // //   final Function(String suggestionName) onSuggestionSelected;
// // //   final VoidCallback onClear;

// // //   const WebSearchBar({
// // //     super.key,
// // //     required this.initialValue,
// // //     required this.cityFilter,
// // //     required this.firestoreService,
// // //     required this.onSearchSubmitted,
// // //     required this.onSuggestionSelected,
// // //     required this.onClear,
// // //   });

// // //   @override
// // //   State<WebSearchBar> createState() => _WebSearchBarState();
// // // }

// // // class _WebSearchBarState extends State<WebSearchBar> {
// // //   final TextEditingController _controller = TextEditingController();
// // //   final FocusNode _focusNode = FocusNode();
// // //   final LayerLink _layerLink = LayerLink();
// // //   Timer? _debounce;
// // //   OverlayEntry? _overlayEntry;

// // //   bool _isLoadingSuggestions = false;
// // //   List<Map<String, dynamic>> _suggestions = [];

// // //   @override
// // //   void initState() {
// // //     super.initState();
// // //     _controller.text = widget.initialValue;
// // //     _controller.addListener(_onTextChanged);
// // //     _focusNode.addListener(_onFocusChanged);
// // //   }

// // //   @override
// // //   void didUpdateWidget(covariant WebSearchBar oldWidget) {
// // //     super.didUpdateWidget(oldWidget);
// // //     if (widget.initialValue != oldWidget.initialValue &&
// // //         widget.initialValue != _controller.text) {
// // //       _controller.text = widget.initialValue;
// // //     }
// // //   }

// // //   void _onTextChanged() {
// // //     if (_debounce?.isActive ?? false) _debounce!.cancel();
// // //     _debounce = Timer(const Duration(milliseconds: 500), () {
// // //       final query = _controller.text.trim();
// // //       if (query.isNotEmpty && _focusNode.hasFocus) {
// // //         _fetchSuggestions(query);
// // //       } else if (mounted) {
// // //         setState(() {
// // //           _suggestions = [];
// // //         });
// // //         _updateOverlay();
// // //       }
// // //     });
// // //     // This setState is needed to update the clear icon visibility
// // //     if (mounted) {
// // //       setState(() {});
// // //     }
// // //   }

// // //   void _onFocusChanged() {
// // //     if (_focusNode.hasFocus) {
// // //       _showOverlay();
// // //       final query = _controller.text.trim();
// // //       if (query.isNotEmpty && _suggestions.isEmpty) {
// // //         _fetchSuggestions(query);
// // //       }
// // //     } else {
// // //       _hideOverlay();
// // //     }
// // //   }

// // //   Future<void> _fetchSuggestions(String query) async {
// // //     if (!mounted) return;
// // //     setState(() => _isLoadingSuggestions = true);
// // //     _updateOverlay(); // Update overlay to show loader

// // //     try {
// // //       final suggestions = await widget.firestoreService.getVenues(
// // //         searchQuery: query,
// // //         cityFilter: widget.cityFilter,
// // //         limit: 500, // as in original code
// // //         forSuggestions: true,
// // //       );
// // //       if (!mounted) return;
// // //       setState(() {
// // //         _suggestions = suggestions;
// // //         _isLoadingSuggestions = false;
// // //       });
// // //     } catch (e) {
// // //       debugPrint("Error fetching web search suggestions: $e");
// // //       if (!mounted) return;
// // //       setState(() {
// // //         _suggestions = [];
// // //         _isLoadingSuggestions = false;
// // //       });
// // //     } finally {
// // //       _updateOverlay(); // Update overlay with results or empty state
// // //     }
// // //   }

// // //   void _showOverlay() {
// // //     if (_overlayEntry != null) return;
// // //     _overlayEntry = _createOverlayEntry();
// // //     Overlay.of(context, rootOverlay: true)?.insert(_overlayEntry!);
// // //   }

// // //   void _hideOverlay() {
// // //     // A small delay to allow tap events on the overlay to register
// // //     Future.delayed(const Duration(milliseconds: 200), () {
// // //       if (!mounted || _focusNode.hasFocus) return;
// // //       _overlayEntry?.remove();
// // //       _overlayEntry = null;
// // //     });
// // //   }

// // //   void _updateOverlay() {
// // //     _overlayEntry?.markNeedsBuild();
// // //   }

// // //   OverlayEntry _createOverlayEntry() {
// // //     final renderBox = context.findRenderObject() as RenderBox;
// // //     final size = renderBox.size;
// // //     final theme = Theme.of(context);

// // //     return OverlayEntry(
// // //       builder: (context) => Positioned(
// // //         width: size.width,
// // //         child: CompositedTransformFollower(
// // //           link: _layerLink,
// // //           showWhenUnlinked: false,
// // //           offset: Offset(0.0, size.height + 4.0),
// // //           child: Material(
// // //             elevation: 4.0,
// // //             borderRadius: BorderRadius.circular(8),
// // //             child: Container(
// // //               constraints: const BoxConstraints(maxHeight: 250),
// // //               decoration: BoxDecoration(
// // //                 color: theme.cardColor,
// // //                 borderRadius: BorderRadius.circular(8),
// // //                 boxShadow: [
// // //                   BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 6, offset: const Offset(0, 3)),
// // //                 ],
// // //               ),
// // //               child: _buildSuggestionBody(theme),
// // //             ),
// // //           ),
// // //         ),
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildSuggestionBody(ThemeData theme) {
// // //     if (_isLoadingSuggestions) {
// // //       return const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)));
// // //     }
// // //     if (_suggestions.isEmpty) {
// // //       return Padding(
// // //         padding: const EdgeInsets.all(16.0),
// // //         child: Text(
// // //           _controller.text.isEmpty && _focusNode.hasFocus ? "Start typing to search..." : "No suggestions found.",
// // //           textAlign: TextAlign.center,
// // //           style: TextStyle(color: theme.hintColor),
// // //         ),
// // //       );
// // //     }
// // //     return ListView.builder(
// // //       shrinkWrap: true,
// // //       padding: EdgeInsets.zero,
// // //       itemCount: _suggestions.length,
// // //       itemBuilder: (context, index) {
// // //         final venue = _suggestions[index];
// // //         final String name = venue['name'] as String? ?? 'N/A';
// // //         final String city = venue['city'] as String? ?? '';
// // //         return ListTile(
// // //           title: Text(name, style: const TextStyle(fontSize: 14)),
// // //           subtitle: city.isNotEmpty ? Text(city, style: const TextStyle(fontSize: 12)) : null,
// // //           dense: true,
// // //           contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
// // //           onTap: () {
// // //             _controller.text = name;
// // //             _controller.selection = TextSelection.fromPosition(TextPosition(offset: _controller.text.length));
// // //             _focusNode.unfocus();
// // //             widget.onSuggestionSelected(name);
// // //           },
// // //         );
// // //       },
// // //     );
// // //   }

// // //   @override
// // //   void dispose() {
// // //     _controller.removeListener(_onTextChanged);
// // //     _controller.dispose();
// // //     _focusNode.removeListener(_onFocusChanged);
// // //     _focusNode.dispose();
// // //     _debounce?.cancel();
// // //     // Ensure the overlay is removed when the widget is disposed
// // //     // Use a post-frame callback to avoid issues during widget tree tear-down.
// // //     WidgetsBinding.instance.addPostFrameCallback((_) {
// // //       _overlayEntry?.remove();
// // //     });
// // //     super.dispose();
// // //   }

// // //   @override
// // //   Widget build(BuildContext context) {
// // //     final theme = Theme.of(context);
// // //     return CompositedTransformTarget(
// // //       link: _layerLink,
// // //       child: Container(
// // //         height: 40,
// // //         decoration: BoxDecoration(
// // //           color: theme.inputDecorationTheme.fillColor ?? theme.colorScheme.surfaceContainerLowest,
// // //           borderRadius: BorderRadius.circular(20),
// // //         ),
// // //         child: Center(
// // //           child: TextField(
// // //             controller: _controller,
// // //             focusNode: _focusNode,
// // //             style: theme.textTheme.bodyMedium,
// // //             textAlignVertical: TextAlignVertical.center,
// // //             decoration: InputDecoration(
// // //               hintText: 'Search venues by name, sport, or city...',
// // //               hintStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
// // //               prefixIcon: Icon(Icons.search_outlined, color: theme.hintColor, size: 20),
// // //               border: InputBorder.none,
// // //               contentPadding: const EdgeInsets.only(left: 0, right: 10, top: 11, bottom: 11),
// // //               isDense: true,
// // //               suffixIcon: _controller.text.isNotEmpty
// // //                   ? IconButton(
// // //                       icon: Icon(Icons.clear_rounded, size: 20, color: theme.hintColor),
// // //                       tooltip: 'Clear Search',
// // //                       onPressed: () {
// // //                         _controller.clear();
// // //                         // _onTextChanged will be called, which will handle state updates.
// // //                         widget.onClear(); // Notify parent that search is cleared.
// // //                       },
// // //                       splashRadius: 18,
// // //                       constraints: const BoxConstraints(),
// // //                       padding: EdgeInsets.zero,
// // //                     )
// // //                   : null,
// // //             ),
// // //             onSubmitted: (value) {
// // //               _focusNode.unfocus();
// // //               widget.onSearchSubmitted(value);
// // //             },
// // //           ),
// // //         ),
// // //       ),
// // //     );
// // //   }
// // // }

// // // // =========================================================================
// // // // REFACTORED: The VenueSearchDelegate for mobile is now corrected.
// // // // =========================================================================
// // // class VenueSearchDelegate extends SearchDelegate<String?> {
// // //   final FirestoreService firestoreService;
// // //   final String? initialCityFilter;

// // //   // <<< NEW: State variables moved to the top level of the delegate >>>
// // //   Timer? _debounce;
// // //   Future<List<Map<String, dynamic>>>? _suggestionFuture;
// // //   String _lastQuery = ''; // To track the last searched query

// // //   VenueSearchDelegate({
// // //     required this.firestoreService,
// // //     this.initialCityFilter,
// // //   }) : super(
// // //           searchFieldLabel: initialCityFilter != null
// // //               ? 'Search in $initialCityFilter...'
// // //               : 'Search venues...',
// // //         );

// // //   @override
// // //   void dispose() {
// // //     _debounce?.cancel();
// // //     super.dispose();
// // //   }
  
// // //   // <<< MODIFIED: This override is no longer needed as the logic is now inside buildSuggestions >>>
// // //   // @override
// // //   // void showSuggestions(BuildContext context) { ... }

// // //   @override
// // //   ThemeData appBarTheme(BuildContext context) {
// // //     final theme = Theme.of(context);
// // //     final Color primaryColor = theme.primaryColor;
// // //     final Color appBarFgColor = theme.colorScheme.onPrimary;

// // //     return theme.copyWith(
// // //       primaryColor: primaryColor,
// // //       scaffoldBackgroundColor: theme.canvasColor,
// // //       appBarTheme: theme.appBarTheme.copyWith(
// // //         backgroundColor: primaryColor,
// // //         elevation: 1.0,
// // //         iconTheme: IconThemeData(color: appBarFgColor),
// // //         actionsIconTheme: IconThemeData(color: appBarFgColor),
// // //         titleTextStyle:
// // //             theme.textTheme.titleLarge?.copyWith(color: appBarFgColor),
// // //         toolbarTextStyle:
// // //             theme.textTheme.bodyMedium?.copyWith(color: appBarFgColor),
// // //       ),
// // //       inputDecorationTheme: InputDecorationTheme(
// // //         hintStyle: theme.textTheme.titleMedium
// // //             ?.copyWith(color: appBarFgColor.withOpacity(0.7)),
// // //         border: InputBorder.none,
// // //       ),
// // //       textSelectionTheme: TextSelectionThemeData(
// // //           cursorColor: appBarFgColor,
// // //           selectionColor: appBarFgColor.withOpacity(0.3),
// // //           selectionHandleColor: appBarFgColor),
// // //     );
// // //   }

// // //   @override
// // //   List<Widget>? buildActions(BuildContext context) {
// // //     return [
// // //       if (query.isNotEmpty)
// // //         IconButton(
// // //           icon: const Icon(Icons.search_outlined),
// // //           tooltip: 'Search',
// // //           onPressed: () {
// // //             if (query.trim().isNotEmpty) {
// // //               showResults(context);
// // //             }
// // //           },
// // //         ),
// // //       if (query.isNotEmpty)
// // //         IconButton(
// // //           icon: const Icon(Icons.clear_rounded),
// // //           tooltip: 'Clear',
// // //           onPressed: () {
// // //             query = '';
// // //             showSuggestions(context);
// // //           },
// // //         ),
// // //     ];
// // //   }

// // //   @override
// // //   Widget? buildLeading(BuildContext context) {
// // //     return IconButton(
// // //       icon: const Icon(Icons.arrow_back_ios_new_rounded),
// // //       tooltip: 'Back',
// // //       onPressed: () {
// // //         close(context, null);
// // //       },
// // //     );
// // //   }

// // //   @override
// // //   Widget buildResults(BuildContext context) {
// // //     final trimmedQuery = query.trim();

// // //     if (trimmedQuery.isEmpty) {
// // //       return _buildInfoWidget("Please enter a search term.");
// // //     }
// // //     return FutureBuilder<List<Map<String, dynamic>>>(
// // //       future: firestoreService.getVenues(
// // //         searchQuery: trimmedQuery,
// // //         cityFilter: initialCityFilter,
// // //       ),
// // //       builder: (context, snapshot) {
// // //         if (snapshot.connectionState == ConnectionState.waiting) {
// // //           return const Center(child: CircularProgressIndicator());
// // //         }
// // //         if (snapshot.hasError) {
// // //           debugPrint("SearchDelegate Results Error: ${snapshot.error}");
// // //           return _buildErrorWidget(
// // //               "Error searching venues. Please try again.");
// // //         }
// // //         if (!snapshot.hasData || snapshot.data!.isEmpty) {
// // //           return _buildNoResultsWidget();
// // //         }
// // //         final results = snapshot.data!;
// // //         return ListView.builder(
// // //           itemCount: results.length,
// // //           itemBuilder: (context, index) {
// // //             final venue = results[index];
// // //             return _buildVenueListTileForResult(context, venue);
// // //           },
// // //         );
// // //       },
// // //     );
// // //   }

// // //   // <<< MODIFIED: buildSuggestions is completely refactored >>>
// // //   @override
// // //   Widget buildSuggestions(BuildContext context) {
// // //     // Using StatefulBuilder to manage the state of suggestions
// // //     return StatefulBuilder(
// // //       builder: (BuildContext context, StateSetter setState) {
// // //         final String currentQuery = query.trim();

// // //         // This block handles the debouncing logic
// // //         if (currentQuery != _lastQuery) {
// // //           _lastQuery = currentQuery;
// // //           _debounce?.cancel();

// // //           if (currentQuery.isEmpty) {
// // //             // If the query is empty, clear the suggestions immediately
// // //             setState(() {
// // //               _suggestionFuture = null; // Use null to show the initial state
// // //             });
// // //           } else {
// // //             // Otherwise, start a timer to fetch new suggestions
// // //             _debounce = Timer(const Duration(milliseconds: 400), () {
// // //               // Only fetch if the query is still the same after the delay
// // //               if (currentQuery == _lastQuery) {
// // //                 final newFuture = firestoreService.getVenues(
// // //                   searchQuery: currentQuery,
// // //                   cityFilter: initialCityFilter,
// // //                   limit: 10,
// // //                   forSuggestions: true,
// // //                 );
// // //                 // Use setState from StatefulBuilder to update the UI
// // //                 setState(() {
// // //                   _suggestionFuture = newFuture;
// // //                 });
// // //               }
// // //             });
// // //           }
// // //         }
        
// // //         // Show initial message or loading indicator
// // //         if (currentQuery.isEmpty || _suggestionFuture == null) {
// // //           return _buildInfoWidget("Start typing to search for venues...");
// // //         }

// // //         // Use a FutureBuilder to display the suggestions
// // //         return FutureBuilder<List<Map<String, dynamic>>>(
// // //           future: _suggestionFuture,
// // //           builder: (context, snapshot) {
// // //             if (snapshot.connectionState == ConnectionState.waiting) {
// // //               return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// // //             }
// // //             if (snapshot.hasError) {
// // //               debugPrint("Suggestion Error: ${snapshot.error}");
// // //               return _buildErrorWidget("Could not load suggestions.");
// // //             }
// // //             if (!snapshot.hasData || snapshot.data!.isEmpty) {
// // //               return _buildInfoWidget('No suggestions found for "$currentQuery".');
// // //             }

// // //             final suggestions = snapshot.data!;
// // //             return ListView.builder(
// // //               itemCount: suggestions.length,
// // //               itemBuilder: (context, index) {
// // //                 final venue = suggestions[index];
// // //                 return _buildSuggestionTile(context, venue);
// // //               },
// // //             );
// // //           },
// // //         );
// // //       },
// // //     );
// // //   }

// // //   Widget _buildSuggestionTile(BuildContext context, Map<String, dynamic> venue) {
// // //     final String name = venue['name'] as String? ?? 'No Name';
// // //     final String city = venue['city'] as String? ?? '';
// // //     final String venueId = venue['id'] as String;

// // //     return ListTile(
// // //       leading: Icon(Icons.place_outlined, color: Theme.of(context).hintColor),
// // //       title: Text(name),
// // //       subtitle: Text(city, maxLines: 1, overflow: TextOverflow.ellipsis),
// // //       onTap: () {
// // //         close(context, null);
// // //         WidgetsBinding.instance.addPostFrameCallback((_) {
// // //           if (context.mounted) {
// // //             Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(
// // //               builder: (context) => VenueDetailScreen(
// // //                 venueId: venueId,
// // //                 initialVenueData: venue,
// // //               ),
// // //             ));
// // //           }
// // //         });
// // //       },
// // //     );
// // //   }

// // //   Widget _buildVenueListTileForResult(BuildContext context, Map<String, dynamic> venue) {
// // //     final String name = venue['name'] as String? ?? 'No Name';
// // //     final String city = venue['city'] as String? ?? '';
// // //     final String address = venue['address'] as String? ?? '';
// // //     final String venueId = venue['id'] as String;
// // //     final List<String> sports = (venue['sportType'] as List<dynamic>?)?.whereType<String>().toList() ?? [];
// // //     final String? imageUrl = venue['imageUrl'] as String?;
// // //     final double rating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;

// // //     return ListTile(
// // //       leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// // //           ? CircleAvatar(backgroundImage: NetworkImage(imageUrl), radius: 25, backgroundColor: Colors.grey[200])
// // //           : CircleAvatar(child: Icon(Icons.sports_soccer_outlined, size: 20), radius: 25, backgroundColor: Colors.grey[200]),
// // //       title: Text(name, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
// // //       subtitle: Text("${sports.isNotEmpty ? sports.join(', ') : 'Venue'} - ${address.isNotEmpty ? '$address, ' : ''}$city", maxLines: 1, overflow: TextOverflow.ellipsis, style: Theme.of(context).textTheme.bodySmall),
// // //       trailing: rating > 0 ? Row(mainAxisSize: MainAxisSize.min, children: [
// // //                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// // //                 const SizedBox(width: 4),
// // //                 Text(rating.toStringAsFixed(1), style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
// // //               ]) : null,
// // //       onTap: () {
// // //         close(context, null);
// // //         WidgetsBinding.instance.addPostFrameCallback((_) {
// // //           if (context.mounted) {
// // //             Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venueId, initialVenueData: venue)));
// // //           }
// // //         });
// // //       },
// // //     );
// // //   }
  
// // //   // (Helper widgets _buildNoResultsWidget, _buildErrorWidget, _buildInfoWidget are unchanged)

// // //   Widget _buildNoResultsWidget() {
// // //     return Center(
// // //       child: Padding(
// // //         padding: const EdgeInsets.all(20.0),
// // //         child: Column(
// // //           mainAxisAlignment: MainAxisAlignment.center,
// // //           children: [
// // //             Icon(Icons.search_off_rounded, size: 60, color: Colors.grey[400]),
// // //             const SizedBox(height: 15),
// // //             Text('No venues found matching "$query"${initialCityFilter != null ? ' in $initialCityFilter' : ''}.', textAlign: TextAlign.center, style: TextStyle(fontSize: 17, color: Colors.grey[600])),
// // //             const SizedBox(height: 10),
// // //             const Text("Try different keywords or check spelling.", style: TextStyle(color: Colors.grey))
// // //           ],
// // //         ),
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildErrorWidget(String message) {
// // //     return Center(
// // //       child: Padding(
// // //         padding: const EdgeInsets.all(16.0),
// // //         child: Column(
// // //           mainAxisAlignment: MainAxisAlignment.center,
// // //           children: [
// // //             const Icon(Icons.error_outline_rounded, color: Colors.red, size: 50),
// // //             const SizedBox(height: 10),
// // //             Text(message, textAlign: TextAlign.center, style: const TextStyle(color: Colors.redAccent)),
// // //           ],
// // //         ),
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildInfoWidget(String message) {
// // //     return Center(
// // //       child: Padding(
// // //         padding: const EdgeInsets.all(16.0),
// // //         child: Text(message, style: TextStyle(fontSize: 16, color: Colors.grey[600])),
// // //       ),
// // //     );
// // //   }
// // // }

// // ///==web search suggestion clickable--------
// // import 'package:flutter/material.dart';
// // import 'package:flutter/scheduler.dart';
// // import 'dart:async';
// // import 'package:mm_associates/features/data/services/firestore_service.dart';
// // import 'package:mm_associates/features/home/screens/venue_detail_screen.dart';

// // // =========================================================================
// // // MODIFIED SECTION: WebSearchBar now clears text after navigating back.
// // // =========================================================================
// // class WebSearchBar extends StatefulWidget {
// //   final String initialValue;
// //   final String? cityFilter;
// //   final FirestoreService firestoreService;
// //   final Function(String query) onSearchSubmitted;
// //   final Function(String suggestionName) onSuggestionSelected;
// //   final VoidCallback onClear;

// //   const WebSearchBar({
// //     super.key,
// //     required this.initialValue,
// //     required this.cityFilter,
// //     required this.firestoreService,
// //     required this.onSearchSubmitted,
// //     required this.onSuggestionSelected,
// //     required this.onClear,
// //   });

// //   @override
// //   State<WebSearchBar> createState() => _WebSearchBarState();
// // }

// // class _WebSearchBarState extends State<WebSearchBar> {
// //   final TextEditingController _controller = TextEditingController();
// //   final FocusNode _focusNode = FocusNode();
// //   final LayerLink _layerLink = LayerLink();
// //   Timer? _debounce;
// //   OverlayEntry? _overlayEntry;

// //   bool _isLoadingSuggestions = false;
// //   List<Map<String, dynamic>> _suggestions = [];

// //   @override
// //   void initState() {
// //     super.initState();
// //     _controller.text = widget.initialValue;
// //     _controller.addListener(_onTextChanged);
// //     _focusNode.addListener(_onFocusChanged);
// //   }

// //   @override
// //   void didUpdateWidget(covariant WebSearchBar oldWidget) {
// //     super.didUpdateWidget(oldWidget);
// //     if (widget.initialValue != oldWidget.initialValue &&
// //         widget.initialValue != _controller.text) {
// //       _controller.text = widget.initialValue;
// //     }
// //   }

// //   void _onTextChanged() {
// //     if (_debounce?.isActive ?? false) _debounce!.cancel();
// //     _debounce = Timer(const Duration(milliseconds: 500), () {
// //       final query = _controller.text.trim();
// //       if (query.isNotEmpty && _focusNode.hasFocus) {
// //         _fetchSuggestions(query);
// //       } else if (mounted) {
// //         setState(() {
// //           _suggestions = [];
// //         });
// //         _updateOverlay();
// //       }
// //     });
// //     if (mounted) {
// //       setState(() {});
// //     }
// //   }

// //   void _onFocusChanged() {
// //     if (_focusNode.hasFocus) {
// //       _showOverlay();
// //       final query = _controller.text.trim();
// //       if (query.isNotEmpty && _suggestions.isEmpty) {
// //         _fetchSuggestions(query);
// //       }
// //     } else {
// //       _hideOverlay();
// //     }
// //   }

// //   Future<void> _fetchSuggestions(String query) async {
// //     if (!mounted) return;
// //     setState(() => _isLoadingSuggestions = true);
// //     _updateOverlay();

// //     try {
// //       final suggestions = await widget.firestoreService.getVenues(
// //         searchQuery: query,
// //         cityFilter: widget.cityFilter,
// //         limit: 500,
// //         forSuggestions: true,
// //       );
// //       if (!mounted) return;
// //       setState(() {
// //         _suggestions = suggestions;
// //         _isLoadingSuggestions = false;
// //       });
// //     } catch (e) {
// //       debugPrint("Error fetching web search suggestions: $e");
// //       if (!mounted) return;
// //       setState(() {
// //         _suggestions = [];
// //         _isLoadingSuggestions = false;
// //       });
// //     } finally {
// //       _updateOverlay();
// //     }
// //   }

// //   void _showOverlay() {
// //     if (_overlayEntry != null) return;
// //     _overlayEntry = _createOverlayEntry();
// //     Overlay.of(context, rootOverlay: true)?.insert(_overlayEntry!);
// //   }

// //   void _hideOverlay() {
// //     Future.delayed(const Duration(milliseconds: 200), () {
// //       if (!mounted || _focusNode.hasFocus) return;
// //       _overlayEntry?.remove();
// //       _overlayEntry = null;
// //     });
// //   }

// //   void _updateOverlay() {
// //     _overlayEntry?.markNeedsBuild();
// //   }

// //   OverlayEntry _createOverlayEntry() {
// //     final renderBox = context.findRenderObject() as RenderBox;
// //     final size = renderBox.size;
// //     final theme = Theme.of(context);

// //     return OverlayEntry(
// //       builder: (context) => Positioned(
// //         width: size.width,
// //         child: CompositedTransformFollower(
// //           link: _layerLink,
// //           showWhenUnlinked: false,
// //           offset: Offset(0.0, size.height + 4.0),
// //           child: Material(
// //             elevation: 4.0,
// //             borderRadius: BorderRadius.circular(8),
// //             child: Container(
// //               constraints: const BoxConstraints(maxHeight: 250),
// //               decoration: BoxDecoration(
// //                 color: theme.cardColor,
// //                 borderRadius: BorderRadius.circular(8),
// //                 boxShadow: [
// //                   BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 6, offset: const Offset(0, 3)),
// //                 ],
// //               ),
// //               child: _buildSuggestionBody(context, theme),
// //             ),
// //           ),
// //         ),
// //       ),
// //     );
// //   }

// //   Widget _buildSuggestionBody(BuildContext overlayContext, ThemeData theme) {
// //     if (_isLoadingSuggestions) {
// //       return const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)));
// //     }
// //     if (_suggestions.isEmpty) {
// //       return Padding(
// //         padding: const EdgeInsets.all(16.0),
// //         child: Text(
// //           _controller.text.isEmpty && _focusNode.hasFocus ? "Start typing to search..." : "No suggestions found.",
// //           textAlign: TextAlign.center,
// //           style: TextStyle(color: theme.hintColor),
// //         ),
// //       );
// //     }
// //     return ListView.builder(
// //       shrinkWrap: true,
// //       padding: EdgeInsets.zero,
// //       itemCount: _suggestions.length,
// //       itemBuilder: (context, index) {
// //         final venue = _suggestions[index];
// //         final String name = venue['name'] as String? ?? 'N/A';
// //         final String city = venue['city'] as String? ?? '';
// //         final String venueId = venue['id'] as String? ?? '';
        
// //         return ListTile(
// //           title: Text(name, style: const TextStyle(fontSize: 14)),
// //           subtitle: city.isNotEmpty ? Text(city, style: const TextStyle(fontSize: 12)) : null,
// //           dense: true,
// //           contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
// //           // <<< MODIFIED: This function is now async to await navigation result >>>
// //           onTap: () async {
// //             // Unfocus to dismiss the keyboard and the suggestion overlay.
// //             _focusNode.unfocus();
            
// //             // Wait for the user to return from the venue detail screen.
// //             await Navigator.of(overlayContext).push(MaterialPageRoute(
// //                 builder: (context) => VenueDetailScreen(
// //                     venueId: venueId,
// //                     initialVenueData: venue,
// //                 ),
// //             ));
            
// //             // AFTER the user navigates back, clear the controller and notify parent.
// //             if (mounted) {
// //               _controller.clear();
// //               widget.onClear();
// //             }
// //           },
// //         );
// //       },
// //     );
// //   }

// //   @override
// //   void dispose() {
// //     _controller.removeListener(_onTextChanged);
// //     _controller.dispose();
// //     _focusNode.removeListener(_onFocusChanged);
// //     _focusNode.dispose();
// //     _debounce?.cancel();
// //     WidgetsBinding.instance.addPostFrameCallback((_) {
// //       _overlayEntry?.remove();
// //     });
// //     super.dispose();
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final theme = Theme.of(context);
// //     return CompositedTransformTarget(
// //       link: _layerLink,
// //       child: Container(
// //         height: 40,
// //         decoration: BoxDecoration(
// //           color: theme.inputDecorationTheme.fillColor ?? theme.colorScheme.surfaceContainerLowest,
// //           borderRadius: BorderRadius.circular(20),
// //         ),
// //         child: Center(
// //           child: TextField(
// //             controller: _controller,
// //             focusNode: _focusNode,
// //             style: theme.textTheme.bodyMedium,
// //             textAlignVertical: TextAlignVertical.center,
// //             decoration: InputDecoration(
// //               hintText: 'Search venues by name, sport, or city...',
// //               hintStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
// //               prefixIcon: Icon(Icons.search_outlined, color: theme.hintColor, size: 20),
// //               border: InputBorder.none,
// //               contentPadding: const EdgeInsets.only(left: 0, right: 10, top: 11, bottom: 11),
// //               isDense: true,
// //               suffixIcon: _controller.text.isNotEmpty
// //                   ? IconButton(
// //                       icon: Icon(Icons.clear_rounded, size: 20, color: theme.hintColor),
// //                       tooltip: 'Clear Search',
// //                       onPressed: () {
// //                         _controller.clear();
// //                         widget.onClear();
// //                       },
// //                       splashRadius: 18,
// //                       constraints: const BoxConstraints(),
// //                       padding: EdgeInsets.zero,
// //                     )
// //                   : null,
// //             ),
// //             onSubmitted: (value) {
// //               _focusNode.unfocus();
// //               widget.onSearchSubmitted(value);
// //             },
// //           ),
// //         ),
// //       ),
// //     );
// //   }
// // }

// // // =========================================================================
// // // UNCHANGED: The mobile search delegate remains exactly the same.
// // // =========================================================================
// // class VenueSearchDelegate extends SearchDelegate<String?> {
// //   // ... (All code for VenueSearchDelegate is exactly the same and omitted for brevity)
// //   final FirestoreService firestoreService;
// //   final String? initialCityFilter;

// //   Timer? _debounce;
// //   Future<List<Map<String, dynamic>>>? _suggestionFuture;
// //   String _lastQuery = '';

// //   VenueSearchDelegate({
// //     required this.firestoreService,
// //     this.initialCityFilter,
// //   }) : super(
// //           searchFieldLabel: initialCityFilter != null
// //               ? 'Search in $initialCityFilter...'
// //               : 'Search venues...',
// //         );

// //   @override
// //   void dispose() {
// //     _debounce?.cancel();
// //     super.dispose();
// //   }
  
// //   @override
// //   ThemeData appBarTheme(BuildContext context) {
// //     final theme = Theme.of(context);
// //     final Color primaryColor = theme.primaryColor;
// //     final Color appBarFgColor = theme.colorScheme.onPrimary;

// //     return theme.copyWith(
// //       primaryColor: primaryColor,
// //       scaffoldBackgroundColor: theme.canvasColor,
// //       appBarTheme: theme.appBarTheme.copyWith(
// //         backgroundColor: primaryColor,
// //         elevation: 1.0,
// //         iconTheme: IconThemeData(color: appBarFgColor),
// //         actionsIconTheme: IconThemeData(color: appBarFgColor),
// //         titleTextStyle:
// //             theme.textTheme.titleLarge?.copyWith(color: appBarFgColor),
// //         toolbarTextStyle:
// //             theme.textTheme.bodyMedium?.copyWith(color: appBarFgColor),
// //       ),
// //       inputDecorationTheme: InputDecorationTheme(
// //         hintStyle: theme.textTheme.titleMedium
// //             ?.copyWith(color: appBarFgColor.withOpacity(0.7)),
// //         border: InputBorder.none,
// //       ),
// //       textSelectionTheme: TextSelectionThemeData(
// //           cursorColor: appBarFgColor,
// //           selectionColor: appBarFgColor.withOpacity(0.3),
// //           selectionHandleColor: appBarFgColor),
// //     );
// //   }

// //   @override
// //   List<Widget>? buildActions(BuildContext context) {
// //     return [
// //       if (query.isNotEmpty)
// //         IconButton(
// //           icon: const Icon(Icons.search_outlined),
// //           tooltip: 'Search',
// //           onPressed: () {
// //             if (query.trim().isNotEmpty) {
// //               showResults(context);
// //             }
// //           },
// //         ),
// //       if (query.isNotEmpty)
// //         IconButton(
// //           icon: const Icon(Icons.clear_rounded),
// //           tooltip: 'Clear',
// //           onPressed: () {
// //             query = '';
// //             showSuggestions(context);
// //           },
// //         ),
// //     ];
// //   }

// //   @override
// //   Widget? buildLeading(BuildContext context) {
// //     return IconButton(
// //       icon: const Icon(Icons.arrow_back_ios_new_rounded),
// //       tooltip: 'Back',
// //       onPressed: () {
// //         close(context, null);
// //       },
// //     );
// //   }

// //   @override
// //   Widget buildResults(BuildContext context) {
// //     final trimmedQuery = query.trim();

// //     if (trimmedQuery.isEmpty) {
// //       return _buildInfoWidget("Please enter a search term.");
// //     }
// //     return FutureBuilder<List<Map<String, dynamic>>>(
// //       future: firestoreService.getVenues(
// //         searchQuery: trimmedQuery,
// //         cityFilter: initialCityFilter,
// //       ),
// //       builder: (context, snapshot) {
// //         if (snapshot.connectionState == ConnectionState.waiting) {
// //           return const Center(child: CircularProgressIndicator());
// //         }
// //         if (snapshot.hasError) {
// //           debugPrint("SearchDelegate Results Error: ${snapshot.error}");
// //           return _buildErrorWidget(
// //               "Error searching venues. Please try again.");
// //         }
// //         if (!snapshot.hasData || snapshot.data!.isEmpty) {
// //           return _buildNoResultsWidget();
// //         }
// //         final results = snapshot.data!;
// //         return ListView.builder(
// //           itemCount: results.length,
// //           itemBuilder: (context, index) {
// //             final venue = results[index];
// //             return _buildVenueListTileForResult(context, venue);
// //           },
// //         );
// //       },
// //     );
// //   }

// //   @override
// //   Widget buildSuggestions(BuildContext context) {
// //     return StatefulBuilder(
// //       builder: (BuildContext context, StateSetter setState) {
// //         final String currentQuery = query.trim();

// //         if (currentQuery != _lastQuery) {
// //           _lastQuery = currentQuery;
// //           _debounce?.cancel();

// //           if (currentQuery.isEmpty) {
// //             setState(() {
// //               _suggestionFuture = null;
// //             });
// //           } else {
// //             _debounce = Timer(const Duration(milliseconds: 400), () {
// //               if (currentQuery == _lastQuery) {
// //                 final newFuture = firestoreService.getVenues(
// //                   searchQuery: currentQuery,
// //                   cityFilter: initialCityFilter,
// //                   limit: 10,
// //                   forSuggestions: true,
// //                 );
// //                 setState(() {
// //                   _suggestionFuture = newFuture;
// //                 });
// //               }
// //             });
// //           }
// //         }
        
// //         if (currentQuery.isEmpty || _suggestionFuture == null) {
// //           return _buildInfoWidget("Start typing to search for venues...");
// //         }

// //         return FutureBuilder<List<Map<String, dynamic>>>(
// //           future: _suggestionFuture,
// //           builder: (context, snapshot) {
// //             if (snapshot.connectionState == ConnectionState.waiting) {
// //               return const Center(child: CircularProgressIndicator(strokeWidth: 2));
// //             }
// //             if (snapshot.hasError) {
// //               debugPrint("Suggestion Error: ${snapshot.error}");
// //               return _buildErrorWidget("Could not load suggestions.");
// //             }
// //             if (!snapshot.hasData || snapshot.data!.isEmpty) {
// //               return _buildInfoWidget('No suggestions found for "$currentQuery".');
// //             }

// //             final suggestions = snapshot.data!;
// //             return ListView.builder(
// //               itemCount: suggestions.length,
// //               itemBuilder: (context, index) {
// //                 final venue = suggestions[index];
// //                 return _buildSuggestionTile(context, venue);
// //               },
// //             );
// //           },
// //         );
// //       },
// //     );
// //   }

// //   Widget _buildSuggestionTile(BuildContext context, Map<String, dynamic> venue) {
// //     final String name = venue['name'] as String? ?? 'No Name';
// //     final String city = venue['city'] as String? ?? '';
// //     final String venueId = venue['id'] as String;

// //     return ListTile(
// //       leading: Icon(Icons.place_outlined, color: Theme.of(context).hintColor),
// //       title: Text(name),
// //       subtitle: Text(city, maxLines: 1, overflow: TextOverflow.ellipsis),
// //       onTap: () {
// //         close(context, null);
// //         WidgetsBinding.instance.addPostFrameCallback((_) {
// //           if (context.mounted) {
// //             Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(
// //               builder: (context) => VenueDetailScreen(
// //                 venueId: venueId,
// //                 initialVenueData: venue,
// //               ),
// //             ));
// //           }
// //         });
// //       },
// //     );
// //   }

// //   Widget _buildVenueListTileForResult(BuildContext context, Map<String, dynamic> venue) {
// //     final String name = venue['name'] as String? ?? 'No Name';
// //     final String city = venue['city'] as String? ?? '';
// //     final String address = venue['address'] as String? ?? '';
// //     final String venueId = venue['id'] as String;
// //     final List<String> sports = (venue['sportType'] as List<dynamic>?)?.whereType<String>().toList() ?? [];
// //     final String? imageUrl = venue['imageUrl'] as String?;
// //     final double rating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;

// //     return ListTile(
// //       leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
// //           ? CircleAvatar(backgroundImage: NetworkImage(imageUrl), radius: 25, backgroundColor: Colors.grey[200])
// //           : CircleAvatar(child: Icon(Icons.sports_soccer_outlined, size: 20), radius: 25, backgroundColor: Colors.grey[200]),
// //       title: Text(name, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
// //       subtitle: Text("${sports.isNotEmpty ? sports.join(', ') : 'Venue'} - ${address.isNotEmpty ? '$address, ' : ''}$city", maxLines: 1, overflow: TextOverflow.ellipsis, style: Theme.of(context).textTheme.bodySmall),
// //       trailing: rating > 0 ? Row(mainAxisSize: MainAxisSize.min, children: [
// //                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
// //                 const SizedBox(width: 4),
// //                 Text(rating.toStringAsFixed(1), style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
// //               ]) : null,
// //       onTap: () {
// //         close(context, null);
// //         WidgetsBinding.instance.addPostFrameCallback((_) {
// //           if (context.mounted) {
// //             Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venueId, initialVenueData: venue)));
// //           }
// //         });
// //       },
// //     );
// //   }
  
// //   Widget _buildNoResultsWidget() {
// //     return Center(
// //       child: Padding(
// //         padding: const EdgeInsets.all(20.0),
// //         child: Column(
// //           mainAxisAlignment: MainAxisAlignment.center,
// //           children: [
// //             Icon(Icons.search_off_rounded, size: 60, color: Colors.grey[400]),
// //             const SizedBox(height: 15),
// //             Text('No venues found matching "$query"${initialCityFilter != null ? ' in $initialCityFilter' : ''}.', textAlign: TextAlign.center, style: TextStyle(fontSize: 17, color: Colors.grey[600])),
// //             const SizedBox(height: 10),
// //             const Text("Try different keywords or check spelling.", style: TextStyle(color: Colors.grey))
// //           ],
// //         ),
// //       ),
// //     );
// //   }

// //   Widget _buildErrorWidget(String message) {
// //     return Center(
// //       child: Padding(
// //         padding: const EdgeInsets.all(16.0),
// //         child: Column(
// //           mainAxisAlignment: MainAxisAlignment.center,
// //           children: [
// //             const Icon(Icons.error_outline_rounded, color: Colors.red, size: 50),
// //             const SizedBox(height: 10),
// //             Text(message, textAlign: TextAlign.center, style: const TextStyle(color: Colors.redAccent)),
// //           ],
// //         ),
// //       ),
// //     );
// //   }

// //   Widget _buildInfoWidget(String message) {
// //     return Center(
// //       child: Padding(
// //         padding: const EdgeInsets.all(16.0),
// //         child: Text(message, style: TextStyle(fontSize: 16, color: Colors.grey[600])),
// //       ),
// //     );
// //   }
// // }


// ///------venues near you in mobile---

// import 'package:flutter/material.dart';
// import 'package:flutter/scheduler.dart';
// import 'dart:async';
// import 'package:mm_associates/features/data/services/firestore_service.dart';
// import 'package:mm_associates/features/home/screens/venue_detail_screen.dart';

// // =========================================================================
// // MODIFIED SECTION: WebSearchBar now clears text after navigating back.
// // =========================================================================
// class WebSearchBar extends StatefulWidget {
//   final String initialValue;
//   final String? cityFilter;
//   final FirestoreService firestoreService;
//   final Function(String query) onSearchSubmitted;
//   final Function(String suggestionName) onSuggestionSelected;
//   final VoidCallback onClear;

//   const WebSearchBar({
//     super.key,
//     required this.initialValue,
//     required this.cityFilter,
//     required this.firestoreService,
//     required this.onSearchSubmitted,
//     required this.onSuggestionSelected,
//     required this.onClear,
//   });

//   @override
//   State<WebSearchBar> createState() => _WebSearchBarState();
// }

// class _WebSearchBarState extends State<WebSearchBar> {
//   final TextEditingController _controller = TextEditingController();
//   final FocusNode _focusNode = FocusNode();
//   final LayerLink _layerLink = LayerLink();
//   Timer? _debounce;
//   OverlayEntry? _overlayEntry;

//   bool _isLoadingSuggestions = false;
//   List<Map<String, dynamic>> _suggestions = [];

//   @override
//   void initState() {
//     super.initState();
//     _controller.text = widget.initialValue;
//     _controller.addListener(_onTextChanged);
//     _focusNode.addListener(_onFocusChanged);
//   }

//   @override
//   void didUpdateWidget(covariant WebSearchBar oldWidget) {
//     super.didUpdateWidget(oldWidget);
//     if (widget.initialValue != oldWidget.initialValue &&
//         widget.initialValue != _controller.text) {
//       _controller.text = widget.initialValue;
//     }
//   }

//   void _onTextChanged() {
//     if (_debounce?.isActive ?? false) _debounce!.cancel();
//     _debounce = Timer(const Duration(milliseconds: 500), () {
//       final query = _controller.text.trim();
//       if (query.isNotEmpty && _focusNode.hasFocus) {
//         _fetchSuggestions(query);
//       } else if (mounted) {
//         setState(() {
//           _suggestions = [];
//         });
//         _updateOverlay();
//       }
//     });
//     if (mounted) {
//       setState(() {});
//     }
//   }

//   void _onFocusChanged() {
//     if (_focusNode.hasFocus) {
//       _showOverlay();
//       final query = _controller.text.trim();
//       if (query.isNotEmpty && _suggestions.isEmpty) {
//         _fetchSuggestions(query);
//       }
//     } else {
//       _hideOverlay();
//     }
//   }

//   Future<void> _fetchSuggestions(String query) async {
//     if (!mounted) return;
//     setState(() => _isLoadingSuggestions = true);
//     _updateOverlay();

//     try {
//       final suggestions = await widget.firestoreService.getVenues(
//         searchQuery: query,
//         cityFilter: widget.cityFilter,
//         limit: 500,
//         forSuggestions: true,
//       );
//       if (!mounted) return;
//       setState(() {
//         _suggestions = suggestions;
//         _isLoadingSuggestions = false;
//       });
//     } catch (e) {
//       debugPrint("Error fetching web search suggestions: $e");
//       if (!mounted) return;
//       setState(() {
//         _suggestions = [];
//         _isLoadingSuggestions = false;
//       });
//     } finally {
//       _updateOverlay();
//     }
//   }

//   void _showOverlay() {
//     if (_overlayEntry != null) return;
//     _overlayEntry = _createOverlayEntry();
//     Overlay.of(context, rootOverlay: true)?.insert(_overlayEntry!);
//   }

//   void _hideOverlay() {
//     Future.delayed(const Duration(milliseconds: 200), () {
//       if (!mounted || _focusNode.hasFocus) return;
//       _overlayEntry?.remove();
//       _overlayEntry = null;
//     });
//   }

//   void _updateOverlay() {
//     _overlayEntry?.markNeedsBuild();
//   }

//   OverlayEntry _createOverlayEntry() {
//     final renderBox = context.findRenderObject() as RenderBox;
//     final size = renderBox.size;
//     final theme = Theme.of(context);

//     return OverlayEntry(
//       builder: (context) => Positioned(
//         width: size.width,
//         child: CompositedTransformFollower(
//           link: _layerLink,
//           showWhenUnlinked: false,
//           offset: Offset(0.0, size.height + 4.0),
//           child: Material(
//             elevation: 4.0,
//             borderRadius: BorderRadius.circular(8),
//             child: Container(
//               constraints: const BoxConstraints(maxHeight: 250),
//               decoration: BoxDecoration(
//                 color: theme.cardColor,
//                 borderRadius: BorderRadius.circular(8),
//                 boxShadow: [
//                   BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 6, offset: const Offset(0, 3)),
//                 ],
//               ),
//               child: _buildSuggestionBody(context, theme),
//             ),
//           ),
//         ),
//       ),
//     );
//   }

//   Widget _buildSuggestionBody(BuildContext overlayContext, ThemeData theme) {
//     if (_isLoadingSuggestions) {
//       return const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)));
//     }
//     if (_suggestions.isEmpty) {
//       return Padding(
//         padding: const EdgeInsets.all(16.0),
//         child: Text(
//           _controller.text.isEmpty && _focusNode.hasFocus ? "Start typing to search..." : "No suggestions found.",
//           textAlign: TextAlign.center,
//           style: TextStyle(color: theme.hintColor),
//         ),
//       );
//     }
//     return ListView.builder(
//       shrinkWrap: true,
//       padding: EdgeInsets.zero,
//       itemCount: _suggestions.length,
//       itemBuilder: (context, index) {
//         final venue = _suggestions[index];
//         final String name = venue['name'] as String? ?? 'N/A';
//         final String city = venue['city'] as String? ?? '';
//         final String venueId = venue['id'] as String? ?? '';
        
//         return ListTile(
//           title: Text(name, style: const TextStyle(fontSize: 14)),
//           subtitle: city.isNotEmpty ? Text(city, style: const TextStyle(fontSize: 12)) : null,
//           dense: true,
//           contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
//           // <<< MODIFIED: This function is now async to await navigation result >>>
//           onTap: () async {
//             // Unfocus to dismiss the keyboard and the suggestion overlay.
//             _focusNode.unfocus();
            
//             // Wait for the user to return from the venue detail screen.
//             await Navigator.of(overlayContext).push(MaterialPageRoute(
//                 builder: (context) => VenueDetailScreen(
//                     venueId: venueId,
//                     initialVenueData: venue,
//                 ),
//             ));
            
//             // AFTER the user navigates back, clear the controller and notify parent.
//             if (mounted) {
//               _controller.clear();
//               widget.onClear();
//             }
//           },
//         );
//       },
//     );
//   }

//   @override
//   void dispose() {
//     _controller.removeListener(_onTextChanged);
//     _controller.dispose();
//     _focusNode.removeListener(_onFocusChanged);
//     _focusNode.dispose();
//     _debounce?.cancel();
//     WidgetsBinding.instance.addPostFrameCallback((_) {
//       _overlayEntry?.remove();
//     });
//     super.dispose();
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     return CompositedTransformTarget(
//       link: _layerLink,
//       child: Container(
//         height: 40,
//         decoration: BoxDecoration(
//           color: theme.inputDecorationTheme.fillColor ?? theme.colorScheme.surfaceContainerLowest,
//           borderRadius: BorderRadius.circular(20),
//         ),
//         child: Center(
//           child: TextField(
//             controller: _controller,
//             focusNode: _focusNode,
//             style: theme.textTheme.bodyMedium,
//             textAlignVertical: TextAlignVertical.center,
//             decoration: InputDecoration(
//               hintText: 'Search venues by name, sport, or city...',
//               hintStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
//               prefixIcon: Icon(Icons.search_outlined, color: theme.hintColor, size: 20),
//               border: InputBorder.none,
//               contentPadding: const EdgeInsets.only(left: 0, right: 10, top: 11, bottom: 11),
//               isDense: true,
//               suffixIcon: _controller.text.isNotEmpty
//                   ? IconButton(
//                       icon: Icon(Icons.clear_rounded, size: 20, color: theme.hintColor),
//                       tooltip: 'Clear Search',
//                       onPressed: () {
//                         _controller.clear();
//                         widget.onClear();
//                       },
//                       splashRadius: 18,
//                       constraints: const BoxConstraints(),
//                       padding: EdgeInsets.zero,
//                     )
//                   : null,
//             ),
//             onSubmitted: (value) {
//               _focusNode.unfocus();
//               widget.onSearchSubmitted(value);
//             },
//           ),
//         ),
//       ),
//     );
//   }
// }

// // =========================================================================
// // UNCHANGED: The mobile search delegate remains exactly the same.
// // =========================================================================
// class VenueSearchDelegate extends SearchDelegate<String?> {
//   // ... (All code for VenueSearchDelegate is exactly the same and omitted for brevity)
//   final FirestoreService firestoreService;
//   final String? initialCityFilter;

//   Timer? _debounce;
//   Future<List<Map<String, dynamic>>>? _suggestionFuture;
//   String _lastQuery = '';

//   VenueSearchDelegate({
//     required this.firestoreService,
//     this.initialCityFilter,
//   }) : super(
//           searchFieldLabel: initialCityFilter != null
//               ? 'Search in $initialCityFilter...'
//               : 'Search venues...',
//         );

//   @override
//   void dispose() {
//     _debounce?.cancel();
//     super.dispose();
//   }
  
//   @override
//   ThemeData appBarTheme(BuildContext context) {
//     final theme = Theme.of(context);
//     final Color primaryColor = theme.primaryColor;
//     final Color appBarFgColor = theme.colorScheme.onPrimary;

//     return theme.copyWith(
//       primaryColor: primaryColor,
//       scaffoldBackgroundColor: theme.canvasColor,
//       appBarTheme: theme.appBarTheme.copyWith(
//         backgroundColor: primaryColor,
//         elevation: 1.0,
//         iconTheme: IconThemeData(color: appBarFgColor),
//         actionsIconTheme: IconThemeData(color: appBarFgColor),
//         titleTextStyle:
//             theme.textTheme.titleLarge?.copyWith(color: appBarFgColor),
//         toolbarTextStyle:
//             theme.textTheme.bodyMedium?.copyWith(color: appBarFgColor),
//       ),
//       inputDecorationTheme: InputDecorationTheme(
//         hintStyle: theme.textTheme.titleMedium
//             ?.copyWith(color: appBarFgColor.withOpacity(0.7)),
//         border: InputBorder.none,
//       ),
//       textSelectionTheme: TextSelectionThemeData(
//           cursorColor: appBarFgColor,
//           selectionColor: appBarFgColor.withOpacity(0.3),
//           selectionHandleColor: appBarFgColor),
//     );
//   }

//   @override
//   List<Widget>? buildActions(BuildContext context) {
//     return [
//       if (query.isNotEmpty)
//         IconButton(
//           icon: const Icon(Icons.search_outlined),
//           tooltip: 'Search',
//           onPressed: () {
//             if (query.trim().isNotEmpty) {
//               showResults(context);
//             }
//           },
//         ),
//       if (query.isNotEmpty)
//         IconButton(
//           icon: const Icon(Icons.clear_rounded),
//           tooltip: 'Clear',
//           onPressed: () {
//             query = '';
//             showSuggestions(context);
//           },
//         ),
//     ];
//   }

//   @override
//   Widget? buildLeading(BuildContext context) {
//     return IconButton(
//       icon: const Icon(Icons.arrow_back_ios_new_rounded),
//       tooltip: 'Back',
//       onPressed: () {
//         close(context, null);
//       },
//     );
//   }

//   @override
//   Widget buildResults(BuildContext context) {
//     final trimmedQuery = query.trim();

//     if (trimmedQuery.isEmpty) {
//       return _buildInfoWidget("Please enter a search term.");
//     }
//     return FutureBuilder<List<Map<String, dynamic>>>(
//       future: firestoreService.getVenues(
//         searchQuery: trimmedQuery,
//         cityFilter: initialCityFilter,
//       ),
//       builder: (context, snapshot) {
//         if (snapshot.connectionState == ConnectionState.waiting) {
//           return const Center(child: CircularProgressIndicator());
//         }
//         if (snapshot.hasError) {
//           debugPrint("SearchDelegate Results Error: ${snapshot.error}");
//           return _buildErrorWidget(
//               "Error searching venues. Please try again.");
//         }
//         if (!snapshot.hasData || snapshot.data!.isEmpty) {
//           return _buildNoResultsWidget();
//         }
//         final results = snapshot.data!;
//         return ListView.builder(
//           itemCount: results.length,
//           itemBuilder: (context, index) {
//             final venue = results[index];
//             return _buildVenueListTileForResult(context, venue);
//           },
//         );
//       },
//     );
//   }

//   @override
//   Widget buildSuggestions(BuildContext context) {
//     return StatefulBuilder(
//       builder: (BuildContext context, StateSetter setState) {
//         final String currentQuery = query.trim();

//         if (currentQuery != _lastQuery) {
//           _lastQuery = currentQuery;
//           _debounce?.cancel();

//           if (currentQuery.isEmpty) {
//             setState(() {
//               _suggestionFuture = null;
//             });
//           } else {
//             _debounce = Timer(const Duration(milliseconds: 400), () {
//               if (currentQuery == _lastQuery) {
//                 final newFuture = firestoreService.getVenues(
//                   searchQuery: currentQuery,
//                   cityFilter: initialCityFilter,
//                   limit: 10,
//                   forSuggestions: true,
//                 );
//                 setState(() {
//                   _suggestionFuture = newFuture;
//                 });
//               }
//             });
//           }
//         }
        
//         if (currentQuery.isEmpty || _suggestionFuture == null) {
//           return _buildInfoWidget("Start typing to search for venues...");
//         }

//         return FutureBuilder<List<Map<String, dynamic>>>(
//           future: _suggestionFuture,
//           builder: (context, snapshot) {
//             if (snapshot.connectionState == ConnectionState.waiting) {
//               return const Center(child: CircularProgressIndicator(strokeWidth: 2));
//             }
//             if (snapshot.hasError) {
//               debugPrint("Suggestion Error: ${snapshot.error}");
//               return _buildErrorWidget("Could not load suggestions.");
//             }
//             if (!snapshot.hasData || snapshot.data!.isEmpty) {
//               return _buildInfoWidget('No suggestions found for "$currentQuery".');
//             }

//             final suggestions = snapshot.data!;
//             return ListView.builder(
//               itemCount: suggestions.length,
//               itemBuilder: (context, index) {
//                 final venue = suggestions[index];
//                 return _buildSuggestionTile(context, venue);
//               },
//             );
//           },
//         );
//       },
//     );
//   }

//   Widget _buildSuggestionTile(BuildContext context, Map<String, dynamic> venue) {
//     final String name = venue['name'] as String? ?? 'No Name';
//     final String city = venue['city'] as String? ?? '';
//     final String venueId = venue['id'] as String;

//     return ListTile(
//       leading: Icon(Icons.place_outlined, color: Theme.of(context).hintColor),
//       title: Text(name),
//       subtitle: Text(city, maxLines: 1, overflow: TextOverflow.ellipsis),
//       onTap: () {
//         close(context, null);
//         WidgetsBinding.instance.addPostFrameCallback((_) {
//           if (context.mounted) {
//             Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(
//               builder: (context) => VenueDetailScreen(
//                 venueId: venueId,
//                 initialVenueData: venue,
//               ),
//             ));
//           }
//         });
//       },
//     );
//   }

//   Widget _buildVenueListTileForResult(BuildContext context, Map<String, dynamic> venue) {
//     final String name = venue['name'] as String? ?? 'No Name';
//     final String city = venue['city'] as String? ?? '';
//     final String address = venue['address'] as String? ?? '';
//     final String venueId = venue['id'] as String;
//     final List<String> sports = (venue['sportType'] as List<dynamic>?)?.whereType<String>().toList() ?? [];
//     final String? imageUrl = venue['imageUrl'] as String?;
//     final double rating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;

//     return ListTile(
//       leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
//           ? CircleAvatar(backgroundImage: NetworkImage(imageUrl), radius: 25, backgroundColor: Colors.grey[200])
//           : CircleAvatar(child: Icon(Icons.sports_soccer_outlined, size: 20), radius: 25, backgroundColor: Colors.grey[200]),
//       title: Text(name, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
//       subtitle: Text("${sports.isNotEmpty ? sports.join(', ') : 'Venue'} - ${address.isNotEmpty ? '$address, ' : ''}$city", maxLines: 1, overflow: TextOverflow.ellipsis, style: Theme.of(context).textTheme.bodySmall),
//       trailing: rating > 0 ? Row(mainAxisSize: MainAxisSize.min, children: [
//                 Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
//                 const SizedBox(width: 4),
//                 Text(rating.toStringAsFixed(1), style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
//               ]) : null,
//       onTap: () {
//         close(context, null);
//         WidgetsBinding.instance.addPostFrameCallback((_) {
//           if (context.mounted) {
//             Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(builder: (context) => VenueDetailScreen(venueId: venueId, initialVenueData: venue)));
//           }
//         });
//       },
//     );
//   }
  
//   Widget _buildNoResultsWidget() {
//     return Center(
//       child: Padding(
//         padding: const EdgeInsets.all(20.0),
//         child: Column(
//           mainAxisAlignment: MainAxisAlignment.center,
//           children: [
//             Icon(Icons.search_off_rounded, size: 60, color: Colors.grey[400]),
//             const SizedBox(height: 15),
//             Text('No venues found matching "$query"${initialCityFilter != null ? ' in $initialCityFilter' : ''}.', textAlign: TextAlign.center, style: TextStyle(fontSize: 17, color: Colors.grey[600])),
//             const SizedBox(height: 10),
//             const Text("Try different keywords or check spelling.", style: TextStyle(color: Colors.grey))
//           ],
//         ),
//       ),
//     );
//   }

//   Widget _buildErrorWidget(String message) {
//     return Center(
//       child: Padding(
//         padding: const EdgeInsets.all(16.0),
//         child: Column(
//           mainAxisAlignment: MainAxisAlignment.center,
//           children: [
//             const Icon(Icons.error_outline_rounded, color: Colors.red, size: 50),
//             const SizedBox(height: 10),
//             Text(message, textAlign: TextAlign.center, style: const TextStyle(color: Colors.redAccent)),
//           ],
//         ),
//       ),
//     );
//   }

//   Widget _buildInfoWidget(String message) {
//     return Center(
//       child: Padding(
//         padding: const EdgeInsets.all(16.0),
//         child: Text(message, style: TextStyle(fontSize: 16, color: Colors.grey[600])),
//       ),
//     );
//   }
// }


===== features\home\widgets\home_search_components.dart =====

// features/home/widgets/home_search_components.dart

import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'dart:async';
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:mm_associates/features/home/screens/venue_detail_screen.dart';

// =========================================================================
// UNCHANGED: WebSearchBar - This component doesn't navigate directly, it
// just calls back to the HomeScreen, which handles the navigation correctly.
// Therefore, no changes are needed here.
// =========================================================================
class WebSearchBar extends StatefulWidget {
  final String initialValue;
  final String? cityFilter;
  final FirestoreService firestoreService;
  final Function(String query) onSearchSubmitted;
  final Function(String suggestionName) onSuggestionSelected;
  final VoidCallback onClear;

  const WebSearchBar({
    super.key,
    required this.initialValue,
    required this.cityFilter,
    required this.firestoreService,
    required this.onSearchSubmitted,
    required this.onSuggestionSelected,
    required this.onClear,
  });

  @override
  State<WebSearchBar> createState() => _WebSearchBarState();
}

class _WebSearchBarState extends State<WebSearchBar> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  final LayerLink _layerLink = LayerLink();
  Timer? _debounce;
  OverlayEntry? _overlayEntry;

  bool _isLoadingSuggestions = false;
  List<Map<String, dynamic>> _suggestions = [];

  @override
  void initState() {
    super.initState();
    _controller.text = widget.initialValue;
    _controller.addListener(_onTextChanged);
    _focusNode.addListener(_onFocusChanged);
  }

  @override
  void didUpdateWidget(covariant WebSearchBar oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialValue != oldWidget.initialValue &&
        widget.initialValue != _controller.text) {
      _controller.text = widget.initialValue;
    }
  }

  void _onTextChanged() {
    if (_debounce?.isActive ?? false) _debounce!.cancel();
    _debounce = Timer(const Duration(milliseconds: 500), () {
      final query = _controller.text.trim();
      if (query.isNotEmpty && _focusNode.hasFocus) {
        _fetchSuggestions(query);
      } else if (mounted) {
        setState(() {
          _suggestions = [];
        });
        _updateOverlay();
      }
    });
    if (mounted) {
      setState(() {});
    }
  }

  void _onFocusChanged() {
    if (_focusNode.hasFocus) {
      _showOverlay();
      final query = _controller.text.trim();
      if (query.isNotEmpty && _suggestions.isEmpty) {
        _fetchSuggestions(query);
      }
    } else {
      _hideOverlay();
    }
  }

  Future<void> _fetchSuggestions(String query) async {
    if (!mounted) return;
    setState(() => _isLoadingSuggestions = true);
    _updateOverlay();

    try {
      final suggestions = await widget.firestoreService.getVenues(
        searchQuery: query,
        cityFilter: widget.cityFilter,
        limit: 500,
        forSuggestions: true,
      );
      if (!mounted) return;
      setState(() {
        _suggestions = suggestions;
        _isLoadingSuggestions = false;
      });
    } catch (e) {
      debugPrint("Error fetching web search suggestions: $e");
      if (!mounted) return;
      setState(() {
        _suggestions = [];
        _isLoadingSuggestions = false;
      });
    } finally {
      _updateOverlay();
    }
  }

  void _showOverlay() {
    if (_overlayEntry != null) return;
    _overlayEntry = _createOverlayEntry();
    Overlay.of(context, rootOverlay: true)?.insert(_overlayEntry!);
  }

  void _hideOverlay() {
    Future.delayed(const Duration(milliseconds: 200), () {
      if (!mounted || _focusNode.hasFocus) return;
      _overlayEntry?.remove();
      _overlayEntry = null;
    });
  }

  void _updateOverlay() {
    _overlayEntry?.markNeedsBuild();
  }

  OverlayEntry _createOverlayEntry() {
    final renderBox = context.findRenderObject() as RenderBox;
    final size = renderBox.size;
    final theme = Theme.of(context);

    return OverlayEntry(
      builder: (context) => Positioned(
        width: size.width,
        child: CompositedTransformFollower(
          link: _layerLink,
          showWhenUnlinked: false,
          offset: Offset(0.0, size.height + 4.0),
          child: Material(
            elevation: 4.0,
            borderRadius: BorderRadius.circular(8),
            child: Container(
              constraints: const BoxConstraints(maxHeight: 250),
              decoration: BoxDecoration(
                color: theme.cardColor,
                borderRadius: BorderRadius.circular(8),
                boxShadow: [
                  BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 6, offset: const Offset(0, 3)),
                ],
              ),
              child: _buildSuggestionBody(context, theme),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSuggestionBody(BuildContext overlayContext, ThemeData theme) {
    if (_isLoadingSuggestions) {
      return const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)));
    }
    if (_suggestions.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16.0),
        child: Text(
          _controller.text.isEmpty && _focusNode.hasFocus ? "Start typing to search..." : "No suggestions found.",
          textAlign: TextAlign.center,
          style: TextStyle(color: theme.hintColor),
        ),
      );
    }
    return ListView.builder(
      shrinkWrap: true,
      padding: EdgeInsets.zero,
      itemCount: _suggestions.length,
      itemBuilder: (context, index) {
        final venue = _suggestions[index];
        final String name = venue['name'] as String? ?? 'N/A';
        final String city = venue['city'] as String? ?? '';
        final String venueId = venue['id'] as String? ?? '';
        
        return ListTile(
          title: Text(name, style: const TextStyle(fontSize: 14)),
          subtitle: city.isNotEmpty ? Text(city, style: const TextStyle(fontSize: 12)) : null,
          dense: true,
          contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0),
          onTap: () async {
            _focusNode.unfocus();
            await Navigator.of(overlayContext).push(MaterialPageRoute(
                builder: (context) => VenueDetailScreen(
                    venueId: venueId,
                    initialVenueData: venue,
                    // Pass a unique context for hero tags
                    heroTagContext: 'search_web_suggestion',
                ),
            ));
            
            if (mounted) {
              _controller.clear();
              widget.onClear();
            }
          },
        );
      },
    );
  }

  @override
  void dispose() {
    _controller.removeListener(_onTextChanged);
    _controller.dispose();
    _focusNode.removeListener(_onFocusChanged);
    _focusNode.dispose();
    _debounce?.cancel();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _overlayEntry?.remove();
    });
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return CompositedTransformTarget(
      link: _layerLink,
      child: Container(
        height: 40,
        decoration: BoxDecoration(
          color: theme.inputDecorationTheme.fillColor ?? theme.colorScheme.surfaceContainerLowest,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Center(
          child: TextField(
            controller: _controller,
            focusNode: _focusNode,
            style: theme.textTheme.bodyMedium,
            textAlignVertical: TextAlignVertical.center,
            decoration: InputDecoration(
              hintText: 'Search venues by name, sport, or city...',
              hintStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor),
              prefixIcon: Icon(Icons.search_outlined, color: theme.hintColor, size: 20),
              border: InputBorder.none,
              contentPadding: const EdgeInsets.only(left: 0, right: 10, top: 11, bottom: 11),
              isDense: true,
              suffixIcon: _controller.text.isNotEmpty
                  ? IconButton(
                      icon: Icon(Icons.clear_rounded, size: 20, color: theme.hintColor),
                      tooltip: 'Clear Search',
                      onPressed: () {
                        _controller.clear();
                        widget.onClear();
                      },
                      splashRadius: 18,
                      constraints: const BoxConstraints(),
                      padding: EdgeInsets.zero,
                    )
                  : null,
            ),
            onSubmitted: (value) {
              _focusNode.unfocus();
              widget.onSearchSubmitted(value);
            },
          ),
        ),
      ),
    );
  }
}

// =========================================================================
// MODIFIED SECTION: VenueSearchDelegate now passes the heroTagContext.
// =========================================================================
class VenueSearchDelegate extends SearchDelegate<String?> {
  final FirestoreService firestoreService;
  final String? initialCityFilter;

  Timer? _debounce;
  Future<List<Map<String, dynamic>>>? _suggestionFuture;
  String _lastQuery = '';

  VenueSearchDelegate({
    required this.firestoreService,
    this.initialCityFilter,
  }) : super(
          searchFieldLabel: initialCityFilter != null
              ? 'Search in $initialCityFilter...'
              : 'Search venues...',
        );

  @override
  void dispose() {
    _debounce?.cancel();
    super.dispose();
  }
  
  @override
  ThemeData appBarTheme(BuildContext context) {
    // ... same as before
    final theme = Theme.of(context);
    final Color primaryColor = theme.primaryColor;
    final Color appBarFgColor = theme.colorScheme.onPrimary;

    return theme.copyWith(
      primaryColor: primaryColor,
      scaffoldBackgroundColor: theme.canvasColor,
      appBarTheme: theme.appBarTheme.copyWith(
        backgroundColor: primaryColor,
        elevation: 1.0,
        iconTheme: IconThemeData(color: appBarFgColor),
        actionsIconTheme: IconThemeData(color: appBarFgColor),
        titleTextStyle:
            theme.textTheme.titleLarge?.copyWith(color: appBarFgColor),
        toolbarTextStyle:
            theme.textTheme.bodyMedium?.copyWith(color: appBarFgColor),
      ),
      inputDecorationTheme: InputDecorationTheme(
        hintStyle: theme.textTheme.titleMedium
            ?.copyWith(color: appBarFgColor.withOpacity(0.7)),
        border: InputBorder.none,
      ),
      textSelectionTheme: TextSelectionThemeData(
          cursorColor: appBarFgColor,
          selectionColor: appBarFgColor.withOpacity(0.3),
          selectionHandleColor: appBarFgColor),
    );
  }

  @override
  List<Widget>? buildActions(BuildContext context) {
    // ... same as before
    return [
      if (query.isNotEmpty)
        IconButton(
          icon: const Icon(Icons.search_outlined),
          tooltip: 'Search',
          onPressed: () {
            if (query.trim().isNotEmpty) {
              showResults(context);
            }
          },
        ),
      if (query.isNotEmpty)
        IconButton(
          icon: const Icon(Icons.clear_rounded),
          tooltip: 'Clear',
          onPressed: () {
            query = '';
            showSuggestions(context);
          },
        ),
    ];
  }

  @override
  Widget? buildLeading(BuildContext context) {
    // ... same as before
    return IconButton(
      icon: const Icon(Icons.arrow_back_ios_new_rounded),
      tooltip: 'Back',
      onPressed: () {
        close(context, null);
      },
    );
  }

  @override
  Widget buildResults(BuildContext context) {
    // ... same as before
    final trimmedQuery = query.trim();

    if (trimmedQuery.isEmpty) {
      return _buildInfoWidget("Please enter a search term.");
    }
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: firestoreService.getVenues(
        searchQuery: trimmedQuery,
        cityFilter: initialCityFilter,
      ),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          debugPrint("SearchDelegate Results Error: ${snapshot.error}");
          return _buildErrorWidget(
              "Error searching venues. Please try again.");
        }
        if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return _buildNoResultsWidget();
        }
        final results = snapshot.data!;
        return ListView.builder(
          itemCount: results.length,
          itemBuilder: (context, index) {
            final venue = results[index];
            return _buildVenueListTileForResult(context, venue);
          },
        );
      },
    );
  }
  
  @override
  Widget buildSuggestions(BuildContext context) {
    // ... same as before
    return StatefulBuilder(
      builder: (BuildContext context, StateSetter setState) {
        final String currentQuery = query.trim();

        if (currentQuery != _lastQuery) {
          _lastQuery = currentQuery;
          _debounce?.cancel();

          if (currentQuery.isEmpty) {
            setState(() {
              _suggestionFuture = null;
            });
          } else {
            _debounce = Timer(const Duration(milliseconds: 400), () {
              if (currentQuery == _lastQuery) {
                final newFuture = firestoreService.getVenues(
                  searchQuery: currentQuery,
                  cityFilter: initialCityFilter,
                  limit: 10,
                  forSuggestions: true,
                );
                setState(() {
                  _suggestionFuture = newFuture;
                });
              }
            });
          }
        }
        
        if (currentQuery.isEmpty || _suggestionFuture == null) {
          return _buildInfoWidget("Start typing to search for venues...");
        }

        return FutureBuilder<List<Map<String, dynamic>>>(
          future: _suggestionFuture,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator(strokeWidth: 2));
            }
            if (snapshot.hasError) {
              debugPrint("Suggestion Error: ${snapshot.error}");
              return _buildErrorWidget("Could not load suggestions.");
            }
            if (!snapshot.hasData || snapshot.data!.isEmpty) {
              return _buildInfoWidget('No suggestions found for "$currentQuery".');
            }

            final suggestions = snapshot.data!;
            return ListView.builder(
              itemCount: suggestions.length,
              itemBuilder: (context, index) {
                final venue = suggestions[index];
                return _buildSuggestionTile(context, venue);
              },
            );
          },
        );
      },
    );
  }

  // <<< MODIFIED to pass heroTagContext >>>
  Widget _buildSuggestionTile(BuildContext context, Map<String, dynamic> venue) {
    final String name = venue['name'] as String? ?? 'No Name';
    final String city = venue['city'] as String? ?? '';
    final String venueId = venue['id'] as String;

    return ListTile(
      leading: Icon(Icons.place_outlined, color: Theme.of(context).hintColor),
      title: Text(name),
      subtitle: Text(city, maxLines: 1, overflow: TextOverflow.ellipsis),
      onTap: () {
        close(context, null);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (context.mounted) {
            Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(
              builder: (context) => VenueDetailScreen(
                venueId: venueId,
                initialVenueData: venue,
                heroTagContext: 'search_suggestion', // Pass a unique context
              ),
            ));
          }
        });
      },
    );
  }

  // <<< MODIFIED to pass heroTagContext >>>
  Widget _buildVenueListTileForResult(BuildContext context, Map<String, dynamic> venue) {
    final String name = venue['name'] as String? ?? 'No Name';
    final String city = venue['city'] as String? ?? '';
    final String address = venue['address'] as String? ?? '';
    final String venueId = venue['id'] as String;
    final List<String> sports = (venue['sportType'] as List<dynamic>?)?.whereType<String>().toList() ?? [];
    final String? imageUrl = venue['imageUrl'] as String?;
    final double rating = (venue['averageRating'] as num?)?.toDouble() ?? 0.0;

    return ListTile(
      leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
          ? CircleAvatar(backgroundImage: NetworkImage(imageUrl), radius: 25, backgroundColor: Colors.grey[200])
          : CircleAvatar(child: Icon(Icons.sports_soccer_outlined, size: 20), radius: 25, backgroundColor: Colors.grey[200]),
      title: Text(name, style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
      subtitle: Text("${sports.isNotEmpty ? sports.join(', ') : 'Venue'} - ${address.isNotEmpty ? '$address, ' : ''}$city", maxLines: 1, overflow: TextOverflow.ellipsis, style: Theme.of(context).textTheme.bodySmall),
      trailing: rating > 0 ? Row(mainAxisSize: MainAxisSize.min, children: [
                Icon(Icons.star_rounded, color: Colors.amber[600], size: 18),
                const SizedBox(width: 4),
                Text(rating.toStringAsFixed(1), style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
              ]) : null,
      onTap: () {
        close(context, null);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (context.mounted) {
            Navigator.of(context, rootNavigator: false).push(MaterialPageRoute(builder: (context) => VenueDetailScreen(
              venueId: venueId, 
              initialVenueData: venue,
              heroTagContext: 'search_result', // Pass a unique context
            )));
          }
        });
      },
    );
  }
  
  Widget _buildNoResultsWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.search_off_rounded, size: 60, color: Colors.grey[400]),
            const SizedBox(height: 15),
            Text('No venues found matching "$query"${initialCityFilter != null ? ' in $initialCityFilter' : ''}.', textAlign: TextAlign.center, style: TextStyle(fontSize: 17, color: Colors.grey[600])),
            const SizedBox(height: 10),
            const Text("Try different keywords or check spelling.", style: TextStyle(color: Colors.grey))
          ],
        ),
      ),
    );
  }

  Widget _buildErrorWidget(String message) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline_rounded, color: Colors.red, size: 50),
            const SizedBox(height: 10),
            Text(message, textAlign: TextAlign.center, style: const TextStyle(color: Colors.redAccent)),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoWidget(String message) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Text(message, style: TextStyle(fontSize: 16, color: Colors.grey[600])),
      ),
    );
  }
}


===== features\home\widgets\osm_map_picker_screen.dart =====

// // import 'dart:convert';
// // import 'package:flutter/material.dart';
// // import 'package:flutter_map/flutter_map.dart';
// // import 'package:latlong2/latlong.dart' as latlng; // Alias to avoid conflict if Google's LatLng is also imported
// // import 'package:http/http.dart' as http; // For Nominatim reverse geocoding

// // class OsmMapPickerScreen extends StatefulWidget {
// //   final latlng.LatLng? initialPosition;

// //   const OsmMapPickerScreen({super.key, this.initialPosition});

// //   @override
// //   State<OsmMapPickerScreen> createState() => _OsmMapPickerScreenState();
// // }

// // class _OsmMapPickerScreenState extends State<OsmMapPickerScreen> {
// //   final MapController _mapController = MapController();
// //   latlng.LatLng? _pickedLocation;
// //   Marker? _selectedMarker;
// //   String _pickedAddress = "Tap on map to select location";
// //   bool _isLoadingAddress = false;

// //   // A default initial position (e.g., world view or specific region)
// //   static final latlng.LatLng _defaultInitialPosition = latlng.LatLng(20.5937, 78.9629); // India
// //   static const double _defaultInitialZoom = 5.0;
// //   static const double _pickedLocationZoom = 15.0;


// //   @override
// //   void initState() {
// //     super.initState();
// //     if (widget.initialPosition != null) {
// //       _pickedLocation = widget.initialPosition;
// //       // Delay map move until layout is complete, or use addPostFrameCallback
// //       WidgetsBinding.instance.addPostFrameCallback((_) {
// //         if (mounted && _pickedLocation != null) {
// //           _mapController.move(_pickedLocation!, _pickedLocationZoom);
// //           _updateMarkerAndAddress(_pickedLocation!);
// //         }
// //       });
// //     }
// //   }

// //   Future<void> _onMapTap(TapPosition tapPosition, latlng.LatLng position) async {
// //     setState(() {
// //       _pickedLocation = position;
// //     });
// //     await _updateMarkerAndAddress(position);
// //   }

// //   Future<void> _updateMarkerAndAddress(latlng.LatLng position) async {
// //     setState(() {
// //       _isLoadingAddress = true;
// //       _selectedMarker = Marker(
// //         width: 80.0,
// //         height: 80.0,
// //         point: position,
// //         child: Icon(
// //           Icons.location_pin,
// //           color: Colors.red.shade700,
// //           size: 40.0,
// //         ),
// //       );
// //     });

// //     // Nominatim Reverse Geocoding (Free OSM service)
// //     // IMPORTANT: Be mindful of Nominatim's usage policy (max 1 request per second, no bulk)
// //     // https://operations.osmfoundation.org/policies/nominatim/
// //     try {
// //       final url = Uri.parse(
// //           'https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${position.latitude}&lon=${position.longitude}&accept-language=en');
// //       final response = await http.get(url, headers: {
// //         'User-Agent': 'YourAppName/1.0 (your-email@example.com)' // Good practice to set User-Agent
// //       });

// //       if (response.statusCode == 200) {
// //         final data = json.decode(response.body);
// //         if (mounted) {
// //           setState(() {
// //             _pickedAddress = data['display_name'] ?? 'Address not found';
// //           });
// //         }
// //       } else {
// //         if (mounted) {
// //           setState(() {
// //             _pickedAddress = 'Failed to fetch address (${response.statusCode})';
// //           });
// //         }
// //       }
// //     } catch (e) {
// //       debugPrint("Nominatim Error: $e");
// //       if (mounted) {
// //         setState(() {
// //           _pickedAddress = 'Could not fetch address';
// //         });
// //       }
// //     } finally {
// //       if (mounted) {
// //         setState(() {
// //           _isLoadingAddress = false;
// //         });
// //       }
// //     }
// //   }


// //   void _confirmLocation() {
// //     if (_pickedLocation != null) {
// //       Navigator.pop(context, _pickedLocation);
// //     } else {
// //       ScaffoldMessenger.of(context).showSnackBar(
// //         const SnackBar(content: Text('Please select a location on the map first.')),
// //       );
// //     }
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     return Scaffold(
// //       appBar: AppBar(
// //         title: const Text('Pick Location (OSM)'),
// //         actions: [
// //           if (_pickedLocation != null)
// //             IconButton(
// //               icon: const Icon(Icons.check),
// //               onPressed: _confirmLocation,
// //               tooltip: 'Confirm Location',
// //             ),
// //         ],
// //       ),
// //       body: Stack(
// //         children: [
// //           FlutterMap(
// //             mapController: _mapController,
// //             options: MapOptions(
// //               initialCenter: widget.initialPosition ?? _pickedLocation ?? _defaultInitialPosition,
// //               initialZoom: widget.initialPosition != null || _pickedLocation != null ? _pickedLocationZoom : _defaultInitialZoom,
// //               onTap: _onMapTap,
// //               // interactionOptions: const InteractionOptions( // Keep defaults, they are good
// //               //   flags: InteractiveFlag.all & ~InteractiveFlag.rotate,
// //               // ),
// //             ),
// //             children: [
// //               TileLayer(
// //                 urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
// //                 userAgentPackageName: 'com.example.yourappname', // Replace with your app's package name
// //                 // Additional tile providers can be found here:
// //                 // https://wiki.openstreetmap.org/wiki/Tile_servers
// //               ),
// //               if (_selectedMarker != null) MarkerLayer(markers: [_selectedMarker!]),
// //               // You can add more layers like attribution, etc.
// //               RichAttributionWidget(
// //                 attributions: [
// //                   TextSourceAttribution(
// //                     'OpenStreetMap contributors',
// //                     onTap: () {
// //                       // launchUrl(Uri.parse('https://openstreetmap.org/copyright')); // Requires url_launcher
// //                     },
// //                   ),
// //                 ],
// //                 alignment: AttributionAlignment.bottomLeft,
// //               ),
// //             ],
// //           ),
// //           // Simple Zoom Buttons
// //           Positioned(
// //             right: 15,
// //             bottom: 90, // Adjust to be above the info panel
// //             child: Column(
// //               children: <Widget>[
// //                 FloatingActionButton.small(
// //                   heroTag: "zoomInBtn",
// //                   onPressed: () {
// //                     _mapController.move(_mapController.camera.center, _mapController.camera.zoom + 1);
// //                   },
// //                   child: const Icon(Icons.add),
// //                 ),
// //                 const SizedBox(height: 8),
// //                 FloatingActionButton.small(
// //                   heroTag: "zoomOutBtn",
// //                   onPressed: () {
// //                     _mapController.move(_mapController.camera.center, _mapController.camera.zoom - 1);
// //                   },
// //                   child: const Icon(Icons.remove),
// //                 ),
// //               ],
// //             ),
// //           ),
// //           Positioned(
// //             bottom: 0,
// //             left: 0,
// //             right: 0,
// //             child: Material(
// //               elevation: 4.0,
// //               child: Container(
// //                 padding: const EdgeInsets.all(12.0),
// //                 color: Theme.of(context).scaffoldBackgroundColor.withOpacity(0.95),
// //                 child: Column(
// //                   mainAxisSize: MainAxisSize.min,
// //                   crossAxisAlignment: CrossAxisAlignment.start,
// //                   children: [
// //                     Text(
// //                       _pickedLocation != null
// //                           ? 'Selected: Lat: ${_pickedLocation!.latitude.toStringAsFixed(5)}, Lng: ${_pickedLocation!.longitude.toStringAsFixed(5)}'
// //                           : 'No location selected',
// //                       style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
// //                     ),
// //                     const SizedBox(height: 4),
// //                     _isLoadingAddress
// //                       ? const Row(children: [SizedBox(height: 16, width:16, child: CircularProgressIndicator(strokeWidth: 2)), SizedBox(width: 8), Text("Fetching address...")])
// //                       : Text(_pickedAddress, style: Theme.of(context).textTheme.bodySmall, maxLines: 2, overflow: TextOverflow.ellipsis,),
// //                     const SizedBox(height: 10),
// //                     if (_pickedLocation != null)
// //                       SizedBox(
// //                         width: double.infinity,
// //                         child: ElevatedButton.icon(
// //                           icon: const Icon(Icons.check_circle_outline),
// //                           label: const Text('Use This Location'),
// //                           onPressed: _confirmLocation,
// //                         ),
// //                       ),
// //                   ],
// //                 ),
// //               ),
// //             ),
// //           ),
// //         ],
// //       ),
// //     );
// //   }
// // }
// import 'dart:convert';
// import 'package:flutter/material.dart';
// import 'package:flutter_map/flutter_map.dart';
// import 'package:geolocator/geolocator.dart'; // <<< ADD FOR CURRENT LOCATION
// import 'package:latlong2/latlong.dart' as latlng;
// import 'package:http/http.dart' as http;

// class OsmMapPickerScreen extends StatefulWidget {
//   final latlng.LatLng? initialPosition; // From previous form or last pick

//   const OsmMapPickerScreen({super.key, this.initialPosition});

//   @override
//   State<OsmMapPickerScreen> createState() => _OsmMapPickerScreenState();
// }

// class _OsmMapPickerScreenState extends State<OsmMapPickerScreen> {
//   final MapController _mapController = MapController();
//   latlng.LatLng? _pickedLocation;
//   Marker? _selectedMarker;
//   String _pickedAddress = "Tap on map to select location";
//   bool _isLoadingAddress = false;
//   bool _isFetchingCurrentLocation = false; // <<< NEW STATE

//   // A sensible default if no initial position or current location is found
//   static final latlng.LatLng _defaultFallbackPosition = latlng.LatLng(20.5937, 78.9629); // India
//   static const double _defaultInitialZoom = 5.0;
//   static const double _focusedZoom = 15.0; // Zoom level when a location is set

//   @override
//   void initState() {
//     super.initState();
//     _initializeMapPosition();
//   }

//   Future<void> _initializeMapPosition() async {
//     if (widget.initialPosition != null) {
//       _pickedLocation = widget.initialPosition;
//       _moveToPosition(widget.initialPosition!, _focusedZoom, updateMarkerAndAddress: true);
//     } else {
//       // Try to get current location if no initial position is provided
//       await _tryGetCurrentLocationAndMove();
//     }
//   }

//   Future<void> _tryGetCurrentLocationAndMove({bool updateMarkerAndAddress = false}) async {
//     if (!mounted) return;
//     setState(() {
//       _isFetchingCurrentLocation = true;
//     });

//     bool serviceEnabled;
//     LocationPermission permission;

//     serviceEnabled = await Geolocator.isLocationServiceEnabled();
//     if (!serviceEnabled) {
//       if(mounted) {
//         ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Location services are disabled.')));
//         _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom); // Move to default
//         setState(() => _isFetchingCurrentLocation = false);
//       }
//       return;
//     }

//     permission = await Geolocator.checkPermission();
//     if (permission == LocationPermission.denied) {
//       permission = await Geolocator.requestPermission();
//       if (permission == LocationPermission.denied) {
//         if(mounted) {
//           ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Location permissions are denied.')));
//           _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom); // Move to default
//           setState(() => _isFetchingCurrentLocation = false);
//         }
//         return;
//       }
//     }

//     if (permission == LocationPermission.deniedForever) {
//       if(mounted) {
//         ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Location permissions are permanently denied, we cannot request permissions.')));
//         _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom); // Move to default
//         setState(() => _isFetchingCurrentLocation = false);
//       }
//       return;
//     }

//     try {
//       Position currentPosition = await Geolocator.getCurrentPosition(
//         desiredAccuracy: LocationAccuracy.high,
//         timeLimit: const Duration(seconds: 10) // Timeout for fetching location
//       );
//       if (!mounted) return;
//       final currentLatLng = latlng.LatLng(currentPosition.latitude, currentPosition.longitude);
//       _pickedLocation = currentLatLng; // Tentatively set picked location
//       _moveToPosition(currentLatLng, _focusedZoom, updateMarkerAndAddress: updateMarkerAndAddress);
//     } catch (e) {
//       debugPrint("Error fetching current location: $e");
//       if(mounted) {
//           ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Could not fetch current location. Moving to default.')));
//         _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom); // Move to default on error
//       }
//     } finally {
//       if (mounted) {
//         setState(() {
//           _isFetchingCurrentLocation = false;
//         });
//       }
//     }
//   }


//   // Helper to move map and optionally update marker/address
//   void _moveToPosition(latlng.LatLng position, double zoom, {bool updateMarkerAndAddress = false}) {
//     // Use addPostFrameCallback to ensure map is ready for move, especially during init
//     WidgetsBinding.instance.addPostFrameCallback((_) {
//       if (mounted) {
//         _mapController.move(position, zoom);
//         if (updateMarkerAndAddress) {
//           _updateMarkerAndAddress(position);
//         }
//       }
//     });
//   }


//   Future<void> _onMapTap(TapPosition tapPosition, latlng.LatLng position) async {
//     if (mounted) {
//       setState(() {
//         _pickedLocation = position;
//         // Optionally move camera to keep tapped point centered if desired
//         // _mapController.move(position, _mapController.camera.zoom);
//       });
//     }
//     await _updateMarkerAndAddress(position);
//   }

//   Future<void> _updateMarkerAndAddress(latlng.LatLng position) async {
//     if (!mounted) return;
//     setState(() {
//       _isLoadingAddress = true;
//       _selectedMarker = Marker(
//         width: 80.0,
//         height: 80.0,
//         point: position,
//         child: Icon(
//           Icons.location_pin,
//           color: Colors.red.shade700,
//           size: 40.0,
//         ),
//       );
//     });

//     try {
//       final url = Uri.parse(
//           'https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${position.latitude}&lon=${position.longitude}&accept-language=en');
//       final response = await http.get(url, headers: {
//         'User-Agent': 'YourAppName/1.0 (your.email@example.com)'
//       }).timeout(const Duration(seconds: 10));

//       if (!mounted) return;

//       if (response.statusCode == 200) {
//         final data = json.decode(response.body);
//         setState(() {
//           _pickedAddress = data['display_name'] ?? 'Address not found for this pin.';
//           if (_pickedAddress.isEmpty) _pickedAddress = 'Address not found for this pin.';
//         });
//       } else {
//         setState(() {
//           _pickedAddress = 'Failed to fetch address (Code: ${response.statusCode})';
//         });
//       }
//     } catch (e) {
//       debugPrint("Nominatim Error: $e");
//       if (mounted) {
//         setState(() {
//           _pickedAddress = 'Could not fetch address. Check connection.';
//         });
//       }
//     } finally {
//       if (mounted) {
//         setState(() {
//           _isLoadingAddress = false;
//         });
//       }
//     }
//   }

//   void _confirmLocation() {
//     if (_pickedLocation != null) {
//       Navigator.pop(context, _pickedLocation);
//     } else {
//        if(mounted) {
//         ScaffoldMessenger.of(context).showSnackBar(
//           const SnackBar(content: Text('Please tap on the map to select a location first.')),
//         );
//       }
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       appBar: AppBar(
//         title: const Text('Pick Location (OSM)'),
//         actions: [
//           if (_pickedLocation != null)
//             IconButton(
//               icon: const Icon(Icons.check),
//               onPressed: _confirmLocation,
//               tooltip: 'Confirm Location',
//             ),
//         ],
//       ),
//       body: Stack(
//         children: [
//           FlutterMap(
//             mapController: _mapController,
//             options: MapOptions(
//               // initialCenter will be handled by _initializeMapPosition or _moveToPosition
//               initialCenter: _pickedLocation ?? widget.initialPosition ?? _defaultFallbackPosition,
//               initialZoom: _pickedLocation != null || widget.initialPosition != null
//                            ? _focusedZoom
//                            : _defaultInitialZoom,
//               onTap: _onMapTap,
//             ),
//             children: [
//               TileLayer(
//                 urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
//                 userAgentPackageName: 'your.app.package.name', // IMPORTANT
//               ),
//               if (_selectedMarker != null) MarkerLayer(markers: [_selectedMarker!]),
//               RichAttributionWidget(
//                 attributions: [
//                   TextSourceAttribution(
//                     'OpenStreetMap contributors',
//                     onTap: () { /* Consider launching OSM copyright URL */ },
//                   ),
//                 ],
//                 alignment: AttributionAlignment.bottomLeft,
//               ),
//             ],
//           ),
//           // "My Location" Button and Zoom Buttons
//           Positioned(
//             right: 15,
//             bottom: 160, // Adjust to be above the info panel
//             child: Column(
//               mainAxisSize: MainAxisSize.min,
//               children: <Widget>[
//                 // My Location Button
//                 FloatingActionButton( // Changed to full size for more prominence
//                   heroTag: "osmMyLocationBtn",
//                   onPressed: _isFetchingCurrentLocation ? null : () => _tryGetCurrentLocationAndMove(updateMarkerAndAddress: true),
//                   child: _isFetchingCurrentLocation
//                       ? const SizedBox(width: 24, height: 24, child: CircularProgressIndicator(strokeWidth: 3, color: Colors.white))
//                       : const Icon(Icons.my_location),
//                   tooltip: 'Go to My Location',
//                 ),
//                 const SizedBox(height: 16), // Increased spacing
//                 // Zoom In
//                 FloatingActionButton.small(
//                   heroTag: "osmZoomInBtn",
//                   onPressed: () {
//                     var currentZoom = _mapController.camera.zoom;
//                     _mapController.move(_mapController.camera.center, currentZoom + 1);
//                   },
//                   child: const Icon(Icons.add),
//                 ),
//                 const SizedBox(height: 8),
//                 // Zoom Out
//                 FloatingActionButton.small(
//                   heroTag: "osmZoomOutBtn",
//                   onPressed: () {
//                      var currentZoom = _mapController.camera.zoom;
//                     _mapController.move(_mapController.camera.center, currentZoom - 1);
//                   },
//                   child: const Icon(Icons.remove),
//                 ),
//               ],
//             ),
//           ),
//           // Info Panel (same as before)
//           Positioned(
//             bottom: 0,
//             left: 0,
//             right: 0,
//             child: Material( /* ... same info panel code ... */
//               elevation: 4.0,
//               child: Container(
//                 padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
//                 color: Theme.of(context).cardColor.withOpacity(0.95),
//                 child: Column(
//                   mainAxisSize: MainAxisSize.min,
//                   crossAxisAlignment: CrossAxisAlignment.stretch,
//                   children: [
//                     Text(
//                       _pickedLocation != null
//                           ? 'Lat: ${_pickedLocation!.latitude.toStringAsFixed(5)}, Lng: ${_pickedLocation!.longitude.toStringAsFixed(5)}'
//                           : 'No location selected',
//                       style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
//                       textAlign: TextAlign.center,
//                     ),
//                     const SizedBox(height: 4),
//                     if (_isLoadingAddress)
//                       const Row(
//                         mainAxisAlignment: MainAxisAlignment.center,
//                         children: [
//                           SizedBox(height: 14, width: 14, child: CircularProgressIndicator(strokeWidth: 2)),
//                           SizedBox(width: 8),
//                           Text("Fetching address...")
//                         ]
//                       )
//                     else
//                       Text(
//                         _pickedAddress,
//                         style: Theme.of(context).textTheme.bodySmall,
//                         textAlign: TextAlign.center,
//                         maxLines: 2,
//                         overflow: TextOverflow.ellipsis,
//                       ),
//                     const SizedBox(height: 10),
//                     if (_pickedLocation != null)
//                       ElevatedButton.icon(
//                         icon: const Icon(Icons.check_circle_outline),
//                         label: const Text('Use This Location'),
//                         onPressed: _confirmLocation,
//                       ),
//                   ],
//                 ),
//               ),
//             ),
//           ),
//         ],
//       ),
//     );
//   }
// }

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:geolocator/geolocator.dart';
import 'package:latlong2/latlong.dart' as latlng;
import 'package:http/http.dart' as http;
// If you want to launch URLs for attribution:
// import 'package:url_launcher/url_launcher.dart';

class OsmMapPickerScreen extends StatefulWidget {
  final latlng.LatLng? initialPosition;

  const OsmMapPickerScreen({super.key, this.initialPosition});

  @override
  State<OsmMapPickerScreen> createState() => _OsmMapPickerScreenState();
}

class _OsmMapPickerScreenState extends State<OsmMapPickerScreen> {
  final MapController _mapController = MapController();
  latlng.LatLng? _pickedLocation;
  Marker? _selectedMarker;
  String _pickedAddress = "Tap on map to select location";
  bool _isLoadingAddress = false;
  bool _isFetchingCurrentLocation = false;

  static final latlng.LatLng _defaultFallbackPosition = latlng.LatLng(20.5937, 78.9629);
  static const double _defaultInitialZoom = 5.0;
  static const double _focusedZoom = 15.0;
  static const double _maxAllowedZoom = 20.0; // <<< INCREASED MAX ZOOM ALLOWED IN MAPOPTIONS
  static const int _maxTileLayerNativeZoom = 19; // <<< Max zoom provided by default OSM tiles (approx)
  static const int _maxTileLayerDisplayZoom = 20; // <<< Allow overzooming default tiles a bit


  // --- Tile Server Configuration ---
  // You can easily swap these out for testing different tile servers
  // Remember to check their usage policies and attribution!
  
  // Default OSM
  final String _tileUrlTemplate = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
  final List<String> _tileSubdomains = const []; // No subdomains for default OSM
  final String _tileAttributionText = 'OpenStreetMap contributors';
  final String? _tileAttributionUrl = 'https://openstreetmap.org/copyright';
  final int _currentTileMaxNativeZoom = _maxTileLayerNativeZoom;
  final int _currentTileMaxDisplayZoom = _maxTileLayerDisplayZoom;

  // Example: OpenTopoMap (check policy)
  // final String _tileUrlTemplate = 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png';
  // final List<String> _tileSubdomains = const ['a', 'b', 'c'];
  // final String _tileAttributionText = '© OpenTopoMap (CC-BY-SA)';
  // final String? _tileAttributionUrl = 'https://opentopomap.org';
  // final int _currentTileMaxNativeZoom = 17; // OpenTopoMap might have different max native zoom
  // final int _currentTileMaxDisplayZoom = 18;

  // Example: Stadia Maps OSM Bright (REQUIRES API KEY & registration)
  // final String _yourStadiaApiKey = 'YOUR_STADIA_API_KEY_HERE'; // Replace this
  // final String _tileUrlTemplate = 'https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}.png?api_key=$_yourStadiaApiKey';
  // final List<String> _tileSubdomains = const [];
  // final String _tileAttributionText = '© Stadia Maps, © OpenMapTiles © OpenStreetMap contributors';
  // final String? _tileAttributionUrl = 'https://stadiamaps.com/';
  // final int _currentTileMaxNativeZoom = 20; // Stadia offers higher native zoom
  // final int _currentTileMaxDisplayZoom = 22;


  @override
  void initState() {
    super.initState();
    _initializeMapPosition();
  }

  Future<void> _initializeMapPosition() async {
    // ... (same as before)
    if (widget.initialPosition != null) {
      _pickedLocation = widget.initialPosition;
      _moveToPosition(widget.initialPosition!, _focusedZoom, updateMarkerAndAddress: true);
    } else {
      await _tryGetCurrentLocationAndMove();
    }
  }

  Future<void> _tryGetCurrentLocationAndMove({bool updateMarkerAndAddress = false}) async {
    // ... (same as before)
     if (!mounted) return;
    setState(() {
      _isFetchingCurrentLocation = true;
    });

    bool serviceEnabled;
    LocationPermission permission;

    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      if(mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Location services are disabled.')));
        _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom);
        setState(() => _isFetchingCurrentLocation = false);
      }
      return;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        if(mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Location permissions are denied.')));
          _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom);
          setState(() => _isFetchingCurrentLocation = false);
        }
        return;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      if(mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Location permissions are permanently denied.')));
        _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom);
        setState(() => _isFetchingCurrentLocation = false);
      }
      return;
    }

    try {
      Position currentPosition = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10)
      );
      if (!mounted) return;
      final currentLatLng = latlng.LatLng(currentPosition.latitude, currentPosition.longitude);
      _pickedLocation = currentLatLng; 
      _moveToPosition(currentLatLng, _focusedZoom, updateMarkerAndAddress: updateMarkerAndAddress);
    } catch (e) {
      debugPrint("Error fetching current location: $e");
      if(mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Could not fetch current location.')));
        _moveToPosition(_defaultFallbackPosition, _defaultInitialZoom);
      }
    } finally {
      if (mounted) {
        setState(() {
          _isFetchingCurrentLocation = false;
        });
      }
    }
  }

  void _moveToPosition(latlng.LatLng position, double zoom, {bool updateMarkerAndAddress = false}) {
    // ... (same as before)
     WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _mapController.move(position, zoom);
        if (updateMarkerAndAddress) {
          _updateMarkerAndAddress(position);
        }
      }
    });
  }

  Future<void> _onMapTap(TapPosition tapPosition, latlng.LatLng position) async {
    // ... (same as before)
     if (mounted) {
      setState(() {
        _pickedLocation = position;
      });
    }
    await _updateMarkerAndAddress(position);
  }

  Future<void> _updateMarkerAndAddress(latlng.LatLng position) async {
    // ... (same as before, but ensure User-Agent is set correctly for Nominatim)
     if (!mounted) return;
    setState(() {
      _isLoadingAddress = true;
      _selectedMarker = Marker(
        width: 80.0,
        height: 80.0,
        point: position,
        child: Icon(
          Icons.location_pin,
          color: Colors.red.shade700,
          size: 40.0,
        ),
      );
    });

    try {
      final url = Uri.parse(
          'https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${position.latitude}&lon=${position.longitude}&accept-language=en');
      final response = await http.get(url, headers: {
        // IMPORTANT: Replace with your actual app name and contact email for Nominatim policy
        'User-Agent': 'YourAppName/1.0 (contact@yourappdomain.com)' 
      }).timeout(const Duration(seconds: 10));

      if (!mounted) return;

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        setState(() {
          _pickedAddress = data['display_name'] ?? 'Address not found for this pin.';
          if (_pickedAddress.isEmpty) _pickedAddress = 'Address not found for this pin.';
        });
      } else {
        setState(() {
          _pickedAddress = 'Failed to fetch address (Code: ${response.statusCode})';
        });
      }
    } catch (e) {
      debugPrint("Nominatim Error: $e");
      if (mounted) {
        setState(() {
          _pickedAddress = 'Could not fetch address. Check connection.';
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoadingAddress = false;
        });
      }
    }
  }

  void _confirmLocation() {
    // ... (same as before)
    if (_pickedLocation != null) {
      Navigator.pop(context, _pickedLocation);
    } else {
       if(mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Please tap on the map to select a location first.')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Pick Location (OSM)'),
        // ... (actions same as before)
        actions: [
          if (_pickedLocation != null)
            IconButton(
              icon: const Icon(Icons.check),
              onPressed: _confirmLocation,
              tooltip: 'Confirm Location',
            ),
        ],
      ),
      body: Stack(
        children: [
          FlutterMap(
            mapController: _mapController,
            options: MapOptions(
              initialCenter: _pickedLocation ?? widget.initialPosition ?? _defaultFallbackPosition,
              initialZoom: _pickedLocation != null || widget.initialPosition != null
                           ? _focusedZoom
                           : _defaultInitialZoom,
              maxZoom: _maxAllowedZoom, // <<< Use the defined max zoom for map interaction
              minZoom: 3.0, // Prevent zooming out too far
              onTap: _onMapTap,
            ),
            children: [
              TileLayer(
                urlTemplate: _tileUrlTemplate, // Use configured tile URL
                subdomains: _tileSubdomains,    // Use configured subdomains
                userAgentPackageName: 'your.app.package.name', // IMPORTANT
                maxZoom: _currentTileMaxDisplayZoom.toDouble(),         // <<< Max zoom for this tile layer (display)
                maxNativeZoom: _currentTileMaxNativeZoom,  // <<< Native max zoom of this tile layer
                // tileProvider: CancellableNetworkTileProvider(), // Good for performance and cancelling requests
              ),
              if (_selectedMarker != null) MarkerLayer(markers: [_selectedMarker!]),
              RichAttributionWidget(
                attributions: [
                  TextSourceAttribution(
                    _tileAttributionText, // Use configured attribution text
                    onTap: () async {
                      if (_tileAttributionUrl != null) {
                        // final Uri attributionUri = Uri.parse(_tileAttributionUrl!);
                        // if (await canLaunchUrl(attributionUri)) {
                        //   await launchUrl(attributionUri);
                        // }
                        // Note: url_launcher would be needed here. For simplicity, omitting actual launch.
                        debugPrint("Attribution tapped: $_tileAttributionUrl");
                      }
                    },
                  ),
                ],
                alignment: AttributionAlignment.bottomLeft,
              ),
            ],
          ),
          // ... (My Location Button and Zoom Buttons - same layout as before)
          Positioned(
            right: 15,
            bottom: 160,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                FloatingActionButton( 
                  heroTag: "osmMyLocationBtn",
                  onPressed: _isFetchingCurrentLocation ? null : () => _tryGetCurrentLocationAndMove(updateMarkerAndAddress: true),
                  child: _isFetchingCurrentLocation
                      ? const SizedBox(width: 24, height: 24, child: CircularProgressIndicator(strokeWidth: 3, color: Colors.white))
                      : const Icon(Icons.my_location),
                  tooltip: 'Go to My Location',
                ),
                const SizedBox(height: 16),
                FloatingActionButton.small(
                  heroTag: "osmZoomInBtn",
                  onPressed: () {
                    var newZoom = _mapController.camera.zoom + 1;
                    if (newZoom <= _maxAllowedZoom) { // Respect overall max zoom
                         _mapController.move(_mapController.camera.center, newZoom);
                    }
                  },
                  child: const Icon(Icons.add),
                ),
                const SizedBox(height: 8),
                FloatingActionButton.small(
                  heroTag: "osmZoomOutBtn",
                  onPressed: () {
                     var newZoom = _mapController.camera.zoom - 1;
                      _mapController.move(_mapController.camera.center, newZoom);
                  },
                  child: const Icon(Icons.remove),
                ),
              ],
            ),
          ),
          // ... (Info Panel - same layout as before)
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Material(
              elevation: 4.0,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
                color: Theme.of(context).cardColor.withOpacity(0.95),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(
                      _pickedLocation != null
                          ? 'Lat: ${_pickedLocation!.latitude.toStringAsFixed(5)}, Lng: ${_pickedLocation!.longitude.toStringAsFixed(5)}'
                          : 'No location selected',
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 4),
                    if (_isLoadingAddress)
                      const Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          SizedBox(height: 14, width: 14, child: CircularProgressIndicator(strokeWidth: 2)),
                          SizedBox(width: 8),
                          Text("Fetching address...")
                        ]
                      )
                    else
                      Text(
                        _pickedAddress,
                        style: Theme.of(context).textTheme.bodySmall,
                        textAlign: TextAlign.center,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    const SizedBox(height: 10),
                    if (_pickedLocation != null)
                      ElevatedButton.icon(
                        icon: const Icon(Icons.check_circle_outline),
                        label: const Text('Use This Location'),
                        onPressed: _confirmLocation,
                      ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== features\profile\screens\edit_profile_screen.dart =====

import 'dart:async';
import 'dart:convert'; 
import 'dart:typed_data'; 

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:mm_associates/features/user/services/user_service.dart';

class EditProfileScreen extends StatefulWidget {
  final String currentName;
  final String currentEmail;
  final String? currentPhone;
  final String? currentProfilePicUrl; // Expects a Cloudinary URL or null
  final String? currentBio;
  final DateTime? currentDateOfBirth;
  final String? currentGender;
  final String? currentAddressStreet;
  final String? currentAddressCity;
  final String? currentAddressState;
  final String? currentAddressZipCode;
  final String? currentAddressCountry;
  final String? currentSocialMediaLink;

  const EditProfileScreen({
    required this.currentName,
    required this.currentEmail,
    this.currentPhone,
    this.currentProfilePicUrl,
    this.currentBio,
    this.currentDateOfBirth,
    this.currentGender,
    this.currentAddressStreet,
    this.currentAddressCity,
    this.currentAddressState,
    this.currentAddressZipCode,
    this.currentAddressCountry,
    this.currentSocialMediaLink,
    super.key,
  });

  @override
  State<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends State<EditProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  final UserService _userService = UserService();
  final ImagePicker _picker = ImagePicker();

  late TextEditingController _phoneController;
  late TextEditingController _bioController;
  late TextEditingController _dobController;
  late TextEditingController _addressStreetController;
  late TextEditingController _addressCityController;
  late TextEditingController _addressStateController;
  late TextEditingController _addressZipController;
  late TextEditingController _addressCountryController;
  late TextEditingController _socialMediaController;

  XFile? _selectedXFile;
  Uint8List? _newlyPickedImageBytes; // For preview of newly picked image

  String? _localProfilePicUrl; // Holds current Cloudinary URL (or old data URI)
  DateTime? _selectedDate;
  String? _selectedGender;
  bool _isLoading = false;
  String? _errorMessage;

  String _initialPhoneNumber = '';
  String _initialBio = '';
  String _initialAddressStreet = '';
  String _initialAddressCity = '';
  String _initialAddressState = '';
  String _initialAddressZip = '';
  String _initialAddressCountry = '';
  String _initialSocialMediaLink = '';
  DateTime? _initialDateOfBirth;
  String? _initialGender;
  String? _initialProfilePicUrl;

  final FocusNode _phoneFocusNode = FocusNode();
  final FocusNode _bioFocusNode = FocusNode();
  final FocusNode _dobFocusNode = FocusNode();
  final FocusNode _genderFocusNode = FocusNode();
  final FocusNode _addressStreetFocusNode = FocusNode();
  final FocusNode _addressCityFocusNode = FocusNode();
  final FocusNode _addressStateFocusNode = FocusNode();
  final FocusNode _addressZipFocusNode = FocusNode();
  final FocusNode _addressCountryFocusNode = FocusNode();
  final FocusNode _socialMediaFocusNode = FocusNode();

  final List<String> _addressValidationTips = [
    'Street Address', 'City', 'State/Province', 'Zip/Postal Code', 'Country'
  ];
  final List<String> _genderOptions = ['Male', 'Female', 'Other', 'Prefer not to say'];
  static const double _inputPaddingHorizontal = 0;
  static const EdgeInsets _fieldPadding = EdgeInsets.symmetric(vertical: 10.0);
  static const double _buttonBorderRadius = 12.0;

  @override
  void initState() {
    super.initState();
    _localProfilePicUrl = widget.currentProfilePicUrl;
    _initialProfilePicUrl = widget.currentProfilePicUrl;

    _phoneController = TextEditingController(text: widget.currentPhone ?? '');
    _initialPhoneNumber = widget.currentPhone ?? '';

    _bioController = TextEditingController(text: widget.currentBio ?? '');
    _initialBio = widget.currentBio ?? '';

    _selectedDate = widget.currentDateOfBirth;
    _initialDateOfBirth = widget.currentDateOfBirth;
    _dobController = TextEditingController(
        text: _selectedDate != null ? DateFormat('dd MMMM yyyy').format(_selectedDate!) : '');

    _selectedGender = (widget.currentGender != null && _genderOptions.contains(widget.currentGender!))
        ? widget.currentGender!
        : null;
    _initialGender = _selectedGender;

    _addressStreetController = TextEditingController(text: widget.currentAddressStreet ?? '');
    _initialAddressStreet = widget.currentAddressStreet ?? '';
    _addressCityController = TextEditingController(text: widget.currentAddressCity ?? '');
    _initialAddressCity = widget.currentAddressCity ?? '';
    _addressStateController = TextEditingController(text: widget.currentAddressState ?? '');
    _initialAddressState = widget.currentAddressState ?? '';
    _addressZipController = TextEditingController(text: widget.currentAddressZipCode ?? '');
    _initialAddressZip = widget.currentAddressZipCode ?? '';
    _addressCountryController = TextEditingController(text: widget.currentAddressCountry ?? '');
    _initialAddressCountry = widget.currentAddressCountry ?? '';
    _socialMediaController = TextEditingController(text: widget.currentSocialMediaLink ?? '');
    _initialSocialMediaLink = widget.currentSocialMediaLink ?? '';
  }

  @override
  void dispose() {
    _phoneController.dispose();
    _bioController.dispose();
    _dobController.dispose();
    _addressStreetController.dispose();
    _addressCityController.dispose();
    _addressStateController.dispose();
    _addressZipController.dispose();
    _addressCountryController.dispose();
    _socialMediaController.dispose();

    _phoneFocusNode.dispose();
    _bioFocusNode.dispose();
    _dobFocusNode.dispose();
    _genderFocusNode.dispose();
    _addressStreetFocusNode.dispose();
    _addressCityFocusNode.dispose();
    _addressStateFocusNode.dispose();
    _addressZipFocusNode.dispose();
    _addressCountryFocusNode.dispose();
    _socialMediaFocusNode.dispose();
    super.dispose();
  }

  bool _hasUnsavedChanges() {
    if (_isLoading) return false;
    if (_selectedXFile != null) return true;
    if (_localProfilePicUrl == null && _initialProfilePicUrl != null) return true; // Image removed
    // This case covers if a URL changed NOT due to _selectedXFile (e.g. pasting a URL directly, if that feature existed)
    // For now, XFile handles explicit new images.
    // if (_localProfilePicUrl != _initialProfilePicUrl && _selectedXFile == null) return true;


    if (_phoneController.text.trim() != _initialPhoneNumber.trim()) return true;
    if (_bioController.text.trim() != _initialBio.trim()) return true;
    if (_addressStreetController.text.trim() != _initialAddressStreet.trim()) return true;
    if (_addressCityController.text.trim() != _initialAddressCity.trim()) return true;
    if (_addressStateController.text.trim() != _initialAddressState.trim()) return true;
    if (_addressZipController.text.trim() != _initialAddressZip.trim()) return true;
    if (_addressCountryController.text.trim() != _initialAddressCountry.trim()) return true;
    if (_socialMediaController.text.trim() != _initialSocialMediaLink.trim()) return true;
    if (_selectedDate != _initialDateOfBirth) return true;
    if (_selectedGender != _initialGender) return true;
    return false;
  }

  Future<bool> _onWillPop() async {
    if (_hasUnsavedChanges()) {
      final result = await showDialog<String>(
        context: context,
        builder: (BuildContext dialogContext) {
          final theme = Theme.of(dialogContext);
          return AlertDialog(
            title: const Text('Unsaved Changes'),
            content: const Text('You have unsaved changes. Do you want to save them before leaving?'),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
            actions: <Widget>[
              TextButton(
                child: Text('Discard', style: TextStyle(color: theme.colorScheme.error)),
                onPressed: () => Navigator.of(dialogContext).pop('discard'),
              ),
              TextButton(
                child: const Text('Cancel'),
                onPressed: () => Navigator.of(dialogContext).pop('cancel'),
              ),
              // MODIFIED: Changed ElevatedButton to TextButton for "Save Changes"
              TextButton(
                child: Text('Save Changes', style: TextStyle(color: theme.colorScheme.primary, fontWeight: FontWeight.bold)),
                onPressed: () {
                  Navigator.of(dialogContext).pop('save');
                }
              ),
            ],
          );
        },
      );
      if (result == 'save') {
        await _saveChanges(); // This will handle popping if successful
        return false; // Don't pop immediately, let _saveChanges handle it
      } else if (result == 'discard') {
        return true; // Allow pop
      } else { // cancel or null
        return false; // Don't pop
      }
    }
    return true; // No unsaved changes, allow pop
  }

  Future<void> _pickImage(ImageSource source) async {
    if (_isLoading) return;
    try {
      final XFile? pickedFile = await _picker.pickImage(
        source: source, imageQuality: 70, maxWidth: 1024, maxHeight: 1024,
      );
      if (pickedFile != null && mounted) {
        Uint8List imageBytes = await pickedFile.readAsBytes();
        if (imageBytes.isEmpty && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("Picked image appears to be empty."), backgroundColor: Colors.orange),
          );
          return;
        }
        setState(() {
          _selectedXFile = pickedFile;
          _newlyPickedImageBytes = imageBytes;
          _localProfilePicUrl = null; // Clear any existing URL if new image is picked
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Error picking image: ${e.toString()}"), backgroundColor: Colors.redAccent),
        );
      }
    }
  }

  Future<void> _selectDate() async {
    if (_isLoading) return;
    FocusScope.of(context).unfocus();
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime(1920, 1),
      lastDate: DateTime.now().add(const Duration(days: 365)), // Allow future date for flexibility if needed
    );
    if (picked != null && picked != _selectedDate && mounted) {
      setState(() {
        _selectedDate = picked;
        _dobController.text = DateFormat('dd MMMM yyyy').format(_selectedDate!);
      });
    }
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate()) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Please fix the errors in the form."), backgroundColor: Colors.orange),
      );
      return;
    }
    FocusScope.of(context).unfocus();
    setState(() { _isLoading = true; _errorMessage = null; });

    Map<String, dynamic> dataToUpdate = {};
    String? finalCloudinaryUrlToStoreInFirestore = _localProfilePicUrl; // Start with current, possibly null

    // 1. Handle Profile Picture
    if (_selectedXFile != null) { // A new image was picked
      try {
        finalCloudinaryUrlToStoreInFirestore = await _userService.uploadProfilePicture(_selectedXFile!);
        dataToUpdate['profilePictureUrl'] = finalCloudinaryUrlToStoreInFirestore;
      } catch (uploadError) {
        if (mounted) {
          setState(() {
            _errorMessage = "Image upload failed: ${uploadError.toString().replaceFirst("Exception: ", "")}";
            _isLoading = false;
          });
        }
        return;
      }
    } else if (_localProfilePicUrl == null && _initialProfilePicUrl != null) {
      // Image was explicitly removed (local URL is null, but there was an initial URL)
      finalCloudinaryUrlToStoreInFirestore = null;
      dataToUpdate['profilePictureUrl'] = FieldValue.delete(); // Or null, depending on Firestore preference
    }
    // If _selectedXFile is null AND _localProfilePicUrl is NOT null, and _localProfilePicUrl is same as initial,
    // then no image change is intended from the user's direct action via picker/remove.
    // If _localProfilePicUrl IS NOT NULL and DIFFERENT from _initialProfilePicUrl BUT _selectedXFile is null,
    // this state shouldn't typically occur with current UI (localProfilePicUrl only becomes null via removal, or non-null via picker).
    // This logic prioritizes _selectedXFile.

    // 2. Handle Text Fields and Other Data
    _updateFieldIfNeeded(dataToUpdate, 'phoneNumber', _phoneController.text, _initialPhoneNumber);
    _updateFieldIfNeeded(dataToUpdate, 'bio', _bioController.text, _initialBio);
    _updateFieldIfNeeded(dataToUpdate, 'addressStreet', _addressStreetController.text, _initialAddressStreet);
    _updateFieldIfNeeded(dataToUpdate, 'addressCity', _addressCityController.text, _initialAddressCity);
    _updateFieldIfNeeded(dataToUpdate, 'addressState', _addressStateController.text, _initialAddressState);
    _updateFieldIfNeeded(dataToUpdate, 'addressZipCode', _addressZipController.text, _initialAddressZip);
    _updateFieldIfNeeded(dataToUpdate, 'addressCountry', _addressCountryController.text, _initialAddressCountry);
    _updateFieldIfNeeded(dataToUpdate, 'socialMediaLink', _socialMediaController.text, _initialSocialMediaLink);

    if (_selectedGender != _initialGender) {
      dataToUpdate['gender'] = _selectedGender; // Can be null if "Prefer not to say" or deselected
    }
    if (_selectedDate != _initialDateOfBirth) {
      dataToUpdate['dateOfBirth'] = _selectedDate != null ? Timestamp.fromDate(_selectedDate!) : null;
    }
    
    // Check if actual data to update, including specific handling for profilePictureUrl if it was just set by upload
    // but its value is the same as initial (though this is less likely if upload provides a new unique URL).
    // The main check is if dataToUpdate map has entries.
    bool actualUpdateOccurred = dataToUpdate.isNotEmpty;

    try {
      if (actualUpdateOccurred) {
        await _userService.updateUserProfileData(dataToUpdate);

        // Update initial values to current ones after successful save
        _initialPhoneNumber = _phoneController.text.trim();
        _initialBio = _bioController.text.trim();
        _initialAddressStreet = _addressStreetController.text.trim();
        _initialAddressCity = _addressCityController.text.trim();
        _initialAddressState = _addressStateController.text.trim();
        _initialAddressZip = _addressZipController.text.trim();
        _initialAddressCountry = _addressCountryController.text.trim();
        _initialSocialMediaLink = _socialMediaController.text.trim();
        _initialDateOfBirth = _selectedDate;
        _initialGender = _selectedGender;
        _initialProfilePicUrl = finalCloudinaryUrlToStoreInFirestore;


        if (mounted) {
          setState(() {
             // Update UI state based on what was saved
            _localProfilePicUrl = finalCloudinaryUrlToStoreInFirestore; // This should be the URL now in Firestore
            _selectedXFile = null; // Clear picked file
            _newlyPickedImageBytes = null; // Clear preview bytes
            _isLoading = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text("Profile updated successfully!"), backgroundColor: Colors.green),
          );
          if (Navigator.canPop(context)) Navigator.pop(context, true); // Indicate success
        }
      } else {
         if (mounted) {
          setState(() => _isLoading = false);
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("No changes detected to save.")));
          if (Navigator.canPop(context)) Navigator.pop(context, false); // Indicate no changes made
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
           _errorMessage = "Profile update failed: ${e.toString().replaceFirst("Exception: ", "")}";
           _isLoading = false;
        });
      }
    }
    // This finally block was redundant as _isLoading=false is handled in success/no-change/catch.
    // finally {
    //   if (mounted) setState(() => _isLoading = false);
    // }
  }

  void _updateFieldIfNeeded(Map<String, dynamic> data, String key, String newValue, String? oldValue) {
    final String trimmedNew = newValue.trim();
    final String currentOld = oldValue?.trim() ?? '';
    if (trimmedNew != currentOld) {
      data[key] = trimmedNew.isEmpty ? FieldValue.delete() : trimmedNew; // Use FieldValue.delete() to remove field or set to null
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return WillPopScope(
      onWillPop: _onWillPop,
      child: IgnorePointer(
        ignoring: _isLoading,
        child: Scaffold(
          appBar: AppBar(
            title: const Text("Edit Profile"),
            backgroundColor: theme.scaffoldBackgroundColor,
            foregroundColor: theme.colorScheme.onSurface,
            elevation: 0.5,
            actions: [
              if (_isLoading)
                const Padding(
                  padding: EdgeInsets.only(right: 16.0),
                  child: Center(child: SizedBox(width: 24, height: 24, child: CircularProgressIndicator(strokeWidth: 3))),
                ),
              // MODIFIED: Removed save icon from AppBar
              // IconButton(
              //   icon: Icon(Icons.save_outlined, color: theme.colorScheme.primary),
              //   tooltip: 'Save Changes',
              //   onPressed: (_isLoading || !_hasUnsavedChanges()) ? null : _saveChanges,
              // ),
            ],
          ),
          body: _buildBody(theme),
        ),
      ),
    );
  }

  Widget _buildInfoTile(ThemeData theme, {required IconData icon, required String title, required String subtitle}) {
    return ListTile(
      leading: Icon(icon, color: theme.colorScheme.secondary, size: 22),
      title: Text(title, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w500)),
      subtitle: Text(subtitle, style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor)),
      dense: true,
      contentPadding: const EdgeInsets.symmetric(horizontal: _inputPaddingHorizontal, vertical: 4.0),
    );
  }

  Widget _buildBody(ThemeData theme) {
    Widget formContent = Form(
      key: _formKey,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          _buildProfilePictureSection(theme),
          const SizedBox(height: 20.0),
          _buildInfoTile(theme, icon: Icons.badge_outlined, title: widget.currentName, subtitle: "Name"),
          _buildInfoTile(theme, icon: Icons.alternate_email_outlined, title: widget.currentEmail, subtitle: "Email"),
          const SizedBox(height: 24.0),
          _buildPhoneField(theme),
          const SizedBox(height: 16.0),
          _buildBioField(theme),
          const SizedBox(height: 16.0),
          _buildDateField(theme),
          const SizedBox(height: 16.0),
          _buildGenderField(theme),
          const SizedBox(height: 16.0),
          _buildAddressFields(theme),
          const SizedBox(height: 16.0),
          _buildSocialMediaField(theme),
          const SizedBox(height: 32.0),
          _buildSaveButton(theme),
          const SizedBox(height: 16.0),
          if (_errorMessage != null)
            Padding(
              padding: const EdgeInsets.only(bottom: 16.0),
              child: Text(
                _errorMessage!,
                textAlign: TextAlign.center,
                style: TextStyle(color: theme.colorScheme.error, fontSize: 14),
              ),
            ),
        ],
      ),
    );

    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
        child: Container(
          constraints: BoxConstraints(
            maxWidth: 550,
            maxHeight: MediaQuery.of(context).size.height * 0.85,
          ),
          decoration: BoxDecoration(
            color: theme.cardColor,
            borderRadius: BorderRadius.circular(16.0),
            border: Border.all(color: theme.dividerColor.withOpacity(0.5), width: 1.0),
            boxShadow: [ BoxShadow(color: Colors.black.withOpacity(0.08), blurRadius: 12.0, offset: const Offset(0, 4)), ],
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(15.0),
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24.0),
              keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
              child: formContent,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildProfilePictureSection(ThemeData theme) {
    ImageProvider? displayImage;

    if (_newlyPickedImageBytes != null) { // Highest priority: a newly picked image
      displayImage = MemoryImage(_newlyPickedImageBytes!);
    } else if (_localProfilePicUrl != null && _localProfilePicUrl!.isNotEmpty) {
      if (_localProfilePicUrl!.startsWith('http')) { // Cloudinary URL
          displayImage = NetworkImage(_localProfilePicUrl!);
      } else if (_localProfilePicUrl!.startsWith('data:image')) { // Old base64 data URI (for backward compatibility)
         try {
            final parts = _localProfilePicUrl!.split(',');
            if (parts.length == 2) {
              displayImage = MemoryImage(base64Decode(parts[1]));
            }
          } catch (e) { debugPrint("Error decoding old base64 data for preview: $e");}
      }
    }

    return Center(
      child: Stack(
        children: [
          CircleAvatar(
            radius: 60,
            backgroundColor: theme.colorScheme.surfaceContainerHighest,
            foregroundImage: displayImage,
            onForegroundImageError: displayImage != null
              ? (exception, stackTrace) {
                  debugPrint('Error loading profile picture into CircleAvatar: $exception');
                }
              : null,
            child: (displayImage == null)
                ? Icon(Icons.person_outline, size: 60, color: theme.colorScheme.onSurfaceVariant)
                : null,
          ),
          Positioned(
            bottom: 0, right: 0,
            child: GestureDetector(
              onTap: () => _showImageSourceSheet(theme),
              child: CircleAvatar(radius: 20, backgroundColor: theme.colorScheme.primary,
                  child: Icon(Icons.camera_alt_outlined, size: 20, color: theme.colorScheme.onPrimary)),
            ),
          ),
          if (_newlyPickedImageBytes != null || (_localProfilePicUrl != null && _localProfilePicUrl!.isNotEmpty))
            Positioned(
              bottom: 0, left: 0,
              child: GestureDetector(
                onTap: () {
                  setState(() {
                    _selectedXFile = null;
                    _newlyPickedImageBytes = null;
                    _localProfilePicUrl = null; // This flags for removal on save if _initialProfilePicUrl was not null
                  });
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text("Profile picture will be removed on save.")),
                    );
                  }
                },
                child: CircleAvatar(radius: 20, backgroundColor: Colors.red[400],
                    child: Icon(Icons.delete_outline, size: 20, color: theme.colorScheme.onPrimary)),
              ),
            ),
        ],
      ),
    );
  }

  void _showImageSourceSheet(ThemeData theme) {
    showModalBottomSheet(
      context: context,
      builder: (bottomSheetContext) => SafeArea(
        child: Wrap(children: <Widget>[
          ListTile(
            leading: Icon(Icons.photo_library_outlined, color: theme.colorScheme.primary),
            title: const Text('Photo Library'),
            onTap: () { Navigator.pop(bottomSheetContext); _pickImage(ImageSource.gallery); },
          ),
          ListTile(
            leading: Icon(Icons.camera_alt_outlined, color: theme.colorScheme.primary),
            title: const Text('Camera'),
            onTap: () { Navigator.pop(bottomSheetContext); _pickImage(ImageSource.camera); },
          ),
        ]),
      ),
    );
  }

  Widget _buildPhoneField(ThemeData theme) {
    return _buildTextField(
      controller: _phoneController,
      focusNode: _phoneFocusNode,
      labelText: 'Phone Number',
      hintText: 'Enter your phone number (e.g., +1234567890)',
      theme: theme,
      keyboardType: TextInputType.phone,
      textInputAction: TextInputAction.next,
      onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_bioFocusNode),
      validator: (value) {
        if (value == null || value.trim().isEmpty) return null;
        final phoneRegExp = RegExp(r'^\+?[0-9\s-]{7,15}$');
        if (!phoneRegExp.hasMatch(value.trim())) return 'Please enter a valid phone number';
        return null;
      },
      inputFormatters: [FilteringTextInputFormatter.allow(RegExp(r'[0-9+\s-]'))],
      onChanged: (_) => setState(() {}), // MODIFIED: Added for save button state update
    );
  }

  Widget _buildBioField(ThemeData theme) {
    return _buildTextField(
      controller: _bioController,
      focusNode: _bioFocusNode,
      labelText: 'Bio',
      hintText: 'Tell us about yourself...',
      theme: theme,
      minLines: 1, maxLines: 4,
      keyboardType: TextInputType.multiline,
      textInputAction: TextInputAction.newline, // Use newline for multiline bio
      validator: (value) => null,
      onChanged: (_) => setState(() {}), // MODIFIED: Added for save button state update
    );
  }

  Widget _buildDateField(ThemeData theme) {
    return _buildTextField(
      controller: _dobController,
      focusNode: _dobFocusNode,
      labelText: 'Date of Birth',
      hintText: 'Select your date of birth',
      theme: theme,
      readOnly: true,
      onTap: _selectDate, // setState is handled within _selectDate
      suffixIcon: Icon(Icons.calendar_today_outlined, color: theme.colorScheme.primary),
      validator: (value) => null,
    );
  }

  Widget _buildGenderField(ThemeData theme) {
    return Padding(
      padding: _fieldPadding,
      child: DropdownButtonFormField<String>(
        focusNode: _genderFocusNode,
        decoration: _inputDecoration(labelText: 'Gender', hintText: 'Select your gender', theme: theme),
        items: [
          DropdownMenuItem<String>(value: null, child: Text('Select your gender', style: TextStyle(color: theme.hintColor))),
          ..._genderOptions.map((String gender) => DropdownMenuItem<String>(value: gender, child: Text(gender))),
        ],
        value: _selectedGender,
        onChanged: (String? newValue) {
          setState(() => _selectedGender = newValue); // This setState handles update for _hasUnsavedChanges
          FocusScope.of(context).requestFocus(_addressStreetFocusNode);
        },
        validator: (value) => null,
        style: theme.textTheme.bodyMedium,
        icon: Icon(Icons.arrow_drop_down, color: theme.colorScheme.primary),
        elevation: 2,
        dropdownColor: theme.colorScheme.surface,
      ),
    );
  }

  Widget _buildAddressFields(ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(bottom: 0.0, left: _inputPaddingHorizontal),
          child: Text("Address", style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
        ),
        _buildTextField(
            controller: _addressStreetController, focusNode: _addressStreetFocusNode,
            labelText: _addressValidationTips[0], theme: theme, keyboardType: TextInputType.streetAddress,
            textInputAction: TextInputAction.next, onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_addressCityFocusNode),
            validator: (v) => null, onChanged: (_) => setState(() {})), // MODIFIED
        _buildTextField(
            controller: _addressCityController, focusNode: _addressCityFocusNode,
            labelText: _addressValidationTips[1], theme: theme, keyboardType: TextInputType.text,
            textInputAction: TextInputAction.next, onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_addressStateFocusNode),
            validator: (v) => null, onChanged: (_) => setState(() {})), // MODIFIED
        _buildTextField(
            controller: _addressStateController, focusNode: _addressStateFocusNode,
            labelText: _addressValidationTips[2], theme: theme, keyboardType: TextInputType.text,
            textInputAction: TextInputAction.next, onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_addressZipFocusNode),
            validator: (v) => null, onChanged: (_) => setState(() {})), // MODIFIED
        _buildTextField(
            controller: _addressZipController, focusNode: _addressZipFocusNode,
            labelText: _addressValidationTips[3], theme: theme, keyboardType: TextInputType.text,
            textInputAction: TextInputAction.next, onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_addressCountryFocusNode),
            validator: (v) => null, onChanged: (_) => setState(() {})), // MODIFIED
        _buildTextField(
            controller: _addressCountryController, focusNode: _addressCountryFocusNode,
            labelText: _addressValidationTips[4], theme: theme, keyboardType: TextInputType.text,
            textInputAction: TextInputAction.next, onFieldSubmitted: (_) => FocusScope.of(context).requestFocus(_socialMediaFocusNode),
            validator: (v) => null, onChanged: (_) => setState(() {})), // MODIFIED
      ],
    );
  }

  Widget _buildSocialMediaField(ThemeData theme) {
    return _buildTextField(
      controller: _socialMediaController,
      focusNode: _socialMediaFocusNode,
      labelText: 'Social Media Link',
      hintText: 'e.g., https://linkedin.com/in/yourprofile',
      theme: theme,
      keyboardType: TextInputType.url,
      textInputAction: TextInputAction.done,
      onFieldSubmitted: (_) => _saveChanges(),
      validator: (value) {
        if (value != null && value.trim().isNotEmpty) {
          final Uri? uri = Uri.tryParse(value.trim());
          if (uri == null || !uri.isAbsolute || (uri.scheme != 'http' && uri.scheme != 'https')) {
            return 'Please enter a valid URL (e.g., http://...)';
          }
        }
        return null;
      },
      suffixIcon: Icon(Icons.link_outlined, color: theme.colorScheme.primary),
      onChanged: (_) => setState(() {}), // MODIFIED: Added for save button state update
    );
  }

  Widget _buildTextField({
    required TextEditingController controller,
    FocusNode? focusNode,
    required String labelText,
    String? hintText,
    required ThemeData theme,
    TextInputType keyboardType = TextInputType.text,
    int? minLines,
    int? maxLines = 1,
    bool readOnly = false,
    VoidCallback? onTap,
    Widget? suffixIcon,
    String? Function(String?)? validator,
    List<TextInputFormatter>? inputFormatters,
    TextInputAction? textInputAction,
    Function(String)? onFieldSubmitted,
    ValueChanged<String>? onChanged, // Added onChanged parameter
  }) {
    return Padding(
      padding: _fieldPadding,
      child: TextFormField(
        controller: controller,
        focusNode: focusNode,
        decoration: _inputDecoration(labelText: labelText, hintText: hintText, theme: theme, suffixIcon: suffixIcon),
        keyboardType: keyboardType,
        minLines: minLines,
        maxLines: (keyboardType == TextInputType.multiline && (maxLines ?? 1) > 1 ) ? maxLines : 1,
        readOnly: readOnly,
        onTap: onTap,
        validator: validator,
        style: theme.textTheme.bodyMedium,
        cursorColor: theme.colorScheme.primary,
        inputFormatters: inputFormatters,
        textInputAction: textInputAction,
        onFieldSubmitted: onFieldSubmitted,
        onChanged: onChanged, // MODIFIED: Used here
        textCapitalization: (keyboardType == TextInputType.name ||
                             keyboardType == TextInputType.streetAddress ||
                            (keyboardType == TextInputType.text &&
                             (labelText.toLowerCase().contains('city') ||
                              labelText.toLowerCase().contains('state') ||
                              labelText.toLowerCase().contains('country'))))
                            ? TextCapitalization.words
                            : (keyboardType == TextInputType.multiline)
                                ? TextCapitalization.sentences
                                : TextCapitalization.none,
      ),
    );
  }

  InputDecoration _inputDecoration({
    required String labelText,
    String? hintText,
    required ThemeData theme,
    Widget? suffixIcon,
  }) {
    final borderSide = BorderSide(color: theme.dividerColor.withOpacity(0.7), width: 1.0);
    final focusedBorderSide = BorderSide(color: theme.colorScheme.primary, width: 1.5);
    final errorBorderSide = BorderSide(color: theme.colorScheme.error, width: 1.0);
    final focusedErrorBorderSide = BorderSide(color: theme.colorScheme.error, width: 1.5);

    return InputDecoration(
      labelText: labelText,
      labelStyle: theme.textTheme.bodyMedium?.copyWith(color: theme.hintColor.withOpacity(0.9)),
      hintText: hintText,
      hintStyle: TextStyle(color: theme.hintColor.withOpacity(0.7)),
      border: UnderlineInputBorder(borderSide: borderSide),
      enabledBorder: UnderlineInputBorder(borderSide: borderSide),
      focusedBorder: UnderlineInputBorder(borderSide: focusedBorderSide),
      errorBorder: UnderlineInputBorder(borderSide: errorBorderSide),
      focusedErrorBorder: UnderlineInputBorder(borderSide: focusedErrorBorderSide),
      contentPadding: const EdgeInsets.symmetric(horizontal: _inputPaddingHorizontal, vertical: 12.0),
      filled: false,
      suffixIcon: suffixIcon,
      isDense: true,
    );
  }

  Widget _buildSaveButton(ThemeData theme) {
    bool canSave = _hasUnsavedChanges();
    return ElevatedButton(
      onPressed: (_isLoading || !canSave) ? null : _saveChanges, // Updated condition
      style: ElevatedButton.styleFrom(
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
        padding: const EdgeInsets.symmetric(vertical: 14.0, horizontal: 24.0),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(_buttonBorderRadius)),
        minimumSize: const Size.fromHeight(50),
        disabledBackgroundColor: theme.colorScheme.primary.withOpacity(0.4),
        disabledForegroundColor: theme.colorScheme.onPrimary.withOpacity(0.7),
      ),
      child: _isLoading
          ? SizedBox(width: 24, height: 24, child: CircularProgressIndicator(strokeWidth: 3, color: theme.colorScheme.onPrimary))
          : Text('Save Changes', style: theme.textTheme.titleMedium?.copyWith(color: theme.colorScheme.onPrimary, fontWeight: FontWeight.bold)),
    );
  }
}


===== features\profile\screens\help_support_screen.dart =====

import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';


class HelpSupportScreen extends StatelessWidget {
  const HelpSupportScreen({super.key});

  Future<void> _launchEmail() async {
    final Uri emailLaunchUri = Uri(
      scheme: 'mailto',
      path: 'support@example.com', // Replace with your support email
      queryParameters: {
        'subject': 'App Support Request',
      },
    );
    if (!await launchUrl(emailLaunchUri)) {
      // TODO: Show an error message to the user if email app can't be launched
      debugPrint('Could not launch email client');
    }
  }


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Help & Support'),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: <Widget>[
          Text(
            'Frequently Asked Questions',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 8),
          const ExpansionTile(
            title: Text('How do I book a venue?'),
            children: <Widget>[
              Padding(
                padding: EdgeInsets.all(16.0),
                child: Text('You can book a venue by navigating to the venue details page and clicking on the "Book Now" button. Follow the on-screen instructions to complete your booking.'),
              ),
            ],
          ),
          const ExpansionTile(
            title: Text('How can I cancel a booking?'),
            children: <Widget>[
              Padding(
                padding: EdgeInsets.all(16.0),
                child: Text('To cancel a booking, please go to "My Bookings", find the booking you wish to cancel, and look for a cancel option. Cancellation policies may apply.'),
              ),
            ],
          ),
          const ExpansionTile(
            title: Text('How do I update my profile information?'),
            children: <Widget>[
              Padding(
                padding: EdgeInsets.all(16.0),
                child: Text('You can update your profile information by navigating to the "My Profile" screen and tapping on "Personal Details".'),
              ),
            ],
          ),
          const Divider(height: 32),
          Text(
            'Contact Us',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 8),
          ListTile(
            leading: const Icon(Icons.email_outlined),
            title: const Text('Email Support'),
            subtitle: const Text('support@example.com'), // Replace
            onTap: _launchEmail,
          ),
          ListTile(
            leading: const Icon(Icons.phone_outlined),
            title: const Text('Call Us (Mon-Fri, 9am-5pm)'),
            subtitle: const Text('+1-234-567-8900'), // Replace
            onTap: () async {
              final Uri phoneLaunchUri = Uri.parse('tel:+1-234-567-8900'); // Replace
               if (!await launchUrl(phoneLaunchUri)) {
                  debugPrint('Could not launch phone dialer');
               }
            },
          ),
          // Add more contact options or links as needed
        ],
      ),
    );
  }
}


===== features\profile\screens\my_bookings_screen.dart =====

import 'package:flutter/material.dart';
// import 'package:mm_associates/features/user/services/user_service.dart'; // Assuming you have this
// import 'package:mm_associates/features/data/models/booking_model.dart'; // Assuming a Booking model
import 'package:shimmer/shimmer.dart';

class MyBookingsScreen extends StatefulWidget {
  const MyBookingsScreen({super.key});

  @override
  State<MyBookingsScreen> createState() => _MyBookingsScreenState();
}

class _MyBookingsScreenState extends State<MyBookingsScreen> {
  // final UserService _userService = UserService(); // Uncomment when ready
  List<Map<String, dynamic>> _bookings = []; // Or List<BookingModel>
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _fetchMyBookings();
  }

  Future<void> _fetchMyBookings() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      // TODO: Replace with your actual data fetching logic
      // _bookings = await _userService.getUserBookings();
      // Simulate a delay and empty data for now
      await Future.delayed(const Duration(seconds: 1));
      // _bookings = []; // Example: Start with empty or mock data

      if (!mounted) return;
      setState(() {
        _isLoading = false;
      });
    } catch (e) {
      debugPrint("Error fetching bookings: $e");
      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = "Could not load your bookings.";
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Bookings'),
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_isLoading) {
      return _buildShimmerList();
    }

    if (_errorMessage != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Text(_errorMessage!, style: const TextStyle(color: Colors.red)),
        ),
      );
    }

    if (_bookings.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.event_busy_outlined, color: Colors.grey[400], size: 60),
              const SizedBox(height: 15),
              Text('No Bookings Yet!', style: TextStyle(fontSize: 18, color: Colors.grey[600])),
              const SizedBox(height: 8),
              const Text('Your active and past bookings will appear here.', textAlign: TextAlign.center, style: TextStyle(color: Colors.grey)),
            ],
          ),
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: _bookings.length,
      itemBuilder: (context, index) {
        final booking = _bookings[index];
        // TODO: Create a BookingListTile widget or build UI here
        return ListTile(
          title: Text(booking['venueName'] ?? 'Booking Details'), // Example field
          subtitle: Text('Date: ${booking['bookingDate'] ?? 'N/A'}'), // Example field
          // onTap: () { /* Navigate to booking detail screen if any */ },
        );
      },
    );
  }

  Widget _buildShimmerList() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[300]!,
      highlightColor: Colors.grey[100]!,
      child: ListView.builder(
        padding: const EdgeInsets.all(8.0),
        itemCount: 5,
        itemBuilder: (context, index) => ListTile(
          leading: Container(width: 40, height: 40, color: Colors.white),
          title: Container(height: 16, width: double.infinity, color: Colors.white),
          subtitle: Container(height: 12, width: MediaQuery.of(context).size.width * 0.5, color: Colors.white, margin: const EdgeInsets.only(top: 4)),
        ),
      ),
    );
  }
}


===== features\profile\screens\my_favourites_screen.dart =====

import 'package:flutter/material.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:mm_associates/features/home/screens/venue_detail_screen.dart'; // For navigation
import 'package:shimmer/shimmer.dart'; // For loading shimmer

class MyFavouritesScreen extends StatefulWidget {
  const MyFavouritesScreen({super.key});

  @override
  State<MyFavouritesScreen> createState() => _MyFavouritesScreenState();
}

class _MyFavouritesScreenState extends State<MyFavouritesScreen> {
  final UserService _userService = UserService();
  final FirestoreService _firestoreService = FirestoreService();

  List<Map<String, dynamic>> _favouriteVenues = [];
  bool _isLoading = true;
  String? _errorMessage;
  Stream<List<String>>? _favoritesStream;
  List<String> _currentFavoriteIds = [];

  @override
  void initState() {
    super.initState();
    _setupFavoritesListenerAndFetchDetails();
  }

  void setStateIfMounted(VoidCallback fn) {
    if (mounted) {
      setState(fn);
    }
  }

  void _setupFavoritesListenerAndFetchDetails() {
    _favoritesStream = _userService.getFavoriteVenueIdsStream();
    _favoritesStream?.listen((favoriteIds) {
      if (!mounted) return;
      // Check if the list of IDs has actually changed to avoid unnecessary refetches
      if (favoriteIds.toSet().difference(_currentFavoriteIds.toSet()).isNotEmpty ||
          _currentFavoriteIds.toSet().difference(favoriteIds.toSet()).isNotEmpty) {
        _currentFavoriteIds = List.from(favoriteIds); // Update current IDs
        _fetchFavouriteVenueDetails(favoriteIds);
      } else if (_favouriteVenues.isEmpty && favoriteIds.isNotEmpty && _isLoading) {
        // Initial load or empty list but favorites exist
        _currentFavoriteIds = List.from(favoriteIds);
        _fetchFavouriteVenueDetails(favoriteIds);
      } else if (favoriteIds.isEmpty) {
        // If all favorites are removed
        setStateIfMounted(() {
          _favouriteVenues = [];
          _isLoading = false;
          _errorMessage = null;
        });
      }
    }, onError: (error) {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = "Error listening to favorites.";
          _favouriteVenues = [];
        });
      }
      debugPrint("Error in favorites stream: $error");
    });
  }


  Future<void> _fetchFavouriteVenueDetails(List<String> venueIds) async {
    if (!mounted) return;
    if (venueIds.isEmpty) {
      setStateIfMounted(() {
        _favouriteVenues = [];
        _isLoading = false;
        _errorMessage = null;
      });
      return;
    }

    setStateIfMounted(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      List<Future<Map<String, dynamic>?>> futures = venueIds
          .map((id) => _firestoreService.getVenueDetails(id))
          .toList();

      final List<Map<String, dynamic>?> venueDetailsResults = await Future.wait(futures);
      
      if (!mounted) return;

      // Filter out nulls (if a venue was deleted but ID still in favorites)
      // and ensure correct type.
      final List<Map<String, dynamic>> validVenues = venueDetailsResults
          .where((details) => details != null)
          .cast<Map<String, dynamic>>()
          .toList();

      // Sort venues by name or any other preferred order
      validVenues.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));

      setStateIfMounted(() {
        _favouriteVenues = validVenues;
        _isLoading = false;
      });
    } catch (e) {
      debugPrint("Error fetching favourite venue details: $e");
      if (mounted) {
        setStateIfMounted(() {
          _isLoading = false;
          _errorMessage = "Could not load your favourite venues.";
        });
      }
    }
  }

  void _navigateToVenueDetail(Map<String, dynamic> venue) {
    if (!context.mounted) return;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => VenueDetailScreen(
          venueId: venue['id'] as String,
          initialVenueData: venue,
          heroTagContext: 'my_favourites',
        ),
      ),
    );
  }


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Favourites'),
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_isLoading) {
      return _buildShimmerList();
    }

    if (_errorMessage != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline, color: Colors.red[300], size: 50),
              const SizedBox(height: 15),
              Text(_errorMessage!, textAlign: TextAlign.center, style: TextStyle(color: Colors.red[700], fontSize: 16)),
              const SizedBox(height: 20),
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh),
                label: const Text("Retry"),
                onPressed: () => _fetchFavouriteVenueDetails(_currentFavoriteIds), // Retry with current IDs
              ),
            ],
          ),
        ),
      );
    }

    if (_favouriteVenues.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.favorite_border, color: Colors.grey[400], size: 60),
              const SizedBox(height: 15),
              Text(
                'No Favourites Yet!',
                style: TextStyle(fontSize: 18, color: Colors.grey[600]),
              ),
              const SizedBox(height: 8),
              const Text(
                'Tap the heart icon on venues to add them here.',
                textAlign: TextAlign.center,
                style: TextStyle(color: Colors.grey),
              ),
            ],
          ),
        ),
      );
    }

    return ListView.separated(
      padding: const EdgeInsets.all(8.0),
      itemCount: _favouriteVenues.length,
      separatorBuilder: (context, index) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final venue = _favouriteVenues[index];
        return _buildFavouriteVenueTile(venue);
      },
    );
  }

  Widget _buildShimmerList() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[300]!,
      highlightColor: Colors.grey[100]!,
      child: ListView.builder(
        padding: const EdgeInsets.all(8.0),
        itemCount: 5, // Number of shimmer items
        itemBuilder: (context, index) => Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(width: 60, height: 60, color: Colors.white, margin: const EdgeInsets.only(right: 12)),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(width: double.infinity, height: 16.0, color: Colors.white),
                    const SizedBox(height: 6),
                    Container(width: MediaQuery.of(context).size.width * 0.5, height: 12.0, color: Colors.white),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildFavouriteVenueTile(Map<String, dynamic> venue) {
    final String name = venue['name'] as String? ?? 'Unnamed Venue';
    final String? imageUrl = venue['imageUrl'] as String?;
    final String city = venue['city'] as String? ?? 'N/A';
    final dynamic sportRaw = venue['sportType'];
    final String sport = (sportRaw is String) ? sportRaw : (sportRaw is List ? sportRaw.whereType<String>().join(', ') : 'Various Sports');

    return ListTile(
      leading: (imageUrl != null && imageUrl.isNotEmpty && Uri.tryParse(imageUrl)?.isAbsolute == true)
          ? SizedBox(
              width: 60, height: 60,
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(imageUrl, fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) => Icon(Icons.broken_image_outlined, color: Colors.grey[400]),
                ),
              ),
            )
          : Container(
              width: 60, height: 60,
              decoration: BoxDecoration(color: Theme.of(context).primaryColor.withOpacity(0.1), borderRadius: BorderRadius.circular(8)),
              child: Icon(Icons.sports_soccer_outlined, color: Theme.of(context).primaryColor.withOpacity(0.7), size: 30),
            ),
      title: Text(name, style: const TextStyle(fontWeight: FontWeight.w600)),
      subtitle: Text("$sport - $city", maxLines: 1, overflow: TextOverflow.ellipsis),
      trailing: const Icon(Icons.chevron_right, color: Colors.grey),
      onTap: () => _navigateToVenueDetail(venue),
    );
  }
}


===== features\profile\screens\my_reviews_screen.dart =====

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_rating_bar/flutter_rating_bar.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:mm_associates/features/home/screens/venue_detail_screen.dart';
import 'package:intl/intl.dart'; 

class MyReviewsScreen extends StatefulWidget {
  const MyReviewsScreen({super.key});

  @override
  State<MyReviewsScreen> createState() => _MyReviewsScreenState();
}

class _MyReviewsScreenState extends State<MyReviewsScreen> {
  final AuthService _authService = AuthService();
  final FirestoreService _firestoreService = FirestoreService();

  List<Map<String, dynamic>> _userReviews = [];
  Map<String, String> _venueNames = {}; // Cache for venue names {venueId: venueName}
  bool _isLoading = true;
  String? _errorMessage;
  String? _userId;

  @override
  void initState() {
    super.initState();
    _userId = _authService.getCurrentUser()?.uid;
    if (_userId != null) {
      _loadUserReviews();
    } else {
      setState(() {
        _isLoading = false;
        _errorMessage = "You need to be logged in to see your reviews.";
      });
    }
  }

  Future<void> _loadUserReviews() async {
    if (!mounted || _userId == null) return;
    setState(() {
      _isLoading = true;
      _errorMessage = null;
      _userReviews = []; // Clear previous reviews
      _venueNames = {}; // Clear venue name cache
    });

    try {
      final reviews = await _firestoreService.getReviewsByUser(_userId!);

      if (mounted) {
        // Now fetch venue names for the fetched reviews
        await _fetchVenueNamesForReviews(reviews);

        setState(() {
          _userReviews = reviews;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = e.toString().replaceFirst("Exception: ", "");
        });
      }
    }
  }

  // Helper to fetch venue names efficiently (avoids N+1 reads if possible)
  Future<void> _fetchVenueNamesForReviews(List<Map<String, dynamic>> reviews) async {
     if (!mounted || reviews.isEmpty) return;

     // Get unique venue IDs from the reviews
     final Set<String> venueIds = reviews.map((r) => r['venueId'] as String?).whereType<String>().toSet();

     if (venueIds.isEmpty) return;

      // In a real-world scenario with potentially many reviews, consider batch fetching
      // For simplicity here, fetch one by one but store in cache (_venueNames)
      for (String venueId in venueIds) {
          if (_venueNames.containsKey(venueId)) continue; // Skip if already fetched

          try {
              final venueData = await _firestoreService.getVenueDetails(venueId);
              if (mounted) {
                _venueNames[venueId] = venueData?['name'] as String? ?? 'Unknown Venue';
              }
          } catch (e) {
              debugPrint("Could not fetch venue name for $venueId: $e");
               if (mounted) {
                 _venueNames[venueId] = 'Venue Error'; // Indicate error fetching name
               }
          }
      }
  }

  Future<void> _confirmAndDeleteReview(String venueId, String reviewId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Delete Review'),
          content: const Text('Are you sure you want to permanently delete this review?'),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(context).pop(false),
            ),
            TextButton(
              style: TextButton.styleFrom(foregroundColor: Colors.redAccent),
              child: const Text('Delete'),
              onPressed: () => Navigator.of(context).pop(true),
            ),
          ],
        );
      },
    );

    if (confirmed == true && mounted) {
      try {
        await _firestoreService.deleteReview(venueId, reviewId);

        // --- IMPORTANT: Trigger rating update for the venue ---
        // Call the client-side recalculation (less reliable) or rely on Cloud Function
        // Example: await _firestoreService.updateVenueRatingClientSide(venueId);
        // --------------------------------------------------------

         if (mounted) {
           ScaffoldMessenger.of(context).showSnackBar(
             const SnackBar(content: Text('Review deleted successfully.'), backgroundColor: Colors.green),
           );
            // Remove the review locally to update UI immediately
            setState(() {
              _userReviews.removeWhere((review) => review['id'] == reviewId && review['venueId'] == venueId);
            });
         }

      } catch (e) {
          if (mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
               SnackBar(content: Text('Failed to delete review: ${e.toString().replaceFirst("Exception: ", "")}'), backgroundColor: Colors.redAccent),
             );
          }
      }
    }
  }

  void _navigateToVenue(String venueId) {
     Navigator.push(
        context,
        MaterialPageRoute(
           // Pass only ID, let detail screen fetch fresh data including reviews
          builder: (context) => VenueDetailScreen(venueId: venueId,heroTagContext: 'my_reviews_list',),
        ),
      );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.brightness == Brightness.light ? Colors.grey[100] : theme.scaffoldBackgroundColor,
      appBar: AppBar(
        title: const Text('My Reviews'),
         elevation: 0,
         backgroundColor: theme.scaffoldBackgroundColor,
         foregroundColor: theme.colorScheme.onSurface,
      ),
      body: RefreshIndicator(
        onRefresh: _loadUserReviews,
        child: _buildBody(theme),
      ),
    );
  }

  Widget _buildBody(ThemeData theme) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_errorMessage != null) {
       return Center(
          child: Padding(
             padding: const EdgeInsets.all(20.0),
             child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                   const Icon(Icons.error_outline, color: Colors.red, size: 50),
                   const SizedBox(height: 15),
                   Text(_errorMessage!, style: TextStyle(color: Colors.red[700], fontSize: 16), textAlign: TextAlign.center),
                   const SizedBox(height: 20),
                   ElevatedButton.icon(
                     icon: const Icon(Icons.refresh),
                     label: const Text("Try Again"),
                     onPressed: _loadUserReviews,
                    ),
                ],
             ),
          ),
       );
    }

    if (_userReviews.isEmpty) {
       return Center(
          child: Padding(
             padding: const EdgeInsets.all(20.0),
             child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                   Icon(Icons.rate_review, color: Colors.grey[400], size: 60),
                   const SizedBox(height: 15),
                   Text(
                      'You haven\'t written any reviews yet.',
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 17, color: Colors.grey[600]),
                    ),
                    const SizedBox(height: 10),
                   Text( "Reviews you write will appear here.", style: TextStyle(color: Colors.grey[600]),)
                ],
             ),
          ),
       );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(12.0), // Add padding around the list
      itemCount: _userReviews.length,
      itemBuilder: (context, index) {
        final review = _userReviews[index];
        final String venueId = review['venueId'] as String? ?? '';
        final String reviewId = review['id'] as String? ?? '';
        final String venueName = _venueNames[venueId] ?? 'Loading Venue...';

        // We need a slightly different list item structure here
        return _buildMyReviewCard(theme, review, venueName, venueId, reviewId);
      },
    );
  }


   // Specific Widget for displaying review in "My Reviews" list
  Widget _buildMyReviewCard(ThemeData theme, Map<String, dynamic> reviewData, String venueName, String venueId, String reviewId) {
     final double rating = (reviewData['rating'] as num?)?.toDouble() ?? 0.0;
     final String comment = reviewData['comment'] as String? ?? '';
     final Timestamp? timestamp = reviewData['createdAt'] as Timestamp?;
     final String dateString = timestamp != null
        ? DateFormat('dd MMM yyyy, hh:mm a').format(timestamp.toDate()) // More precise date
        : 'Unknown date';


     return Card(
       margin: const EdgeInsets.only(bottom: 12.0), // Spacing between cards
       elevation: 1.5,
       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10.0)),
       child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
             crossAxisAlignment: CrossAxisAlignment.start,
            children: [
               // Venue Name (Clickable)
              InkWell(
                onTap: venueId.isNotEmpty ? () => _navigateToVenue(venueId) : null,
                child: Row(
                   children: [
                     Icon(Icons.sports_gymnastics, size: 18, color: theme.colorScheme.primary), // Or other relevant icon
                     const SizedBox(width: 8),
                     Expanded(
                        child: Text(
                           venueName,
                           style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600, color: theme.colorScheme.primary),
                            overflow: TextOverflow.ellipsis,
                        ),
                      ),
                       if (venueId.isNotEmpty)
                          Icon(Icons.chevron_right, color: theme.colorScheme.secondary, size: 20),
                    ],
                ),
              ),
              const Divider(height: 16, thickness: 1),

              // Rating and Date
               Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                     IgnorePointer( // Makes the rating bar non-interactive
                       child: RatingBar.builder(
                          initialRating: rating,
                          minRating: 1, direction: Axis.horizontal, allowHalfRating: false,
                          itemCount: 5, itemSize: 20.0,
                          itemPadding: const EdgeInsets.symmetric(horizontal: 0.5),
                          itemBuilder: (context, _) => const Icon(Icons.star, color: Colors.amber),
                          onRatingUpdate: (rating) {}, // Required but unused
                       ),
                     ),
                      Text(dateString, style: TextStyle(color: Colors.grey[600], fontSize: 12)),
                  ],
               ),

               // Comment (if exists)
               if (comment.isNotEmpty) ...[
                  const SizedBox(height: 10),
                  Text(comment, style: theme.textTheme.bodyMedium?.copyWith(height: 1.4)),
                ],

               // Delete Button aligned to the right
               Align(
                 alignment: Alignment.centerRight,
                 child: Padding(
                    padding: const EdgeInsets.only(top: 10.0),
                    child: IconButton(
                       icon: Icon(Icons.delete_outline, color: Colors.redAccent[100], size: 22),
                       tooltip: 'Delete Review',
                       onPressed: (venueId.isEmpty || reviewId.isEmpty) ? null : () => _confirmAndDeleteReview(venueId, reviewId),
                       // Visual density can make the tap target smaller/larger
                       // visualDensity: VisualDensity.compact,
                        // constraints: BoxConstraints(), // Remove default padding if needed
                        padding: EdgeInsets.zero, // Adjust padding if needed
                    ),
                 ),
               )
            ],
          ),
       ),
     );
   }
}


===== features\profile\screens\my_venues_screen.dart =====

import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:mm_associates/features/home/screens/venue_form.dart'; // For editing
import 'package:shimmer/shimmer.dart'; // For loading shimmer

class MyVenuesScreen extends StatefulWidget {
  const MyVenuesScreen({Key? key}) : super(key: key);

  @override
  _MyVenuesScreenState createState() => _MyVenuesScreenState();
}

class _MyVenuesScreenState extends State<MyVenuesScreen> {
  final FirestoreService _firestoreService = FirestoreService();
  final FirebaseAuth _auth = FirebaseAuth.instance;
  User? _currentUser;

  List<Map<String, dynamic>> _myVenues = [];
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _currentUser = _auth.currentUser;
    _fetchMyVenues();
  }

  Future<void> _fetchMyVenues() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    if (_currentUser == null) {
      setState(() {
        _isLoading = false;
        _errorMessage = "You must be logged in to see your venues.";
      });
      return;
    }

    try {
      final venues = await _firestoreService.getVenuesByCreator(_currentUser!.uid);
      if (!mounted) return;
      setState(() {
        _myVenues = venues;
        _isLoading = false;
      });
    } catch (e) {
      debugPrint("Error fetching admin's venues: $e");
      if (!mounted) return;
      setState(() {
        _isLoading = false;
        _errorMessage = "Failed to load your venues. Please try again.";
      });
    }
  }

  Future<void> _navigateToEditVenue(Map<String, dynamic> venueData) async {
    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) => AddVenueFormScreen(
          venueIdToEdit: venueData['id'] as String,
          initialData: venueData,
        ),
      ),
    );
    if (result == true && mounted) {
      _fetchMyVenues(); // Refresh the list if a venue was updated
    }
  }

  Future<void> _confirmDeleteVenue(String venueId, String venueName) async {
    final bool? confirmDelete = await showDialog<bool>(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Confirm Deletion'),
          content: Text('Are you sure you want to delete the venue "$venueName"? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(dialogContext).pop(false),
            ),
            TextButton(
              style: TextButton.styleFrom(foregroundColor: Colors.red),
              child: const Text('Delete'),
              onPressed: () => Navigator.of(dialogContext).pop(true),
            ),
          ],
        );
      },
    );

    if (confirmDelete == true) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Deleting "$venueName"...'), duration: const Duration(seconds: 2)),
      );
      try {
        await _firestoreService.deleteVenue(venueId);
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Venue "$venueName" deleted successfully.'), backgroundColor: Colors.green),
        );
        _fetchMyVenues(); // Refresh the list
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to delete venue: ${e.toString()}'), backgroundColor: Theme.of(context).colorScheme.error),
        );
      }
    }
  }

  Widget _buildShimmerLoadingList() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[300]!,
      highlightColor: Colors.grey[100]!,
      child: ListView.builder(
        itemCount: 6, // Number of shimmer items
        itemBuilder: (_, __) => Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: <Widget>[
              Container(
                width: 48.0,
                height: 48.0,
                color: Colors.white,
              ),
              const Padding(
                padding: EdgeInsets.symmetric(horizontal: 8.0),
              ),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    Container(
                      width: double.infinity,
                      height: 8.0,
                      color: Colors.white,
                    ),
                    const Padding(
                      padding: EdgeInsets.symmetric(vertical: 2.0),
                    ),
                    Container(
                      width: double.infinity,
                      height: 8.0,
                      color: Colors.white,
                    ),
                    const Padding(
                      padding: EdgeInsets.symmetric(vertical: 2.0),
                    ),
                    Container(
                      width: 40.0,
                      height: 8.0,
                      color: Colors.white,
                    ),
                  ],
                ),
              )
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Venues'),
      ),
      body: RefreshIndicator(
        onRefresh: _fetchMyVenues,
        child: Builder(
          builder: (context) {
            if (_isLoading) {
              return _buildShimmerLoadingList();
            }
            if (_errorMessage != null) {
              return Center(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error, size: 50),
                      const SizedBox(height: 10),
                      Text(_errorMessage!, textAlign: TextAlign.center, style: TextStyle(color: Theme.of(context).colorScheme.error)),
                      const SizedBox(height: 10),
                      ElevatedButton.icon(
                        icon: const Icon(Icons.refresh),
                        label: const Text('Try Again'),
                        onPressed: _fetchMyVenues,
                      )
                    ],
                  ),
                ),
              );
            }
            if (_myVenues.isEmpty) {
              return Center(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.no_photography_outlined, size: 60, color: Theme.of(context).hintColor),
                      const SizedBox(height: 16),
                      Text(
                        'You haven\'t added any venues yet.',
                        style: Theme.of(context).textTheme.titleMedium,
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Venues you create will appear here.',
                        style: Theme.of(context).textTheme.bodySmall,
                        textAlign: TextAlign.center,
                      ),
                       const SizedBox(height: 20),
                        ElevatedButton.icon(
                          icon: const Icon(Icons.add_location_alt_outlined),
                          label: const Text('Add New Venue'),
                          onPressed: () async {
                              final result = await Navigator.push<bool>(
                                context,
                                MaterialPageRoute(builder: (context) => const AddVenueFormScreen()),
                              );
                              if (result == true && mounted) {
                                _fetchMyVenues(); // Refresh if a venue was added
                              }
                          },
                        ),
                    ],
                  ),
                ),
              );
            }

            return ListView.separated(
              itemCount: _myVenues.length,
              separatorBuilder: (context, index) => const Divider(height: 1),
              itemBuilder: (context, index) {
                final venue = _myVenues[index];
                final String venueName = venue['name'] as String? ?? 'Unnamed Venue';
                final String venueCity = venue['city'] as String? ?? 'N/A';
                final bool isActive = venue['isActive'] as bool? ?? false;
                final String? imageUrl = venue['imageUrl'] as String?;

                return ListTile(
                  leading: SizedBox(
                    width: 50,
                    height: 50,
                    child: (imageUrl != null && imageUrl.isNotEmpty)
                      ? Image.network(imageUrl, fit: BoxFit.cover,
                          errorBuilder: (ctx, err, st) => Icon(Icons.broken_image, color: Theme.of(context).hintColor),
                          loadingBuilder: (ctx, child, progress) => progress == null ? child : const Center(child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))),
                        )
                      : Icon(Icons.location_city, color: Theme.of(context).hintColor),
                  ),
                  title: Text(venueName, style: const TextStyle(fontWeight: FontWeight.w500)),
                  subtitle: Text("$venueCity - ${isActive ? 'Active' : 'Inactive'}"),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: Icon(Icons.edit_outlined, color: Theme.of(context).colorScheme.primary),
                        tooltip: 'Edit Venue',
                        onPressed: () => _navigateToEditVenue(venue),
                      ),
                      IconButton(
                        icon: Icon(Icons.delete_outline, color: Theme.of(context).colorScheme.error),
                        tooltip: 'Delete Venue',
                        onPressed: () => _confirmDeleteVenue(venue['id'] as String, venueName),
                      ),
                    ],
                  ),
                  onTap: () => _navigateToEditVenue(venue), // Also allow tapping tile to edit
                );
              },
            );
          },
        ),
      ),
    );
  }
}


===== features\profile\screens\privacy_policy_screen.dart =====

import 'package:flutter/material.dart';

class PrivacyPolicyScreen extends StatelessWidget {
  const PrivacyPolicyScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Privacy Policy'),
      ),
      body: const SingleChildScrollView(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Privacy Policy for MM Associates App',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 10),
            Text(
              'Last Updated: [Date]', // TODO: Update this date
              style: TextStyle(fontStyle: FontStyle.italic),
            ),
            SizedBox(height: 20),
            Text(
              '1. Introduction',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 5),
            Text(
              'Welcome to MM Associates App. We are committed to protecting your personal information and your right to privacy. If you have any questions or concerns about our policy, or our practices with regards to your personal information, please contact us at support@example.com.',
            ),
            SizedBox(height: 15),
            Text(
              '2. Information We Collect',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 5),
            Text(
              'We collect personal information that you voluntarily provide to us when you register on the App, express an interest in obtaining information about us or our products and services, when you participate in activities on the App or otherwise when you contact us.',
            ),
            SizedBox(height: 10),
            Text(
              'The personal information that we collect depends on the context of your interactions with us and the App, the choices you make and the products and features you use. The personal information we collect may include the following: Name, Email Address, Phone Number, Location Data (if permission granted), etc.',
            ),
            SizedBox(height: 15),
            Text(
              '3. How We Use Your Information',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 5),
            Text(
              'We use personal information collected via our App for a variety of business purposes described below. We process your personal information for these purposes in reliance on our legitimate business interests, in order to enter into or perform a contract with you, with your consent, and/or for compliance with our legal obligations.',
            ),
            // TODO: Add more sections like:
            // - Will Your Information Be Shared With Anyone?
            // - How Long Do We Keep Your Information?
            // - How Do We Keep Your Information Safe?
            // - Do We Collect Information From Minors?
            // - What Are Your Privacy Rights?
            // - Controls for Do-Not-Track Features
            // - Do California Residents Have Specific Privacy Rights?
            // - Do We Make Updates to This Policy?
            // - How Can You Contact Us About This Policy?
            SizedBox(height: 20),
            Text(
              '[... Add your full privacy policy text here ...]'
            ),
          ],
        ),
      ),
    );
  }
}


===== features\profile\screens\profile_screen.dart =====

// // // // import 'package:flutter/material.dart';
// // // // import 'package:firebase_auth/firebase_auth.dart';
// // // // import 'package:intl/intl.dart';
// // // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // // import 'package:flutter/foundation.dart'; // Import for debugPrint
// // // // import 'package:mm_associates/features/user/services/user_service.dart';
// // // // import 'package:mm_associates/features/profile/screens/edit_profile_screen.dart';

// // // // import 'my_favourites_screen.dart';
// // // // import 'my_bookings_screen.dart';
// // // // import 'my_reviews_screen.dart';
// // // // import 'help_support_screen.dart';
// // // // import 'privacy_policy_screen.dart';
// // // // import 'sign_out_button_tile.dart'; // Import the sign out tile

// // // // class ProfileScreen extends StatefulWidget {
// // // //   const ProfileScreen({Key? key}) : super(key: key);
// // // //   @override
// // // //   _ProfileScreenState createState() => _ProfileScreenState();
// // // // }

// // // // class _ProfileScreenState extends State<ProfileScreen> {
// // // //   final AuthService _authService = AuthService();
// // // //   final UserService _userService = UserService();
// // // //   User? _currentUser;
// // // //   Map<String, dynamic>? _userData;
// // // //   bool _isLoading = true;
// // // //   String? _errorMessage;

// // // //   @override
// // // //   void initState() {
// // // //     super.initState();
// // // //     _loadUserProfile();
// // // //   }

// // // //   void setStateIfMounted(VoidCallback fn) {
// // // //     if (mounted) {
// // // //       setState(fn);
// // // //     }
// // // //   }

// // // //   Future<void> _loadUserProfile({bool forceRefresh = false}) async {
// // // //     debugPrint(
// // // //         '_loadUserProfile - Start: _isLoading: $_isLoading, _errorMessage: $_errorMessage, _currentUser: ${_currentUser?.uid}');
// // // //     if (!mounted) return;
// // // //     setStateIfMounted(() {
// // // //       _isLoading = true;
// // // //       _errorMessage = null;
// // // //     });

// // // //     _currentUser = _authService.getCurrentUser();
// // // //     if (_currentUser == null) {
// // // //       debugPrint('_loadUserProfile - User is null');
// // // //       setStateIfMounted(() {
// // // //         _isLoading = false;
// // // //         _errorMessage = "User not logged in.";
// // // //       });
// // // //       return;
// // // //     }

// // // //     try {
// // // //       // It's good practice to reload user to get fresh emailVerified status, etc.
// // // //       await _currentUser?.reload(); 
// // // //       _currentUser = _authService.getCurrentUser(); // Re-fetch after reload

// // // //       _userData =
// // // //           await _userService.getUserProfileData(forceRefresh: forceRefresh);
// // // //       if (!mounted) return;
// // // //       debugPrint('_loadUserProfile - User data loaded: ${_userData != null}');
// // // //       setStateIfMounted(() {
// // // //         _isLoading = false;
// // // //       });
// // // //     } catch (e) {
// // // //       debugPrint("Error loading profile: $e");
// // // //       if (!mounted) return;
// // // //       setStateIfMounted(() {
// // // //         _isLoading = false;
// // // //         _errorMessage = "Failed to load profile details.";
// // // //       });
// // // //     }
// // // //   }

// // // //   void _navigateToEditProfile() async {
// // // //     if (_currentUser == null || _userData == null) {
// // // //       ScaffoldMessenger.of(context).showSnackBar(
// // // //         const SnackBar(content: Text("Profile data not loaded yet.")),
// // // //       );
// // // //       return;
// // // //     }

// // // //     // Ensure 'name' from userData is prioritized, fallback to Firebase displayName
// // // //     final String currentName = _userData!['name'] as String? ?? _currentUser!.displayName ?? 'N/A';
// // // //     final String currentEmail = _currentUser!.email ?? 'N/A'; // Email is from Auth User
// // // //     final String? currentPhone = _userData!['phoneNumber'] as String?;
// // // //     final String? currentProfilePicUrl = _userData!['profilePictureUrl'] as String?;
// // // //     final String? currentBio = _userData!['bio'] as String?;
// // // //     final Timestamp? dobTimestamp = _userData!['dateOfBirth'] as Timestamp?;
// // // //     final DateTime? currentDateOfBirth = dobTimestamp?.toDate();
// // // //     final String? currentGender = _userData!['gender'] as String?;
// // // //     final String? currentAddressStreet = _userData!['addressStreet'] as String?;
// // // //     final String? currentAddressCity = _userData!['addressCity'] as String?;
// // // //     final String? currentAddressState = _userData!['addressState'] as String?;
// // // //     final String? currentAddressZipCode = _userData!['addressZipCode'] as String?;
// // // //     final String? currentAddressCountry = _userData!['addressCountry'] as String?;
// // // //     final String? currentSocialMediaLink = _userData!['socialMediaLink'] as String?;

// // // //     final result = await Navigator.push<bool>(
// // // //       context,
// // // //       MaterialPageRoute(
// // // //         builder: (context) => EditProfileScreen(
// // // //           currentName: currentName,
// // // //           currentEmail: currentEmail,
// // // //           currentPhone: currentPhone,
// // // //           currentProfilePicUrl: currentProfilePicUrl,
// // // //           currentBio: currentBio,
// // // //           currentDateOfBirth: currentDateOfBirth,
// // // //           currentGender: currentGender,
// // // //           currentAddressStreet: currentAddressStreet,
// // // //           currentAddressCity: currentAddressCity,
// // // //           currentAddressState: currentAddressState,
// // // //           currentAddressZipCode: currentAddressZipCode,
// // // //           currentAddressCountry: currentAddressCountry,
// // // //           currentSocialMediaLink: currentSocialMediaLink,
// // // //         ),
// // // //       ),
// // // //     );

// // // //     if (result == true && mounted) {
// // // //       _loadUserProfile(forceRefresh: true); // Force refresh if changes were saved
// // // //     }
// // // //   }


// // // //   @override
// // // //   Widget build(BuildContext context) {
// // // //     final ThemeData theme = Theme.of(context);
// // // //     return Scaffold(
// // // //       backgroundColor: theme.brightness == Brightness.light
// // // //           ? Colors.grey[100]!
// // // //           : theme.scaffoldBackgroundColor,
// // // //       appBar: AppBar(
// // // //         title: const Text('My Profile'),
// // // //         elevation: 0,
// // // //         backgroundColor: theme.scaffoldBackgroundColor,
// // // //         foregroundColor: theme.colorScheme.onSurface,
// // // //         actions: const [
// // // //           // Removed settings/edit icon from here as per typical UI patterns
// // // //           // where edit is invoked from within the profile details area.
// // // //         ],
// // // //       ),
// // // //       body: RefreshIndicator(
// // // //         onRefresh: () => _loadUserProfile(forceRefresh: true),
// // // //         child: _buildBody(theme),
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildBody(ThemeData theme) {
// // // //     if (_isLoading) {
// // // //       return const Center(child: CircularProgressIndicator());
// // // //     }

// // // //     if (_errorMessage != null || _currentUser == null || _userData == null) {
// // // //       return Center(
// // // //         child: Padding(
// // // //           padding: const EdgeInsets.all(20.0),
// // // //           child: Column(
// // // //             mainAxisAlignment: MainAxisAlignment.center,
// // // //             children: [
// // // //               Icon(Icons.error_outline, color: Colors.red[300], size: 60),
// // // //               const SizedBox(height: 15),
// // // //               Text(
// // // //                 _errorMessage ?? "Could not load profile.",
// // // //                 textAlign: TextAlign.center,
// // // //                 style: TextStyle(color: Colors.red[700], fontSize: 16),
// // // //               ),
// // // //               const SizedBox(height: 20),
// // // //               ElevatedButton.icon(
// // // //                 icon: const Icon(Icons.refresh),
// // // //                 label: const Text("Try Again"),
// // // //                 onPressed: () => _loadUserProfile(forceRefresh: true),
// // // //                 style: ElevatedButton.styleFrom(foregroundColor: theme.colorScheme.onError, backgroundColor: theme.colorScheme.error,)
// // // //               ),
// // // //             ],
// // // //           ),
// // // //         ),
// // // //       );
// // // //     }

// // // //     Widget profilePageContent = Column(
// // // //       mainAxisSize: MainAxisSize.min, // Allow column to take minimum necessary space
// // // //       crossAxisAlignment: CrossAxisAlignment.stretch,
// // // //       children: [
// // // //         _buildHeaderCard(theme),
// // // //         // MODIFIED: Reduced SizedBox height
// // // //         const SizedBox(height: 16),
// // // //         _buildActionsCard(theme),
// // // //       ],
// // // //     );

// // // //     return Center(
// // // //       child: Padding(
// // // //         // MODIFIED: Reduced vertical padding
// // // //         padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
// // // //         child: Container(
// // // //           constraints: BoxConstraints(
// // // //             maxWidth: 550,
// // // //             // Keep maxHeight relatively high to accommodate content, rely on SingleChildScrollView
// // // //             maxHeight: MediaQuery.of(context).size.height * 0.9, 
// // // //           ),
// // // //           decoration: BoxDecoration(
// // // //             color: theme.cardColor,
// // // //             borderRadius: BorderRadius.circular(16.0),
// // // //             border: Border.all(
// // // //               color: theme.dividerColor.withOpacity(0.5),
// // // //               width: 1.0,
// // // //             ),
// // // //             boxShadow: [
// // // //               BoxShadow(
// // // //                 color: Colors.black.withOpacity(0.08),
// // // //                 blurRadius: 12.0,
// // // //                 offset: const Offset(0, 4),
// // // //               ),
// // // //             ],
// // // //           ),
// // // //           child: ClipRRect(
// // // //             borderRadius: BorderRadius.circular(15.0),
// // // //             child: SingleChildScrollView(
// // // //               // MODIFIED: Reduced vertical padding inside scroll view
// // // //               padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
// // // //               child: profilePageContent,
// // // //             ),
// // // //           ),
// // // //         ),
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildHeaderCard(ThemeData theme) {
// // // //     // Prioritize name from Firestore, then Auth, then fallback.
// // // //     final String displayName = _userData?['name'] as String? ?? _currentUser?.displayName ?? 'User';
// // // //     final String email = _currentUser?.email ?? 'No Email';
// // // //     final String profilePicUrl = _userData?['profilePictureUrl'] as String? ?? '';
// // // //     final bool isEmailVerified = _currentUser?.emailVerified ?? false;
// // // //     // Handle Firestore Timestamp for updatedAt
// // // //     final dynamic updatedAtRaw = _userData?['updatedAt'];
// // // //     DateTime? lastUpdated;
// // // //     if (updatedAtRaw is Timestamp) {
// // // //       lastUpdated = updatedAtRaw.toDate();
// // // //     } else if (updatedAtRaw is String) {
// // // //       lastUpdated = DateTime.tryParse(updatedAtRaw); // Or custom parsing if string format is known
// // // //     }


// // // //     String joinedDateString = "";
// // // //     final creationTime = _currentUser?.metadata.creationTime;
// // // //     if (creationTime != null) {
// // // //       joinedDateString = "Since ${DateFormat('MMM yyyy').format(creationTime)}";
// // // //     }

// // // //     // MODIFIED: Slightly reduced ribbon space
// // // //     const double ribbonSpace = 90.0;


// // // //     return Card(
// // // //       elevation: 2.0,
// // // //       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
// // // //       clipBehavior: Clip.antiAlias,
// // // //       child: Stack(
// // // //         children: [
// // // //           // Main content of the card
// // // //           Padding(
// // // //             padding: const EdgeInsets.fromLTRB(16.0, 16.0, ribbonSpace, 16.0),
// // // //             child: Row(
// // // //               crossAxisAlignment: CrossAxisAlignment.center, // Center items vertically in the row
// // // //               children: [
// // // //                 CircleAvatar(
// // // //                   // MODIFIED: Slightly smaller avatar
// // // //                   radius: 36,
// // // //                   backgroundColor: theme.colorScheme.surfaceContainerHighest,
// // // //                   foregroundImage: profilePicUrl.isNotEmpty ? NetworkImage(profilePicUrl) : null,
// // // //                   child: profilePicUrl.isEmpty ? Icon(Icons.person_outline, size: 38, color: theme.colorScheme.onSurfaceVariant) : null,
// // // //                 ),
// // // //                 // MODIFIED: Slightly smaller SizedBox
// // // //                 const SizedBox(width: 12),
// // // //                 Expanded(
// // // //                   child: Column(
// // // //                     crossAxisAlignment: CrossAxisAlignment.start,
// // // //                     mainAxisSize: MainAxisSize.min, // Crucial for Column inside Row to not over-expand
// // // //                     children: [
// // // //                       Text(
// // // //                         displayName,
// // // //                         style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold), // Adjusted from headlineSmall
// // // //                         maxLines: 2, 
// // // //                         overflow: TextOverflow.ellipsis,
// // // //                       ),
// // // //                       const SizedBox(height: 2), // Reduced spacing
// // // //                       Text(
// // // //                         email, 
// // // //                         style: theme.textTheme.bodyMedium, // Adjusted from bodyLarge
// // // //                         maxLines: 2, // MODIFIED: Allow email to wrap to 2 lines
// // // //                         overflow: TextOverflow.ellipsis,
// // // //                       ),
// // // //                       if (!isEmailVerified)
// // // //                         Padding(
// // // //                           padding: const EdgeInsets.only(top: 5.0), // Adjusted padding
// // // //                           child: Container(
// // // //                             padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2), // Adjusted padding
// // // //                             decoration: BoxDecoration(color: Colors.orange.withAlpha(38), borderRadius: BorderRadius.circular(4)),
// // // //                             child: Row(mainAxisSize: MainAxisSize.min, children: [
// // // //                               Icon(Icons.warning_amber_rounded, color: Colors.orange[700], size: 13),
// // // //                               const SizedBox(width: 3),
// // // //                               Text("Email Not Verified", style: TextStyle(color: Colors.orange[800], fontSize: 10, fontWeight: FontWeight.w500))
// // // //                             ]),
// // // //                           ),
// // // //                         ),
// // // //                       if (lastUpdated != null) ...[
// // // //                         const SizedBox(height: 5), // Adjusted spacing
// // // //                         Text(
// // // //                           "Last updated: ${DateFormat('dd MMM yyyy, hh:mm a').format(lastUpdated)}",
// // // //                           style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor, fontSize: 11), // Adjusted for conciseness
// // // //                            maxLines: 1,
// // // //                            overflow: TextOverflow.ellipsis,
// // // //                         )
// // // //                       ],
// // // //                     ],
// // // //                   ),
// // // //                 ),
// // // //               ],
// // // //             ),
// // // //           ),

// // // //           // Positioned Ribbon
// // // //           if (joinedDateString.isNotEmpty)
// // // //             Positioned(
// // // //               top: 16.0,
// // // //               right: 0, 
// // // //               child: Container(
// // // //                 padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
// // // //                 decoration: BoxDecoration(
// // // //                   color: theme.colorScheme.primary,
// // // //                   borderRadius: const BorderRadius.only(
// // // //                     topLeft: Radius.circular(6.0),
// // // //                     bottomLeft: Radius.circular(6.0),
// // // //                   ),
// // // //                   boxShadow: [
// // // //                     BoxShadow(
// // // //                       color: Colors.black.withOpacity(0.1),
// // // //                       blurRadius: 3,
// // // //                       offset: const Offset(-1,1)
// // // //                     )
// // // //                   ]
// // // //                 ),
// // // //                 child: Text(
// // // //                   joinedDateString,
// // // //                   style: theme.textTheme.bodySmall?.copyWith(
// // // //                     color: theme.colorScheme.onPrimary,
// // // //                     fontWeight: FontWeight.w500,
// // // //                     fontSize: 10, // Make ribbon text slightly smaller if needed
// // // //                   ),
// // // //                 ),
// // // //               ),
// // // //             ),
// // // //         ],
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildActionsCard(ThemeData theme) {
// // // //     return Card(
// // // //       elevation: 1.5,
// // // //       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
// // // //       child: Column(
// // // //         children: [
// // // //           _buildActionTile(theme, icon: Icons.edit_note_outlined, title: "Personal Details", onTap: _navigateToEditProfile),
// // // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // // //           _buildActionTile(theme, icon: Icons.favorite_border_outlined, title: "My Favourites", onTap: () {
// // // //             if (!mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyFavouritesScreen()));
// // // //           }),
// // // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // // //           _buildActionTile(theme, icon: Icons.event_note_outlined, title: "My Bookings", onTap: () {
// // // //             if (!mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyBookingsScreen()));
// // // //           }),
// // // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // // //           _buildActionTile(theme, icon: Icons.rate_review_outlined, title: "My Reviews", onTap: () {
// // // //             if (!mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyReviewsScreen()));
// // // //           }),
// // // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // // //           _buildActionTile(theme, icon: Icons.support_agent_outlined, title: "Help & Support", onTap: () {
// // // //             if (!mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const HelpSupportScreen()));
// // // //           }),
// // // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // // //           _buildActionTile(theme, icon: Icons.privacy_tip_outlined, title: "Privacy Policy", onTap: () {
// // // //             if (!mounted) return;
// // // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const PrivacyPolicyScreen()));
// // // //           }),
// // // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // // //           const SignOutButtonTile(), // Assuming this widget is styled appropriately
// // // //         ],
// // // //       ),
// // // //     );
// // // //   }

// // // //   Widget _buildActionTile(ThemeData theme, {required IconData icon, required String title, required VoidCallback onTap}) {
// // // //     return ListTile(
// // // //       leading: Icon(icon, color: theme.colorScheme.secondary, size: 22), // Slightly smaller icon
// // // //       title: Text(title, style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500)), // titleSmall from titleMedium
// // // //       trailing: Icon(Icons.chevron_right, color: Colors.grey[400], size: 20),
// // // //       onTap: onTap,
// // // //       // MODIFIED: Reduced vertical padding in ListTile for compactness
// // // //       contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 2.0), 
// // // //       dense: true,
// // // //     );
// // // //   }
// // // // }

// // // import 'package:flutter/material.dart';
// // // import 'package:firebase_auth/firebase_auth.dart';
// // // import 'package:intl/intl.dart';
// // // import 'package:cloud_firestore/cloud_firestore.dart';
// // // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // // import 'package:flutter/foundation.dart'; // Import for debugPrint
// // // import 'package:mm_associates/features/user/services/user_service.dart';
// // // import 'package:mm_associates/features/profile/screens/edit_profile_screen.dart';

// // // import 'my_favourites_screen.dart';
// // // import 'my_bookings_screen.dart';
// // // import 'my_reviews_screen.dart';
// // // import 'help_support_screen.dart';
// // // import 'privacy_policy_screen.dart';
// // // import 'sign_out_button_tile.dart'; // Import the sign out tile

// // // class ProfileScreen extends StatefulWidget {
// // //   const ProfileScreen({Key? key}) : super(key: key);
// // //   @override
// // //   _ProfileScreenState createState() => _ProfileScreenState();
// // // }

// // // class _ProfileScreenState extends State<ProfileScreen> {
// // //   final AuthService _authService = AuthService();
// // //   final UserService _userService = UserService();
// // //   User? _currentUser;
// // //   Map<String, dynamic>? _userData;
// // //   bool _isLoading = true;
// // //   String? _errorMessage;

// // //   @override
// // //   void initState() {
// // //     super.initState();
// // //     _loadUserProfile();
// // //   }

// // //   void setStateIfMounted(VoidCallback fn) {
// // //     if (mounted) {
// // //       setState(fn);
// // //     }
// // //   }

// // //   Future<void> _loadUserProfile({bool forceRefresh = false}) async {
// // //     debugPrint(
// // //         '_loadUserProfile - Start: _isLoading: $_isLoading, _errorMessage: $_errorMessage, _currentUser: ${_currentUser?.uid}');
// // //     if (!mounted) return;
// // //     setStateIfMounted(() {
// // //       _isLoading = true;
// // //       _errorMessage = null;
// // //     });

// // //     _currentUser = _authService.getCurrentUser();
// // //     if (_currentUser == null) {
// // //       debugPrint('_loadUserProfile - User is null');
// // //       setStateIfMounted(() {
// // //         _isLoading = false;
// // //         _errorMessage = "User not logged in.";
// // //       });
// // //       return;
// // //     }

// // //     try {
// // //       // It's good practice to reload user to get fresh emailVerified status, etc.
// // //       await _currentUser?.reload();
// // //       _currentUser = _authService.getCurrentUser(); // Re-fetch after reload

// // //       _userData =
// // //           await _userService.getUserProfileData(forceRefresh: forceRefresh);
// // //       if (!mounted) return;
// // //       debugPrint('_loadUserProfile - User data loaded: ${_userData != null}');
// // //       setStateIfMounted(() {
// // //         _isLoading = false;
// // //       });
// // //     } catch (e) {
// // //       debugPrint("Error loading profile: $e");
// // //       if (!mounted) return;
// // //       setStateIfMounted(() {
// // //         _isLoading = false;
// // //         _errorMessage = "Failed to load profile details.";
// // //       });
// // //     }
// // //   }

// // //   void _navigateToEditProfile() async {
// // //     if (_currentUser == null || _userData == null) {
// // //       ScaffoldMessenger.of(context).showSnackBar(
// // //         const SnackBar(content: Text("Profile data not loaded yet.")),
// // //       );
// // //       return;
// // //     }

// // //     // Ensure 'name' from userData is prioritized, fallback to Firebase displayName
// // //     final String currentName = _userData!['name'] as String? ?? _currentUser!.displayName ?? 'N/A';
// // //     final String currentEmail = _currentUser!.email ?? 'N/A'; // Email is from Auth User
// // //     final String? currentPhone = _userData!['phoneNumber'] as String?;
// // //     final String? currentProfilePicUrl = _userData!['profilePictureUrl'] as String?;
// // //     final String? currentBio = _userData!['bio'] as String?;
// // //     final Timestamp? dobTimestamp = _userData!['dateOfBirth'] as Timestamp?;
// // //     final DateTime? currentDateOfBirth = dobTimestamp?.toDate();
// // //     final String? currentGender = _userData!['gender'] as String?;
// // //     final String? currentAddressStreet = _userData!['addressStreet'] as String?;
// // //     final String? currentAddressCity = _userData!['addressCity'] as String?;
// // //     final String? currentAddressState = _userData!['addressState'] as String?;
// // //     final String? currentAddressZipCode = _userData!['addressZipCode'] as String?;
// // //     final String? currentAddressCountry = _userData!['addressCountry'] as String?;
// // //     final String? currentSocialMediaLink = _userData!['socialMediaLink'] as String?;

// // //     final result = await Navigator.push<bool>(
// // //       context,
// // //       MaterialPageRoute(
// // //         builder: (context) => EditProfileScreen(
// // //           currentName: currentName,
// // //           currentEmail: currentEmail,
// // //           currentPhone: currentPhone,
// // //           currentProfilePicUrl: currentProfilePicUrl,
// // //           currentBio: currentBio,
// // //           currentDateOfBirth: currentDateOfBirth,
// // //           currentGender: currentGender,
// // //           currentAddressStreet: currentAddressStreet,
// // //           currentAddressCity: currentAddressCity,
// // //           currentAddressState: currentAddressState,
// // //           currentAddressZipCode: currentAddressZipCode,
// // //           currentAddressCountry: currentAddressCountry,
// // //           currentSocialMediaLink: currentSocialMediaLink,
// // //         ),
// // //       ),
// // //     );

// // //     if (result == true && mounted) {
// // //       _loadUserProfile(forceRefresh: true); // Force refresh if changes were saved
// // //     }
// // //   }


// // //   @override
// // //   Widget build(BuildContext context) {
// // //     final ThemeData theme = Theme.of(context);
// // //     return Scaffold(
// // //       backgroundColor: theme.brightness == Brightness.light
// // //           ? Colors.grey[100]!
// // //           : theme.scaffoldBackgroundColor,
// // //       appBar: AppBar(
// // //         title: const Text('My Profile'),
// // //         elevation: 0,
// // //         backgroundColor: theme.brightness == Brightness.light ? Colors.grey[100]! : theme.scaffoldBackgroundColor,
// // //         foregroundColor: theme.colorScheme.onSurface,
// // //       ),
// // //       body: RefreshIndicator(
// // //         onRefresh: () => _loadUserProfile(forceRefresh: true),
// // //         child: _buildBody(theme),
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildBody(ThemeData theme) {
// // //     if (_isLoading) {
// // //       return const Center(child: CircularProgressIndicator());
// // //     }

// // //     if (_errorMessage != null || _currentUser == null || _userData == null) {
// // //       return Center(
// // //         child: Padding(
// // //           padding: const EdgeInsets.all(20.0),
// // //           child: Column(
// // //             mainAxisAlignment: MainAxisAlignment.center,
// // //             children: [
// // //               Icon(Icons.error_outline, color: Colors.red[300], size: 60),
// // //               const SizedBox(height: 15),
// // //               Text(
// // //                 _errorMessage ?? "Could not load profile.",
// // //                 textAlign: TextAlign.center,
// // //                 style: TextStyle(color: Colors.red[700], fontSize: 16),
// // //               ),
// // //               const SizedBox(height: 20),
// // //               ElevatedButton.icon(
// // //                 icon: const Icon(Icons.refresh),
// // //                 label: const Text("Try Again"),
// // //                 onPressed: () => _loadUserProfile(forceRefresh: true),
// // //                 style: ElevatedButton.styleFrom(foregroundColor: theme.colorScheme.onError, backgroundColor: theme.colorScheme.error,)
// // //               ),
// // //             ],
// // //           ),
// // //         ),
// // //       );
// // //     }

// // //     // Determine if it's web or mobile like context (not strictly kIsWeb)
// // //     // For this example, we'll use a simple screen width check for layout
// // //     bool isTabletOrLarger = MediaQuery.of(context).size.width >= 720; // Threshold for web-like layout

// // //     if (isTabletOrLarger) { // Web-like or tablet layout - REVERTED TO ORIGINAL BOXED LAYOUT
// // //         return Center(
// // //           child: Padding(
// // //             // Original padding
// // //             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
// // //             child: Container(
// // //               constraints: BoxConstraints(
// // //                 maxWidth: 550, // Original max width
// // //                 maxHeight: MediaQuery.of(context).size.height * 0.9,
// // //               ),
// // //               decoration: BoxDecoration(
// // //                 color: theme.cardColor,
// // //                 borderRadius: BorderRadius.circular(16.0),
// // //                 border: Border.all(
// // //                   color: theme.dividerColor.withOpacity(0.5),
// // //                   width: 1.0,
// // //                 ),
// // //                 boxShadow: [
// // //                   BoxShadow(
// // //                     color: Colors.black.withOpacity(0.08),
// // //                     blurRadius: 12.0,
// // //                     offset: const Offset(0, 4),
// // //                   ),
// // //                 ],
// // //               ),
// // //               child: ClipRRect(
// // //                 borderRadius: BorderRadius.circular(15.0),
// // //                 child: SingleChildScrollView(
// // //                   // Original padding inside scroll view
// // //                   padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
// // //                   child: Column( // Original Column for stacking header and actions
// // //                     mainAxisSize: MainAxisSize.min,
// // //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// // //                     children: [
// // //                        _buildHeaderSection(theme),
// // //                        const SizedBox(height: 16),
// // //                        _buildActionsSection(theme),
// // //                     ],
// // //                   ),
// // //                 ),
// // //               ),
// // //             ),
// // //           ),
// // //         );
// // //     } else { // Mobile layout (stacked) - without the outer box
// // //         return SingleChildScrollView(
// // //           padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
// // //           child: Column(
// // //             crossAxisAlignment: CrossAxisAlignment.stretch,
// // //             children: [
// // //               _buildHeaderSection(theme),
// // //               const SizedBox(height: 16), 
// // //               _buildActionsSection(theme),
// // //               const SizedBox(height: 24), 
// // //             ],
// // //           ),
// // //         );
// // //     }
// // //   }

// // //   Widget _buildHeaderSection(ThemeData theme) {
// // //     return _buildHeaderCard(theme);
// // //   }

// // //   Widget _buildActionsSection(ThemeData theme) {
// // //     return _buildActionsCard(theme);
// // //   }


// // //   Widget _buildHeaderCard(ThemeData theme) {
// // //     final String displayName = _userData?['name'] as String? ?? _currentUser?.displayName ?? 'User';
// // //     final String email = _currentUser?.email ?? 'No Email';
// // //     final String profilePicUrl = _userData?['profilePictureUrl'] as String? ?? '';
// // //     final bool isEmailVerified = _currentUser?.emailVerified ?? false;
// // //     final dynamic updatedAtRaw = _userData?['updatedAt'];
// // //     DateTime? lastUpdated;
// // //     if (updatedAtRaw is Timestamp) {
// // //       lastUpdated = updatedAtRaw.toDate();
// // //     } else if (updatedAtRaw is String) {
// // //       lastUpdated = DateTime.tryParse(updatedAtRaw);
// // //     }

// // //     String joinedDateString = "";
// // //     final creationTime = _currentUser?.metadata.creationTime;
// // //     if (creationTime != null) {
// // //       joinedDateString = "Since ${DateFormat('MMM yyyy').format(creationTime)}";
// // //     }

// // //     const double ribbonSpace = 90.0; // Space for the "Joined since" ribbon

// // //     return Card(
// // //       elevation: 2.0,
// // //       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
// // //       clipBehavior: Clip.antiAlias,
// // //       margin: EdgeInsets.zero,
// // //       child: Stack(
// // //         children: [
// // //           Padding(
// // //             padding: const EdgeInsets.fromLTRB(16.0, 16.0, ribbonSpace, 16.0),
// // //             child: Row(
// // //               crossAxisAlignment: CrossAxisAlignment.center,
// // //               children: [
// // //                 CircleAvatar(
// // //                   radius: 36,
// // //                   backgroundColor: theme.colorScheme.surfaceContainerHighest,
// // //                   foregroundImage: profilePicUrl.isNotEmpty ? NetworkImage(profilePicUrl) : null,
// // //                   child: profilePicUrl.isEmpty ? Icon(Icons.person_outline, size: 38, color: theme.colorScheme.onSurfaceVariant) : null,
// // //                 ),
// // //                 const SizedBox(width: 12),
// // //                 Expanded(
// // //                   child: Column(
// // //                     crossAxisAlignment: CrossAxisAlignment.start,
// // //                     mainAxisSize: MainAxisSize.min,
// // //                     children: [
// // //                       Text(
// // //                         displayName,
// // //                         style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
// // //                         maxLines: 2,
// // //                         overflow: TextOverflow.ellipsis,
// // //                       ),
// // //                       const SizedBox(height: 2),
// // //                       Text(
// // //                         email,
// // //                         style: theme.textTheme.bodyMedium,
// // //                         maxLines: 2,
// // //                         overflow: TextOverflow.ellipsis,
// // //                       ),
// // //                       if (!isEmailVerified)
// // //                         Padding(
// // //                           padding: const EdgeInsets.only(top: 5.0),
// // //                           child: Container(
// // //                             padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
// // //                             decoration: BoxDecoration(color: Colors.orange.withAlpha(38), borderRadius: BorderRadius.circular(4)),
// // //                             child: Row(mainAxisSize: MainAxisSize.min, children: [
// // //                               Icon(Icons.warning_amber_rounded, color: Colors.orange[700], size: 13),
// // //                               const SizedBox(width: 3),
// // //                               Text("Email Not Verified", style: TextStyle(color: Colors.orange[800], fontSize: 10, fontWeight: FontWeight.w500))
// // //                             ]),
// // //                           ),
// // //                         ),
// // //                       if (lastUpdated != null) ...[
// // //                         const SizedBox(height: 5),
// // //                         Text(
// // //                           "Last updated: ${DateFormat('dd MMM yyyy, hh:mm a').format(lastUpdated)}",
// // //                           style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor, fontSize: 11),
// // //                           maxLines: 2, // MODIFIED: Allow wrapping to 2 lines
// // //                           overflow: TextOverflow.ellipsis, // Ellipsis if it still exceeds
// // //                         )
// // //                       ],
// // //                     ],
// // //                   ),
// // //                 ),
// // //               ],
// // //             ),
// // //           ),
// // //           if (joinedDateString.isNotEmpty)
// // //             Positioned(
// // //               top: 16.0,
// // //               right: 0,
// // //               child: Container(
// // //                 padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
// // //                 decoration: BoxDecoration(
// // //                   color: theme.colorScheme.primary,
// // //                   borderRadius: const BorderRadius.only(
// // //                     topLeft: Radius.circular(6.0),
// // //                     bottomLeft: Radius.circular(6.0),
// // //                   ),
// // //                   boxShadow: [
// // //                     BoxShadow(
// // //                       color: Colors.black.withOpacity(0.1),
// // //                       blurRadius: 3,
// // //                       offset: const Offset(-1,1)
// // //                     )
// // //                   ]
// // //                 ),
// // //                 child: Text(
// // //                   joinedDateString,
// // //                   style: theme.textTheme.bodySmall?.copyWith(
// // //                     color: theme.colorScheme.onPrimary,
// // //                     fontWeight: FontWeight.w500,
// // //                     fontSize: 10,
// // //                   ),
// // //                 ),
// // //               ),
// // //             ),
// // //         ],
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildActionsCard(ThemeData theme) {
// // //     return Card(
// // //       elevation: 1.5,
// // //       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
// // //       margin: EdgeInsets.zero,
// // //       child: Column(
// // //         mainAxisAlignment: MainAxisAlignment.start,
// // //         mainAxisSize: MainAxisSize.min,
// // //         children: [
// // //           _buildActionTile(theme, icon: Icons.edit_note_outlined, title: "Personal Details", onTap: _navigateToEditProfile),
// // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // //           _buildActionTile(theme, icon: Icons.favorite_border_outlined, title: "My Favourites", onTap: () {
// // //             if (!mounted) return;
// // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyFavouritesScreen()));
// // //           }),
// // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // //           _buildActionTile(theme, icon: Icons.event_note_outlined, title: "My Bookings", onTap: () {
// // //             if (!mounted) return;
// // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyBookingsScreen()));
// // //           }),
// // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // //           _buildActionTile(theme, icon: Icons.rate_review_outlined, title: "My Reviews", onTap: () {
// // //             if (!mounted) return;
// // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyReviewsScreen()));
// // //           }),
// // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // //           _buildActionTile(theme, icon: Icons.support_agent_outlined, title: "Help & Support", onTap: () {
// // //             if (!mounted) return;
// // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const HelpSupportScreen()));
// // //           }),
// // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // //           _buildActionTile(theme, icon: Icons.privacy_tip_outlined, title: "Privacy Policy", onTap: () {
// // //             if (!mounted) return;
// // //             Navigator.push(context, MaterialPageRoute(builder: (context) => const PrivacyPolicyScreen()));
// // //           }),
// // //           const Divider(height: 0, indent: 16, endIndent: 16),
// // //           const SignOutButtonTile(),
// // //         ],
// // //       ),
// // //     );
// // //   }

// // //   Widget _buildActionTile(ThemeData theme, {required IconData icon, required String title, required VoidCallback onTap}) {
// // //     return ListTile(
// // //       leading: Icon(icon, color: theme.colorScheme.secondary, size: 22),
// // //       title: Text(title, style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500)),
// // //       trailing: Icon(Icons.chevron_right, color: Colors.grey[400], size: 20),
// // //       onTap: onTap,
// // //       contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 2.0),
// // //       dense: true,
// // //     );
// // //   }
// // // }

// // import 'package:flutter/material.dart';
// // import 'package:firebase_auth/firebase_auth.dart';
// // import 'package:intl/intl.dart';
// // import 'package:cloud_firestore/cloud_firestore.dart';
// // import 'package:mm_associates/features/auth/services/auth_service.dart';
// // import 'package:flutter/foundation.dart'; // Import for debugPrint
// // import 'package:mm_associates/features/user/services/user_service.dart';
// // import 'package:mm_associates/features/profile/screens/edit_profile_screen.dart';

// // import 'my_favourites_screen.dart';
// // import 'my_bookings_screen.dart';
// // import 'my_reviews_screen.dart';
// // import 'help_support_screen.dart';
// // import 'privacy_policy_screen.dart';
// // import 'sign_out_button_tile.dart'; // Import the sign out tile

// // class ProfileScreen extends StatefulWidget {
// //   const ProfileScreen({Key? key}) : super(key: key);
// //   @override
// //   _ProfileScreenState createState() => _ProfileScreenState();
// // }

// // class _ProfileScreenState extends State<ProfileScreen> {
// //   final AuthService _authService = AuthService();
// //   final UserService _userService = UserService();
// //   User? _currentUser;
// //   Map<String, dynamic>? _userData;
// //   bool _isLoading = true;
// //   String? _errorMessage;

// //   @override
// //   void initState() {
// //     super.initState();
// //     _loadUserProfile();
// //   }

// //   void setStateIfMounted(VoidCallback fn) {
// //     if (mounted) {
// //       setState(fn);
// //     }
// //   }

// //   Future<void> _loadUserProfile({bool forceRefresh = false}) async {
// //     debugPrint(
// //         '_loadUserProfile - Start: _isLoading: $_isLoading, _errorMessage: $_errorMessage, _currentUser: ${_currentUser?.uid}');
// //     if (!mounted) return;
// //     setStateIfMounted(() {
// //       _isLoading = true;
// //       _errorMessage = null;
// //     });

// //     _currentUser = _authService.getCurrentUser();
// //     if (_currentUser == null) {
// //       debugPrint('_loadUserProfile - User is null');
// //       setStateIfMounted(() {
// //         _isLoading = false;
// //         _errorMessage = "User not logged in.";
// //       });
// //       return;
// //     }

// //     try {
// //       await _currentUser?.reload();
// //       _currentUser = _authService.getCurrentUser();

// //       _userData =
// //           await _userService.getUserProfileData(forceRefresh: forceRefresh);
// //       if (!mounted) return;
// //       debugPrint('_loadUserProfile - User data loaded: ${_userData != null}');
// //       setStateIfMounted(() {
// //         _isLoading = false;
// //       });
// //     } catch (e) {
// //       debugPrint("Error loading profile: $e");
// //       if (!mounted) return;
// //       setStateIfMounted(() {
// //         _isLoading = false;
// //         _errorMessage = "Failed to load profile details.";
// //       });
// //     }
// //   }

// //   void _navigateToEditProfile() async {
// //     if (_currentUser == null || _userData == null) {
// //       ScaffoldMessenger.of(context).showSnackBar(
// //         const SnackBar(content: Text("Profile data not loaded yet.")),
// //       );
// //       return;
// //     }

// //     final String currentName = _userData!['name'] as String? ?? _currentUser!.displayName ?? 'N/A';
// //     final String currentEmail = _currentUser!.email ?? 'N/A';
// //     final String? currentPhone = _userData!['phoneNumber'] as String?;
// //     final String? currentProfilePicUrl = _userData!['profilePictureUrl'] as String?;
// //     final String? currentBio = _userData!['bio'] as String?;
// //     final Timestamp? dobTimestamp = _userData!['dateOfBirth'] as Timestamp?;
// //     final DateTime? currentDateOfBirth = dobTimestamp?.toDate();
// //     final String? currentGender = _userData!['gender'] as String?;
// //     final String? currentAddressStreet = _userData!['addressStreet'] as String?;
// //     final String? currentAddressCity = _userData!['addressCity'] as String?;
// //     final String? currentAddressState = _userData!['addressState'] as String?;
// //     final String? currentAddressZipCode = _userData!['addressZipCode'] as String?;
// //     final String? currentAddressCountry = _userData!['addressCountry'] as String?;
// //     final String? currentSocialMediaLink = _userData!['socialMediaLink'] as String?;

// //     final result = await Navigator.push<bool>(
// //       context,
// //       MaterialPageRoute(
// //         builder: (context) => EditProfileScreen(
// //           currentName: currentName,
// //           currentEmail: currentEmail,
// //           currentPhone: currentPhone,
// //           currentProfilePicUrl: currentProfilePicUrl,
// //           currentBio: currentBio,
// //           currentDateOfBirth: currentDateOfBirth,
// //           currentGender: currentGender,
// //           currentAddressStreet: currentAddressStreet,
// //           currentAddressCity: currentAddressCity,
// //           currentAddressState: currentAddressState,
// //           currentAddressZipCode: currentAddressZipCode,
// //           currentAddressCountry: currentAddressCountry,
// //           currentSocialMediaLink: currentSocialMediaLink,
// //         ),
// //       ),
// //     );

// //     if (result == true && mounted) {
// //       _loadUserProfile(forceRefresh: true);
// //     }
// //   }


// //   @override
// //   Widget build(BuildContext context) {
// //     final ThemeData theme = Theme.of(context);
// //     return Scaffold(
// //       backgroundColor: theme.brightness == Brightness.light
// //           ? Colors.grey[100]!
// //           : theme.scaffoldBackgroundColor,
// //       appBar: AppBar(
// //         title: const Text('My Profile'),
// //         elevation: 0,
// //         backgroundColor: theme.brightness == Brightness.light ? Colors.grey[100]! : theme.scaffoldBackgroundColor,
// //         foregroundColor: theme.colorScheme.onSurface,
// //       ),
// //       body: RefreshIndicator(
// //         onRefresh: () => _loadUserProfile(forceRefresh: true),
// //         child: _buildBody(theme),
// //       ),
// //     );
// //   }

// //   Widget _buildBody(ThemeData theme) {
// //     if (_isLoading) {
// //       return const Center(child: CircularProgressIndicator());
// //     }

// //     if (_errorMessage != null || _currentUser == null || _userData == null) {
// //       return Center(
// //         child: Padding(
// //           padding: const EdgeInsets.all(20.0),
// //           child: Column(
// //             mainAxisAlignment: MainAxisAlignment.center,
// //             children: [
// //               Icon(Icons.error_outline, color: Colors.red[300], size: 60),
// //               const SizedBox(height: 15),
// //               Text(
// //                 _errorMessage ?? "Could not load profile.",
// //                 textAlign: TextAlign.center,
// //                 style: TextStyle(color: Colors.red[700], fontSize: 16),
// //               ),
// //               const SizedBox(height: 20),
// //               ElevatedButton.icon(
// //                 icon: const Icon(Icons.refresh),
// //                 label: const Text("Try Again"),
// //                 onPressed: () => _loadUserProfile(forceRefresh: true),
// //                 style: ElevatedButton.styleFrom(foregroundColor: theme.colorScheme.onError, backgroundColor: theme.colorScheme.error,)
// //               ),
// //             ],
// //           ),
// //         ),
// //       );
// //     }

// //     bool isTabletOrLarger = MediaQuery.of(context).size.width >= 720; 

// //     if (isTabletOrLarger) { 
// //         return Center(
// //           child: Padding(
// //             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
// //             child: Container(
// //               constraints: BoxConstraints(
// //                 maxWidth: 550, 
// //                 maxHeight: MediaQuery.of(context).size.height * 0.9,
// //               ),
// //               decoration: BoxDecoration(
// //                 color: theme.cardColor,
// //                 borderRadius: BorderRadius.circular(16.0),
// //                 border: Border.all(
// //                   color: theme.dividerColor.withOpacity(0.5),
// //                   width: 1.0,
// //                 ),
// //                 boxShadow: [
// //                   BoxShadow(
// //                     color: Colors.black.withOpacity(0.08),
// //                     blurRadius: 12.0,
// //                     offset: const Offset(0, 4),
// //                   ),
// //                 ],
// //               ),
// //               child: ClipRRect(
// //                 borderRadius: BorderRadius.circular(15.0),
// //                 child: SingleChildScrollView(
// //                   padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
// //                   child: Column( 
// //                     mainAxisSize: MainAxisSize.min,
// //                     crossAxisAlignment: CrossAxisAlignment.stretch,
// //                     children: [
// //                        _buildHeaderSection(theme),
// //                        const SizedBox(height: 16),
// //                        _buildActionsSection(theme),
// //                     ],
// //                   ),
// //                 ),
// //               ),
// //             ),
// //           ),
// //         );
// //     } else { 
// //         return SingleChildScrollView(
// //           padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
// //           child: Column(
// //             crossAxisAlignment: CrossAxisAlignment.stretch,
// //             children: [
// //               _buildHeaderSection(theme),
// //               const SizedBox(height: 16), 
// //               _buildActionsSection(theme),
// //               const SizedBox(height: 24), 
// //             ],
// //           ),
// //         );
// //     }
// //   }

// //   Widget _buildHeaderSection(ThemeData theme) {
// //     return _buildHeaderCard(theme);
// //   }

// //   Widget _buildActionsSection(ThemeData theme) {
// //     return _buildActionsCard(theme);
// //   }


// //   Widget _buildHeaderCard(ThemeData theme) {
// //     final String displayName = _userData?['name'] as String? ?? _currentUser?.displayName ?? 'User';
// //     final String email = _currentUser?.email ?? 'No Email';
// //     final String profilePicUrl = _userData?['profilePictureUrl'] as String? ?? '';
// //     final bool isEmailVerified = _currentUser?.emailVerified ?? false;
// //     final dynamic updatedAtRaw = _userData?['updatedAt'];
// //     DateTime? lastUpdated;
// //     if (updatedAtRaw is Timestamp) {
// //       lastUpdated = updatedAtRaw.toDate();
// //     } else if (updatedAtRaw is String) {
// //       lastUpdated = DateTime.tryParse(updatedAtRaw);
// //     }

// //     String joinedDateString = "";
// //     final creationTime = _currentUser?.metadata.creationTime;
// //     if (creationTime != null) {
// //       joinedDateString = "Since ${DateFormat('MMM yyyy').format(creationTime)}";
// //     }

// //     // MODIFIED: Reduced ribbonSpace to give more horizontal room to the text
// //     const double ribbonSpace = 80.0; 

// //     return Card(
// //       elevation: 2.0,
// //       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
// //       clipBehavior: Clip.antiAlias,
// //       margin: EdgeInsets.zero,
// //       child: Stack(
// //         children: [
// //           Padding(
// //             padding: EdgeInsets.fromLTRB(16.0, 16.0, ribbonSpace, 16.0),
// //             child: Row(
// //               crossAxisAlignment: CrossAxisAlignment.center,
// //               children: [
// //                 CircleAvatar(
// //                   radius: 36,
// //                   backgroundColor: theme.colorScheme.surfaceContainerHighest,
// //                   foregroundImage: profilePicUrl.isNotEmpty ? NetworkImage(profilePicUrl) : null,
// //                   child: profilePicUrl.isEmpty ? Icon(Icons.person_outline, size: 38, color: theme.colorScheme.onSurfaceVariant) : null,
// //                 ),
// //                 const SizedBox(width: 12),
// //                 Expanded(
// //                   child: Column(
// //                     crossAxisAlignment: CrossAxisAlignment.start,
// //                     mainAxisSize: MainAxisSize.min,
// //                     children: [
// //                       Text(
// //                         displayName,
// //                         style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
// //                         maxLines: 2,
// //                         overflow: TextOverflow.ellipsis,
// //                       ),
// //                       const SizedBox(height: 2),
// //                       Text(
// //                         email,
// //                         style: theme.textTheme.bodyMedium,
// //                         maxLines: 2,
// //                         overflow: TextOverflow.ellipsis,
// //                       ),
// //                       if (!isEmailVerified)
// //                         Padding(
// //                           padding: const EdgeInsets.only(top: 5.0),
// //                           child: Container(
// //                             padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
// //                             decoration: BoxDecoration(color: Colors.orange.withAlpha(38), borderRadius: BorderRadius.circular(4)),
// //                             child: Row(mainAxisSize: MainAxisSize.min, children: [
// //                               Icon(Icons.warning_amber_rounded, color: Colors.orange[700], size: 13),
// //                               const SizedBox(width: 3),
// //                               Text("Email Not Verified", style: TextStyle(color: Colors.orange[800], fontSize: 10, fontWeight: FontWeight.w500))
// //                             ]),
// //                           ),
// //                         ),
// //                       if (lastUpdated != null) ...[
// //                         const SizedBox(height: 5),
// //                         Text(
// //                           "Last updated: ${DateFormat('dd MMM yyyy, hh:mm a').format(lastUpdated)}",
// //                           style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor, fontSize: 11),
// //                           maxLines: 2, 
// //                           overflow: TextOverflow.ellipsis, 
// //                         )
// //                       ],
// //                     ],
// //                   ),
// //                 ),
// //               ],
// //             ),
// //           ),
// //           if (joinedDateString.isNotEmpty)
// //             Positioned(
// //               top: 16.0,
// //               right: 0,
// //               child: Container(
// //                 padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
// //                 decoration: BoxDecoration(
// //                   color: theme.colorScheme.primary,
// //                   borderRadius: const BorderRadius.only(
// //                     topLeft: Radius.circular(6.0),
// //                     bottomLeft: Radius.circular(6.0),
// //                   ),
// //                   boxShadow: [
// //                     BoxShadow(
// //                       color: Colors.black.withOpacity(0.1),
// //                       blurRadius: 3,
// //                       offset: const Offset(-1,1)
// //                     )
// //                   ]
// //                 ),
// //                 child: Text(
// //                   joinedDateString,
// //                   style: theme.textTheme.bodySmall?.copyWith(
// //                     color: theme.colorScheme.onPrimary,
// //                     fontWeight: FontWeight.w500,
// //                     fontSize: 10,
// //                   ),
// //                 ),
// //               ),
// //             ),
// //         ],
// //       ),
// //     );
// //   }

// //   Widget _buildActionsCard(ThemeData theme) {
// //     return Card(
// //       elevation: 1.5,
// //       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
// //       margin: EdgeInsets.zero,
// //       child: Column(
// //         mainAxisAlignment: MainAxisAlignment.start,
// //         mainAxisSize: MainAxisSize.min,
// //         children: [
// //           _buildActionTile(theme, icon: Icons.edit_note_outlined, title: "Personal Details", onTap: _navigateToEditProfile),
// //           const Divider(height: 0, indent: 16, endIndent: 16),
// //           _buildActionTile(theme, icon: Icons.favorite_border_outlined, title: "My Favourites", onTap: () {
// //             if (!mounted) return;
// //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyFavouritesScreen()));
// //           }),
// //           const Divider(height: 0, indent: 16, endIndent: 16),
// //           _buildActionTile(theme, icon: Icons.event_note_outlined, title: "My Bookings", onTap: () {
// //             if (!mounted) return;
// //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyBookingsScreen()));
// //           }),
// //           const Divider(height: 0, indent: 16, endIndent: 16),
// //           _buildActionTile(theme, icon: Icons.rate_review_outlined, title: "My Reviews", onTap: () {
// //             if (!mounted) return;
// //             Navigator.push(context, MaterialPageRoute(builder: (context) => const MyReviewsScreen()));
// //           }),
// //           const Divider(height: 0, indent: 16, endIndent: 16),
// //           _buildActionTile(theme, icon: Icons.support_agent_outlined, title: "Help & Support", onTap: () {
// //             if (!mounted) return;
// //             Navigator.push(context, MaterialPageRoute(builder: (context) => const HelpSupportScreen()));
// //           }),
// //           const Divider(height: 0, indent: 16, endIndent: 16),
// //           _buildActionTile(theme, icon: Icons.privacy_tip_outlined, title: "Privacy Policy", onTap: () {
// //             if (!mounted) return;
// //             Navigator.push(context, MaterialPageRoute(builder: (context) => const PrivacyPolicyScreen()));
// //           }),
// //           const Divider(height: 0, indent: 16, endIndent: 16),
// //           const SignOutButtonTile(),
// //         ],
// //       ),
// //     );
// //   }

// //   Widget _buildActionTile(ThemeData theme, {required IconData icon, required String title, required VoidCallback onTap}) {
// //     return ListTile(
// //       leading: Icon(icon, color: theme.colorScheme.secondary, size: 22),
// //       title: Text(title, style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500)),
// //       trailing: Icon(Icons.chevron_right, color: Colors.grey[400], size: 20),
// //       onTap: onTap,
// //       contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 2.0),
// //       dense: true,
// //     );
// //   }
// // }


// //admin related changes----
// import 'package:flutter/material.dart';
// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:intl/intl.dart';
// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:mm_associates/features/auth/services/auth_service.dart';
// import 'package:flutter/foundation.dart'; // Import for debugPrint
// import 'package:mm_associates/features/user/services/user_service.dart';
// import 'package:mm_associates/features/profile/screens/edit_profile_screen.dart';

// import 'my_venues_screen.dart'; // <<< ADDED IMPORT FOR ADMIN
// import 'my_favourites_screen.dart';
// import 'my_bookings_screen.dart';
// import 'my_reviews_screen.dart';
// import 'help_support_screen.dart';
// import 'privacy_policy_screen.dart';
// import 'sign_out_button_tile.dart';

// class ProfileScreen extends StatefulWidget {
//   const ProfileScreen({Key? key}) : super(key: key);
//   @override
//   _ProfileScreenState createState() => _ProfileScreenState();
// }

// class _ProfileScreenState extends State<ProfileScreen> {
//   final AuthService _authService = AuthService();
//   final UserService _userService = UserService();
//   User? _currentUser;
//   Map<String, dynamic>? _userData;
//   bool _isLoading = true;
//   String? _errorMessage;
//   bool _isAdmin = false; // <<< ADDED STATE FOR ADMIN ROLE

//   @override
//   void initState() {
//     super.initState();
//     _loadUserProfile();
//   }

//   void setStateIfMounted(VoidCallback fn) {
//     if (mounted) {
//       setState(fn);
//     }
//   }

//   Future<void> _loadUserProfile({bool forceRefresh = false}) async {
//     if (!mounted) return;
//     setStateIfMounted(() {
//       _isLoading = true;
//       _errorMessage = null;
//     });

//     _currentUser = _authService.getCurrentUser();
//     if (_currentUser == null) {
//       setStateIfMounted(() {
//         _isLoading = false;
//         _errorMessage = "User not logged in.";
//       });
//       return;
//     }

//     try {
//       await _currentUser?.reload();
//       _currentUser = _authService.getCurrentUser();

//       // Fetch user data and admin status in parallel for efficiency
//       final results = await Future.wait([
//         _userService.getUserProfileData(forceRefresh: forceRefresh),
//         _userService.isCurrentUserAdmin(),
//       ]);

//       if (!mounted) return;
      
//       _userData = results[0] as Map<String, dynamic>?;
//       final bool isAdmin = results[1] as bool;

//       debugPrint('_loadUserProfile - User data loaded: ${_userData != null}, isAdmin: $isAdmin');
      
//       setStateIfMounted(() {
//         _isAdmin = isAdmin;
//         _isLoading = false;
//       });
//     } catch (e) {
//       debugPrint("Error loading profile: $e");
//       if (!mounted) return;
//       setStateIfMounted(() {
//         _isLoading = false;
//         _errorMessage = "Failed to load profile details.";
//       });
//     }
//   }

//   void _navigateToEditProfile() async {
//     if (_currentUser == null || _userData == null) {
//       ScaffoldMessenger.of(context).showSnackBar(
//         const SnackBar(content: Text("Profile data not loaded yet.")),
//       );
//       return;
//     }

//     final String currentName = _userData!['name'] as String? ?? _currentUser!.displayName ?? 'N/A';
//     final String currentEmail = _currentUser!.email ?? 'N/A';
//     final String? currentPhone = _userData!['phoneNumber'] as String?;
//     final String? currentProfilePicUrl = _userData!['profilePictureUrl'] as String?;
//     final String? currentBio = _userData!['bio'] as String?;
//     final Timestamp? dobTimestamp = _userData!['dateOfBirth'] as Timestamp?;
//     final DateTime? currentDateOfBirth = dobTimestamp?.toDate();
//     final String? currentGender = _userData!['gender'] as String?;
//     final String? currentAddressStreet = _userData!['addressStreet'] as String?;
//     final String? currentAddressCity = _userData!['addressCity'] as String?;
//     final String? currentAddressState = _userData!['addressState'] as String?;
//     final String? currentAddressZipCode = _userData!['addressZipCode'] as String?;
//     final String? currentAddressCountry = _userData!['addressCountry'] as String?;
//     final String? currentSocialMediaLink = _userData!['socialMediaLink'] as String?;

//     final result = await Navigator.push<bool>(
//       context,
//       MaterialPageRoute(
//         builder: (context) => EditProfileScreen(
//           currentName: currentName,
//           currentEmail: currentEmail,
//           currentPhone: currentPhone,
//           currentProfilePicUrl: currentProfilePicUrl,
//           currentBio: currentBio,
//           currentDateOfBirth: currentDateOfBirth,
//           currentGender: currentGender,
//           currentAddressStreet: currentAddressStreet,
//           currentAddressCity: currentAddressCity,
//           currentAddressState: currentAddressState,
//           currentAddressZipCode: currentAddressZipCode,
//           currentAddressCountry: currentAddressCountry,
//           currentSocialMediaLink: currentSocialMediaLink,
//         ),
//       ),
//     );

//     if (result == true && mounted) {
//       _loadUserProfile(forceRefresh: true);
//     }
//   }


//   @override
//   Widget build(BuildContext context) {
//     final ThemeData theme = Theme.of(context);
//     return Scaffold(
//       backgroundColor: theme.brightness == Brightness.light
//           ? Colors.grey[100]!
//           : theme.scaffoldBackgroundColor,
//       appBar: AppBar(
//         title: const Text('My Profile'),
//         elevation: 0,
//         backgroundColor: theme.brightness == Brightness.light ? Colors.grey[100]! : theme.scaffoldBackgroundColor,
//         foregroundColor: theme.colorScheme.onSurface,
//       ),
//       body: RefreshIndicator(
//         onRefresh: () => _loadUserProfile(forceRefresh: true),
//         child: _buildBody(theme),
//       ),
//     );
//   }

//   Widget _buildBody(ThemeData theme) {
//     if (_isLoading) {
//       return const Center(child: CircularProgressIndicator());
//     }

//     if (_errorMessage != null || _currentUser == null || _userData == null) {
//       return Center(
//         child: Padding(
//           padding: const EdgeInsets.all(20.0),
//           child: Column(
//             mainAxisAlignment: MainAxisAlignment.center,
//             children: [
//               Icon(Icons.error_outline, color: Colors.red[300], size: 60),
//               const SizedBox(height: 15),
//               Text(
//                 _errorMessage ?? "Could not load profile.",
//                 textAlign: TextAlign.center,
//                 style: TextStyle(color: Colors.red[700], fontSize: 16),
//               ),
//               const SizedBox(height: 20),
//               ElevatedButton.icon(
//                 icon: const Icon(Icons.refresh),
//                 label: const Text("Try Again"),
//                 onPressed: () => _loadUserProfile(forceRefresh: true),
//                 style: ElevatedButton.styleFrom(foregroundColor: theme.colorScheme.onError, backgroundColor: theme.colorScheme.error,)
//               ),
//             ],
//           ),
//         ),
//       );
//     }

//     bool isTabletOrLarger = MediaQuery.of(context).size.width >= 720; 

//     if (isTabletOrLarger) { 
//         return Center(
//           child: Padding(
//             padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
//             child: Container(
//               constraints: BoxConstraints(
//                 maxWidth: 550, 
//                 maxHeight: MediaQuery.of(context).size.height * 0.9,
//               ),
//               decoration: BoxDecoration(
//                 color: theme.cardColor,
//                 borderRadius: BorderRadius.circular(16.0),
//                 border: Border.all(
//                   color: theme.dividerColor.withOpacity(0.5),
//                   width: 1.0,
//                 ),
//                 boxShadow: [
//                   BoxShadow(
//                     color: Colors.black.withOpacity(0.08),
//                     blurRadius: 12.0,
//                     offset: const Offset(0, 4),
//                   ),
//                 ],
//               ),
//               child: ClipRRect(
//                 borderRadius: BorderRadius.circular(15.0),
//                 child: SingleChildScrollView(
//                   padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
//                   child: Column( 
//                     mainAxisSize: MainAxisSize.min,
//                     crossAxisAlignment: CrossAxisAlignment.stretch,
//                     children: [
//                        _buildHeaderSection(theme),
//                        const SizedBox(height: 16),
//                        _buildActionsSection(theme),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ),
//         );
//     } else { 
//         return SingleChildScrollView(
//           padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
//           child: Column(
//             crossAxisAlignment: CrossAxisAlignment.stretch,
//             children: [
//               _buildHeaderSection(theme),
//               const SizedBox(height: 16), 
//               _buildActionsSection(theme),
//               const SizedBox(height: 24), 
//             ],
//           ),
//         );
//     }
//   }

//   Widget _buildHeaderSection(ThemeData theme) {
//     return _buildHeaderCard(theme);
//   }

//   Widget _buildActionsSection(ThemeData theme) {
//     return _buildActionsCard(theme);
//   }

//   Widget _buildHeaderCard(ThemeData theme) {
//     final String displayName = _userData?['name'] as String? ?? _currentUser?.displayName ?? 'User';
//     final String email = _currentUser?.email ?? 'No Email';
//     final String profilePicUrl = _userData?['profilePictureUrl'] as String? ?? '';
//     final bool isEmailVerified = _currentUser?.emailVerified ?? false;
//     final dynamic updatedAtRaw = _userData?['updatedAt'];
//     DateTime? lastUpdated;
//     if (updatedAtRaw is Timestamp) {
//       lastUpdated = updatedAtRaw.toDate();
//     } else if (updatedAtRaw is String) {
//       lastUpdated = DateTime.tryParse(updatedAtRaw);
//     }

//     String joinedDateString = "";
//     final creationTime = _currentUser?.metadata.creationTime;
//     if (creationTime != null) {
//       joinedDateString = "Since ${DateFormat('MMM yyyy').format(creationTime)}";
//     }
    
//     const double ribbonSpace = 80.0; 

//     return Card(
//       elevation: 2.0,
//       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
//       clipBehavior: Clip.antiAlias,
//       margin: EdgeInsets.zero,
//       child: Stack(
//         children: [
//           Padding(
//             padding: EdgeInsets.fromLTRB(16.0, 16.0, ribbonSpace, 16.0),
//             child: Row(
//               crossAxisAlignment: CrossAxisAlignment.center,
//               children: [
//                 CircleAvatar(
//                   radius: 36,
//                   backgroundColor: theme.colorScheme.surfaceContainerHighest,
//                   foregroundImage: profilePicUrl.isNotEmpty ? NetworkImage(profilePicUrl) : null,
//                   child: profilePicUrl.isEmpty ? Icon(Icons.person_outline, size: 38, color: theme.colorScheme.onSurfaceVariant) : null,
//                 ),
//                 const SizedBox(width: 12),
//                 Expanded(
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.start,
//                     mainAxisSize: MainAxisSize.min,
//                     children: [
//                       Text(
//                         displayName,
//                         style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
//                         maxLines: 2,
//                         overflow: TextOverflow.ellipsis,
//                       ),
//                       const SizedBox(height: 2),
//                       Text(
//                         email,
//                         style: theme.textTheme.bodyMedium,
//                         maxLines: 2,
//                         overflow: TextOverflow.ellipsis,
//                       ),
//                       if (!isEmailVerified)
//                         Padding(
//                           padding: const EdgeInsets.only(top: 5.0),
//                           child: Container(
//                             padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
//                             decoration: BoxDecoration(color: Colors.orange.withAlpha(38), borderRadius: BorderRadius.circular(4)),
//                             child: Row(mainAxisSize: MainAxisSize.min, children: [
//                               Icon(Icons.warning_amber_rounded, color: Colors.orange[700], size: 13),
//                               const SizedBox(width: 3),
//                               Text("Email Not Verified", style: TextStyle(color: Colors.orange[800], fontSize: 10, fontWeight: FontWeight.w500))
//                             ]),
//                           ),
//                         ),
//                       if (lastUpdated != null) ...[
//                         const SizedBox(height: 5),
//                         Text(
//                           "Last updated: ${DateFormat('dd MMM yyyy, hh:mm a').format(lastUpdated)}",
//                           style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor, fontSize: 11),
//                           maxLines: 2, 
//                           overflow: TextOverflow.ellipsis, 
//                         )
//                       ],
//                     ],
//                   ),
//                 ),
//               ],
//             ),
//           ),
//           if (joinedDateString.isNotEmpty)
//             Positioned(
//               top: 16.0,
//               right: 0,
//               child: Container(
//                 padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
//                 decoration: BoxDecoration(
//                   color: theme.colorScheme.primary,
//                   borderRadius: const BorderRadius.only(
//                     topLeft: Radius.circular(6.0),
//                     bottomLeft: Radius.circular(6.0),
//                   ),
//                   boxShadow: [
//                     BoxShadow(
//                       color: Colors.black.withOpacity(0.1),
//                       blurRadius: 3,
//                       offset: const Offset(-1,1)
//                     )
//                   ]
//                 ),
//                 child: Text(
//                   joinedDateString,
//                   style: theme.textTheme.bodySmall?.copyWith(
//                     color: theme.colorScheme.onPrimary,
//                     fontWeight: FontWeight.w500,
//                     fontSize: 10,
//                   ),
//                 ),
//               ),
//             ),
//         ],
//       ),
//     );
//   }

//   // <<< MODIFIED WIDGET TO BE ROLE-AWARE >>>
//   Widget _buildActionsCard(ThemeData theme) {
//     // A list to hold the action tiles which we will build dynamically.
//     List<Widget> actionTiles = [];

//     // Personal Details - Common for all users
//     actionTiles.add(_buildActionTile(theme, icon: Icons.edit_note_outlined, title: "Personal Details", onTap: _navigateToEditProfile));
//     actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
    
//     // Role-specific tiles
//     if (_isAdmin) {
//       // Tiles for Admin users
//       actionTiles.add(_buildActionTile(
//         theme, 
//         icon: Icons.store_mall_directory_outlined, 
//         title: "My Venues", 
//         onTap: () {
//           if (!mounted) return;
//           Navigator.push(context, MaterialPageRoute(builder: (context) => const MyVenuesScreen()));
//         }
//       ));
//     } else {
//       // Tiles for regular users
//       actionTiles.add(_buildActionTile(theme, icon: Icons.favorite_border_outlined, title: "My Favourites", onTap: () {
//         if (!mounted) return;
//         Navigator.push(context, MaterialPageRoute(builder: (context) => const MyFavouritesScreen()));
//       }));
//       actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
//       actionTiles.add(_buildActionTile(theme, icon: Icons.event_note_outlined, title: "My Bookings", onTap: () {
//         if (!mounted) return;
//         Navigator.push(context, MaterialPageRoute(builder: (context) => const MyBookingsScreen()));
//       }));
//       actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
//       actionTiles.add(_buildActionTile(theme, icon: Icons.rate_review_outlined, title: "My Reviews", onTap: () {
//         if (!mounted) return;
//         Navigator.push(context, MaterialPageRoute(builder: (context) => const MyReviewsScreen()));
//       }));
//     }
    
//     // Common tiles for all users
//     actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
//     actionTiles.add(_buildActionTile(theme, icon: Icons.support_agent_outlined, title: "Help & Support", onTap: () {
//       if (!mounted) return;
//       Navigator.push(context, MaterialPageRoute(builder: (context) => const HelpSupportScreen()));
//     }));
//     actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
//     actionTiles.add(_buildActionTile(theme, icon: Icons.privacy_tip_outlined, title: "Privacy Policy", onTap: () {
//       if (!mounted) return;
//       Navigator.push(context, MaterialPageRoute(builder: (context) => const PrivacyPolicyScreen()));
//     }));
//     actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
//     actionTiles.add(const SignOutButtonTile());

//     return Card(
//       elevation: 1.5,
//       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
//       margin: EdgeInsets.zero,
//       child: Column(
//         mainAxisAlignment: MainAxisAlignment.start,
//         mainAxisSize: MainAxisSize.min,
//         children: actionTiles,
//       ),
//     );
//   }

//   Widget _buildActionTile(ThemeData theme, {required IconData icon, required String title, required VoidCallback onTap}) {
//     return ListTile(
//       leading: Icon(icon, color: theme.colorScheme.secondary, size: 22),
//       title: Text(title, style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500)),
//       trailing: Icon(Icons.chevron_right, color: Colors.grey[400], size: 20),
//       onTap: onTap,
//       contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 2.0),
//       dense: true,
//     );
//   }
// }


//---my bookings for admins---
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:flutter/foundation.dart'; // Import for debugPrint
import 'package:mm_associates/features/user/services/user_service.dart';
import 'package:mm_associates/features/profile/screens/edit_profile_screen.dart';

// MODIFICATION: Import the new screen for admin bookings
import 'package:mm_associates/features/admin/screens/admin_bookings_screen.dart';

import 'my_venues_screen.dart'; 
import 'my_favourites_screen.dart';
import 'my_bookings_screen.dart';
import 'my_reviews_screen.dart';
import 'help_support_screen.dart';
import 'privacy_policy_screen.dart';
import 'sign_out_button_tile.dart';

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);
  @override
  _ProfileScreenState createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  final AuthService _authService = AuthService();
  final UserService _userService = UserService();
  User? _currentUser;
  Map<String, dynamic>? _userData;
  bool _isLoading = true;
  String? _errorMessage;
  bool _isAdmin = false;

  @override
  void initState() {
    super.initState();
    _loadUserProfile();
  }

  void setStateIfMounted(VoidCallback fn) {
    if (mounted) {
      setState(fn);
    }
  }

  Future<void> _loadUserProfile({bool forceRefresh = false}) async {
    if (!mounted) return;
    setStateIfMounted(() {
      _isLoading = true;
      _errorMessage = null;
    });

    _currentUser = _authService.getCurrentUser();
    if (_currentUser == null) {
      setStateIfMounted(() {
        _isLoading = false;
        _errorMessage = "User not logged in.";
      });
      return;
    }

    try {
      await _currentUser?.reload();
      _currentUser = _authService.getCurrentUser();

      final results = await Future.wait([
        _userService.getUserProfileData(forceRefresh: forceRefresh),
        _userService.isCurrentUserAdmin(),
      ]);

      if (!mounted) return;
      
      _userData = results[0] as Map<String, dynamic>?;
      final bool isAdmin = results[1] as bool;

      debugPrint('_loadUserProfile - User data loaded: ${_userData != null}, isAdmin: $isAdmin');
      
      setStateIfMounted(() {
        _isAdmin = isAdmin;
        _isLoading = false;
      });
    } catch (e) {
      debugPrint("Error loading profile: $e");
      if (!mounted) return;
      setStateIfMounted(() {
        _isLoading = false;
        _errorMessage = "Failed to load profile details.";
      });
    }
  }

  void _navigateToEditProfile() async {
    if (_currentUser == null || _userData == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Profile data not loaded yet.")),
      );
      return;
    }

    final String currentName = _userData!['name'] as String? ?? _currentUser!.displayName ?? 'N/A';
    final String currentEmail = _currentUser!.email ?? 'N/A';
    final String? currentPhone = _userData!['phoneNumber'] as String?;
    final String? currentProfilePicUrl = _userData!['profilePictureUrl'] as String?;
    final String? currentBio = _userData!['bio'] as String?;
    final Timestamp? dobTimestamp = _userData!['dateOfBirth'] as Timestamp?;
    final DateTime? currentDateOfBirth = dobTimestamp?.toDate();
    final String? currentGender = _userData!['gender'] as String?;
    final String? currentAddressStreet = _userData!['addressStreet'] as String?;
    final String? currentAddressCity = _userData!['addressCity'] as String?;
    final String? currentAddressState = _userData!['addressState'] as String?;
    final String? currentAddressZipCode = _userData!['addressZipCode'] as String?;
    final String? currentAddressCountry = _userData!['addressCountry'] as String?;
    final String? currentSocialMediaLink = _userData!['socialMediaLink'] as String?;

    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) => EditProfileScreen(
          currentName: currentName,
          currentEmail: currentEmail,
          currentPhone: currentPhone,
          currentProfilePicUrl: currentProfilePicUrl,
          currentBio: currentBio,
          currentDateOfBirth: currentDateOfBirth,
          currentGender: currentGender,
          currentAddressStreet: currentAddressStreet,
          currentAddressCity: currentAddressCity,
          currentAddressState: currentAddressState,
          currentAddressZipCode: currentAddressZipCode,
          currentAddressCountry: currentAddressCountry,
          currentSocialMediaLink: currentSocialMediaLink,
        ),
      ),
    );

    if (result == true && mounted) {
      _loadUserProfile(forceRefresh: true);
    }
  }


  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.brightness == Brightness.light
          ? Colors.grey[100]!
          : theme.scaffoldBackgroundColor,
      appBar: AppBar(
        title: const Text('My Profile'),
        elevation: 0,
        backgroundColor: theme.brightness == Brightness.light ? Colors.grey[100]! : theme.scaffoldBackgroundColor,
        foregroundColor: theme.colorScheme.onSurface,
      ),
      body: RefreshIndicator(
        onRefresh: () => _loadUserProfile(forceRefresh: true),
        child: _buildBody(theme),
      ),
    );
  }

  Widget _buildBody(ThemeData theme) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_errorMessage != null || _currentUser == null || _userData == null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline, color: Colors.red[300], size: 60),
              const SizedBox(height: 15),
              Text(
                _errorMessage ?? "Could not load profile.",
                textAlign: TextAlign.center,
                style: TextStyle(color: Colors.red[700], fontSize: 16),
              ),
              const SizedBox(height: 20),
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh),
                label: const Text("Try Again"),
                onPressed: () => _loadUserProfile(forceRefresh: true),
                style: ElevatedButton.styleFrom(foregroundColor: theme.colorScheme.onError, backgroundColor: theme.colorScheme.error,)
              ),
            ],
          ),
        ),
      );
    }

    bool isTabletOrLarger = MediaQuery.of(context).size.width >= 720; 

    if (isTabletOrLarger) { 
        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
            child: Container(
              constraints: BoxConstraints(
                maxWidth: 550, 
                maxHeight: MediaQuery.of(context).size.height * 0.9,
              ),
              decoration: BoxDecoration(
                color: theme.cardColor,
                borderRadius: BorderRadius.circular(16.0),
                border: Border.all(
                  color: theme.dividerColor.withOpacity(0.5),
                  width: 1.0,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.08),
                    blurRadius: 12.0,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(15.0),
                child: SingleChildScrollView(
                  padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
                  child: Column( 
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                       _buildHeaderSection(theme),
                       const SizedBox(height: 16),
                       _buildActionsSection(theme),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
    } else { 
        return SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildHeaderSection(theme),
              const SizedBox(height: 16), 
              _buildActionsSection(theme),
              const SizedBox(height: 24), 
            ],
          ),
        );
    }
  }

  Widget _buildHeaderSection(ThemeData theme) {
    return _buildHeaderCard(theme);
  }

  Widget _buildActionsSection(ThemeData theme) {
    return _buildActionsCard(theme);
  }

  Widget _buildHeaderCard(ThemeData theme) {
    final String displayName = _userData?['name'] as String? ?? _currentUser?.displayName ?? 'User';
    final String email = _currentUser?.email ?? 'No Email';
    final String profilePicUrl = _userData?['profilePictureUrl'] as String? ?? '';
    final bool isEmailVerified = _currentUser?.emailVerified ?? false;
    final dynamic updatedAtRaw = _userData?['updatedAt'];
    DateTime? lastUpdated;
    if (updatedAtRaw is Timestamp) {
      lastUpdated = updatedAtRaw.toDate();
    } else if (updatedAtRaw is String) {
      lastUpdated = DateTime.tryParse(updatedAtRaw);
    }

    String joinedDateString = "";
    final creationTime = _currentUser?.metadata.creationTime;
    if (creationTime != null) {
      joinedDateString = "Since ${DateFormat('MMM yyyy').format(creationTime)}";
    }
    
    const double ribbonSpace = 80.0; 

    return Card(
      elevation: 2.0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
      clipBehavior: Clip.antiAlias,
      margin: EdgeInsets.zero,
      child: Stack(
        children: [
          Padding(
            padding: EdgeInsets.fromLTRB(16.0, 16.0, ribbonSpace, 16.0),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                CircleAvatar(
                  radius: 36,
                  backgroundColor: theme.colorScheme.surfaceContainerHighest,
                  foregroundImage: profilePicUrl.isNotEmpty ? NetworkImage(profilePicUrl) : null,
                  child: profilePicUrl.isEmpty ? Icon(Icons.person_outline, size: 38, color: theme.colorScheme.onSurfaceVariant) : null,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        displayName,
                        style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 2),
                      Text(
                        email,
                        style: theme.textTheme.bodyMedium,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      if (!isEmailVerified)
                        Padding(
                          padding: const EdgeInsets.only(top: 5.0),
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                            decoration: BoxDecoration(color: Colors.orange.withAlpha(38), borderRadius: BorderRadius.circular(4)),
                            child: Row(mainAxisSize: MainAxisSize.min, children: [
                              Icon(Icons.warning_amber_rounded, color: Colors.orange[700], size: 13),
                              const SizedBox(width: 3),
                              Text("Email Not Verified", style: TextStyle(color: Colors.orange[800], fontSize: 10, fontWeight: FontWeight.w500))
                            ]),
                          ),
                        ),
                      if (lastUpdated != null) ...[
                        const SizedBox(height: 5),
                        Text(
                          "Last updated: ${DateFormat('dd MMM yyyy, hh:mm a').format(lastUpdated)}",
                          style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor, fontSize: 11),
                          maxLines: 2, 
                          overflow: TextOverflow.ellipsis, 
                        )
                      ],
                    ],
                  ),
                ),
              ],
            ),
          ),
          if (joinedDateString.isNotEmpty)
            Positioned(
              top: 16.0,
              right: 0,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary,
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(6.0),
                    bottomLeft: Radius.circular(6.0),
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 3,
                      offset: const Offset(-1,1)
                    )
                  ]
                ),
                child: Text(
                  joinedDateString,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onPrimary,
                    fontWeight: FontWeight.w500,
                    fontSize: 10,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  // MODIFIED: Added Venue Bookings for admin.
  Widget _buildActionsCard(ThemeData theme) {
    List<Widget> actionTiles = [];

    // Personal Details - Common for all users
    actionTiles.add(_buildActionTile(theme, icon: Icons.edit_note_outlined, title: "Personal Details", onTap: _navigateToEditProfile));
    actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
    
    // Role-specific tiles
    if (_isAdmin) {
      // Tiles for Admin users
      actionTiles.add(_buildActionTile(
        theme, 
        icon: Icons.store_mall_directory_outlined, 
        title: "My Venues", 
        onTap: () {
          if (!mounted) return;
          Navigator.push(context, MaterialPageRoute(builder: (context) => const MyVenuesScreen()));
        }
      ));
      
      // <<< THIS IS THE NEWLY ADDED TILE FOR ADMINS >>>
      actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
      actionTiles.add(_buildActionTile(
        theme, 
        icon: Icons.event_available_outlined, 
        title: "Venue Bookings", 
        onTap: () {
          if (!mounted) return;
          Navigator.push(context, MaterialPageRoute(builder: (context) => const AdminBookingsScreen()));
        }
      ));
      // <<< END OF NEWLY ADDED TILE >>>

    } else {
      // Tiles for regular users
      actionTiles.add(_buildActionTile(theme, icon: Icons.favorite_border_outlined, title: "My Favourites", onTap: () {
        if (!mounted) return;
        Navigator.push(context, MaterialPageRoute(builder: (context) => const MyFavouritesScreen()));
      }));
      actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
      actionTiles.add(_buildActionTile(theme, icon: Icons.event_note_outlined, title: "My Bookings", onTap: () {
        if (!mounted) return;
        Navigator.push(context, MaterialPageRoute(builder: (context) => const MyBookingsScreen()));
      }));
      actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
      actionTiles.add(_buildActionTile(theme, icon: Icons.rate_review_outlined, title: "My Reviews", onTap: () {
        if (!mounted) return;
        Navigator.push(context, MaterialPageRoute(builder: (context) => const MyReviewsScreen()));
      }));
    }
    
    // Common tiles for all users
    actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
    actionTiles.add(_buildActionTile(theme, icon: Icons.support_agent_outlined, title: "Help & Support", onTap: () {
      if (!mounted) return;
      Navigator.push(context, MaterialPageRoute(builder: (context) => const HelpSupportScreen()));
    }));
    actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
    actionTiles.add(_buildActionTile(theme, icon: Icons.privacy_tip_outlined, title: "Privacy Policy", onTap: () {
      if (!mounted) return;
      Navigator.push(context, MaterialPageRoute(builder: (context) => const PrivacyPolicyScreen()));
    }));
    actionTiles.add(const Divider(height: 0, indent: 16, endIndent: 16));
    actionTiles.add(const SignOutButtonTile());

    return Card(
      elevation: 1.5,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
      margin: EdgeInsets.zero,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: actionTiles,
      ),
    );
  }

  Widget _buildActionTile(ThemeData theme, {required IconData icon, required String title, required VoidCallback onTap}) {
    return ListTile(
      leading: Icon(icon, color: theme.colorScheme.secondary, size: 22),
      title: Text(title, style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w500)),
      trailing: Icon(Icons.chevron_right, color: Colors.grey[400], size: 20),
      onTap: onTap,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 2.0),
      dense: true,
    );
  }
}


===== features\profile\screens\sign_out_button_tile.dart =====

// File: lib/features/profile/screens/sign_out_button_tile.dart
import 'package:flutter/material.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart'; // Absolute import for AuthService

class SignOutButtonTile extends StatelessWidget {
  const SignOutButtonTile({super.key});

  Future<void> _signOut(BuildContext context) async {
    final AuthService authService = AuthService(); // Instantiated here
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text("Sign Out"),
        content: const Text("Are you sure you want to sign out?"),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext, false),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(dialogContext, true);
            } ,
            child: const Text("Sign Out", style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      try {
        await authService.signOut();
        if (context.mounted) {
  Navigator.of(context).popUntil((route) => route.isFirst);
}
      } catch (e) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text("Error signing out: ${e.toString()}"),
              backgroundColor: Colors.redAccent,
              behavior: SnackBarBehavior.floating,
              margin: const EdgeInsets.all(10),
            ),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    return ListTile(
      leading: Icon(Icons.logout_outlined, color: theme.colorScheme.error), 
      title: Text(
        "Sign Out",
        style: theme.textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w500,
          color: theme.colorScheme.error, 
        ),
      ),
      trailing: Icon(Icons.chevron_right, color: Colors.grey[400]),
      onTap: () => _signOut(context),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
      dense: true,
    );
  }
}


===== features\reviews\widgets\add_review_dialog.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_rating_bar/flutter_rating_bar.dart';
import 'package:mm_associates/features/auth/services/auth_service.dart';
import 'package:mm_associates/features/data/services/firestore_service.dart';

class AddReviewDialog extends StatefulWidget {
  final String venueId;

  const AddReviewDialog({super.key, required this.venueId});

  @override
  State<AddReviewDialog> createState() => _AddReviewDialogState();
}

class _AddReviewDialogState extends State<AddReviewDialog> {
  final _formKey = GlobalKey<FormState>();
  final _commentController = TextEditingController();
  final FirestoreService _firestoreService = FirestoreService();
  final AuthService _authService = AuthService(); // To get user name

  double _rating = 3.0; // Default rating
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void dispose() {
    _commentController.dispose();
    super.dispose();
  }

  Future<void> _submitReview() async {
    FocusScope.of(context).unfocus();
    if (!_formKey.currentState!.validate()) {
       return;
    }
    if (_rating == 0) {
        setState(() => _errorMessage = "Please select a rating (1-5 stars).");
        return;
    }

    setState(() { _isLoading = true; _errorMessage = null; });

    final currentUser = _authService.getCurrentUser();
    if (currentUser == null) {
        setState(() { _errorMessage = "You must be logged in to submit a review."; _isLoading = false; });
        return;
    }
    final userId = currentUser.uid;
    final userData = await _authService.getUserData(userId);
    final userName = userData?['name'] as String? ?? currentUser.email?.split('@')[0] ?? 'Anonymous User';

    try {
      await _firestoreService.addReviewForVenue(
          widget.venueId,
          userId,
          userName,
          _rating,
          _commentController.text.trim());

       if (mounted) {
          Navigator.pop(context, true); // Indicate success
           ScaffoldMessenger.of(context).showSnackBar(
               const SnackBar(content: Text("Review submitted successfully!"), backgroundColor: Colors.green),
            );
       }
    } catch (e) {
        if (mounted) {
            setState(() {
              _errorMessage = e.toString().replaceFirst("Exception: ", "");
              _isLoading = false;
            });
        }
    }

  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
        title: const Text('Write a Review'),
         shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15.0)),
        content: SingleChildScrollView(
             child: Form(
               key: _formKey,
               child: ListBody(
                  children: <Widget>[
                     const Text("Rate this venue:"),
                     const SizedBox(height: 8),
                     Center(
                       child: RatingBar.builder(
                         initialRating: _rating,
                         minRating: 1,
                         direction: Axis.horizontal,
                         allowHalfRating: false, // Or true if you prefer
                         itemCount: 5,
                         itemPadding: const EdgeInsets.symmetric(horizontal: 4.0),
                         itemBuilder: (context, _) => const Icon(Icons.star, color: Colors.amber),
                         onRatingUpdate: (rating) => setState(() => _rating = rating),
                       ),
                     ),
                    const SizedBox(height: 20),
                     TextFormField(
                        controller: _commentController,
                        decoration: const InputDecoration(
                            labelText: 'Your Comments (Optional)',
                             hintText: 'Share your experience...',
                            border: OutlineInputBorder(),
                            alignLabelWithHint: true,
                           ),
                        maxLines: 3,
                        textCapitalization: TextCapitalization.sentences,
                      ),
                     if (_errorMessage != null)
                        Padding(
                           padding: const EdgeInsets.only(top: 15.0),
                           child: Text(_errorMessage!, style: const TextStyle(color: Colors.red, fontSize: 13), textAlign: TextAlign.center),
                        ),
                  ],
               ),
             ),
           ),
         actions: <Widget>[
           TextButton(
               onPressed: _isLoading ? null : () => Navigator.of(context).pop(false),
               child: const Text('Cancel'),
             ),
            TextButton(
               onPressed: _isLoading ? null : _submitReview,
               child: _isLoading
                   ? const SizedBox(
                        width: 18, height: 18,
                        child: CircularProgressIndicator(strokeWidth: 2)
                      )
                   : const Text('Submit'),
             ),
         ],
    );
  }
}


===== features\reviews\widgets\review_list_item.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_rating_bar/flutter_rating_bar.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart'; // Add intl package to pubspec.yaml for date formatting

class ReviewListItem extends StatelessWidget {
  final Map<String, dynamic> reviewData;

  const ReviewListItem({super.key, required this.reviewData});

  @override
  Widget build(BuildContext context) {
     final String userName = reviewData['userName'] as String? ?? 'Anonymous';
     final double rating = (reviewData['rating'] as num?)?.toDouble() ?? 0.0;
     final String comment = reviewData['comment'] as String? ?? '';
     final Timestamp? timestamp = reviewData['createdAt'] as Timestamp?;
     final String dateString = timestamp != null
        ? DateFormat('dd MMM yyyy').format(timestamp.toDate()) // Format date
        : 'Unknown date';

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12.0),
      child: Column(
         crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
             mainAxisAlignment: MainAxisAlignment.spaceBetween,
             children: [
                Expanded(
                  child: Text(
                     userName,
                     style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 15),
                     overflow: TextOverflow.ellipsis,
                   ),
                ),
                 Text(dateString, style: TextStyle(color: Colors.grey[600], fontSize: 12)),
             ],
           ),
          const SizedBox(height: 4),
           IgnorePointer( // Makes the rating bar non-interactive
              child: RatingBar.builder(
                initialRating: rating,
                minRating: 1,
                direction: Axis.horizontal,
                allowHalfRating: false,
                itemCount: 5,
                itemSize: 18.0, // Smaller stars for display
                itemPadding: const EdgeInsets.symmetric(horizontal: 0.5),
                itemBuilder: (context, _) => const Icon(Icons.star, color: Colors.amber),
                onRatingUpdate: (rating) {}, // Required but unused
              ),
           ),
           if (comment.isNotEmpty) ...[
               const SizedBox(height: 6),
               Text(comment, style: const TextStyle(fontSize: 14, height: 1.3)),
            ],
        ],
      ),
    );
  }
}


===== features\user\services\user_service.dart =====

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:mm_associates/features/data/services/firestore_service.dart';
import 'package:image_picker/image_picker.dart';
import 'package:mm_associates/core/services/image_upload_service.dart'; // <--- IMPORT NEW SERVICE

class UserService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final FirestoreService _firestoreService = FirestoreService();
  final ImageUploadService _imageUploadService = ImageUploadService(); // <--- INSTANTIATE

  static const String _usersCollection = 'mm_users';
  static const String _favoritesField = 'favoriteVenueIds';
  static const String _profilePictureUploadPreset = 'mm_associates_profile_pics';

  String? get _currentUserId => _firebaseAuth.currentUser?.uid;

  Future<String?> uploadProfilePicture(XFile imageXFile) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");

    try {
      debugPrint("UserService: Calling ImageUploadService to upload to Cloudinary...");
      final String? cloudinaryUrl = await _imageUploadService.uploadImageToCloudinary(
        imageXFile,
        uploadPreset: _profilePictureUploadPreset,
        folder: 'profile_pictures/$userId' // Optional: organize in Cloudinary by user ID
      );

      if (cloudinaryUrl != null) {
        debugPrint("UserService: Cloudinary URL received: $cloudinaryUrl. Updating Firestore.");
        await updateProfilePictureUrl(cloudinaryUrl);
        return cloudinaryUrl; // Return the URL for immediate UI update if needed
      } else {
        throw Exception("Failed to get URL from Cloudinary.");
      }
    } catch (e) {
      debugPrint('UserService: Error in uploadProfilePicture orchestrator: $e');
      throw Exception("Profile picture upload failed overall: $e");
    }
  }

  Future<void> updateProfilePictureUrl(String? url) async {
     final userId = _currentUserId;
     if (userId == null) throw Exception("User not logged in");
     await _updateUserData(userId, {'profilePictureUrl': url}); // Send null to remove
   }


  Future<void> addFavorite(String venueId) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");
    if (venueId.isEmpty) return;
    try {
      final userDocRef = _firestore.collection(_usersCollection).doc(userId);
      await userDocRef.update({_favoritesField: FieldValue.arrayUnion([venueId])});
    } catch (e) { debugPrint("Error adding favorite: $e"); throw Exception("Could not add favorite."); }
  }

  Future<void> removeFavorite(String venueId) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");
    if (venueId.isEmpty) return;
    try {
      final userDocRef = _firestore.collection(_usersCollection).doc(userId);
      await userDocRef.update({_favoritesField: FieldValue.arrayRemove([venueId])});
    } catch (e) { debugPrint("Error removing favorite: $e"); throw Exception("Could not remove favorite.");}
  }

  Future<bool> isVenueFavorite(String venueId) async {
    final userId = _currentUserId;
    if (userId == null || venueId.isEmpty) return false;
    try {
      final userDoc = await _firestore.collection(_usersCollection).doc(userId).get();
      if (userDoc.exists) {
        final data = userDoc.data();
        final favorites = data?[_favoritesField] as List<dynamic>? ?? [];
        return favorites.contains(venueId);
      } return false;
    } catch (e) { debugPrint("Error checking if favorite: $e"); return false; }
  }

  Stream<List<String>> getFavoriteVenueIdsStream() {
     final userId = _currentUserId;
     if (userId == null) return Stream.value([]);
     return _firestore.collection(_usersCollection).doc(userId).snapshots().map((snapshot) {
        if (!snapshot.exists) return <String>[];
        final data = snapshot.data();
        final favorites = data?[_favoritesField] as List<dynamic>? ?? [];
        return favorites.cast<String>().toList();
     }).handleError((error) { debugPrint("Error getting favorite venue IDs stream: $error"); return <String>[]; });
  }

  Future<List<String>> getFavoriteVenueIds() async {
    final userId = _currentUserId;
    if (userId == null) return [];
    try {
      final userDoc = await _firestore.collection(_usersCollection).doc(userId).get();
      if (userDoc.exists) {
        final data = userDoc.data();
        final favorites = data?[_favoritesField] as List<dynamic>? ?? [];
        return favorites.cast<String>().toList();
      } return [];
    } catch (e) { debugPrint("Error getting favorite venue IDs: $e"); return []; }
  }

  Future<List<Map<String, dynamic>>> getFavoriteVenues() async {
    final List<String> favoriteIds = await getFavoriteVenueIds();
    if (favoriteIds.isEmpty) return [];
    List<Map<String, dynamic>> favoriteVenuesData = [];
    try {
      for (String venueId in favoriteIds) {
        final venueData = await _firestoreService.getVenueDetails(venueId);
        if (venueData != null) { favoriteVenuesData.add(venueData); }
        else { debugPrint("Favorite venue $venueId not found or error fetching details.");}
      }
      favoriteVenuesData.sort((a, b) => (a['name'] as String? ?? '').compareTo(b['name'] as String? ?? ''));
      return favoriteVenuesData;
    } catch (e) { debugPrint("Error fetching details for favorite venues: $e"); throw Exception("Failed to load favorite venues.");}
  }

  Future<Map<String, dynamic>?> getUserProfileData({bool forceRefresh = false}) async {
    final userId = _currentUserId;
    if (userId == null) { debugPrint("User not logged in, cannot fetch profile data."); return null; }
    try {
      final userDoc = await _firestore.collection(_usersCollection).doc(userId).get();
      return userDoc.data();
    } catch (e) { debugPrint("Error fetching user profile data for UID $userId: $e"); return null;}
  }

  Future<void> _updateUserData(String userId, Map<String, dynamic> dataToUpdate) async {
    if (userId.isEmpty) throw Exception("User ID invalid");
    try {
      Map<String, dynamic> finalUpdateData = Map.from(dataToUpdate);
      finalUpdateData['updatedAt'] = FieldValue.serverTimestamp();
      await _firestore.collection(_usersCollection).doc(userId).update(finalUpdateData);
    } catch (e) { debugPrint('Error updating user data for UID $userId: $e'); throw Exception("Failed to update profile data in Firestore.");}
  }

  Future<void> updateUserProfileData(Map<String, dynamic> dataToUpdate) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");
    await _updateUserData(userId, dataToUpdate);
  }

  Future<void> updateUserName(String name) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");
    if (name.trim().isEmpty || name.trim().length < 2) throw Exception("Invalid name");
    await _updateUserData(userId, {'name': name.trim()});
  }

  Future<void> updatePhoneNumber(String? phoneNumber, {bool? isVerified}) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");
    Map<String, dynamic> phoneUpdateData = {'phoneNumber': phoneNumber?.trim()};
    if (isVerified != null) { phoneUpdateData['phoneVerified'] = isVerified; }
    await _updateUserData(userId, phoneUpdateData);
  }

  Future<void> updateUserEmailInFirestore(String newEmail) async {
    final userId = _currentUserId;
    if (userId == null) throw Exception("User not logged in");
    await _updateUserData(userId, {'email': newEmail.trim(), 'emailVerified': false});
  }

   Future<bool> isCurrentUserAdmin() async {
    final User? currentUser = _firebaseAuth.currentUser;

    // If no user is logged in, they are not an admin.
    if (currentUser == null) {
      return false;
    }

    try {
      final docSnapshot = await _firestore.collection('mm_users').doc(currentUser.uid).get();

      if (docSnapshot.exists && docSnapshot.data()?['isAdmin'] == true) {
        debugPrint("User is an admin.");
        return true;
      }
    } catch (e) {
      debugPrint("Error checking admin status: $e");
      return false;
    }

    debugPrint("User is not an admin.");
    return false;
  }

}


===== widgets\error_display.dart =====




===== widgets\loading_indicator.dart =====



